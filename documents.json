[
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Security/Custom Login Form.html",
    "title": "Custom Login Form",
    "body": " Back Custom Login Form Now we are going to configure the security of the access to web path in application, login, logout, etc: package com.springsecurity.demo.config; import org.springframework.context.annotation.Configuration; import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; import org.springframework.security.core.userdetails.User; import org.springframework.security.core.userdetails.User.UserBuilder; @Configuration @EnableWebSecurity public class DemoSecurityConfig extends WebSecurityConfigurerAdapter { \t@Override \tprotected void configure(AuthenticationManagerBuilder auth) throws Exception { \t\t// add our users for in memory authentication \t\tUserBuilder users = User.withDefaultPasswordEncoder(); \t\t \t\tauth.inMemoryAuthentication() \t\t\t.withUser(users.username(\"john\").password(\"test123\").roles(\"EMPLOYEE\")) \t\t\t.withUser(users.username(\"mary\").password(\"test123\").roles(\"MANAGER\")) \t\t\t.withUser(users.username(\"susan\").password(\"test123\").roles(\"ADMIN\")); \t} \t@Override \tprotected void configure(HttpSecurity http) throws Exception { // Here is the control of the access to web path http.authorizeRequests() // Require authentication for every request .anyRequest().authenticated() // And for form login customize the login page shown .and() .formLogin() \t\t\t\t\t\t// Custom jsp page .loginPage(\"/showMyLoginPage\") \t\t\t\t\t\t// You do not need to create a method in your controller for this endpoint, it is handled by spring .loginProcessingUrl(\"/authenticateTheUser\") .permitAll(); \t\t \t} } Create the form We create the login page /showMyLoginPage as follows: <!-- Reference the spring and jsp tags --> <%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %> <%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %> <html> <head> \t<title>Custom Login Page</title> \t<style> \t\t.failed { \t\t\tcolor: red; \t\t} \t</style> </head> <body> <h3>My Custom Login Page</h3> \t\t<!-- The form points to the endpoint specified preivously: \"authenticateTheUser\" --> \t\t<!-- contextPath is the domain of our app, i.e. localhost:8080 --> \t<form:form action=\"${pageContext.request.contextPath}/authenticateTheUser\" \t\t\t method=\"POST\"> \t\t<!-- Check for login error --> \t\t<c:if test=\"${param.error != null}\"> \t\t\t<i class=\"failed\">Sorry! You entered invalid username/password.</i> \t\t</c:if> \t\t<p> \t\t\tUser name: <input type=\"text\" name=\"username\" /> \t\t</p> \t\t<p> \t\t\tPassword: <input type=\"password\" name=\"password\" /> \t\t</p> \t\t<input type=\"submit\" value=\"Login\" /> \t</form:form> </body> </html> Note that Spring appends a parameter error when the user fails to login. That is what we use as a condition to show our error message, that is, we check if param.error exists. Also, Spring security defines default names for login form fields: User name field: username Password field: password Login Controller We also need a controller method for requests to /showMyLoginPage: package com.springsecurity.demo.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.GetMapping; @Controller public class LoginController { \t@GetMapping(\"/showMyLoginPage\") \tpublic String showMyLoginPage() { \t\t \t\t// This is the custom-login.jsp we created in the previous section \t\treturn \"custom-login\"; \t\t \t} } "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Security/Display User and Roles.html",
    "title": "Display User and Roles",
    "body": " Back Display User and Roles In this section we are going to show how to display in our jsp files the user id and its role: Add JSP Tag library as dependency First we add to our pom.xml file the JSP Tag Library: \t\t<!-- Add Spring Security Taglibs support --> \t\t<dependency> \t\t <groupId>org.springframework.security</groupId> \t\t <artifactId>spring-security-taglibs</artifactId> \t\t <version>${springsecurity.version}</version> \t\t</dependency>\t JSP page Then add the tag library to the jsp page, and we use its tags to access the user id and its role: <%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %> <!-- Add tag library --> <%@ taglib prefix=\"security\" uri=\"http://www.springframework.org/security/tags\" %> <html> <head> \t<title>luv2code Company Home Page</title> </head> <body> \t<h2>luv2code Company Home Page</h2> \t<hr> \t<p> \tWelcome to the luv2code company home page! \t</p> \t<hr> \t<!-- display user name and role --> \t<p> \t\tUser: <security:authentication property=\"principal.username\" /> \t\t<br><br> \t\tRole(s): <security:authentication property=\"principal.authorities\" /> \t</p> \t<hr> \t<!-- Add a logout button --> \t<form:form action=\"${pageContext.request.contextPath}/logout\" \t\t\t method=\"POST\"> \t\t<input type=\"submit\" value=\"Logout\" /> \t</form:form> </body> </html> "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Security/Cross Site Request Forgery.html",
    "title": "Cross Site Request Forgery",
    "body": " Back Cross Site Request Forgery Spring Security protects against Cross-Site Request Forgery. CSRF is a security attack where a website tricks you into executing an action on a web application that you are currently logged in. Protection from this type of attack is embedded in the Spring Security Filters. This protection is enabled by default. Spring Security uses the Synchronizer Token Pattern, where each request includes a session cookie and a randomly generated token. So for request processing, Spring Security verifies the token before processing. How to use it? For form submissions use \"POST\" instead of \"GET\" The Spring Security tag <form:form> automatically adds the CSRF token. If you do not use the tag, you must manually add the CSRF token. If you do not add the token you get an error message: 403 Forbidden, and further information about how the token cannot be null. How to see the CSRF token? When your jsp with the <form:form> tag is processed into an html page, you will be able to see the token inside the form tag: "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Security/Java Configuration.html",
    "title": "Java Configuration",
    "body": " Back Java Configuration We are going to show the DemoAppConfig.java that holds the base configuration of our application: package com.springsecurity.demo.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.ViewResolver; import org.springframework.web.servlet.config.annotation.EnableWebMvc; import org.springframework.web.servlet.view.InternalResourceViewResolver; // Tell spring this is a configuration file @Configuration // Enables annotations @EnableWebMvc // Search for components in \"com.springsecurity.demo\" package @ComponentScan(basePackages=\"com.springsecurity.demo\") public class DemoAppConfig { \t// define a bean for ViewResolver \t@Bean \tpublic ViewResolver viewResolver() { \t\t \t\tInternalResourceViewResolver viewResolver = new InternalResourceViewResolver(); \t\t \t\tviewResolver.setPrefix(\"/WEB-INF/view/\"); \t\tviewResolver.setSuffix(\".jsp\"); \t\t \t\treturn viewResolver; \t} } As you can see we have defined a ViewResolver that prepends /WEB-INF/view/ to every view, and appends .jsp to every view. Web App Initializer Spring MVC provides support for web app initialization, and makes sure your code is automatically detected. Your code is used to initialize the servlet container. As an example: package com.springsecurity.demo.config; import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer; public class MySpringMvcDispatcherServletInitializer extends AbstractAnnotationConfigDispatcherServletInitializer { \t@Override \tprotected Class<?>[] getRootConfigClasses() { \t\t// TODO Auto-generated method stub \t\treturn null; \t} \t@Override \t// Tell spring where the configuration for the servlet is \tprotected Class<?>[] getServletConfigClasses() { \t\treturn new Class[] { DemoAppConfig.class }; \t} \t@Override \t// Map the servlet to the path \"/\" \tprotected String[] getServletMappings() { \t\treturn new String[] { \"/\" }; \t} } Here is the correspondence with the xml servlet configuration file: "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Security/Log Out.html",
    "title": "Log Out",
    "body": " Back Log Out We are going to show in this section how to add the logout functionality to our Spring application. Configuration To our existing configuration we add: package com.springsecurity.demo.config; import org.springframework.context.annotation.Configuration; import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; import org.springframework.security.core.userdetails.User; import org.springframework.security.core.userdetails.User.UserBuilder; @Configuration @EnableWebSecurity public class DemoSecurityConfig extends WebSecurityConfigurerAdapter { \t@Override \tprotected void configure(AuthenticationManagerBuilder auth) throws Exception { \t\t// add our users for in memory authentication \t\tUserBuilder users = User.withDefaultPasswordEncoder(); \t\t \t\tauth.inMemoryAuthentication() \t\t\t.withUser(users.username(\"john\").password(\"test123\").roles(\"EMPLOYEE\")) \t\t\t.withUser(users.username(\"mary\").password(\"test123\").roles(\"MANAGER\")) \t\t\t.withUser(users.username(\"susan\").password(\"test123\").roles(\"ADMIN\")); \t} \t@Override \tprotected void configure(HttpSecurity http) throws Exception { // Here is the control of the access to web path http.authorizeRequests() // Require authentication for every request .anyRequest().authenticated() .and() .formLogin() .loginPage(\"/showMyLoginPage\") .loginProcessingUrl(\"/authenticateTheUser\") .permitAll(); // Add logout functionality .and() .logout().permitAll() \t\t \t} } The default url for logging out is /logout. Log Out Button Now we create the logout button in our home page: <%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %> <html> <head> \t<title>luv2code Company Home Page</title> </head> <body> \t<h2>luv2code Company Home Page</h2> \t<hr> \t<p> \tWelcome to the luv2code company home page! \t</p> \t<!-- Add a logout button: it point to \"/logout\" endpoint --> \t<form:form action=\"${pageContext.request.contextPath}/logout\" \t\t\t method=\"POST\"> \t\t<input type=\"submit\" value=\"Logout\" /> \t</form:form> </body> </html> Note that the logout logic is handled directly by spring, what it does is: Invalidate the user's HTTP session and remove cookies, etc. Sends the user back to the login page Appends a logout parameter: ?logout "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Security/Authorization.html",
    "title": "Authorization",
    "body": " Back Authorization In this section we are going to show how to restrict access based on roles. Our example follows the following scheme: Where only MANAGERS and above can access the /leaders endpoint and only ADMINS can access the /systems endpoint. Create Controllers We create a basic controller for every endpoint: package com.springsecurity.demo.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.GetMapping; @Controller public class DemoController { \t// add request mapping for index page \t@GetMapping(\"/\") \tpublic String showHome() { \t\t \t\treturn \"home\"; \t} \t \t// add request mapping for /leaders \t@GetMapping(\"/leaders\") \tpublic String showLeaders() { \t\t \t\treturn \"leaders\"; \t} \t \t// add request mapping for /systems \t@GetMapping(\"/systems\") \tpublic String showSystems() { \t\t \t\treturn \"systems\"; \t} \t } We also create a controller for the /acess-denied endpoint: package com.springsecurity.demo.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.GetMapping; @Controller public class LoginController { \t@GetMapping(\"/showMyLoginPage\") \tpublic String showMyLoginPage() { \t\t \t\t// return \"plain-login\"; \t\treturn \"fancy-login\"; \t} \t \t// add request mapping for /access-denied \t@GetMapping(\"/access-denied\") \tpublic String showAccessDenied() { \t\t \t\treturn \"access-denied\"; \t} } Define User Roles and Restrict Accessand Restrict Access In our configuration file we had saved in-memory a list of users with some defined roles, we are going to update it to have more roles. We are also going to define the authorization scheme we showed earlier. package com.springsecurity.demo.config; import org.springframework.context.annotation.Configuration; import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; import org.springframework.security.core.userdetails.User; import org.springframework.security.core.userdetails.User.UserBuilder; @Configuration @EnableWebSecurity public class DemoSecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { // add our users for in memory authentication UserBuilder users = User.withDefaultPasswordEncoder(); // add more roles auth.inMemoryAuthentication() .withUser(users.username(\"john\").password(\"test123\").roles(\"EMPLOYEE\")) .withUser(users.username(\"mary\").password(\"test123\").roles(\"EMPLOYEE\", \"MANAGER\")) .withUser(users.username(\"susan\").password(\"test123\").roles(\"EMPLOYEE\", \"ADMIN\")); } @Override protected void configure(HttpSecurity http) throws Exception { // Handle requests http.authorizeRequests() // Set role for index page .antMatchers(\"/\").hasRole(\"EMPLOYEE\") // Set role for leaders page .antMatchers(\"/leaders/**\").hasRole(\"MANAGER\") // Set role for systems page .antMatchers(\"/systems/**\").hasRole(\"ADMIN\") .and() .formLogin() .loginPage(\"/showMyLoginPage\") .loginProcessingUrl(\"/authenticateTheUser\") .permitAll() .and() .logout().permitAll() // also define the page where the user is redirected if it does not have access to the resource it requests .and() .exceptionHandling().accessDeniedPage(\"/access-denied\"); } } Display Content based on Roles In our home page, we add two conditionals so only managers can see the link to the leaders page, and only admins can see the link to the systems page: <%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %> <%@ taglib prefix=\"security\" uri=\"http://www.springframework.org/security/tags\" %> <html> <head> \t<title>luv2code Company Home Page</title> </head> <body> \t<h2>luv2code Company Home Page</h2> \t<hr> \t<p> \tWelcome to the luv2code company home page! \t</p> \t<hr> \t<!-- display user name and role --> \t<p> \t\tUser: <security:authentication property=\"principal.username\" /> \t\t<br><br> \t\tRole(s): <security:authentication property=\"principal.authorities\" /> \t</p> \t<!-- Check if user has the manager role, if so show the link --> \t<security:authorize access=\"hasRole('MANAGER')\"> \t\t<!-- Add a link to point to /leaders ... this is for the managers --> \t\t<p> \t\t\t<a href=\"${pageContext.request.contextPath}/leaders\">Leadership Meeting</a> \t\t\t(Only for Manager peeps) \t\t</p> \t</security:authorize>\t \t<!-- Check if user has the admin role, if so show the link --> \t<security:authorize access=\"hasRole('ADMIN')\"> \t\t<!-- Add a link to point to /systems ... this is for the admins --> \t\t<p> \t\t\t<a href=\"${pageContext.request.contextPath}/systems\">IT Systems Meeting</a> \t\t\t(Only for Admin peeps) \t\t</p> \t</security:authorize> \t<hr> \t<!-- Add a logout button --> \t<form:form action=\"${pageContext.request.contextPath}/logout\" \t\t\t method=\"POST\"> \t\t<input type=\"submit\" value=\"Logout\" /> \t</form:form> </body> </html> "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Security/JDBC Database Authentication.html",
    "title": "JDBC Database Authentication",
    "body": " Back JDBC Database Authentication Spring Security can read user account info from Database By default, you have to follow Spring Security's predefined table schemas. You can customize the table schemas, but you will be responsible for writing the code to access the data. Set Up Database The tables we have to create are the following: Password Encryption In Spring Security 5, passwords are stored using a specific format: {id}encodedPassword The id references the operation used to encrypt the password: noop: plain text. So the password is stored as follows in the database: {noop}test123 bcrypt: BCrypt password hashing. So the password is stored as follows in the database: {bcrypt}$2a$12$R9h/cIPz0gi.URNNX3kh2OPST9/PgBkqquzi.Ss7KIUgO2t0jWMUW etc. Add Dependiencies We define the dependencies in our pom.xmlfile that are needed to add support to connect to databases: \t\t<!-- Add MySQL and C3P0 support --> \t\t<dependency> \t\t\t<groupId>mysql</groupId> \t\t\t<artifactId>mysql-connector-java</artifactId> \t\t\t<version>8.0.16</version> \t\t</dependency> \t\t \t\t<dependency> \t\t\t<groupId>com.mchange</groupId> \t\t\t<artifactId>c3p0</artifactId> \t\t\t<version>0.9.5.4</version> \t\t</dependency> JDBC Properties files Inside /src/main/resources we create the properties file persistence-mysql.properties for our database connections: # # JDBC connection properties # jdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/spring_security_demo_plaintext?useSSL=false jdbc.user=springstudent jdbc.password=springstudent # # Connection pool properties # connection.pool.initialPoolSize=5 connection.pool.minPoolSize=5 connection.pool.maxPoolSize=20 connection.pool.maxIdleTime=3000 Spring Security Configuration We have to modify our main configuration class, to include our database properties file and create the datasource package com.luv2code.springsecurity.demo.config; import java.beans.PropertyVetoException; import java.util.logging.Logger; import javax.sql.DataSource; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.PropertySource; import org.springframework.core.env.Environment; import org.springframework.web.servlet.ViewResolver; import org.springframework.web.servlet.config.annotation.EnableWebMvc; import org.springframework.web.servlet.view.InternalResourceViewResolver; import com.mchange.v2.c3p0.ComboPooledDataSource; @Configuration @EnableWebMvc @ComponentScan(basePackages=\"com.luv2code.springsecurity.demo\") @PropertySource(\"classpath:persistence-mysql.properties\") public class DemoAppConfig { \t// set up variable to hold the properties \t@Autowired \tprivate Environment env; \t \t// set up a logger for diagnostics \tprivate Logger logger = Logger.getLogger(getClass().getName()); \t \t \t// define a bean for ViewResolver \t@Bean \tpublic ViewResolver viewResolver() { \t\t \t\tInternalResourceViewResolver viewResolver = new InternalResourceViewResolver(); \t\t \t\tviewResolver.setPrefix(\"/WEB-INF/view/\"); \t\tviewResolver.setSuffix(\".jsp\"); \t\t \t\treturn viewResolver; \t} \t \t// define a bean for our security datasource \t \t@Bean \tpublic DataSource securityDataSource() { \t\t \t\t// create connection pool \t\tComboPooledDataSource securityDataSource \t\t\t\t\t\t\t\t\t= new ComboPooledDataSource(); \t\t\t\t \t\t// set the jdbc driver class \t\ttry { // Obtain driver from properties file \t\t\tsecurityDataSource.setDriverClass(env.getProperty(\"jdbc.driver\")); \t\t} catch (PropertyVetoException exc) { \t\t\tthrow new RuntimeException(exc); \t\t} \t\t \t\t // Obtain database info from properties file \t\tlogger.info(\">>> jdbc.url=\" + env.getProperty(\"jdbc.url\")); \t\tlogger.info(\">>> jdbc.user=\" + env.getProperty(\"jdbc.user\")); \t\t \t\t \t\t// set database connection props \t\tsecurityDataSource.setJdbcUrl(env.getProperty(\"jdbc.url\")); \t\tsecurityDataSource.setUser(env.getProperty(\"jdbc.user\")); \t\tsecurityDataSource.setPassword(env.getProperty(\"jdbc.password\")); \t\t \t\t// set connection pool props \t\tsecurityDataSource.setInitialPoolSize( \t\t\t\tgetIntProperty(\"connection.pool.initialPoolSize\")); \t\tsecurityDataSource.setMinPoolSize( \t\t\t\tgetIntProperty(\"connection.pool.minPoolSize\")); \t\tsecurityDataSource.setMaxPoolSize( \t\t\t\tgetIntProperty(\"connection.pool.maxPoolSize\")); \t\tsecurityDataSource.setMaxIdleTime( \t\t\t\tgetIntProperty(\"connection.pool.maxIdleTime\")); \t\t \t\treturn securityDataSource; \t} \t \t// need a helper method \t// read environment property and convert to int \t \tprivate int getIntProperty(String propName) { \t\t \t\tString propVal = env.getProperty(propName); \t\t \t\t// now convert to int \t\tint intPropVal = Integer.parseInt(propVal); \t\t \t\treturn intPropVal; \t} } Now in our security configuration we do two things: Inject the datasource we defined previouly that holds authentication information Tell Spring to use JDBC for authentication package com.springsecurity.demo.config; import javax.sql.DataSource; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Configuration; import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; import org.springframework.security.core.userdetails.User; import org.springframework.security.core.userdetails.User.UserBuilder; @Configuration @EnableWebSecurity public class DemoSecurityConfig extends WebSecurityConfigurerAdapter { \t// add a reference to our security data source \t@Autowired \tprivate DataSource securityDataSource; \t \t \t@Override \tprotected void configure(AuthenticationManagerBuilder auth) throws Exception { \t\t// use jdbc authentication \t\tauth.jdbcAuthentication().dataSource(securityDataSource); \t\t \t} \t@Override \tprotected void configure(HttpSecurity http) throws Exception { \t\thttp.authorizeRequests() \t\t\t.antMatchers(\"/\").hasRole(\"EMPLOYEE\") \t\t\t.antMatchers(\"/leaders/**\").hasRole(\"MANAGER\") \t\t\t.antMatchers(\"/systems/**\").hasRole(\"ADMIN\") \t\t\t.and() \t\t\t.formLogin() \t\t\t\t.loginPage(\"/showMyLoginPage\") \t\t\t\t.loginProcessingUrl(\"/authenticateTheUser\") \t\t\t\t.permitAll() \t\t\t.and() \t\t\t.logout().permitAll() \t\t\t.and() \t\t\t.exceptionHandling().accessDeniedPage(\"/access-denied\"); \t\t \t} } "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Security/index.html",
    "title": "Overview",
    "body": " Back Overview Spring Security is implemented using Servlet filters in the background There are two methods of securing a Web App: Declarative Programmatic Servlet Filters Servlet filters are used to pre-process/post-process web requests. They can route web requests based on security logic. Spring provides a bulk of security functionality with servlet filters. This is described in the following picture: We can see Spring intercepts the request to /mytopsecretstuff and uses the app's security configuration, alongside information about the user, passwords and roles to pre and post-process the request. Spring Security in Action Next we show a flowchart of the pre-processing made by Spring Security Filters: If the resource is protected we go to step (2), else we go to step (4) If the user is authenticated we go to step (3), else we go to step (6) If the user is authorized to access the resource we go to step (4), else we go to step (5) The resource is shown to the user The access to the resource is denied We send the user to the login page, if the user logins correctly we go to step (3) Declarative Security You define your application's security constraints in configuration. For that, you can either: Use all Java configuration (@Configuration) Use a Spring configuration file (XML) Programmatic Security You can also do it programmatically: Spring Security provides an API for custom application coding. It also provides greater customization for specific apps. Authentication/Authorization Information about users/passwords/roles, etc can be stored: In-memory JDBC LDAP Custom etc Maven Dependencies To use this framework, you have to add the following dependency to your project: \t<dependencies> ... \t\t<!-- Spring Security --> \t\t<!-- spring-security-web and spring-security-config --> \t\t \t\t<dependency> \t\t <groupId>org.springframework.security</groupId> \t\t <artifactId>spring-security-web</artifactId> \t\t <version>${springsecurity.version}</version> \t\t</dependency> ... \t<dependencies> "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Security/Basic Security.html",
    "title": "Basic Security",
    "body": " Back Basic Security Create Security Spring Initializer Spring security provides support for security initialization. Your security code is used to initialize the servlet container. There is a special class to register the Spring Security Filters. You need this class for the Spring Security Filters to \"activate\". Next we show an example: package com.springsecurity.demo.config; import org.springframework.security.web.context.AbstractSecurityWebApplicationInitializer; public class SecurityWebApplicationInitializer \t\t\t\t\t\textends AbstractSecurityWebApplicationInitializer { } Create Spring Security Configuration (@Configuration) Now we create our spring security configuration file: package com.springsecurity.demo.config; import org.springframework.context.annotation.Configuration; import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; import org.springframework.security.core.userdetails.User; import org.springframework.security.core.userdetails.User.UserBuilder; // Tell spring this is a configuration file @Configuration @EnableWebSecurity public class DemoSecurityConfig extends WebSecurityConfigurerAdapter { \t@Override \tprotected void configure(AuthenticationManagerBuilder auth) throws Exception { \t\t// add our users for in memory authentication (this is for test purposes only, you would usually retrieve this information encrypted from the database) \t\tUserBuilder users = User.withDefaultPasswordEncoder(); \t\t // Use the AuthenticationManagerBuilder given by Spring to handle authentication \t\tauth \t\t\t.inMemoryAuthentication() \t\t\t.withUser(users.username(\"john\").password(\"test123\").roles(\"EMPLOYEE\")) \t\t\t.withUser(users.username(\"mary\").password(\"test123\").roles(\"MANAGER\")) \t\t\t.withUser(users.username(\"susan\").password(\"test123\").roles(\"ADMIN\")); \t} } Add users, passwords and roles "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Java Configuration/Inversion of Control.html",
    "title": "Inversion of Control",
    "body": " Back Inversion of Control To define a bean, we now use our configuration class: Create the Bean package com.springdemo; // Note there are no special annotations public class SwimCoach implements Coach { \tprivate FortuneService fortuneService; \tpublic SwimCoach(FortuneService theFortuneService) { \t\tfortuneService = theFortuneService; \t} \t \t@Override \tpublic String getDailyWorkout() { \t\treturn \"Swim 1000 meters as a warm up.\"; \t} \t@Override \tpublic String getDailyFortune() { \t\treturn fortuneService.getFortune(); \t} } We also create the SadFortuneService Bean: package com.springdemo; import org.springframework.stereotype.Component; @Component public class SadFortuneService implements FortuneService { \t@Override \tpublic String getFortune() { \t\treturn \"Today is a sad day :(\"; \t} } Define the Bean in the Configuration Class package com.springdemo; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class SportConfig { \t \t// define bean for our sad fortune service \t@Bean \tpublic FortuneService sadFortuneService() { \t\treturn new SadFortuneService(); \t} \t \t// define bean for our swim coach AND inject dependency // without springs dependency injection \t@Bean \tpublic Coach swimCoach() { \t\tSwimCoach mySwimCoach = new SwimCoach(sadFortuneService()); \t\t \t\treturn mySwimCoach; \t} \t } The @Bean annotation tells Spring that we are creating a bean component manually. We didn't specify a scope so the default scope is singleton. public Coach swimCoach(){ specifies that the bean will bean id of \"swimCoach\". The @Bean annotation will intercept any requests for \"swimCoach\" bean. Since we didn't specify a scope, the bean scope is singleton. So now in our main method: Main Method package com.luv2code.springdemo; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class JavaConfigDemoApp { \tpublic static void main(String[] args) { \t\t// read spring config java class \t\tAnnotationConfigApplicationContext context = \t\t\t\tnew AnnotationConfigApplicationContext(SportConfig.class); \t\t \t\t// get the bean from spring container by its id \t\tCoach theCoach = context.getBean(\"swimCoach\", Coach.class); \t\t \t\t// call a method on the bean \t\tSystem.out.println(theCoach.getDailyWorkout()); \t\t\t\t \t\t// call method to get the daily fortune \t\tSystem.out.println(theCoach.getDailyFortune()); \t\t\t\t\t \t\t// close the context \t\tcontext.close(); \t\t \t} } "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Java Configuration/index.html",
    "title": "Spring Configuration with Java",
    "body": " Back Spring Configuration with Java We are now going to use Java to configure our application instead of using XML, to do that we follow the next steps: Create a Java class and annotate as @Configuration Add Component scanning support with @ComponentScan (optional), which is XML we did as: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" ....> \t<!-- add entry to enable component scanning --> \t<context:component-scan base-package=\"com.springdemo\" /> </beans> In the main app read the Spring Java configuration class Configuration With Java Inversion of Control Load Properties from File Dependency Injection "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Java Configuration/Configuration With Java.html",
    "title": "Configuration With Java",
    "body": " Back Configuration With Java Create Configuration Class package com.springdemo; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; // 1. Define configuration class @Configuration // 2. Add component scanning support @ComponentScan(\"com.springdemo\") public class SportConfig { \t } Load the Configuration Class package com.springdemo; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class JavaConfigDemoApp { \tpublic static void main(String[] args) { \t\t// read spring config java class \t\tAnnotationConfigApplicationContext context = \t\t\t\tnew AnnotationConfigApplicationContext(SportConfig.class); \t\t \t\t// get the bean from spring container \t\tCoach theCoach = context.getBean(\"tennisCoach\", Coach.class); \t\t \t\t// call a method on the bean \t\tSystem.out.println(theCoach.getDailyWorkout()); \t\t\t\t \t\t// call method to get the daily fortune \t\tSystem.out.println(theCoach.getDailyFortune()); \t\t\t\t\t \t\t// close the context \t\tcontext.close(); \t\t \t} } "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Java Configuration/Load Properties from File.html",
    "title": "Load Properties from File",
    "body": " Back Load Properties from File In order to inject values read from a properties file we do the following: Create the File First, we create the file sport.properties foo.email=myeasycoach@luv2code.com foo.team=Awesome Java Coders Load the File Now, we load the file from our Configuration class: package com.springdemo; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.PropertySource; import org.springframework.context.support.PropertySourcesPlaceholderConfigurer; @Configuration @PropertySource(\"classpath:sport.properties\") public class SportConfig { \t \t// define bean for our sad fortune service \t@Bean \tpublic FortuneService sadFortuneService() { \t\treturn new SadFortuneService(); \t} \t \t// define bean for our swim coach AND inject dependency \t@Bean \tpublic Coach swimCoach() { \t\tSwimCoach mySwimCoach = new SwimCoach(sadFortuneService()); \t\t \t\treturn mySwimCoach; \t} \t } Inject Values We inject the values at field level in our Bean: package com.springdemo; import org.springframework.beans.factory.annotation.Value; public class SwimCoach implements Coach { \tprivate FortuneService fortuneService; \t@Value(\"${foo.email}\") \tprivate String email; \t \t@Value(\"${foo.team}\") \tprivate String team; ... "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/XML configuration file.html",
    "title": "Configure Spring Container with an XML file",
    "body": " Back Configure Spring Container with an XML file First we create the config file <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"> <!-- Define your beans here --> <bean id=\"myCoach\" class=\"com.luv2code.springdemo.TrackCoach\"> </bean> </beans> Then we create the Spring container in our application: package com.springdemo; /* Class to create a spring container using xml files */ import org.springframework.context.support.ClassPathXmlApplicationContext; public class MyApp { \tpublic static void main(String[] args) { \t\t// load the spring configuration file \t\tClassPathXmlApplicationContext context = \t\t\t\tnew ClassPathXmlApplicationContext(\"applicationContext.xml\"); \t\t\t\t \t\t// retrieve bean from spring container by its id \t\tCoach theCoach = context.getBean(\"myCoach\", Coach.class); \t\t \t\t// call methods on the bean \t\tSystem.out.println(theCoach.getDailyWorkout()); \t\t \t\t// close the context \t\tcontext.close(); \t} } "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Maven/POM File Structure.html",
    "title": "POM File Structure",
    "body": " Back POM File Structure The POM File has the following structure: Project metadata: information about the project Dependencies: list of dependencies for the project Plug-ins: additional custom tasks to run (JUnit tests, reports, etc) Project Coordinates Project coordinates uniquely identify a project: Where: Group ID: name of company, group or organization Artifact ID: name for the project Version: a specific release version Dependency Coordinates To add a given dependency project, we need: Group ID Artifact ID Optional: version (best practice to include the version) Find Dependencies Search Maven Maven Repository "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Maven/Overview.html",
    "title": "Maven",
    "body": " Back Maven Maven is a project management tool. The most popular use of Maven is for build management and dependencies. Behind the scenes what Maven does is: Reads the configuration file of our application: pom.xml Checks on the local repository if the library is already stored (like a cache) If not, it goes to the remote repository and searches for it Then it saves it to the local repository Finally it uses the downloaded library to build and run the application Maven also downloads the libraries' dependencies. And when you build and run your application, maven will handle the class/build path for you, based on the configuration file. Standard Directory Structure "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Maven/Private Repositories.html",
    "title": "Private Repositories",
    "body": " Back Private Repositories If you want to create repositories with restricted access you can: Set up your own private Maven Repository in your server, that is secure with credentials: id/password Some Maven repository manager products are: Archiva Artifactory Nexus If you do not want to create your own server, there are also cloud based solutions like: Package Cloud My Maven Repo "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Maven/Maven Archetypes.html",
    "title": "Maven Archetypes",
    "body": " Back Maven Archetypes Archetypes are used to create new Maven projects, you can think of them as starter projects. Some archetypes are: For standalone projects: maven-archetype-quickstart For web projects: maven-archetype-webapp "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Maven/Additional Repositories.html",
    "title": "Additional Repositories",
    "body": " Back Additional Repositories As we have said, if Maven does not find some dependency in your local repository it goes to the central repository to search for it. But what if the dependency is not in the central repository. Then we have to define the repository in our pom.xml: "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Bean Scopes/Life Cycle.html",
    "title": "Bean Life Cycle",
    "body": " Back Bean Life Cycle The bean life cycle is as follows: As you can see you can add method/hooks: Add custom code during bean initialization Calling business logic methods Setting up handles to resources (db, sockets, etc) Add custom code during bean destruction Calling business logic methods Clean up handles to resources (db, sockets, etc) Define Methods First of all we define the methods in our bean: package com.springdemo; public class TrackCoach implements Coach { \tprivate FortuneService fortuneService; \tpublic TrackCoach() { \t\t \t} \t \tpublic TrackCoach(FortuneService fortuneService) { \t\tthis.fortuneService = fortuneService; \t} \t@Override \tpublic String getDailyWorkout() { \t\treturn \"Run a hard 5k\"; \t} \t@Override \tpublic String getDailyFortune() { \t\treturn \"Just Do It: \" + fortuneService.getFortune(); \t} \t// add an init method \tpublic void doMyStartupStuff() { \t\tSystem.out.println(\"TrackCoach: inside method doMyStartupStuff\"); \t} \t \t// add a destroy method \tpublic void doMyCleanupStuffYoYo() { \t\tSystem.out.println(\"TrackCoach: inside method doMyCleanupStuffYoYo\");\t\t \t} } Configure Hooks in the Configuration File Once the initialization and clean-up methods have been defined, we configure them in our configuration file: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"> \t<!-- Define your beans here --> \t \t<!-- define the dependency --> \t<bean id=\"myFortuneService\" \t class=\"com.springdemo.HappyFortuneService\"> \t</bean> \t \t<!-- Note the new tag \"scope\" --> \t<bean id=\"myCoach\" \tclass=\"com.springdemo.TrackCoach\" \t\tinit-method=\"doMyStartupStuff\" \t\tdestroy-method=\"doMyCleanupStuffYoYo\">\t \t\t \t\t<!-- set up constructor injection --> \t\t<constructor-arg ref=\"myFortuneService\" /> \t</bean> </beans> Main Method Now in our App, we create the bean to check that our methods are being called: package com.springdemo; import org.springframework.context.support.ClassPathXmlApplicationContext; public class BeanLifeCycleDemoApp { \t \tpublic static void main(String[] args) { \t\t// load the spring configuration file \t\tClassPathXmlApplicationContext context = \t\t\t\tnew ClassPathXmlApplicationContext(\"beanLifeCycle-applicationContext.xml\"); \t\t\t\t \t\t// retrieve bean from spring container \t\tCoach theCoach = context.getBean(\"myCoach\", Coach.class); \t\tSystem.out.println(theCoach.getDailyWorkout()); \t\t \t\t// close the context \t\tcontext.close(); \t} } Notes When using XML configuration, I want to provide additional details regarding the method signatures of the init-method and destroy-method . Access modifier: The method can have any access modifier (public, protected, private) Return type: The method can have any return type. However, \"void' is most commonly used. If you give a return type just note that you will not be able to capture the return value. As a result, \"void\" is commonly used. Method name: The method can have any method name. Arguments: The method can not accept any arguments. The method should be no-arg. "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Bean Scopes/Bean Scopes and Life cycle.html",
    "title": "Spring Bean Scopes and Life Cycle",
    "body": " Back Spring Bean Scopes and Life Cycle Scope Life Cycle "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Bean Scopes/Scope.html",
    "title": "Bean Scopes",
    "body": " Back Bean Scopes Intro The scope of a bean refers to the life cycle of the bean: How long does it live How many instances are created How is the bean shared The default scope of the bean is a Singleton: The Spring container creates only one instance of the bean It is cached in memory All requests to the bean will return a shared reference to the same bean Other scopes are: A singleton scope is good for stateless data A prototype scope is good for stateful data (the container returns a new bean for each request). Note that for this type of bean, Spring does not call the destroy method. Specify Scope in XML Config File <?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"> <!-- Define your beans here --> <!-- define the dependency --> <bean id=\"myFortuneService\" class=\"com.springdemo.HappyFortuneService\"> </bean> <!-- Note the new tag \"scope\" --> <bean id=\"myCoach\" class=\"com.springdemo.TrackCoach\" scope=\"prototype\">\t <!-- set up constructor injection --> <constructor-arg ref=\"myFortuneService\" /> </bean> </beans> Main Method Now, from our application we do: package com.springdemo; import org.springframework.context.support.ClassPathXmlApplicationContext; public class BeanScopeDemoApp { \tpublic static void main(String[] args) { \t\t// load the spring configuration file \t\tClassPathXmlApplicationContext context = \t\t\t\tnew ClassPathXmlApplicationContext(\"beanScope-applicationContext.xml\"); \t\t\t\t \t\t// retrieve bean from spring container \t\tCoach theCoach = context.getBean(\"myCoach\", Coach.class); \t\tCoach alphaCoach = context.getBean(\"myCoach\", Coach.class); \t\t \t\t// check if they are the same \t\tboolean result = (theCoach == alphaCoach); \t\t \t\t// print out the results \t\tSystem.out.println(\"\\nPointing to the same object: \" + result); \t\t \t\tSystem.out.println(\"\\nMemory location for theCoach: \" + theCoach); \t\tSystem.out.println(\"\\nMemory location for alphaCoach: \" + alphaCoach + \"\\n\"); \t \t\t// close the context \t\tcontext.close(); \t} } Observe, the result variable should be set to false, because we are using the prototype scope. Also the values of the memory location for the two objects should be distinct for that same reason. However if we were using scope=\"singleton\", then result should be true, and both objects should have the same memory location. "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/MVC/Resources.html",
    "title": "Add CSS and JS",
    "body": " Back Add CSS and JS Here are the steps on how to access static resources in a Spring MVC. For example, you can use this to access images, css, JavaScript files etc. You can configure references to static resources in the spring-mvc-demo-servlet.xml. Add the following entry to your Spring MVC configuration file: spring-mvc-demo-servlet.xml <mvc:resources mapping=\"/resources/**\" location=\"/resources/\"></mvc:resources> Now in your view pages, you can access the static files using this syntax: <img src=\"${pageContext.request.contextPath}/resources/images/spring-logo.png\"> "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/MVC/Request Params and Request Mappings.html",
    "title": "Request Params and Request Mappings",
    "body": " Back Request Params and Request Mappings Request Params Spring provides for a specific annotation that allows you to retrieve request parameters directly without using the HttpServletRequest object. Given the form: package com.springdemo.mvc; import javax.servlet.http.HttpServletRequest; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; @Controller public class HelloWorldController { \t@RequestMapping(\"/processFormVersionThree\")\t \tpublic String processFormVersionThree( // We use the annotation to obtain the parameter \t\t\t@RequestParam(\"studentName\") String theName, \t\t\tModel model) { \t\t\t\t \t\t// convert the data to all caps \t\ttheName = theName.toUpperCase(); \t\t \t\t// create the message \t\tString result = \"Hey My Friend from v3! \" + theName; \t\t \t\t// add message to the model \t\tmodel.addAttribute(\"message\", result); \t\t\t\t \t\treturn \"helloworld\"; \t}\t } Controller Request Mappings They serve as a parent mapping for the controller All request mappings on methods in the controller are relative For example: package com.springdemo.mvc; import javax.servlet.http.HttpServletRequest; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestParam; @Controller // This is the request mapping for the controller @RequestMapping(\"/hello\") public class HelloWorldController { \t// Both of these request mappings are relative to the parent mapping \t// that is the mapping translates to domain/hello/showForm \t// need a controller method to show the initial HTML form \t@RequestMapping(\"/showForm\") \tpublic String showForm() { \t\treturn \"helloworld-form\"; \t} \t\t \t// need a controller method to process the HTML form \t@RequestMapping(\"/processForm\") \tpublic String processForm() { \t\treturn \"helloworld\"; \t} } "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/MVC/Validation with Regular Expressions.html",
    "title": "Validation with Regular Expressions",
    "body": " Back Validation with Regular Expressions In this section we will show how to perform a validation with regular expressions. Add Validation Rule to Bean We create a Customer class, whose freePasses variable must be a number between 0 and 10. public class Customer { \tprivate String firstName; \t \t@NotNull(message=\"is required\") \t@Size(min=1, message=\"is required\") \tprivate String lastName; \t@Min(value=0, message=\"must be greater than or equal to zero\") \t@Max(value=10, message=\"must be less than or equal to 10\") \tprivate int freePasses; // Define the regular expression for the postalCode attribute @Pattern(regexp=\"^[a-zA-Z0-9]{5}\", message=\"only 5 chars/digits\") \tprivate String postalCode; \t \t... Perform Validation in the Controller We also package com.springdemo.mvc; import javax.validation.Valid; import org.springframework.beans.propertyeditors.StringTrimmerEditor; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.validation.BindingResult; import org.springframework.web.bind.WebDataBinder; import org.springframework.web.bind.annotation.InitBinder; import org.springframework.web.bind.annotation.ModelAttribute; import org.springframework.web.bind.annotation.RequestMapping; @Controller @RequestMapping(\"/customer\") public class CustomerController { \t// add an initbinder ... to convert trim input strings \t// remove leading and trailing whitespace \t// resolve issue for our validation \t \t@InitBinder \t//@InitBinder annotation works as a pre-processor \t// It will pre-process each web request to our controller \tpublic void initBinder(WebDataBinder dataBinder) { \t\t \t\t// Trim strings (true: empty strings to null) \t\tStringTrimmerEditor stringTrimmerEditor = new StringTrimmerEditor(true); \t \t\t// For every string class apply the trim editor \t\tdataBinder.registerCustomEditor(String.class, stringTrimmerEditor); \t} \t \t \t@RequestMapping(\"/showForm\") \tpublic String showForm(Model theModel) { \t\t \t\ttheModel.addAttribute(\"customer\", new Customer()); \t\t \t\treturn \"customer-form\"; \t} \t \t@RequestMapping(\"/processForm\") \t// @Valid: Tells spring to perform validation on the customer object \t// BindingResult: results of the validation will be placed in BindingResult \tpublic String processForm( \t\t\t@Valid @ModelAttribute(\"customer\") Customer theCustomer, \t\t\tBindingResult theBindingResult) { \t\t \t\tSystem.out.println(\"Last name: |\" + theCustomer.getLastName() + \"|\"); \t\t \t\t// Check if validation was sucessfull \t\tif (theBindingResult.hasErrors()) { \t\t\t// If not sucessfull send back \t\t\treturn \"customer-form\"; \t\t} \t\telse { \t\t\t// If sucessfull \t\t\treturn \"customer-confirmation\"; \t\t} \t} } When performing Spring MVC validation, the location of the BindingResult parameter is very important. In the method signature, the BindingResult parameter must appear immediately after the model attribute. Display error on HTML <%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %> <html> <head> \t<title>Customer Registration Form</title> \t \t<style> \t\t.error {color:red} \t</style> </head> <body> <i>Fill out the form. Asterisk (*) means required.</i> <br><br> \t<form:form action=\"processForm\" modelAttribute=\"customer\"> \t\tFirst name: <form:input path=\"firstName\" /> \t\t<br><br> \t\tLast name (*): <form:input path=\"lastName\" /> \t\t<form:errors path=\"lastName\" cssClass=\"error\" /> \t\t<br><br> \t\tFree passes: <form:input path=\"freePasses\" /> \t\t<form:errors path=\"freePasses\" cssClass=\"error\" /> <br><br> \t\tPostal Code: <form:input path=\"postalCode\" /> <!-- The message shown equals the messages from both of the validation annotations defined for the postalCode attribute in the Customer class --> \t\t<form:errors path=\"postalCode\" cssClass=\"error\" /> \t\t<br><br> \t\t<input type=\"submit\" value=\"Submit\" /> \t</form:form> </body> </html> "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/MVC/Form Validation.html",
    "title": "Form Validation",
    "body": " Back Form Validation Java has a standard Bean Validation API that defines a metadata model and an API for entity validation. Here is a list of bean validation features you can check: required validate length validate numbers validate with regular expressions custom validation Some Annotations to perform the validation are the following: Set up Add Hibernate's library (Hibernate Validator)for Bean Validation which is fully compliant with Java's Bean Validation API. Required Validation Number Range Validation Validation with Regular Expressions Handle String in Integer Field Custom Validation "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/MVC/Controller.html",
    "title": "Controller",
    "body": " Back Controller Create Controller Class package com.springdemo.mvc; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; // Add controller annotation @Controller public class HomeController { \t \t// Add request mapping: this method controls the request coming to this url \t@RequestMapping(\"/\") \tpublic String showPage() { \t // Name of the view that is returned: note they are stored in WEB-INF/view/ \t\treturn \"main-menu\"; \t} } Now, we create the view "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/MVC/Form Tags.html",
    "title": "Form Tags",
    "body": " Back Form Tags Form Tags are configurable an reusable: They can make use of data binding (you can automatically set and retrieve data from a Java object) You can mix them in with you HTML web page Some examples are: Reference Spring MVC Form Tags To use these tags in your web page you have to specify the spring namespace at the beginning of the JSP file: <!-- Reference to the namespace --> <%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %> <!DOCTYPE html> <html> <head></head> <body> </body> </html> Text Fields Drop Down Lists Radio Buttons CheckBox "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/MVC/Adding Data.html",
    "title": "Model",
    "body": " Back Model The Model is a container for the application data. So in your controller you can put anything in the model (strings, objects, info from DB, etc). And then you view page (JSP) can access data from the model. Example Controller package com.springdemo.mvc; import javax.servlet.http.HttpServletRequest; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; @Controller public class HelloWorldController { // new a controller method to read form data and // add data to the model @RequestMapping(\"/processFormVersionTwo\")\t // the HttpServletRequest allows you to retrieve information from the request (like the parameters of a form) // the model is our Model where we will store data public String parseString(HttpServletRequest request, Model model) { // read the request parameter from the HTML form String theName = request.getParameter(\"studentName\"); // convert the data to all caps theName = theName.toUpperCase(); // create the message String result = \"Yo! \" + theName; // add message attribute to the model model.addAttribute(\"message\", result); \t\t return \"helloworld\"; } } View Now, on the view, we can access the Model data: <!DOCTYPE html> <html> <body> Hello World of Spring! <br><br> Student name: ${param.studentName} <br><br> <!-- Access model data by the attribute's name--> The message: ${message} </body> </html> "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/MVC/Read HTML Form Data.html",
    "title": "Read HTML Form Data",
    "body": " Back Read HTML Form Data The flow of our example will be the following: When the user accesses the URL /showForm, the browser will send a request to our controller, and our controller will return the corresponding view When the user hits submit on the form the action /processForm is passed to the browser that will send a request to our controller, and our controller will process the request Controller package com.springdemo.mvc; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; @Controller public class HelloWorldController { \t// need a controller method to show the initial HTML form \t@RequestMapping(\"/showForm\") // The method name can be anything \tpublic String showForm() { \t\treturn \"helloworld-form\"; \t} \t\t \t// need a controller method to process the HTML form \t@RequestMapping(\"/processForm\") \tpublic String processForm() { \t\treturn \"helloworld\"; \t} \t\t } View We create WEB-INF/view/helloworld-form.jsp <!DOCTYPE html> <html> <head> \t<title>Hello World - Input Form</title> </head> <body> <!-- The action is the request url --> \t<form action=\"processForm\" method=\"GET\"> \t\t<input type=\"text\" name=\"studentName\" \t\t\tplaceholder=\"What's your name?\" /> \t\t<input type=\"submit\" /> \t</form> </body> </html> And we create WEB-INF/view/helloworld-form.jsp <!DOCTYPE html> <html> <body> Hello World of Spring! <br><br> <!-- name of HTML form field from previous jsp view --> Student name: ${param.studentName} </body> </html> "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/MVC/Text Fields.html",
    "title": "Text Fields",
    "body": " Back Text Fields To pass and bind data from input text fields to controllers an another views we use the Form Tag form:input along with form:form: Controller Add a Model to the controller method for the form and create the model attribute, that holds the data and perfoms data binding package com.springdemo.mvc; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.ModelAttribute; import org.springframework.web.bind.annotation.RequestMapping; @Controller @RequestMapping(\"/student\") public class StudentController { \t \t// Request to show the view that contains the form \t@RequestMapping(\"/showForm\") \tpublic String showForm(Model theModel) { \t\t \t\t// create a student object \t\tStudent theStudent = new Student(); \t\t \t\t// add student object to the model \t\ttheModel.addAttribute(\"student\", theStudent); \t\t \t\treturn \"student-form\"; \t} \t \t// Process the submit event on the form \t@RequestMapping(\"/processForm\") \t// We obtain the model attribute with the following annotation \tpublic String processForm(@ModelAttribute(\"student\") Student theStudent) { \t\t \t\t// Now we can retrieve the updated information from the form \t\tSystem.out.println(\"theStudent: \" + theStudent.getFirstName() \t\t\t\t\t\t\t+ \" \" + theStudent.getLastName()); \t\t \t\treturn \"student-confirmation\"; \t} } View Setting the HTML for data binding: For student-form.jsp: <%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %> <!DOCTYPE html> <html> <head> \t<title>Student Registration Form</title> </head> <body> \t<!-- Note the modelAttribute equals the attribute we added to the model in the controller--> \t<form:form action=\"processForm\" modelAttribute=\"student\"> \t\t<!-- To retrieve the data this maps to student.getFirstName() --> \t\tFirst name: <form:input path=\"firstName\" /> \t\t<br><br> \t\tLast name: <form:input path=\"lastName\" /> \t\t<br><br> \t\t<input type=\"submit\" value=\"Submit\" /> \t</form:form> </body> </html> When we submit Spring will call student.setFirstName() and student.setLastName() to save the data in the Student object, so we can retrieve it from our controller method. For student-confirmation.jsp: <%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %> <!DOCTYPE html> <html> <head> \t<title>Student Confirmation</title> </head> <body> \t<!-- Obtain data from the model: note we use the attribute's name (i.e. student) to access the object --> \tThe student is confirmed: ${student.firstName} ${student.lastName} </body> </html> Model The model attribute \"student\" is populated with an instance of the following Student class: package com.springdemo.mvc; import java.util.LinkedHashMap; public class Student { \tprivate String firstName; \tprivate String lastName; \t\t \tpublic Student() {} \tpublic String getFirstName() { \t\treturn firstName; \t} \tpublic void setFirstName(String firstName) { \t\tthis.firstName = firstName; \t} \tpublic String getLastName() { \t\treturn lastName; \t} \tpublic void setLastName(String lastName) { \t\tthis.lastName = lastName; \t} } "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/MVC/Custom Validation.html",
    "title": "Custom Validation",
    "body": " Back Custom Validation Create a Custom Java Annotation Create Annotation Clas package com.springdemo.mvc.validation; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; import javax.validation.Constraint; import javax.validation.Payload; // Specify the class that holds the validation logic @Constraint(validatedBy = CourseCodeConstraintValidator.class) // Where you can use this annotation: on a method or on a field @Target( { ElementType.METHOD, ElementType.FIELD } ) @Retention(RetentionPolicy.RUNTIME) // Note the @interface (it is needed to create the annotation) public @interface CourseCode { \t// define default course code \tpublic String value() default \"LUV\"; \t \t// define default error message \tpublic String message() default \"must start with LUV\"; \t \t// define default groups \tpublic Class<?>[] groups() default {}; \t \t// define default payloads \tpublic Class<? extends Payload>[] payload() default {}; } Create Validator Class This class holds the validation logic package com.springdemo.mvc.validation; import javax.validation.ConstraintValidator; import javax.validation.ConstraintValidatorContext; // Implements the previous ConstraintValidator interface, with generics: <Annotation Interface, Data Type> public class CourseCodeConstraintValidator \timplements ConstraintValidator<CourseCode, String> { \tprivate String coursePrefix; \t \t@Override \tpublic void initialize(CourseCode theCourseCode) { \t\t// Obtain prefix from the \"value\" attribute of our annotation \t\tcoursePrefix = theCourseCode.value(); \t} \t@Override \t// Called when we use the @Valid annotation \tpublic boolean isValid(String theCode, ConstraintValidatorContext theConstraintValidatorContext) { \t\tboolean result; \t\t \t\t// Validation logic \t\tif (theCode != null) { \t\t\tresult = theCode.startsWith(coursePrefix); \t\t} \t\telse { \t\t\tresult = true; \t\t} \t\t \t\treturn result; \t} } Add Custom Validation public class Customer { \tprivate String firstName; \t \t@NotNull(message=\"is required\") \t@Size(min=1, message=\"is required\") \tprivate String lastName; \t@NotNull(message=\"is required\") \t@Min(value=0, message=\"must be greater than or equal to zero\") \t@Max(value=10, message=\"must be less than or equal to 10\") \tprivate Integer freePasses; \t@Pattern(regexp=\"^[a-zA-Z0-9]{5}\", message=\"only 5 chars/digits\") \tprivate String postalCode; \t // Use our custom validation tag \t@CourseCode(value=\"TOPS\", message=\"must start with TOPS\") \tprivate String courseCode; Perform Validation on Controller package com.springdemo.mvc; import javax.validation.Valid; import org.springframework.beans.propertyeditors.StringTrimmerEditor; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.validation.BindingResult; import org.springframework.web.bind.WebDataBinder; import org.springframework.web.bind.annotation.InitBinder; import org.springframework.web.bind.annotation.ModelAttribute; import org.springframework.web.bind.annotation.RequestMapping; @Controller @RequestMapping(\"/customer\") public class CustomerController { \t// add an initbinder ... to convert trim input strings \t// remove leading and trailing whitespace \t// resolve issue for our validation \t \t@InitBinder \t//@InitBinder annotation works as a pre-processor \t// It will pre-process each web request to our controller \tpublic void initBinder(WebDataBinder dataBinder) { \t\t \t\t// Trim strings (true: empty strings to null) \t\tStringTrimmerEditor stringTrimmerEditor = new StringTrimmerEditor(true); \t \t\t// For every string class apply the trim editor \t\tdataBinder.registerCustomEditor(String.class, stringTrimmerEditor); \t} \t \t \t@RequestMapping(\"/showForm\") \tpublic String showForm(Model theModel) { \t\t \t\ttheModel.addAttribute(\"customer\", new Customer()); \t\t \t\treturn \"customer-form\"; \t} \t \t@RequestMapping(\"/processForm\") \t// @Valid: Tells spring to perform validation on the customer object \t// BindingResult: results of the validation will be placed in BindingResult \tpublic String processForm( \t\t\t@Valid @ModelAttribute(\"customer\") Customer theCustomer, \t\t\tBindingResult theBindingResult) { \t\t \t\tSystem.out.println(\"Last name: |\" + theCustomer.getLastName() + \"|\"); \t\t \t\t// Check if validation was sucessfull \t\tif (theBindingResult.hasErrors()) { \t\t\t// If not sucessfull send back \t\t\treturn \"customer-form\"; \t\t} \t\telse { \t\t\t// If sucessfull \t\t\treturn \"customer-confirmation\"; \t\t} \t} } When performing Spring MVC validation, the location of the BindingResult parameter is very important. In the method signature, the BindingResult parameter must appear immediately after the model attribute. Display error on HTML <%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %> <html> <head> \t<title>Customer Registration Form</title> \t \t<style> \t\t.error {color:red} \t</style> </head> <body> <i>Fill out the form. Asterisk (*) means required.</i> <br><br> \t<form:form action=\"processForm\" modelAttribute=\"customer\"> \t\tFirst name: <form:input path=\"firstName\" /> \t\t<br><br> \t\tLast name (*): <form:input path=\"lastName\" /> \t\t<form:errors path=\"lastName\" cssClass=\"error\" /> \t\t<br><br> \t\tFree passes: <form:input path=\"freePasses\" /> \t\t<form:errors path=\"freePasses\" cssClass=\"error\" /> <br><br> \t\tPostal Code: <form:input path=\"postalCode\" /> \t\t<form:errors path=\"postalCode\" cssClass=\"error\" /> \t\t<br><br> <!-- The message shown equals the messages from both of the validation annotations defined for the courseCode attribute in the Customer class --> \t\t\tCourse Code: <form:input path=\"courseCode\" /> \t\t\t<form:errors path=\"courseCode\" cssClass=\"error\" /> \t\t<br><br> \t\t<input type=\"submit\" value=\"Submit\" /> \t</form:form> </body> </html> "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/MVC/Drop Down Lists.html",
    "title": "Drop Down Lists",
    "body": " Back Drop Down Lists To pass and bind data from drop down lists to controllers an another views we use the Form Tags form:select that encloses a set of options represented with form:option tags. And all these are surrounded by a form:form: Controller Add a Model to the controller method for the form and create the model attribute, that holds the data and performs data binding package com.springdemo.mvc; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.ModelAttribute; import org.springframework.web.bind.annotation.RequestMapping; @Controller @RequestMapping(\"/student\") public class StudentController { \t \t// Request to show the view that contains the form \t@RequestMapping(\"/showForm\") \tpublic String showForm(Model theModel) { \t\t \t\t// create a student object \t\tStudent theStudent = new Student(); \t\t \t\t// add student object to the model \t\ttheModel.addAttribute(\"student\", theStudent); \t\t \t\treturn \"student-form\"; \t} \t \t// Process the submit event on the form \t@RequestMapping(\"/processForm\") \t// We obtain the model attribute with the following annotation \tpublic String processForm(@ModelAttribute(\"student\") Student theStudent) { \t\t \t\t// Now we can retrieve the updated information from the form \t\tSystem.out.println(\"theStudent: \" + theStudent.getFirstName() \t\t\t\t\t\t\t+ \" \" + theStudent.getLastName()); \t\t \t\treturn \"student-confirmation\"; \t} } View Setting the HTML for data binding: For student-form.jsp: <%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %> <!DOCTYPE html> <html> <head> \t<title>Student Registration Form</title> </head> <body> \t<form:form action=\"processForm\" modelAttribute=\"student\"> \t\tFirst name: <form:input path=\"firstName\" /> \t\t<br><br> \t\tLast name: <form:input path=\"lastName\" /> \t\t<br><br> \t\tCountry: \t\t<!-- Drop down list of country options --> \t\t<!-- We specify the variable where we store the selected value in the student object: which is country --> \t\t<form:select path=\"country\"> \t\t\t<!-- This is a list that was populated when we created the student object --> \t\t\t<!-- Remember Spring calls student.getCountryOptions() --> \t\t\t<form:options items=\"${student.countryOptions}\" /> \t\t</form:select> \t\t<br><br> \t\t<input type=\"submit\" value=\"Submit\" /> \t</form:form> </body> </html> For student-confirmation.jsp: <%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %> <!DOCTYPE html> <html> <head> \t<title>Student Confirmation</title> </head> <body> \tThe student is confirmed: ${student.firstName} ${student.lastName} \t<!-- Obtain the value saved in the coutry variable inside the student's object (corresponds to the selected value) --> \tSelected coutry: ${student.country} ${student.lastName} </body> </html> Model The model attribute \"student\" is populated with an instance of the following Student class: package com.springdemo.mvc; import java.util.LinkedHashMap; public class Student { \tprivate String firstName; \tprivate String lastName; \t \tprivate String country; \t \tprivate LinkedHashMap<String, String> countryOptions; \t \tpublic Student() { \t\t \t\t// populate country options: used ISO country code \t\tcountryOptions = new LinkedHashMap<>(); \t\t \t\tcountryOptions.put(\"BR\", \"Brazil\"); \t\tcountryOptions.put(\"FR\", \"France\"); \t\tcountryOptions.put(\"DE\", \"Germany\"); \t\tcountryOptions.put(\"IN\", \"India\"); \t\tcountryOptions.put(\"US\", \"United States of America\");\t\t \t} \tpublic String getFirstName() { \t\treturn firstName; \t} \tpublic void setFirstName(String firstName) { \t\tthis.firstName = firstName; \t} \tpublic String getLastName() { \t\treturn lastName; \t} \tpublic void setLastName(String lastName) { \t\tthis.lastName = lastName; \t} \tpublic String getCountry() { \t\treturn country; \t} \t// Setter and getter handlers for the new binded attribute \tpublic void setCountry(String country) { \t\tthis.country = country; \t} \tpublic LinkedHashMap<String, String> getCountryOptions() { \t\treturn countryOptions; \t} } Country options from a properties file We create WEB-INF/countries.properties: BR=Brazil FR=France CO=Colombia IN=India Update configuration's file spring-mvc-dmo-servlet.xml header (to use a new set of Spring tags: utils): <?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:util=\"http://www.springframework.org/schema/util\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd\"> Load the country options properties file in the Spring configuration file, with a bean id equal to \"countryOptions\": <util:properties id=\"countryOptions\" location=\"classpath:../countries.properties\" /> Inject properties inside our controller: @Value(\"#{countryOptions}\") private Map<String, String> countryOptions; Add countryOptions as an attribute of the model inside the controller method: @RequestMapping(\"/showForm\") public String showForm(Model theModel) { // create a student object Student Student theStudent = new Student(); // add student object to the model theModel.addAttribute(\"student\", theStudent); // add the country options to the model theModel.addAttribute(\"theCountryOptions\", countryOptions); return \"student-form\"; } Update the view as follows: <form:select path=\"country\"> <form:options items=\"${theCountryOptions}\" /> </form:select> "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/MVC/Radio Buttons.html",
    "title": "Radio Buttons",
    "body": " Back Radio Buttons To pass and bind data from radio buttons to controllers an another views we use the Form Tag form:radiobutton which is surrounded by a form:form: Controller Add a Model to the controller method for the form and create the model attribute, that holds the data and performs data binding package com.springdemo.mvc; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.ModelAttribute; import org.springframework.web.bind.annotation.RequestMapping; @Controller @RequestMapping(\"/student\") public class StudentController { \t \t// Request to show the view that contains the form \t@RequestMapping(\"/showForm\") \tpublic String showForm(Model theModel) { \t\t \t\t// create a student object \t\tStudent theStudent = new Student(); \t\t \t\t// add student object to the model \t\ttheModel.addAttribute(\"student\", theStudent); \t\t \t\treturn \"student-form\"; \t} \t \t// Process the submit event on the form \t@RequestMapping(\"/processForm\") \t// We obtain the model attribute with the following annotation \tpublic String processForm(@ModelAttribute(\"student\") Student theStudent) { \t\t \t\t// Now we can retrieve the updated information from the form \t\tSystem.out.println(\"theStudent: \" + theStudent.getFirstName() \t\t\t\t\t\t\t+ \" \" + theStudent.getLastName()); \t\t \t\treturn \"student-confirmation\"; \t} } View Setting the HTML for data binding: For student-form.jsp: <%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %> <!DOCTYPE html> <html> <head> \t<title>Student Registration Form</title> </head> <body> \t<form:form action=\"processForm\" modelAttribute=\"student\"> \t\tFirst name: <form:input path=\"firstName\" /> \t\t<br><br> \t\tLast name: <form:input path=\"lastName\" /> \t\t<br><br> \t\tCountry: \t\t<!-- Drop down list of country options --> \t\t<!-- We specify the variable where we store the selected value in the student object: which is country --> \t\t<form:select path=\"country\"> \t\t\t<!-- This is a list that was populated when we created the student object --> \t\t\t<!-- Remember Spring calls student.getCountryOptions() --> \t\t\t<form:options items=\"${student.countryOptions}\" /> \t\t</form:select> \t\t<br><br> \t\t<br><br> \t\tFavorite Language: \t\t \t\t<!-- The \"path\" specifies the name of the property we are going to bind the radiobutton to, in this case \"favoriteLanguage\" --> \t\t<!-- Note these can also be populated from the Student class or using a properties file --> \t\tJava <form:radiobutton path=\"favoriteLanguage\" value=\"Java\" /> \t\tC# <form:radiobutton path=\"favoriteLanguage\" value=\"C#\" /> \t\tPHP <form:radiobutton path=\"favoriteLanguage\" value=\"PHP\" /> \t\tRuby <form:radiobutton path=\"favoriteLanguage\" value=\"Ruby\" /> \t\t<br><br> \t\t<input type=\"submit\" value=\"Submit\" /> \t</form:form> </body> </html> For student-confirmation.jsp: <%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %> <!DOCTYPE html> <html> <head> \t<title>Student Confirmation</title> </head> <body> \tThe student is confirmed: ${student.firstName} ${student.lastName} \t<br><br> \tSelected coutry: ${student.country} ${student.lastName} \t<br><br> \t<!-- Obtain the value using the binded variable inside the student object --> \tFavorite language: ${student.favoriteLanguage} </body> </html> Model The model attribute \"student\" is populated with an instance of the following Student class: package com.springdemo.mvc; import java.util.LinkedHashMap; public class Student { \tprivate String firstName; \tprivate String lastName; \t \tprivate String country; \t \tprivate LinkedHashMap<String, String> countryOptions; \t \t// Property we are going to bind to the radio buttons \tprivate String favoriteLanguage; \t \tpublic Student() { \t\t \t\t// populate country options: used ISO country code \t\tcountryOptions = new LinkedHashMap<>(); \t\t \t\tcountryOptions.put(\"BR\", \"Brazil\"); \t\tcountryOptions.put(\"FR\", \"France\"); \t\tcountryOptions.put(\"DE\", \"Germany\"); \t\tcountryOptions.put(\"IN\", \"India\"); \t\tcountryOptions.put(\"US\", \"United States of America\");\t\t \t\t \t\t// We can also populate the favoriteLanguage options from here \t\t// in the same manner we did with the country options \t} \tpublic String getFirstName() { \t\treturn firstName; \t} \tpublic void setFirstName(String firstName) { \t\tthis.firstName = firstName; \t} \tpublic String getLastName() { \t\treturn lastName; \t} \tpublic void setLastName(String lastName) { \t\tthis.lastName = lastName; \t} \tpublic String getCountry() { \t\treturn country; \t} \tpublic void setCountry(String country) { \t\tthis.country = country; \t} \tpublic LinkedHashMap<String, String> getCountryOptions() { \t\treturn countryOptions; \t} \t \t// Setter and getter handlers for the new binded attribute \tpublic String getFavoriteLanguage() { \t\treturn favoriteLanguage; \t} \tpublic void setFavoriteLanguage(String favoriteLanguage) { \t\tthis.favoriteLanguage = favoriteLanguage; \t} } "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/MVC/Handle String in Integer Field.html",
    "title": "Handle String Input in Integer Field",
    "body": " Back Handle String Input in Integer Field If we want to avoid the trace returned by errors like inputting the wrong data type (string instead of int), we can define a custom message that will override those messages. Create a custom message Create a properties file in resources/messages.properties // ErrorType.SpringModelAttributeName.FieldName typeMismatch.customer.freePasses=Invalid number Specify Properties file in Configuration We add the following in our configuration file spring-mvc-demo-servlet.xml <?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" \txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \txmlns:context=\"http://www.springframework.org/schema/context\" \txmlns:mvc=\"http://www.springframework.org/schema/mvc\" \txsi:schemaLocation=\" \t\thttp://www.springframework.org/schema/beans \thttp://www.springframework.org/schema/beans/spring-beans.xsd \thttp://www.springframework.org/schema/context \thttp://www.springframework.org/schema/context/spring-context.xsd \thttp://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"> \t<context:component-scan base-package=\"com.luv2code.springdemo\" /> \t<mvc:annotation-driven/> \t<bean \t\tclass=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"> \t\t<property name=\"prefix\" value=\"/WEB-INF/view/\" /> \t\t<property name=\"suffix\" value=\".jsp\" /> \t</bean> \t <!-- Load custom message resources --> <bean id=\"messageSource\" class=\"org.springframework.context.support.ResourceBundleMessageSource\"> \t\t\t\t<!-- Path where the properties file is stored --> <property name=\"basenames\" value=\"resources/messages\" /> </bean> </beans> "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/MVC/CheckBox.html",
    "title": "Check Box",
    "body": " Back Check Box To pass and bind data from check boxes to controllers an another views we use the Form Tag form:checkbox which is surrounded by a form:form: Controller Add a Model to the controller method for the form and create the model attribute, that holds the data and performs data binding package com.springdemo.mvc; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.ModelAttribute; import org.springframework.web.bind.annotation.RequestMapping; @Controller @RequestMapping(\"/student\") public class StudentController { \t \t// Request to show the view that contains the form \t@RequestMapping(\"/showForm\") \tpublic String showForm(Model theModel) { \t\t \t\t// create a student object \t\tStudent theStudent = new Student(); \t\t \t\t// add student object to the model \t\ttheModel.addAttribute(\"student\", theStudent); \t\t \t\treturn \"student-form\"; \t} \t \t// Process the submit event on the form \t@RequestMapping(\"/processForm\") \t// We obtain the model attribute with the following annotation \tpublic String processForm(@ModelAttribute(\"student\") Student theStudent) { \t\t \t\t// Now we can retrieve the updated information from the form \t\tSystem.out.println(\"theStudent: \" + theStudent.getFirstName() \t\t\t\t\t\t\t+ \" \" + theStudent.getLastName()); \t\t \t\treturn \"student-confirmation\"; \t} } View Setting the HTML for data binding: For student-form.jsp: <%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %> <!DOCTYPE html> <html> <head> \t<title>Student Registration Form</title> </head> <body> \t<form:form action=\"processForm\" modelAttribute=\"student\"> \t\tFirst name: <form:input path=\"firstName\" /> \t\t<br><br> \t\tLast name: <form:input path=\"lastName\" /> \t\t<br><br> \t\tCountry: \t\t<!-- Drop down list of country options --> \t\t<!-- We specify the variable where we store the selected value in the student object: which is country --> \t\t<form:select path=\"country\"> \t\t\t<!-- This is a list that was populated when we created the student object --> \t\t\t<!-- Remember Spring calls student.getCountryOptions() --> \t\t\t<form:options items=\"${student.countryOptions}\" /> \t\t</form:select> \t\t<br><br> \t\t<br><br> \t\tFavorite Language: \t\t \t\tJava <form:radiobutton path=\"favoriteLanguage\" value=\"Java\" /> \t\tC# <form:radiobutton path=\"favoriteLanguage\" value=\"C#\" /> \t\tPHP <form:radiobutton path=\"favoriteLanguage\" value=\"PHP\" /> \t\tRuby <form:radiobutton path=\"favoriteLanguage\" value=\"Ruby\" /> \t\t<br><br> \t\tOperating Systems: \t\t \t\t<!-- The \"path\" specifies the name of the property we are going to bind the radiobutton to, in this case \"operatingSystems\" --> \t\t<!-- Note these can also be populated from the Student class or using a properties file --> \t\tLinux <form:checkbox path=\"operatingSystems\" value=\"Linux\" /> \t\tMac OS <form:checkbox path=\"operatingSystems\" value=\"Mac OS\" /> \t\tMS Windows <form:checkbox path=\"operatingSystems\" value=\"MS Window\" />\t \t\t<br><br> \t\t<input type=\"submit\" value=\"Submit\" /> \t</form:form> </body> </html> For student-confirmation.jsp: <%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %> <!DOCTYPE html> <html> <head> \t<title>Student Confirmation</title> </head> <body> \tThe student is confirmed: ${student.firstName} ${student.lastName} \t<br><br> \tSelected coutry: ${student.country} ${student.lastName} \t<br><br> \t<!-- Obtain the value using the binded variable inside the student object --> \tFavorite language: ${student.favoriteLanguage} \t<br><br> \tOperating Systems: \t<!-- Create an unordered list of the selected values in the checkbox --> \t\t<ul> \t\t\t<c:forEach var=\"temp\" items=\"${student.operatingSystems}\"> \t\t\t\t<li> ${temp} </li> \t\t\t</c:forEach> \t\t</ul> </body> </html> Model The model attribute \"student\" is populated with an instance of the following Student class: package com.springdemo.mvc; import java.util.LinkedHashMap; public class Student { \tprivate String firstName; \tprivate String lastName; \t \tprivate String country; \t \tprivate LinkedHashMap<String, String> countryOptions; \t \tprivate String favoriteLanguage; // Attribute bound to the checkbox (multiple options so it is an array) private String[] operatingSystems; \t \tpublic Student() { \t\t \t\t// populate country options: used ISO country code \t\tcountryOptions = new LinkedHashMap<>(); \t\t \t\tcountryOptions.put(\"BR\", \"Brazil\"); \t\tcountryOptions.put(\"FR\", \"France\"); \t\tcountryOptions.put(\"DE\", \"Germany\"); \t\tcountryOptions.put(\"IN\", \"India\"); \t\tcountryOptions.put(\"US\", \"United States of America\");\t\t \t\t \t\t// We can also populate the favoriteLanguage options from here \t\t// in the same manner we did with the country options \t} \tpublic String getFirstName() { \t\treturn firstName; \t} \tpublic void setFirstName(String firstName) { \t\tthis.firstName = firstName; \t} \tpublic String getLastName() { \t\treturn lastName; \t} \tpublic void setLastName(String lastName) { \t\tthis.lastName = lastName; \t} \tpublic String getCountry() { \t\treturn country; \t} \tpublic void setCountry(String country) { \t\tthis.country = country; \t} \tpublic LinkedHashMap<String, String> getCountryOptions() { \t\treturn countryOptions; \t} \t \tpublic String getFavoriteLanguage() { \t\treturn favoriteLanguage; \t} \tpublic void setFavoriteLanguage(String favoriteLanguage) { \t\tthis.favoriteLanguage = favoriteLanguage; \t} \t// Setter and getter handlers for the new bound attribute public String[] getOperatingSystems() { \t\treturn operatingSystems; \t} \tpublic void setOperatingSystems(String[] operatingSystems) { \t\tthis.operatingSystems = operatingSystems; \t} } "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/MVC/Required Validation.html",
    "title": "Required Validation",
    "body": " Back Required Validation In this section we will show how to perform a required validation. Add Validation Rule to Bean We create a Customer class, whose lastName attribute must be non-null, that is, lastName is a required attribute: package com.springdemo.mvc; import javax.validation.constraints.NotNull; import javax.validation.constraints.Size; public class Customer { \tprivate String firstName; \t // Validation annotation \t@NotNull(message=\"is required\") \t@Size(min=1, message=\"is required\") \tprivate String lastName; \tpublic String getFirstName() { \t\treturn firstName; \t} \tpublic void setFirstName(String firstName) { \t\tthis.firstName = firstName; \t} \tpublic String getLastName() { \t\treturn lastName; \t} \tpublic void setLastName(String lastName) { \t\tthis.lastName = lastName; \t} } Note that if we wanted to make an integer required, we must use the wrapper java classes (i.e. Integer), that will be able to handle empty strings as inputs and nulls. The primitive types will throw an exception. Perform Validation in the Controller We also package com.springdemo.mvc; import javax.validation.Valid; import org.springframework.beans.propertyeditors.StringTrimmerEditor; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.validation.BindingResult; import org.springframework.web.bind.WebDataBinder; import org.springframework.web.bind.annotation.InitBinder; import org.springframework.web.bind.annotation.ModelAttribute; import org.springframework.web.bind.annotation.RequestMapping; @Controller @RequestMapping(\"/customer\") public class CustomerController { \t// add an initbinder ... to convert trim input strings \t// remove leading and trailing whitespace \t// resolve issue for our validation \t \t@InitBinder \t//@InitBinder annotation works as a pre-processor \t// It will pre-process each web request to our controller \tpublic void initBinder(WebDataBinder dataBinder) { \t\t \t\t// Trim strings (true: empty strings to null) \t\tStringTrimmerEditor stringTrimmerEditor = new StringTrimmerEditor(true); \t \t\t// For every string class apply the trim editor \t\tdataBinder.registerCustomEditor(String.class, stringTrimmerEditor); \t} \t \t \t@RequestMapping(\"/showForm\") \tpublic String showForm(Model theModel) { \t\t \t\ttheModel.addAttribute(\"customer\", new Customer()); \t\t \t\treturn \"customer-form\"; \t} \t \t@RequestMapping(\"/processForm\") \t// @Valid: Tells spring to perform validation on the customer object \t// BindingResult: results of the validation will be placed in BindingResult \tpublic String processForm( \t\t\t@Valid @ModelAttribute(\"customer\") Customer theCustomer, \t\t\tBindingResult theBindingResult) { \t\t \t\tSystem.out.println(\"Last name: |\" + theCustomer.getLastName() + \"|\"); \t\t \t\t// Check if validation was sucessfull \t\tif (theBindingResult.hasErrors()) { \t\t\t// If not sucessfull send back \t\t\treturn \"customer-form\"; \t\t} \t\telse { \t\t\t// If sucessfull \t\t\treturn \"customer-confirmation\"; \t\t} \t} } When performing Spring MVC validation, the location of the BindingResult parameter is very important. In the method signature, the BindingResult parameter must appear immediately after the model attribute. Display error on HTML <%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %> <html> <head> \t<title>Customer Registration Form</title> \t \t<style> \t\t.error {color:red} \t</style> </head> <body> <i>Fill out the form. Asterisk (*) means required.</i> <br><br> \t<form:form action=\"processForm\" modelAttribute=\"customer\"> \t\tFirst name: <form:input path=\"firstName\" /> \t\t<br><br> \t\tLast name (*): <form:input path=\"lastName\" /> <!-- We use the error form tag to display an error when the input is not valid --> <!-- The message shown equals the messages from both of the validation annotations defined for the lastName attribute in the Customer class --> \t\t<form:errors path=\"lastName\" cssClass=\"error\" /> \t\t<br><br> \t\t<input type=\"submit\" value=\"Submit\" /> \t</form:form> </body> </html> "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/MVC/View.html",
    "title": "View",
    "body": " Back View Create View Inside WEB-INF/view we create a file main-menu.jsp: <!DOCTYPE> <html> <body> <h2>Spring MVC Demo - Home Page</h2> </body> </html> "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/MVC/index.html",
    "title": "Spring MVC",
    "body": " Back Spring MVC Spring MVC is a framework for building web applications in Java based on the Model-View-Controller design patter. The Front Controller is known as DispatcherServlet: It is part of the Spring Framework Pre-processes and delegates requests from the web browser to your controllers The MVC pattern is made up of: Model objects: contains the data View templates: UI of the app that displays data (most common templates: JSP + JSLT) Controller classes: business logic (handle request, access db, etc.) It includes the features of the Core Spring Framework (Inversion of Control and Dependency Injection) "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/MVC/Number Validation.html",
    "title": "Number Range Validation",
    "body": " Back Number Range Validation In this section we will show how to perform a number range validation. Add Validation Rule to Bean We create a Customer class, whose freePasses variable must be a number between 0 and 10. public class Customer { \tprivate String firstName; \t \t@NotNull(message=\"is required\") \t@Size(min=1, message=\"is required\") \tprivate String lastName; \t// Minimum value we will expect \t@Min(value=0, message=\"must be greater than or equal to zero\") \t// Maximum value we will expect \t@Max(value=10, message=\"must be less than or equal to 10\") \tprivate int freePasses; \t \t... Perform Validation in the Controller We also package com.springdemo.mvc; import javax.validation.Valid; import org.springframework.beans.propertyeditors.StringTrimmerEditor; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.validation.BindingResult; import org.springframework.web.bind.WebDataBinder; import org.springframework.web.bind.annotation.InitBinder; import org.springframework.web.bind.annotation.ModelAttribute; import org.springframework.web.bind.annotation.RequestMapping; @Controller @RequestMapping(\"/customer\") public class CustomerController { \t// add an initbinder ... to convert trim input strings \t// remove leading and trailing whitespace \t// resolve issue for our validation \t \t@InitBinder \t//@InitBinder annotation works as a pre-processor \t// It will pre-process each web request to our controller \tpublic void initBinder(WebDataBinder dataBinder) { \t\t \t\t// Trim strings (true: empty strings to null) \t\tStringTrimmerEditor stringTrimmerEditor = new StringTrimmerEditor(true); \t \t\t// For every string class apply the trim editor \t\tdataBinder.registerCustomEditor(String.class, stringTrimmerEditor); \t} \t \t \t@RequestMapping(\"/showForm\") \tpublic String showForm(Model theModel) { \t\t \t\ttheModel.addAttribute(\"customer\", new Customer()); \t\t \t\treturn \"customer-form\"; \t} \t \t@RequestMapping(\"/processForm\") \t// @Valid: Tells spring to perform validation on the customer object \t// BindingResult: results of the validation will be placed in BindingResult \tpublic String processForm( \t\t\t@Valid @ModelAttribute(\"customer\") Customer theCustomer, \t\t\tBindingResult theBindingResult) { \t\t \t\tSystem.out.println(\"Last name: |\" + theCustomer.getLastName() + \"|\"); \t\t \t\t// Check if validation was sucessfull \t\tif (theBindingResult.hasErrors()) { \t\t\t// If not sucessfull send back \t\t\treturn \"customer-form\"; \t\t} \t\telse { \t\t\t// If sucessfull \t\t\treturn \"customer-confirmation\"; \t\t} \t} } When performing Spring MVC validation, the location of the BindingResult parameter is very important. In the method signature, the BindingResult parameter must appear immediately after the model attribute. Display error on HTML <%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %> <html> <head> \t<title>Customer Registration Form</title> \t \t<style> \t\t.error {color:red} \t</style> </head> <body> <i>Fill out the form. Asterisk (*) means required.</i> <br><br> \t<form:form action=\"processForm\" modelAttribute=\"customer\"> \t\tFirst name: <form:input path=\"firstName\" /> \t\t<br><br> \t\tLast name (*): <form:input path=\"lastName\" /> <!-- The message shown equals the messages from both of the validation annotations defined for the lastName attribute in the Customer class --> \t\t<form:errors path=\"lastName\" cssClass=\"error\" /> \t\t<br><br> \t\tFree passes: <form:input path=\"freePasses\" /> <!-- The message shown equals the messages from both of the validation annotations defined for the freePasses attribute in the Customer class --> \t\t<form:errors path=\"freePasses\" cssClass=\"error\" /> \t\t<br><br> \t\t<input type=\"submit\" value=\"Submit\" /> \t</form:form> </body> </html> "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/MVC/Configuration.html",
    "title": "Configuration",
    "body": " Back Configuration Add configurations to file: WEB-INF/web.xml Configure Spring MVC Dispatcher Servlet Set up URL mappings to Spring MVC Dispatcher Servlet Add configurations to spring configuration file: WEB-INF/spring-mvc-demo-servlet.xml Add support for Spring Component Scanning Add support for conversion, formatting and validation Configure Spring MVC View Resolver Configuration on web.xml We have to add an entry for our Front Controller: DispatcherServlet <?xml version=\"1.0\" encoding=\"UTF-8\"?> <web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \txmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" \txsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\" \tid=\"WebApp_ID\" version=\"3.1\"> \t<display-name>spring-mvc-demo</display-name> \t<absolute-ordering /> \t<!-- Step 1: Configure Spring MVC Dispatcher Servlet --> \t<servlet> \t\t<!-- Name to reference this servlet --> \t\t<servlet-name>dispatcher</servlet-name> \t\t<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class> \t\t<!-- File of configuration of spring application --> \t\t<init-param> \t\t\t<param-name>contextConfigLocation</param-name> \t\t\t<param-value>/WEB-INF/spring-mvc-demo-servlet.xml</param-value> \t\t</init-param> \t\t<load-on-startup>1</load-on-startup> \t</servlet> \t<!-- Step 2: Set up URL mapping for Spring MVC Dispatcher Servlet --> \t<servlet-mapping> \t\t<servlet-name>dispatcher</servlet-name> \t\t<!-- For any url that comes in pass it to the \"dispatcher\" servlet --> \t\t<url-pattern>/</url-pattern> \t</servlet-mapping> </web-app> Configuration on spring-mvc-demo-servlet.xml <?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" \txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \txmlns:context=\"http://www.springframework.org/schema/context\" \txmlns:mvc=\"http://www.springframework.org/schema/mvc\" \txsi:schemaLocation=\" \t\thttp://www.springframework.org/schema/beans \thttp://www.springframework.org/schema/beans/spring-beans.xsd \thttp://www.springframework.org/schema/context \thttp://www.springframework.org/schema/context/spring-context.xsd \thttp://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"> \t<!-- Step 3: Add support for component scanning --> \t<context:component-scan base-package=\"com.springdemo\" /> \t<!-- Step 4: Add support for conversion, formatting and validation support --> \t<mvc:annotation-driven/> \t<!-- Step 5: Define Spring MVC view resolver --> \t<bean \t\tclass=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"> \t\t<!-- Specify where to look for view files --> \t\t<property name=\"prefix\" value=\"/WEB-INF/view/\" /> \t\t<property name=\"suffix\" value=\".jsp\" /> \t</bean> </beans> "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Thymeleaf/Tables.html",
    "title": "Tables in Thymeleaf",
    "body": " Back Tables in Thymeleaf In this section we are going to show how to create a table with Thymeleaf: Controller We create a controller for Employee, to list and add employees. package com.springboot.thymeleafdemo.controller; import java.util.ArrayList; import java.util.List; import javax.annotation.PostConstruct; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import com.springboot.thymeleafdemo.model.Employee; @Controller @RequestMapping(\"/employees\") public class EmployeeController { \t// load employee data \t \tprivate List<Employee> theEmployees; \t \t@PostConstruct \tprivate void loadData() { \t\t \t\t// create employees \t\tEmployee emp1 = new Employee(1, \"Leslie\", \"Andrews\", \"leslie@luv2code.com\"); \t\tEmployee emp2 = new Employee(2, \"Emma\", \"Baumgarten\", \"emma@luv2code.com\"); \t\tEmployee emp3 = new Employee(3, \"Avani\", \"Gupta\", \"avani@luv2code.com\"); \t\t// create the list \t\ttheEmployees = new ArrayList<>(); \t\t \t\t// add to the list \t\ttheEmployees.add(emp1); \t\ttheEmployees.add(emp2); \t\ttheEmployees.add(emp3); \t \t} \t \t// add mapping for \"/list\" \t@GetMapping(\"/list\") \tpublic String listEmployees(Model theModel) { \t\t \t\t// add to the spring model \t\ttheModel.addAttribute(\"employees\", theEmployees); \t\t \t\treturn \"list-employees\"; \t} } Entity We create the entity Employee: package com.springboot.thymeleafdemo.model; public class Employee { \tprivate int id; \tprivate String firstName; \tprivate String lastName; \tprivate String email; \tpublic Employee() { \t\t \t} \tpublic Employee(int id, String firstName, String lastName, String email) { \t\tthis.id = id; \t\tthis.firstName = firstName; \t\tthis.lastName = lastName; \t\tthis.email = email; \t} \tpublic int getId() { \t\treturn id; \t} \tpublic void setId(int id) { \t\tthis.id = id; \t} \tpublic String getFirstName() { \t\treturn firstName; \t} \tpublic void setFirstName(String firstName) { \t\tthis.firstName = firstName; \t} \tpublic String getLastName() { \t\treturn lastName; \t} \tpublic void setLastName(String lastName) { \t\tthis.lastName = lastName; \t} \tpublic String getEmail() { \t\treturn email; \t} \tpublic void setEmail(String email) { \t\tthis.email = email; \t} \t@Override \tpublic String toString() { \t\treturn \"Employee [id=\" + id + \", firstName=\" + firstName + \", lastName=\" + lastName + \", email=\" + email + \"]\"; \t} \t\t } Template Finally we create the template for list-employees.html: <!DOCTYPE HTML> <html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"> <head> <!-- Required meta tags --> <meta charset=\"utf-8\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"> <!-- Bootstrap CSS --> <link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/css/bootstrap.min.css\" integrity=\"sha384-GJzZqFGwb1QTTN6wy59ffF1BuGJpLSa9DkKMp0DgiMDm4iYMj70gZWKYbI706tWS\" crossorigin=\"anonymous\"> <title>Employee Directory</title> </head> <body> <div class=\"container\"> <h3>Employee Directory</h3> <hr> <table class=\"table table-bordered table-striped\"> <thead class=\"thead-dark\"> <tr> <th>First Name</th> <th>Last Name</th> <th>Email</th> </tr> </thead> <tbody> <!-- for loop for all employees, stored in the model --> <tr th:each=\"tempEmployee : ${employees}\"> <td th:text=\"${tempEmployee.firstName}\" />\t <td th:text=\"${tempEmployee.lastName}\" />\t <td th:text=\"${tempEmployee.email}\" />\t </tr> </tbody>\t\t </table> </div> </body> </html> "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Thymeleaf/Overview.html",
    "title": "Overview",
    "body": " Back Overview Thymeleaf is a Java templating engine. A thymeleaf template can be an HTML page with some thymeleaf expressions and include dynamic content from thymeleaf expressions. In a web app, thymeleaf is processed on the server. To use thymeleaf you have to include it in your dependencies: ... \t\t<dependency> \t\t\t<groupId>org.springframework.boot</groupId> \t\t\t<artifactId>spring-boot-starter-thymeleaf</artifactId> \t\t</dependency> ... Placement In Spring Boot, your Thymeleaf template files go in src/main/resources/templates. And for web apps, Thymeleaf templates have an .html extension. Example Given the following controller: @Controller public class DemoController { \t// create a mapping for \"/hello\" \t@GetMapping(\"/hello\") \tpublic String sayHello(Model theModel) { \t\t \t\ttheModel.addAttribute(\"theDate\", new java.util.Date()); \t\t \t\treturn \"helloworld\"; \t} } We create the corresponding template helloworld.html: <!DOCTYPE HTML> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> \t<title>Thymeleaf Demo</title> </head> <!-- We obtain the date from the model --> <body> \t<p th:text=\"'Time on the server is ' + ${theDate}\" /> </body> </html> To add styles, we create a css files in src/main/resources/static/css, and then we reference the styles: <!DOCTYPE HTML> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> \t<title>Thymeleaf Demo</title> \t<!-- reference CSS file --> \t<link rel=\"stylesheet\" \t\t th:href=\"@{/css/demo.css}\" /> </head> <body> \t<p th:text=\"'Time on the server is ' + ${theDate}\" class=\"funny\" /> </body> </html> "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Java Annotations/Field Injection.html",
    "title": "Field Injection",
    "body": " Back Field Injection Field Injection allows you to inject dependencies by setting field values on your class directly (even private ones). This is accomplished by using Java Reflection. For this, we need to configure the Autowired annotation as follows: Apply it directly to the field Which saves us from using setter methods for dependency injection. Define Dependency as Component package com.springdemo; import org.springframework.stereotype.Component; // We tell spring this is a bean @Component public class HappyFortuneService implements FortuneService { \t@Override \tpublic String getFortune() { \t\treturn \"Today is your lucky day!\"; \t} } Specify Dependency package com.springdemo; import org.springframework.stereotype.Component; import org.springframework.beans.factory.annotation.Autowired; @Component public class TennisCoach implements Coach { // We tell spring to search for beans (classes with @Component annotation) // that implement the FortuneService interface @Autowired \tprivate FortuneService fortuneService; \t \tpublic TennisCoach() {} \t@Override \tpublic String getDailyWorkout() { \t\treturn \"Practice your backhand volley\"; \t} \t@Override \tpublic String getDailyFortune() { \t\treturn fortuneService.getFortune(); \t} } The main method and the configuration files remain unchanged. And when we execute this piece of code, spring will automatically inject the dependency because of the Autowired annotation. package com.springdemo; import org.springframework.context.support.ClassPathXmlApplicationContext; public class AnnotationDemoApp { \tpublic static void main(String[] args) { \t\t// read spring config file \t\tClassPathXmlApplicationContext context = \t\t\t\tnew ClassPathXmlApplicationContext(\"applicationContext.xml\"); \t\t \t\t// get the bean from spring container \t\tCoach theCoach = context.getBean(\"tennisCoach\", Coach.class); \t\t \t\t// call a method on the bean \t\tSystem.out.println(theCoach.getDailyWorkout()); \t\t// call method to get daily fortune \t\tSystem.out.println(theCoach.getDailyFortune()); \t\t\t\t \t\t// close the context \t\tcontext.close(); \t} } "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Java Annotations/Setter Injection.html",
    "title": "Setter Injection",
    "body": " Back Setter Injection Define Dependency as Component package com.springdemo; import org.springframework.stereotype.Component; // We tell spring this is a bean @Component public class HappyFortuneService implements FortuneService { \t@Override \tpublic String getFortune() { \t\treturn \"Today is your lucky day!\"; \t} } Specify Dependency We now create a setter method in our class for the injection: package com.springdemo; import org.springframework.stereotype.Component; import org.springframework.beans.factory.annotation.Autowired; @Component public class TennisCoach implements Coach { \tprivate FortuneService fortuneService; \t \tpublic TennisCoach() {} // We tell spring to search for beans (classes with @Component annotation) // that implement the FortuneService interface \t@Autowired public setFortuneService(FortuneService fortuneService){ this.fortuneService = fortuneService; } \t@Override \tpublic String getDailyWorkout() { \t\treturn \"Practice your backhand volley\"; \t} \t@Override \tpublic String getDailyFortune() { \t\treturn fortuneService.getFortune(); \t} } The main method and the configuration files remain unchanged. And when we execute this piece of code, spring will automatically inject the dependency because of the Autowired annotation. package com.springdemo; import org.springframework.context.support.ClassPathXmlApplicationContext; public class AnnotationDemoApp { \tpublic static void main(String[] args) { \t\t// read spring config file \t\tClassPathXmlApplicationContext context = \t\t\t\tnew ClassPathXmlApplicationContext(\"applicationContext.xml\"); \t\t \t\t// get the bean from spring container \t\tCoach theCoach = context.getBean(\"tennisCoach\", Coach.class); \t\t \t\t// call a method on the bean \t\tSystem.out.println(theCoach.getDailyWorkout()); \t\t// call method to get daily fortune \t\tSystem.out.println(theCoach.getDailyFortune()); \t\t\t\t \t\t// close the context \t\tcontext.close(); \t} } "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Java Annotations/Inject using Properties File.html",
    "title": "Inject properties file using Java annotations",
    "body": " Back Inject properties file using Java annotations This solution will show you how inject values from a properties file using annotations. The values will no longer be hard coded in the Java code. Create a properties file We create new text file: src/sport.properties foo.email=myeasycoach@luv2code.com foo.team=Silly Java Coders Load the properties We load the properties in the configuration XML file. For that we add the line: <context:property-placeholder location=\"classpath:sport.properties\"/> Inject Values Lastly we inject the properties values into our bean like so: @Value(\"${foo.email}\") private String email; @Value(\"${foo.team}\") private String team; "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Java Annotations/Dependency Injection.html",
    "title": "Dependency Injection",
    "body": " Back Dependency Injection We will introduce dependency injection with annotation using autowiring: Spring looks for a class that matches the attribute type (call or interface) (i.e. FortuneService) Spring will inject it automatically If there are multiple implementations: tell Spring which specific bean to use with the Qualifier annotation Constructor Injection Setter Injection Method Injection Field Injection Inject using Properties File Qualifier Annotation Which dependency to use Choose a style and stay consistent in your project. You get the same functionality regardless of the type of dependency injection you use. "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Java Annotations/Method Injection.html",
    "title": "Method Injection",
    "body": " Back Method Injection One thing to note is that you can add dependency injection on any method you want, does not have to be a setter method: Define Dependency as Component package com.springdemo; import org.springframework.stereotype.Component; // We tell spring this is a bean @Component public class HappyFortuneService implements FortuneService { \t@Override \tpublic String getFortune() { \t\treturn \"Today is your lucky day!\"; \t} } Specify Dependency We now create a setter method in our class for the injection: package com.springdemo; import org.springframework.stereotype.Component; import org.springframework.beans.factory.annotation.Autowired; @Component public class TennisCoach implements Coach { \tprivate FortuneService fortuneService; \t \tpublic TennisCoach() {} // We tell spring to search for beans (classes with @Component annotation) // that implement the FortuneService interface \t@Autowired public anyMethod(FortuneService fortuneService){ this.fortuneService = fortuneService; } \t@Override \tpublic String getDailyWorkout() { \t\treturn \"Practice your backhand volley\"; \t} \t@Override \tpublic String getDailyFortune() { \t\treturn fortuneService.getFortune(); \t} } The main method and the configuration files remain unchanged. And when we execute this piece of code, spring will automatically inject the dependency because of the Autowired annotation. package com.springdemo; import org.springframework.context.support.ClassPathXmlApplicationContext; public class AnnotationDemoApp { \tpublic static void main(String[] args) { \t\t// read spring config file \t\tClassPathXmlApplicationContext context = \t\t\t\tnew ClassPathXmlApplicationContext(\"applicationContext.xml\"); \t\t \t\t// get the bean from spring container \t\tCoach theCoach = context.getBean(\"tennisCoach\", Coach.class); \t\t \t\t// call a method on the bean \t\tSystem.out.println(theCoach.getDailyWorkout()); \t\t// call method to get daily fortune \t\tSystem.out.println(theCoach.getDailyFortune()); \t\t\t\t \t\t// close the context \t\tcontext.close(); \t} } "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Java Annotations/Constructor Injection.html",
    "title": "Constructor Injection",
    "body": " Back Constructor Injection Define Dependency as Component package com.springdemo; import org.springframework.stereotype.Component; // We tell spring this is a bean @Component public class HappyFortuneService implements FortuneService { \t@Override \tpublic String getFortune() { \t\treturn \"Today is your lucky day!\"; \t} } Specify Dependency package com.springdemo; import org.springframework.stereotype.Component; import org.springframework.beans.factory.annotation.Autowired; @Component public class TennisCoach implements Coach { \tprivate FortuneService fortuneService; \t // We tell spring to search for beans (classes with @Component annotation) // that implement the FortuneService interface \t@Autowired \tpublic TennisCoach(FortuneService theFortuneService) { \t\tfortuneService = theFortuneService; \t} \t@Override \tpublic String getDailyWorkout() { \t\treturn \"Practice your backhand volley\"; \t} \t@Override \tpublic String getDailyFortune() { \t\treturn fortuneService.getFortune(); \t} } The main method and the configuration files remain unchanged. package com.springdemo; import org.springframework.context.support.ClassPathXmlApplicationContext; public class AnnotationDemoApp { \tpublic static void main(String[] args) { \t\t// read spring config file \t\tClassPathXmlApplicationContext context = \t\t\t\tnew ClassPathXmlApplicationContext(\"applicationContext.xml\"); \t\t \t\t// get the bean from spring container \t\tCoach theCoach = context.getBean(\"tennisCoach\", Coach.class); \t\t \t\t// call a method on the bean \t\tSystem.out.println(theCoach.getDailyWorkout()); \t\t// call method to get daily fortune \t\tSystem.out.println(theCoach.getDailyFortune()); \t\t\t\t \t\t// close the context \t\tcontext.close(); \t} } "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Java Annotations/Inversion of Control.html",
    "title": "Inversion of Control",
    "body": " Back Inversion of Control Let's see how to make us of Inversion of Control with Annotations: Enable Component Scanning We remove all of the beans we defined, and enable component scanning: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"> \t<!-- add entry to enable component scanning --> \t<context:component-scan base-package=\"com.springdemo\" /> </beans> Now Spring will scan recursively all of the files in this package. Add @Component Annotation to Classes We add the @Component annotation to our classes (note we do not add it to the interfaces like Coach). package com.springdemo; import org.springframework.stereotype.Component; @Component // We can also set the explicit name like // @Component(\"myTennisCoach\") public class TennisCoach implements Coach { \t \t@Override \tpublic String getDailyWorkout() { \t\treturn \"Practice your backhand volley\"; \t} } Note that we can name the component explicitly or by default. Main Method In our application we do not really need to change anything. We create our bean the same way we did before. The only thing to note is that if we set the name of the Component explicitly, then when we instantiate the bean, we should refer to it by said name. package com.springdemo; import org.springframework.context.support.ClassPathXmlApplicationContext; public class AnnotationDemoApp { \tpublic static void main(String[] args) { \t\t// read spring config file \t\tClassPathXmlApplicationContext context = \t\t\t\tnew ClassPathXmlApplicationContext(\"applicationContext.xml\"); \t\t \t\t// get the bean from spring container \t\t// If we set the name explicitly \t\tCoach theCoach = context.getBean(\"myTennisCoach\", Coach.class); // Else \t\tCoach theCoach = context.getBean(\"tennisCoach\", Coach.class); \t\t \t\t// call a method on the bean \t\tSystem.out.println(theCoach.getDailyWorkout()); \t\t\t\t \t\t// close the context \t\tcontext.close(); \t\t \t} } "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Java Annotations/index.html",
    "title": "Java Annotations",
    "body": " Back Java Annotations Java Annotations are special labels added to classes. They provide metadata about the class, and can be processed at compile time or run-time for special processing. We use annotations to minimize the XML configuration. Spring scans the classes to find Beans and configure them internally (as we have done with the XML configuration). In order to use this approach we need to: Enable component scanning in our Spring configuration file and Add the @Component annotation to our class Inversion of Control Dependency Injection Scopes Life Cycles "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Java Annotations/Life Cycles.html",
    "title": "Life Cycle",
    "body": " Back Life Cycle To define methods to add when the beans is constructed or destroyed we use the PostConstruct and PreDestroy annotation. package com.springdemo; public class TrackCoach implements Coach { \t \tprivate FortuneService fortuneService; \t \tpublic TrackCoach() { \t\t \t} \t \tpublic TrackCoach(FortuneService fortuneService) { \t\tthis.fortuneService = fortuneService; \t} \t \t@Override \tpublic String getDailyWorkout() { \t\treturn \"Run a hard 5k\"; \t} \t \t@Override \tpublic String getDailyFortune() { \t\treturn \"Just Do It: \" + fortuneService.getFortune(); \t} \t \t// Run when the bean is done creating \t@PostConstruct \tpublic void doMyStartupStuff() { \t\tSystem.out.println(\"TrackCoach: inside method doMyStartupStuff\"); \t} \t \t// Run before the bean is destroyed \t@PreDestroy \tpublic void doMyCleanupStuffYoYo() { \t\tSystem.out.println(\"TrackCoach: inside method doMyCleanupStuffYoYo\");\t\t \t} } Refer to more information about scopes are in Bean Life Cycle: Notes Access modifier: The method can have any access modifier (public, protected, private) Return type: The method can have any return type. However, \"void' is most commonly used. If you give a return type just note that you will not be able to capture the return value. As a result, \"void\" is commonly used. Method name: The method can have any method name. Arguments: The method can not accept any arguments. The method should be no-arg. "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Java Annotations/Qualifier Annotation.html",
    "title": "Qualifier",
    "body": " Back Qualifier In order to specify which specific implementation of an interface we want to use, when this interface is implemented by several beans, then we use the Qualifier annotation. The Qualifier annotation can be used in any Dependency Injection implementation: Constructor Injection (has different syntax) Setter Injection Method Injection Field Injection Define Dependency as Component package com.springdemo; import org.springframework.stereotype.Component; // We tell spring this is a bean @Component public class HappyFortuneService implements FortuneService { \t@Override \tpublic String getFortune() { \t\treturn \"Today is your lucky day!\"; \t} } Specify Dependency package com.springdemo; import org.springframework.stereotype.Component; import org.springframework.beans.factory.annotation.Autowired; @Component public class TennisCoach implements Coach { \t \t// We tell spring to search for beans (classes with @Component annotation) \t// that implement the FortuneService interface whose name is \"happyFortuneService\" \t// (note this is the default name of the component if you set one explicitly you \t// will have to specify that one in the Qualifier annotation) \t@Autowired \t@Qualifier(\"happyFortuneService\") \tprivate FortuneService fortuneService; \t \tpublic TennisCoach() {} \t \t@Override \tpublic String getDailyWorkout() { \t\treturn \"Practice your backhand volley\"; \t} \t \t@Override \tpublic String getDailyFortune() { \t\treturn fortuneService.getFortune(); \t} } The main method and the configuration files remain unchanged. And when we execute this piece of code, spring will automatically inject the dependency because of the Autowired annotation. package com.springdemo; import org.springframework.context.support.ClassPathXmlApplicationContext; public class AnnotationDemoApp { \tpublic static void main(String[] args) { \t\t// read spring config file \t\tClassPathXmlApplicationContext context = \t\t\t\tnew ClassPathXmlApplicationContext(\"applicationContext.xml\"); \t\t \t\t// get the bean from spring container \t\tCoach theCoach = context.getBean(\"tennisCoach\", Coach.class); \t\t \t\t// call a method on the bean \t\tSystem.out.println(theCoach.getDailyWorkout()); \t\t// call method to get daily fortune \t\tSystem.out.println(theCoach.getDailyFortune()); \t\t\t\t \t\t// close the context \t\tcontext.close(); \t} } Qualifier in Constructor package com.springdemo; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.stereotype.Component; @Component public class TennisCoach implements Coach { private FortuneService fortuneService; // define a default constructor public TennisCoach() { System.out.println(\">> TennisCoach: inside default constructor\"); } @Autowired public TennisCoach(@Qualifier(\"happyFortuneService\") FortuneService theFortuneService) { System.out.println(\">> TennisCoach: inside constructor using @autowired and @qualifier\"); fortuneService = theFortuneService; } } "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Java Annotations/Scopes.html",
    "title": "Scopes",
    "body": " Back Scopes To explicitly specify scopes with Java Annotations you do as follows: package com.springdemo; import org.springframework.stereotype.Component; import org.springframework.context.annotation.Scope; @Component @Scope(\"singleton\") public class TennisCoach implements Coach { ... or package com.springdemo; import org.springframework.stereotype.Component; import org.springframework.context.annotation.Scope; @Component @Scope(\"prototype\") public class TennisCoach implements Coach { ... Refer to more information about scopes are in Bean Scopes: "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/SpringBoot/Controller.html",
    "title": "Rest Controller",
    "body": " Back Rest Controller In this section we are going to show how to create a REST controller in a Spring Boot application: Create Controller The controller is the same as in Spring REST: package com.springboot.demo.mycoolapp.rest; import java.time.LocalDateTime; import org.springframework.beans.factory.annotation.Value; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class FunRestController { \t\t \t// expose \"/\" that return \"Hello World\" \t \t@GetMapping(\"/\") \tpublic String sayHello() { \t\treturn \"Hello World! Time on server is \" + LocalDateTime.now(); \t} \t Main App The SpringBootApplication is made up of three annotations: Auto configuration (@EnableAutoConfiguration) Component scanning (@ComponentScan) Additional configuration (@Configuration) package com.springboot.demo.mycoolapp; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; // Annotation to tell Spring this is an spring application @SpringBootApplication public class MycoolappApplication { \tpublic static void main(String[] args) { \t\t// Boostrap spring boot application \t\tSpringApplication.run(MycoolappApplication.class, args); \t} } "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/SpringBoot/Spring Boot Project Structure.html",
    "title": "Spring Boot Project Structure",
    "body": " Back Spring Boot Project Structure Application Properties By default, Spring Boot will load properties from: application.properties in the src project directory. We inject it in our code the same way we did it with Spring Static Content By default, Spring Boot wil load static resources from \"/static\" directory Testing Unit tests are stored on the src directory under the /test folder "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/SpringBoot/Spring Data REST.html",
    "title": "Spring Data Rest",
    "body": " Back Spring Data Rest What if we want to also reduce the code for creating API, that is, what if Spring could create a REST API for us using our JPARepository, such that it would expose all of the basic REST API CRUD features automatically. What does it do? It scans your project fro JPARepository It exposes REST APIs for each entity type for your JPARepository So now, we can remove our Employee services and our REST Controllers, because it is handled automatically by Spring. The only thing needed is adding Spring Data REST as a dependency: \t<dependencies> ... \t\t<!-- Add dependency for Spring Data REST --> \t\t<dependency> \t\t\t<groupId>org.springframework.boot</groupId> \t\t\t<artifactId>spring-boot-starter-data-rest</artifactId> \t\t</dependency> ... \t</dependencies> To sum up, now in your application you only will have: Your entity: Employee The corresponding JPA Repository: EmployeeRepository Dependency Main application The first one applies to each entity your application has. Spring Data Rest is HATEOAS compliant (the responses include metadata about itself). Configuration You can specify the name of the endpoint that is exposed (by the default is the plural of the entity) with: @RepositoryRestResource(path=\"members\") public interface EmployeeRepository extends JpaRepository<Employee, Integer> { } The default number of elements returned are 20, then we can use pagination to retrieve the next ones with query parameters (?page=0). Some properties available to tweak in application.properties are: spring.data.rest.base-path: Base path used to expose repository resources spring.data.rest.default-page-size: Default size pages spring.data.rest.max-page-size: Maximum size of pages Sorting You can sort by the property names of your entity. On the Employee example we have firstName, lastName and email, therefore we can do: http://localhost:8080/employees?sort=firstName or http://localhost:8080/employees?sort=firstName,desc "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/SpringBoot/Spring Boot Actuator.html",
    "title": "Spring Boot Actuator",
    "body": " Back Spring Boot Actuator Spring Boot Actuator automatically exposes endpoints to monitor and manage your application. You only need to add the dependency to you pom.xml file: ... \t<dependencies> ... \t\t<!-- ADD SUPPORT FOR SPRING BOOT ACTUATOR --> \t\t<dependency> \t\t\t<groupId>org.springframework.boot</groupId> \t\t\t<artifactId>spring-boot-starter-actuator</artifactId> \t\t</dependency> \t\t\t\t \t</dependencies> ... The endpoints are prefixed by /actuator, some of them are: /health: health information about your application /info: information about your project. By default it return an empty json object. You can add info through application.properties as follows: info.app.name=My Super Cool App info.app.description=A crazy fun app, yoohoo! info.app.version=1.0.0 /auditevents: Audit events for your application /beans: List of all beans registered in the Spring application context /mappings: List of all @RequestMapping path By default only /health and /info are exposed, to expose all actuator endpoints you need to specify on application.properties (you can also specify only the ones you want separated by commas): management.endpoints.web.exposure.include=* Add security First you need to add Spring Security as a dependency in your pom.xml: ... \t<dependencies> \t\t... <!-- SECURITY --> \t\t<dependency> \t\t\t<groupId>org.springframework.boot</groupId> \t\t\t<artifactId>spring-boot-starter-security</artifactId> \t\t</dependency> \t\t... \t</dependencies> ... Now, when we access some endpoints like /actuator/beans Spring will prompt a login to grant access to the endpoint. The default user name is \"user\" The password will be printed on the console where you start the application To override these defaults edit the application.properties file as follows: spring.security.user.name=alba spring.security.user.password=mypassword We can also exclude endpoints by adding the following declarations to the application.properties file: management.endpoints.web.exposure.exclude=health,info "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/SpringBoot/Spring Data JPA.html",
    "title": "Spring Data JPA",
    "body": " Back Spring Data JPA With JPA API we created a Employee DAO, however what if we need to create one for each entity we manage. Then we would duplicate a lot of code, because the calls to the API are basically the same. That is what we use Spring Data JPA, we plug in the entity type and the primary key to the DAO, and Spring creates it an manages it for us. Create Repository So now the Employee DAO is as follows: package com.springboot.cruddemo.dao; import org.springframework.data.jpa.repository.JpaRepository; import com.springboot.cruddemo.entity.Employee; public interface EmployeeRepository extends JpaRepository<Employee, Integer> { } Use Repository And the Employee Service is: package com.springboot.cruddemo.service; import java.util.List; import java.util.Optional; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import com.springboot.cruddemo.dao.EmployeeRepository; import com.springboot.cruddemo.entity.Employee; @Service public class EmployeeServiceImpl implements EmployeeService { // Here we make use of the above implemented repository \tprivate EmployeeRepository employeeRepository; \t \t@Autowired \tpublic EmployeeServiceImpl(EmployeeRepository theEmployeeRepository) { \t\temployeeRepository = theEmployeeRepository; \t} \t \t@Override \tpublic List<Employee> findAll() { \t\treturn employeeRepository.findAll(); \t} \t@Override \tpublic Employee findById(int theId) { \t\tOptional<Employee> result = employeeRepository.findById(theId); \t\t \t\tEmployee theEmployee = null; \t\t \t\tif (result.isPresent()) { \t\t\ttheEmployee = result.get(); \t\t} \t\telse { \t\t\t// we didn't find the employee \t\t\tthrow new RuntimeException(\"Did not find employee id - \" + theId); \t\t} \t\t \t\treturn theEmployee; \t} \t@Override \tpublic void save(Employee theEmployee) { \t\temployeeRepository.save(theEmployee); \t} \t@Override \tpublic void deleteById(int theId) { \t\temployeeRepository.deleteById(theId); \t} } This EmployeeService implements the interface: package com.springboot.cruddemo.service; import java.util.List; import com.springboot.cruddemo.entity.Employee; public interface EmployeeService { \tpublic List<Employee> findAll(); \t \tpublic Employee findById(int theId); \t \tpublic void save(Employee theEmployee); \t \tpublic void deleteById(int theId); \t } "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/SpringBoot/Spring Boot DevTools.html",
    "title": "Spring Boot DevTools",
    "body": " Back Spring Boot DevTools Spring Boot Dev Tools automatically restart your application when code is updated. The only thing you need to do is add the module to the dependencies: ... \t<dependencies> \t\t<!-- ADD SUPPORT FOR AUTOMATIC RELOADING --> \t\t<dependency> \t\t\t<groupId>org.springframework.boot</groupId> \t\t\t<artifactId>spring-boot-devtools</artifactId> \t\t</dependency> \t\t\t\t \t</dependencies> ... "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/SpringBoot/Application Properties.html",
    "title": "Application Properties",
    "body": " Back Application Properties By default Spring Boot reads information from a standard properties file in src/main/resources/application.properties. You can define any custom properties in this file and your app can access properties using the annotation @Value(We have done this before). Configuring the Spring Boot Server Some properties offered by Spring are: Core # Log levels severity mapping logging.level.org.springframework=DEBUG logging.level.org.hibernate=TRACE logging.level.org.luv2code=INFO # Log file name logging.file=date.log Web # HTTP Server port server.port=7070 # Context path of the application server.servlet.context-path=/my-app # Default HTTP Session timeout server.servlet.session.timeout=15m Actuator Properties # Endpoints to include by name or wildcard management.endpoints.web.exposure.include=* # Endpoints to exclude by name or wildcard management.endpoints.web.exposure.exclude=beans,mapping Security # Default username spring.security.user.name=admin # Password for default user spring.security.user.password=mypass Data Properties # JDBC URL of the database spring.datasource.url=jdbc:mysql://localhost:3306/myapp # Login username of the database spring.datasource.username=alba # Login password of the database spring.datasource.password=testpass "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/SpringBoot/JPA.html",
    "title": "JPA",
    "body": " Back JPA Until now, to manage data we have been using the EntityManager along with the Hibernate API. However now we are going to use the Standard JPA API. The JPA API methods are similar to Native Hibernate API. It also supports a query language JPQL (JPA Query Language) Comparing Hibernate to JPA: Example: for managing employees with JPA, we first create the Data Access Object: package com.springboot.cruddemo.dao; import java.util.List; import javax.persistence.EntityManager; import javax.persistence.Query; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Repository; import com.luv2code.springboot.cruddemo.entity.Employee; @Repository public class EmployeeDAOJpaImpl implements EmployeeDAO { \tprivate EntityManager entityManager; \t \t@Autowired \tpublic EmployeeDAOJpaImpl(EntityManager theEntityManager) { \t\tentityManager = theEntityManager; \t} \t \t@Override \tpublic List<Employee> findAll() { \t\t// create a query \t\tQuery theQuery = \t\t\t\tentityManager.createQuery(\"from Employee\"); \t\t \t\t// execute query and get result list \t\tList<Employee> employees = theQuery.getResultList(); \t\t \t\t// return the results\t\t \t\treturn employees; \t} \t@Override \tpublic Employee findById(int theId) { \t\t// get employee \t\tEmployee theEmployee = \t\t\t\tentityManager.find(Employee.class, theId); \t\t \t\t// return employee \t\treturn theEmployee; \t} \t@Override \tpublic void save(Employee theEmployee) { \t\t// save or update the employee \t\tEmployee dbEmployee = entityManager.merge(theEmployee); \t\t \t\t// update with id from db ... so we can get generated id for save/insert \t\ttheEmployee.setId(dbEmployee.getId()); \t\t \t} \t@Override \tpublic void deleteById(int theId) { \t\t// delete object with primary key \t\tQuery theQuery = entityManager.createQuery( \t\t\t\t\t\t\t\"delete from Employee where id=:employeeId\"); \t\t \t\ttheQuery.setParameter(\"employeeId\", theId); \t\t \t\ttheQuery.executeUpdate(); \t} } And then we call it from the Employee Service: package com.springboot.cruddemo.service; import java.util.List; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Transactional; import com.springboot.cruddemo.dao.EmployeeDAO; import com.springboot.cruddemo.entity.Employee; @Service public class EmployeeServiceImpl implements EmployeeService { \tprivate EmployeeDAO employeeDAO; \t \t@Autowired \tpublic EmployeeServiceImpl(@Qualifier(\"employeeDAOJpaImpl\") EmployeeDAO theEmployeeDAO) { \t\temployeeDAO = theEmployeeDAO; \t} \t \t@Override \t@Transactional \tpublic List<Employee> findAll() { \t\treturn employeeDAO.findAll(); \t} \t@Override \t@Transactional \tpublic Employee findById(int theId) { \t\treturn employeeDAO.findById(theId); \t} \t@Override \t@Transactional \tpublic void save(Employee theEmployee) { \t\temployeeDAO.save(theEmployee); \t} \t@Override \t@Transactional \tpublic void deleteById(int theId) { \t\temployeeDAO.deleteById(theId); \t} } This class implements the following interface: package com.springboot.cruddemo.service; import java.util.List; import com.springboot.cruddemo.entity.Employee; public interface EmployeeService { \tpublic List<Employee> findAll(); \t \tpublic Employee findById(int theId); \t \tpublic void save(Employee theEmployee); \t \tpublic void deleteById(int theId); \t } "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/SpringBoot/index.html",
    "title": "Overview",
    "body": " Back Overview Spring Boot is a framework that: Make it easier to get started with Spring development Minimize the amount of manual configuration Perform auto-configuration based on props files and JAR classpath Help to resolve dependency conflicts (Maven or Gradle) Provide an embedded HTTP server so you can get started quickly To create a new project you just have to go to Spring Initiliazr, where you simply select your dependencies and lets you create a maven/gradle project and import it into an IDE. So now our app is a jar file, and it includes the source code and also the embedded http server, so can be ran from the command line, from your IDE, etc. However if you want to export your code as a war file, you can also do that by exporting only your source code, without the embedded server. With the jar file you can run your application by executing: $ java -jar app.jar "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/SpringBoot/Spring Boot Starters.html",
    "title": "Spring Boot Starters",
    "body": " Back Spring Boot Starters Spring Boot Staters offer a curated list of dependencies that are grouped together and tested by the Spring Development Team. So now, if your application depends on the Web and Security module and also uses Thymeleaf and JPA, you add the following dependencies: ... \t<dependencies> <!-- WEB --> \t\t<dependency> \t\t\t<groupId>org.springframework.boot</groupId> \t\t\t<artifactId>spring-boot-starter-web</artifactId> \t\t</dependency> <!-- SECURITY --> \t\t<dependency> \t\t\t<groupId>org.springframework.boot</groupId> \t\t\t<artifactId>spring-boot-starter-security</artifactId> \t\t</dependency> <!-- JPA --> \t\t<dependency> \t\t\t<groupId>org.springframework.boot</groupId> \t\t\t<artifactId>spring-boot-starter-data-jpa</artifactId> \t\t</dependency> <!-- Thymeleaf --> \t\t<dependency> \t\t\t<groupId>org.springframework.boot</groupId> \t\t\t<artifactId>spring-boot-starter-thymeleaf</artifactId> \t\t</dependency> \t\t<!-- ADD SUPPORT FOR AUTOMATIC RELOADING --> \t\t<dependency> \t\t\t<groupId>org.springframework.boot</groupId> \t\t\t<artifactId>spring-boot-devtools</artifactId> \t\t</dependency> \t\t\t\t \t</dependencies> ... Spring Boot Starter Parent This is a special starter that provides defaults: Default compiler level UTF-8 source encoding You include it in your pom.xml file as follows: ... \t<parent> \t\t<groupId>org.springframework.boot</groupId> \t\t<artifactId>spring-boot-starter-parent</artifactId> \t\t<version>2.1.2.RELEASE</version> \t\t<relativePath/> <!-- lookup parent from repository --> \t</parent> \t<dependencies> \t... \t</dependencies> ... If you want to override a default, you use properties: ... \t<parent> \t\t<groupId>org.springframework.boot</groupId> \t\t<artifactId>spring-boot-starter-parent</artifactId> \t\t<version>2.1.2.RELEASE</version> \t\t<relativePath/> <!-- lookup parent from repository --> \t</parent> \t \t<!-- Override default java version --> \t<properties> \t\t<java.version>1.8</java.version> \t</properties> \t<dependencies> \t... \t</dependencies> ... "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/AOP/Pointcut Declarations.html",
    "title": "Pointcut Declarations",
    "body": " Back Pointcut Declarations How can we reuse a pointcut expression? We need to: Create a pointcut Declaration Apply the pointcut declaration to the advices we want Create Pointcut Declaration We define the pointcut declaration with the Pointcut annotation and we bind it to an arbitrary method. package com.aopdemo.aspect; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Before; import org.aspectj.lang.annotation.Pointcut; import org.springframework.stereotype.Component; @Aspect @Component public class MyDemoLoggingAspect { \t@Pointcut(\"execution(* com.aopdemo.dao.*.*(..))\") \tprivate void forDaoPackage() {} } Reuse Pointcut Declaration To reuse this declaration we simply call the method that is bound to the pointcut declaration: package com.aopdemo.aspect; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Before; import org.aspectj.lang.annotation.Pointcut; import org.springframework.stereotype.Component; @Aspect @Component public class MyDemoLoggingAspect { \t@Pointcut(\"execution(* com.aopdemo.dao.*.*(..))\") \tprivate void forDaoPackage() {} \t // Reuse declaration \t@Before(\"forDaoPackage()\") \tpublic void beforeAddAccountAdvice() {\t\t \t\tSystem.out.println(\"\\n=====>>> Executing @Before advice on method\");\t\t \t} \t // Reuse declaration \t@Before(\"forDaoPackage()\") \tpublic void performApiAnalytics() { \t\tSystem.out.println(\"\\n=====>>> Performing API analytics\");\t\t \t} \t } Combine Pointcut Declarations How can we apply multiple pointcut expressions to a single advice? Well we can combine pointcut expressions using logic operators: AND (&&) OR (||) NOT (!) For example: @Before(\"expressionOne() && expressionTwo()\") @Before(\"expressionOne() || expressionTwo()\") @Before(\"expressionOne() && !expressionTwo()\") Imagine we want to execute an advice for every method in the package except for getters and setters, then we do: package com.aopdemo.aspect; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Before; import org.aspectj.lang.annotation.Pointcut; import org.springframework.stereotype.Component; @Aspect @Component public class MyDemoLoggingAspect { \t@Pointcut(\"execution(* com.aopdemo.dao.*.*(..))\") \tprivate void forDaoPackage() {} \t \t// create pointcut for getter methods \t@Pointcut(\"execution(* com.aopdemo.dao.*.get*(..))\") \tprivate void getter() {} \t \t// create pointcut for setter methods \t@Pointcut(\"execution(* com.aopdemo.dao.*.set*(..))\") \tprivate void setter() {} \t \t// create pointcut: include package ... exclude getter/setter \t@Pointcut(\"forDaoPackage() && !(getter() || setter())\") \tprivate void forDaoPackageNoGetterSetter() {} \t \t@Before(\"forDaoPackageNoGetterSetter()\") \tpublic void beforeAddAccountAdvice() {\t\t \t\tSystem.out.println(\"\\n=====>>> Executing @Before advice on method\");\t\t \t} \t \t@Before(\"forDaoPackageNoGetterSetter()\") \tpublic void performApiAnalytics() { \t\tSystem.out.println(\"\\n=====>>> Performing API analytics\");\t\t \t} } "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/AOP/Control Aspect Order.html",
    "title": "Control Aspect Order",
    "body": " Back Control Aspect Order How do we control the order of advices being applied when they all match the pointcut expressions? To control order we should: Refactor: place advices in separate Aspects Control order on Aspects using the @Order annotation Refactor and Order We are going to create three aspects separate from each other as follows: So with the ordering the aspect flow looks something like this: Log to Cloud Aspect package com.luv2code.aopdemo.aspect; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Before; import org.springframework.core.annotation.Order; import org.springframework.stereotype.Component; @Aspect @Component // Set order @Order(1) public class MyCloudLogAsyncAspect { \t@Before(\"com.aopdemo.aspect.LuvAopExpressions.forDaoPackageNoGetterSetter()\") \tpublic void logToCloudAsync() { \t\tSystem.out.println(\"\\n=====>>> Logging to Cloud in async fashion\");\t\t \t} } Logging Aspect package com.aopdemo.aspect; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Before; import org.springframework.core.annotation.Order; import org.springframework.stereotype.Component; @Aspect @Component // Set the order @Order(2) public class MyDemoLoggingAspect { \t \t@Before(\"com.aopdemo.aspect.LuvAopExpressions.forDaoPackageNoGetterSetter()\") \tpublic void beforeAddAccountAdvice() {\t\t \t\tSystem.out.println(\"\\n=====>>> Executing @Before advice on method\");\t\t \t} \t } Analytics Aspect package com.aopdemo.aspect; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Before; import org.springframework.core.annotation.Order; import org.springframework.stereotype.Component; @Aspect @Component // Set the order @Order(3) public class MyApiAnalyticsAspect { \t@Before(\"com.aopdemo.aspect.LuvAopExpressions.forDaoPackageNoGetterSetter()\") \tpublic void performApiAnalytics() { \t\tSystem.out.println(\"\\n=====>>> Performing API analytics\");\t\t \t} } "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/AOP/Pointcut Expressions.html",
    "title": "Pointcut Expressions",
    "body": " Back Pointcut Expressions A pointcut expression is a predicate expression that tells spring when to apply a given advice. Spring AOP uses AspectJ's pointcut expression language. Execution Pointcut The expression pattern is the following: execution(modifiers-pattern? return-type-pattern declaring-type-pattern? method-name-pattern(param-pattern) throws-pattern?) modifiers-pattern?: Spring AOP only supports public or * return-type-pattern: void, boolean, string, List<Costumer>, etc declaring-type-pattern?: the class name method-name-pattern(param-pattern): method name to match, and parameters type to match throws-pattern?: exception types to match If the parameter is optional it is followed by an ?. You can also add wildcards inside the patterns. Match Methods Some examples are: Match concrete method inside a class: @Before(\"execution(public void com.aopdemo.dao.AccountDAO.addAccount())\") Match a method inside any class: @Before(\"execution(public void addAccount())\") Match any method that starts with add: @Before(\"execution(public void add*())\") Match all methods inside a given package: @Before(\"execution(* com.aopdemo.dao.*.*(..))\") The first * denotes the return type, it can be anything The second * denotes the class name, it can be anything inside the package The third * denotes the method name, it can be anything Lastly, .. denotes the param-type, there can be 0 or more parameters Match Parameters There are the following parameter pattern wildcards: (): matches a method with no arguments (*): matches a method with one argument of any type (..): matches a method with 0 or more arguments of any type For example: Match addAccount methods with no arguments: @Before(\"execution(* addAccount())\") Match addAcount methods with one Account parameter: @Before(\"execution(* addAccount(com.aopdemo.Account))\") Match addAcount methods with any number of parameters: @Before(\"execution(* addAccount(*))\") "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/AOP/After Advice.html",
    "title": "After Advice",
    "body": " Back After Advice This advice runs always when the method is completed (like a finally clause inside a try catch). For example if we want to always run the advice afterFinallyFindAccountsAdvice when the method findAccounts inside AccountDAO finishes: package com.aopdemo.aspect; import java.util.List; import org.aspectj.lang.JoinPoint; import org.aspectj.lang.annotation.After; import org.aspectj.lang.annotation.AfterReturning; import org.aspectj.lang.annotation.AfterThrowing; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Before; import org.aspectj.lang.reflect.MethodSignature; import org.springframework.core.annotation.Order; import org.springframework.stereotype.Component; import com.aopdemo.Account; @Aspect @Component @Order(2) public class MyDemoLoggingAspect { \t@After(\"execution(* com.aopdemo.dao.AccountDAO.findAccounts(..))\") \tpublic void afterFinallyFindAccountsAdvice(JoinPoint theJoinPoint) { \t\t \t\t// print out which method we are advising on \t\tString method = theJoinPoint.getSignature().toShortString(); \t\tSystem.out.println(\"\\n=====>>> Executing @After (finally) on method: \" \t\t\t\t\t\t\t+ method); \t \t} } "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/AOP/Before Advice.html",
    "title": "Before Advice",
    "body": " Back Before Advice We use the tag @Before to execute some code before we call the target object function: Add Dependencies We have to download the AspectJ jar file, because Spring AOP depends on some on their framework's classes Create Target Object We create a DAO object: package com.aopdemo.dao; import org.springframework.stereotype.Component; @Component public class AccountDAO { \tpublic void addAccount() { \t\tSystem.out.println( \t\t\tgetClass() \t\t\t+ \": DOING MY DB WORK: ADDING AN ACCOUNT\" \t\t); \t} } Spring Configuration We now have to enable AOP proxying in our app configuration: package com.aopdemo; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.EnableAspectJAutoProxy; @Configuration // Enable proxying to add before advice @EnableAspectJAutoProxy @ComponentScan(\"com.aopdemo\") public class DemoConfig { } Create Aspect with @Before Now it is time to create an aspect with @Before advice: package com.aopdemo.aspect; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Before; import org.springframework.stereotype.Component; @Aspect @Component public class MyDemoLoggingAspect { \t// this is where we add all of our related advices for logging \t// Here we specify we want to run this code before calling the \t// object method public void addAccount \t@Before(\"execution(public void addAccount())\") \tpublic void beforeAddAccountAdvice() { \t\tSystem.out.println(\"\\n=====>>> Executing @Before advice on addAccount()\"); \t} } Main App We now create a demo app: package com.aopdemo; import org.springframework.context.annotation.AnnotationConfigApplicationContext; import com.aopdemo.dao.AccountDAO; public class MainDemoApp { \tpublic static void main(String[] args) { \t\t// read spring config java class \t\tAnnotationConfigApplicationContext context = \t\t\t\tnew AnnotationConfigApplicationContext(DemoConfig.class); \t\t \t\t// get the bean from spring container \t\tAccountDAO theAccountDAO = context.getBean(\"accountDAO\", AccountDAO.class); \t\t \t\t// call the business method \t\ttheAccountDAO.addAccount(); \t\t// do it again! \t\tSystem.out.println(\"\\nlet's call it again!\\n\"); \t\t \t\t// call the business method again \t\ttheAccountDAO.addAccount(); \t\t\t\t \t\t// close the context \t\tcontext.close(); \t} } "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/AOP/Overview.html",
    "title": "Overview",
    "body": " Back Overview Aspect-Oriented Programming is a programming technique based on the concept of an Aspect (that is something that encapsulated cross-cutting logic/functionality, which means logic that affect the project transversally like logging or security). What AOP does behind the scenes is call methods from the classes/aspects (like a logging class) whenever a method is called (this depends on the configuration): Advantages Reusable modules Resolve code tangling Resolve code scatter Applied selectively based on configuration Disadvantages Too many aspects and app flow is hard to follow Minor performance cost for aspect execution Terminology Aspect: module of code for a cross-cutting concern (logging, security...) Advice: what action is takes and when it should be applied Joint Point: when to apply code during program execution Pointcut: a predicate expression for where advice should be applied Advice Types Before advice: run before the method After finally advice: run after the method (like finally clause in try catch) After returning advice: run after the method (success execution) After throwing advice: run after the method (if exception if thrown) Around advice: run before and after the method Weaving It refers to the connection being made between aspects and target objects to create an advised object. There are different types: Compile-time Load-time Run-time Note that the slowest is the run-time weaving Best Practices Keep the code inside the advices small Keep the code fast Do not perform any expensive/slow operations "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/AOP/AfterThrowing Advice.html",
    "title": "AfterThrowing Advice",
    "body": " Back AfterThrowing Advice This advice is run whenever the target object throws and execption. For example: package com.aopdemo.aspect; import java.util.List; import org.aspectj.lang.JoinPoint; import org.aspectj.lang.annotation.AfterReturning; import org.aspectj.lang.annotation.AfterThrowing; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Before; import org.aspectj.lang.reflect.MethodSignature; import org.springframework.core.annotation.Order; import org.springframework.stereotype.Component; import com.luv2code.aopdemo.Account; @Aspect @Component @Order(2) public class MyDemoLoggingAspect { \t \t@AfterThrowing( \t\t\tpointcut=\"execution(* com.aopdemo.dao.AccountDAO.findAccounts(..))\", \t\t\t// Define the name of the parameter that holds the exception object \t\t\tthrowing=\"theExc\") \tpublic void afterThrowingFindAccountsAdvice( \t\t\t\t\tJoinPoint theJoinPoint, Throwable theExc) { \t\t \t\t// print out which method we are advising on \t\tString method = theJoinPoint.getSignature().toShortString(); \t\tSystem.out.println(\"\\n=====>>> Executing @AfterThrowing on method: \" + method); \t\t \t\t// log the exception \t\tSystem.out.println(\"\\n=====>>> The exception is: \" + theExc); \t \t} } In this code sample we have the advice afterThrowingFindAccountsAdvice that is run whenever the method findAccounts inside AccountDAO throws an exception. We also make use of the throwing attribute that lets us map the exception object to a parameter inside our advice. "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/AOP/Around Advice.html",
    "title": "Around Advice",
    "body": " Back Around Advice This type of advice is always called before and after the target object. When using the @Around advice we have access to a reference of a proceeding join point. Which is a handle to the target method, and will let us execute the taget method. So for example if we want to measure the performance of the getFortuneMethod: package com.aopdemo.aspect; import java.util.List; import org.aspectj.lang.JoinPoint; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.After; import org.aspectj.lang.annotation.AfterReturning; import org.aspectj.lang.annotation.AfterThrowing; import org.aspectj.lang.annotation.Around; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Before; import org.aspectj.lang.reflect.MethodSignature; import org.springframework.core.annotation.Order; import org.springframework.stereotype.Component; import com.aopdemo.Account; @Aspect @Component @Order(2) public class MyDemoLoggingAspect { \t \t@Around(\"execution(* com.aopdemo.service.*.getFortune(..))\")\t \tpublic Object aroundGetFortune( \t\t\tProceedingJoinPoint theProceedingJoinPoint) throws Throwable { \t\t \t\t// print out method we are advising on \t\tString method = theProceedingJoinPoint.getSignature().toShortString(); \t\tSystem.out.println(\"\\n=====>>> Executing @Around on method: \" + method); \t\t \t\t// get begin timestamp \t\tlong begin = System.currentTimeMillis(); \t\t \t\t// now, let's execute the method \t\tObject result = theProceedingJoinPoint.proceed(); \t\t \t\t// get end timestamp \t\tlong end = System.currentTimeMillis(); \t\t \t\t// compute duration and display it \t\tlong duration = end - begin; \t\tSystem.out.println(\"\\n=====> Duration: \" + duration / 1000.0 + \" seconds\"); \t\t \t\treturn result; \t} } The advice aroundGetFortune is called before the getFortune is called, then it proceeds to call from inside the advice and we measure how long does the method take to run. Exception Handling Inside an advice, to handle exceptions you can: Handle the exception inside the advice \t@Around(\"execution(* com.aopdemo.service.*.getFortune(..))\")\t \tpublic Object aroundGetFortune( \t\t\tProceedingJoinPoint theProceedingJoinPoint) throws Throwable { \t\t \t\t// print out method we are advising on \t\tString method = theProceedingJoinPoint.getSignature().toShortString(); \t\tSystem.out.println(\"\\n=====>>> Executing @Around on method: \" + method); \t\t \t\t// get begin timestamp \t\tlong begin = System.currentTimeMillis(); \t\t \t\ttry { \t\t\tresult = theProceedingJoinPoint.proceed(); \t\t} catch (Exception e) { \t\t\t// log the exception \t\t\tmyLogger.warning(e.getMessage()); \t\t\t \t\t\t// give users a custom messagee \t\t\tresult = \"Major accident! But no worries, \" \t\t\t\t\t+ \"your private AOP helicopter is on the way!\"; \t\t} \t\t \t\t// get end timestamp \t\tlong end = System.currentTimeMillis(); \t\t \t\t// compute duration and display it \t\tlong duration = end - begin; \t\tSystem.out.println(\"\\n=====> Duration: \" + duration / 1000.0 + \" seconds\"); \t\t \t\treturn result; \t} Simply rethrow the exception \t@Around(\"execution(* com.aopdemo.service.*.getFortune(..))\")\t \tpublic Object aroundGetFortune( \t\t\tProceedingJoinPoint theProceedingJoinPoint) throws Throwable { \t\t \t\t// print out method we are advising on \t\tString method = theProceedingJoinPoint.getSignature().toShortString(); \t\tSystem.out.println(\"\\n=====>>> Executing @Around on method: \" + method); \t\t \t\t// get begin timestamp \t\tlong begin = System.currentTimeMillis(); \t\t \t\ttry { \t\t\tresult = theProceedingJoinPoint.proceed(); \t\t} catch (Exception e) { \t\t\t// log the exception \t\t\tmyLogger.warning(e.getMessage()); \t\t\t// rethrow exception \t\t\tthrow e; \t\t} \t\t \t\t// get end timestamp \t\tlong end = System.currentTimeMillis(); \t\t \t\t// compute duration and display it \t\tlong duration = end - begin; \t\tSystem.out.println(\"\\n=====> Duration: \" + duration / 1000.0 + \" seconds\"); \t\t \t\treturn result; \t} "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/AOP/JoinPoints.html",
    "title": "JoinPoints",
    "body": " Back JoinPoints When we are in an aspect, how can we access method parameters? Display Method Signature To display the method signature we do the following: package com.aopdemo.aspect; import org.aspectj.lang.JoinPoint; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Before; import org.aspectj.lang.reflect.MethodSignature; import org.springframework.core.annotation.Order; import org.springframework.stereotype.Component; import com.aopdemo.Account; @Aspect @Component @Order(2) public class MyDemoLoggingAspect { \t \t@Before(\"com.aopdemo.aspect.LuvAopExpressions.forDaoPackageNoGetterSetter()\") \tpublic void beforeAddAccountAdvice(JoinPoint theJoinPoint) { \t\t \t\tSystem.out.println(\"\\n=====>>> Executing @Before advice on method\");\t \t\t \t\t// display the method signature \t\tMethodSignature methodSig = (MethodSignature) theJoinPoint.getSignature(); \t\t \t\tSystem.out.println(\"Method: \" + methodSig); \t} } Display Method Arguments Also, to display the method arguments: package com.aopdemo.aspect; import org.aspectj.lang.JoinPoint; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Before; import org.aspectj.lang.reflect.MethodSignature; import org.springframework.core.annotation.Order; import org.springframework.stereotype.Component; import com.aopdemo.Account; @Aspect @Component @Order(2) public class MyDemoLoggingAspect { \t \t@Before(\"com.aopdemo.aspect.LuvAopExpressions.forDaoPackageNoGetterSetter()\") \tpublic void beforeAddAccountAdvice(JoinPoint theJoinPoint) { \t\t \t\tSystem.out.println(\"\\n=====>>> Executing @Before advice on method\");\t \t\t// display method arguments \t\t// get args \t\tObject[] args = theJoinPoint.getArgs(); \t\t \t\t// loop through args \t\tfor (Object tempArg : args) { \t\t\tSystem.out.println(tempArg); \t\t\t \t\t\tif (tempArg instanceof Account) { \t\t\t\t \t\t\t\t// downcast and print Account specific stuff \t\t\t\tAccount theAccount = (Account) tempArg; \t\t\t\t \t\t\t\tSystem.out.println(\"account name: \" + theAccount.getName()); \t\t\t\tSystem.out.println(\"account level: \" + theAccount.getLevel());\t\t\t\t\t\t\t\t \t\t\t} \t\t}\t\t \t} } "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/AOP/AfterReturning Advice.html",
    "title": "AfterReturning Advice",
    "body": " Back AfterReturning Advice This advice is run after the method is done executing, and it executed successfully. The flow of this advice is the following: So for example, if you want to have an advice run everytime we call the findAccounts method inside a concrete class, and we also want to print out the result we obtained we do the following: package com.aopdemo.aspect; import java.util.List; import org.aspectj.lang.JoinPoint; import org.aspectj.lang.annotation.AfterReturning; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Before; import org.aspectj.lang.reflect.MethodSignature; import org.springframework.core.annotation.Order; import org.springframework.stereotype.Component; import com.aopdemo.Account; @Aspect @Component @Order(2) public class MyDemoLoggingAspect { \t\t \t// add a new advice for @AfterReturning on the findAccounts method \t@AfterReturning( \t\t\tpointcut=\"execution(* com.aopdemo.dao.AccountDAO.findAccounts(..))\", // This is the parameter name of the list of accounts returned by findAccounts \t\t\treturning=\"result\") \tpublic void afterReturningFindAccountsAdvice( \t\t\t\t\tJoinPoint theJoinPoint, List<Account> result) { \t\t \t\t// print out which method we are advising on \t\tString method = theJoinPoint.getSignature().toShortString(); \t\tSystem.out.println(\"\\n=====>>> Executing @AfterReturning on method: \" + method); \t\t\t\t \t\t// print out the results of the method call \t\tSystem.out.println(\"\\n=====>>> result is: \" + result); \t} } "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Spring Rest/POJOs as JSON.html",
    "title": "POJOs as JSON",
    "body": " Back POJOs as JSON To test converting POJOs to JSON we are going to create a service that allows us to retrieve a list of students: Create POJO We are going to create the Student entity: package com.springdemo.entity; public class Student { \tprivate String firstName; \tprivate String lastName; \t \tpublic Student() { \t\t \t} \tpublic Student(String firstName, String lastName) { \t\tthis.firstName = firstName; \t\tthis.lastName = lastName; \t} \tpublic String getFirstName() { \t\treturn firstName; \t} \tpublic void setFirstName(String firstName) { \t\tthis.firstName = firstName; \t} \tpublic String getLastName() { \t\treturn lastName; \t} \tpublic void setLastName(String lastName) { \t\tthis.lastName = lastName; \t} \t } Create Service We now code the logic that handles the controller. package com.springdemo.rest; import java.util.ArrayList; import java.util.List; import javax.annotation.PostConstruct; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import com.luv2code.springdemo.entity.Student; @RestController @RequestMapping(\"/api\") public class StudentRestController { \tprivate List<Student> theStudents; \t \t \t// define @PostConstruct to load the student data ... only once! \t@PostConstruct \tpublic void loadData() { \t \t\ttheStudents = new ArrayList<>(); \t\t \t\ttheStudents.add(new Student(\"Poornima\", \"Patel\")); \t\ttheStudents.add(new Student(\"Mario\", \"Rossi\")); \t\ttheStudents.add(new Student(\"Mary\", \"Smith\"));\t\t \t} \t \t \t \t// define endpoint for \"/students\" - return list of students \t@GetMapping(\"/students\") \tpublic List<Student> getStudents() { \t\t\t \t\treturn theStudents; \t} \t \t// define endpoint for \"/students/{studentId}\" - return student at index \t@GetMapping(\"/students/{studentId}\") \tpublic Student getStudent(@PathVariable int studentId) { \t\t \t\t// just index into the list ... keep it simple for now \t\treturn theStudents.get(studentId); \t\t \t} } Note that the endpoint \"/students/{studentId}\" has a path variable studentId "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Spring Rest/JSON Data Binding.html",
    "title": "Java JSON Data Binding",
    "body": " Back Java JSON Data Binding Data binding is the process of converting JSON data to a Java POJO (the conversion goes both ways) Data binding is the same as Serialization/Deserialization and Marshalling/Unmarshalling. Spring uses the Jackson Project behind the scenes which handles data binding between JSON and Java POJOs. For conversion we use Object Mapper By default Jackson will call appropiate getter and setter methods to populate a POJO from a JSON or to create a JSON object from a POJO. To convert from JSON to Java, Jackson calls the setter methods To convert from Java to JSON, Jackson calls the getter methods Set Up Add Jackson Project as a dependency in the maven file: \t<dependencies> \t\t<!-- TODO: Add your dependency here --> \t\t<dependency> \t\t\t<groupId>com.fasterxml.jackson.core</groupId> \t\t\t<artifactId>jackson-databind</artifactId> \t\t\t<version>2.10.0.pr1</version> \t\t</dependency>\t \t\t\t \t</dependencies> Create POJO Class We now create the class we are going to convert to JSON (Serialize): package com.jackson.json.demo; public class Student { \tprivate int id; \tprivate String firstName; \tprivate String lastName; \tprivate boolean active; \t \tpublic Student() { \t\t \t} \t \tpublic int getId() { \t\treturn id; \t} \t \tpublic void setId(int id) { \t\tthis.id = id; \t} \t \tpublic String getFirstName() { \t\treturn firstName; \t} \t \tpublic void setFirstName(String firstName) { \t\tthis.firstName = firstName; \t} \t \tpublic String getLastName() { \t\treturn lastName; \t} \t \tpublic void setLastName(String lastName) { \t\tthis.lastName = lastName; \t} \t \tpublic boolean isActive() { \t\treturn active; \t} \t \tpublic void setActive(boolean active) { \t\tthis.active = active; \t} \t } Main App Now, to test it we are going to create a Student object by reading from a JSON object: package com.jackson.json.demo; import java.io.File; import com.fasterxml.jackson.databind.ObjectMapper; public class Driver { \tpublic static void main(String[] args) { \t\t \t\ttry { \t\t\t// create object mapper \t\t\tObjectMapper mapper = new ObjectMapper(); \t\t\t \t\t\t// read JSON file and map/convert to Java POJO: \t\t\t// data/sample-lite.json \t\t\t \t\t\tStudent theStudent = mapper.readValue( \t\t\t\t\t\tnew File(\"data/sample-lite.json\"), Student.class); \t\t} \t\tcatch (Exception exc) { \t\t\texc.printStackTrace(); \t\t} \t} } Nested Objects But, how can we read nested properties inside a json file, like the following: { \t\"id\": 14, \t\"firstName\": \"Mario\", \t\"lastName\": \"Rossi\", \t\"active\": true, \t\"address\": { \t\t\"street\": \"100 Main St\", \t\t\"city\": \"Philadelphia\", \t\t\"state\": \"Pennsylvania\", \t\t\"zip\": \"19103\", \t\t\"country\": \"USA\" \t}, \t\"languages\" : [\"Java\", \"C#\", \"Python\", \"Javascript\"] } As you can see the address property has properties inside it. What we are going to do is create a new attribute address inside the Student object, which will be a POJO object in itself. package com.jackson.json.demo; public class Student { \tprivate int id; \tprivate String firstName; \tprivate String lastName; \tprivate boolean active; \t \tprivate Address address; \t \tprivate String[] languages; \t \tpublic Student() { \t\t \t} \t \tpublic int getId() { \t\treturn id; \t} \t \tpublic void setId(int id) { \t\tthis.id = id; \t} \t \tpublic String getFirstName() { \t\treturn firstName; \t} \t \tpublic void setFirstName(String firstName) { \t\tthis.firstName = firstName; \t} \t \tpublic String getLastName() { \t\treturn lastName; \t} \t \tpublic void setLastName(String lastName) { \t\tthis.lastName = lastName; \t} \t \tpublic boolean isActive() { \t\treturn active; \t} \t \tpublic void setActive(boolean active) { \t\tthis.active = active; \t} \tpublic Address getAddress() { \t\treturn address; \t} \tpublic void setAddress(Address address) { \t\tthis.address = address; \t} \tpublic String[] getLanguages() { \t\treturn languages; \t} \tpublic void setLanguages(String[] languages) { \t\tthis.languages = languages; \t} \t } We also need to create the Address class: package com.jackson.json.demo; public class Address { \tprivate String street; \tprivate String city; \tprivate String state; \tprivate String zip; \tprivate String country; \t \tpublic Address() { \t\t \t} \tpublic String getStreet() { \t\treturn street; \t} \tpublic void setStreet(String street) { \t\tthis.street = street; \t} \tpublic String getCity() { \t\treturn city; \t} \tpublic void setCity(String city) { \t\tthis.city = city; \t} \tpublic String getState() { \t\treturn state; \t} \tpublic void setState(String state) { \t\tthis.state = state; \t} \tpublic String getZip() { \t\treturn zip; \t} \tpublic void setZip(String zip) { \t\tthis.zip = zip; \t} \tpublic String getCountry() { \t\treturn country; \t} \tpublic void setCountry(String country) { \t\tthis.country = country; \t} } Ignore Unknwon Properties To ignore properties from the JSON file that cannot be mapped to an attribute in the POJO we use the annotation: package com.jackson.json.demo; @JsonIgnoreProperties(ignoreUnkown=true) public class Student { \tprivate int id; \tprivate String firstName; "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Spring Rest/Exception Handling.html",
    "title": "Exception Handling",
    "body": " Back Exception Handling In this section we are going to show how to create an error page to display when there is an error on a request. Create Error Response Class package com.springdemo.rest; public class StudentErrorResponse { \tprivate int status; \tprivate String message; \tprivate long timeStamp; \tpublic StudentErrorResponse() { \t\t \t} \t \tpublic StudentErrorResponse(int status, String message, long timeStamp) { \t\tthis.status = status; \t\tthis.message = message; \t\tthis.timeStamp = timeStamp; \t} \tpublic int getStatus() { \t\treturn status; \t} \tpublic void setStatus(int status) { \t\tthis.status = status; \t} \tpublic String getMessage() { \t\treturn message; \t} \tpublic void setMessage(String message) { \t\tthis.message = message; \t} \tpublic long getTimeStamp() { \t\treturn timeStamp; \t} \tpublic void setTimeStamp(long timeStamp) { \t\tthis.timeStamp = timeStamp; \t} \t \t } Create Exception Class package com.springdemo.rest; public class StudentNotFoundException extends RuntimeException { \tpublic StudentNotFoundException(String message, Throwable cause) { \t\tsuper(message, cause); \t} \tpublic StudentNotFoundException(String message) { \t\tsuper(message); \t} \tpublic StudentNotFoundException(Throwable cause) { \t\tsuper(cause); \t} \t } Rest Service with Exception What we need to know is: Define an exception handler method with @ExceptionHandler annotation The exception handler will return a Response Entity Response Entity is a wrapper for the HTTP response object ResposneEntity provides a fine-grained control to specify: HTTP status code HTTP headers Response body package com.springdemo.rest; import java.util.ArrayList; import java.util.List; import javax.annotation.PostConstruct; import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.ExceptionHandler; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import com.springdemo.entity.Student; @RestController @RequestMapping(\"/api\") public class StudentRestController { \tprivate List<Student> theStudents; \t// define @PostConstruct to load the student data ... only once! \t@PostConstruct \tpublic void loadData() { \t \t\ttheStudents = new ArrayList<>(); \t\t \t\ttheStudents.add(new Student(\"Poornima\", \"Patel\")); \t\ttheStudents.add(new Student(\"Mario\", \"Rossi\")); \t\ttheStudents.add(new Student(\"Mary\", \"Smith\"));\t\t \t} \t \t \t \t// define endpoint for \"/students\" - return list of students \t@GetMapping(\"/students\") \tpublic List<Student> getStudents() { \t\t\t \t\treturn theStudents; \t} \t \t// define endpoint for \"/students/{studentId}\" - return student at index \t@GetMapping(\"/students/{studentId}\") \tpublic Student getStudent(@PathVariable int studentId) { \t\t \t\t// just index into the list ... keep it simple for now \t\t// check the studentId against list size \t\tif ( (studentId >= theStudents.size()) || (studentId < 0) ) {\t\t\t \t\t\tthrow new StudentNotFoundException(\"Student id not found - \" + studentId); \t\t} \t\t \t\treturn theStudents.get(studentId); \t\t \t} // Tag it as an exception handling method \t@ExceptionHandler // Type of response body Exception type to handle \tpublic ResponseEntity<StudentErrorResponse> handleException(StudentNotFoundException exc) { \t\t \t\tStudentErrorResponse error = new StudentErrorResponse(); \t\t // json error object \t\terror.setStatus(HttpStatus.NOT_FOUND.value()); \t\terror.setMessage(exc.getMessage()); \t\terror.setTimeStamp(System.currentTimeMillis()); \t // return response with the error object and the status code \t\treturn new ResponseEntity<>(error, HttpStatus.NOT_FOUND); \t } // Another exception handler \t@ExceptionHandler // Catch any exception thrown \tpublic ResponseEntity<StudentErrorResponse> handleException(Exception exc) { \t\t \t\tStudentErrorResponse error = new StudentErrorResponse(); \t\t \t\terror.setStatus(HttpStatus.BAD_REQUEST.value()); \t\terror.setMessage(exc.getMessage()); \t\terror.setTimeStamp(System.currentTimeMillis()); \t\t \t\treturn new ResponseEntity<>(error, HttpStatus.BAD_REQUEST); \t}\t } Global Exception Handler Instead of having the exception handling methods in every controller, we defined them globally. For that we use ControllerAdvice that acts as a filter between the requests and the controller. It: Pre-processes requests to controllers Post-processes responses to handle exceptions So, we create a class with the @ControllerAdvice annotation: package com.springdemo.rest; import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.ControllerAdvice; import org.springframework.web.bind.annotation.ExceptionHandler; @ControllerAdvice public class StudentRestExceptionHandler { \t// add exception handling code here \t// Add an exception handler using @ExceptionHandler \t@ExceptionHandler \tpublic ResponseEntity<StudentErrorResponse> handleException(StudentNotFoundException exc) { \t\t \t\t// create a StudentErrorResponse \t\tStudentErrorResponse error = new StudentErrorResponse(); \t\t \t\terror.setStatus(HttpStatus.NOT_FOUND.value()); \t\terror.setMessage(exc.getMessage()); \t\terror.setTimeStamp(System.currentTimeMillis()); \t\t \t\t// return ResponseEntity \t\treturn new ResponseEntity<>(error, HttpStatus.NOT_FOUND); \t} \t \t// add another exception handler ... to catch any exception (catch all) \t@ExceptionHandler \tpublic ResponseEntity<StudentErrorResponse> handleException(Exception exc) { \t\t \t\t// create a StudentErrorResponse \t\tStudentErrorResponse error = new StudentErrorResponse(); \t\terror.setStatus(HttpStatus.BAD_REQUEST.value()); \t\terror.setMessage(exc.getMessage()); \t\terror.setTimeStamp(System.currentTimeMillis()); \t\t \t\t// return ResponseEntity\t\t \t\treturn new ResponseEntity<>(error, HttpStatus.BAD_REQUEST); \t} \t } And now we modify the controller to make use of this paradigm: package com.springdemo.rest; import java.util.ArrayList; import java.util.List; import javax.annotation.PostConstruct; import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.web.bind.annotation.ExceptionHandler; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import com.springdemo.entity.Student; @RestController @RequestMapping(\"/api\") public class StudentRestController { \tprivate List<Student> theStudents; \t \t// define @PostConstruct to load the student data ... only once! \t@PostConstruct \tpublic void loadData() { \t \t\ttheStudents = new ArrayList<>(); \t\t \t\ttheStudents.add(new Student(\"Poornima\", \"Patel\")); \t\ttheStudents.add(new Student(\"Mario\", \"Rossi\")); \t\ttheStudents.add(new Student(\"Mary\", \"Smith\"));\t\t \t} \t// define endpoint for \"/students\" - return list of students \t@GetMapping(\"/students\") \tpublic List<Student> getStudents() { \t\t\t \t\treturn theStudents; \t} \t \t// define endpoint for \"/students/{studentId}\" - return student at index \t@GetMapping(\"/students/{studentId}\") \tpublic Student getStudent(@PathVariable int studentId) { \t\t \t\t// just index into the list ... keep it simple for now \t\t// check the studentId against list size \t\tif ( (studentId >= theStudents.size()) || (studentId < 0) ) { \t\t\tthrow new StudentNotFoundException(\"Student id not found - \" + studentId); \t\t} \t\t\t \t\treturn theStudents.get(studentId); \t}\t } "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Spring Rest/Spring Rest Controller.html",
    "title": "Spring Rest Controller",
    "body": " Back Spring Rest Controller Spring Web MVC provides support for Spring REST. For that we use a new annotation called RestController which is an extension of Controller and handles REST requests and responses. Spring REST will also automatically convert Java POJOs to JSON as long as the Jackson project is on the classpath or pom.xml. Hello World To exemplify how to set up a REST Controller in Spring we will create an application that upong request sends back a Hello World! message: Configuration First of all, make sure you have the Jackson project, MVC and REST and also Servlet libraries as a maven dependency or as a library in your classpath. \t<dependencies> \t\t<!-- Add Spring MVC and REST support --> \t\t<dependency> \t\t\t<groupId>org.springframework</groupId> \t\t\t<artifactId>spring-webmvc</artifactId> \t\t\t<version>5.0.5.RELEASE</version> \t\t</dependency> \t\t \t\t<!-- Add Jackson for JSON converters --> \t\t<dependency> \t\t\t<groupId>com.fasterxml.jackson.core</groupId> \t\t\t<artifactId>jackson-databind</artifactId> \t\t\t<version>2.9.9.2</version> \t\t</dependency> \t\t<!-- Add Servlet support for \t\t\t Spring's AbstractAnnotationConfigDispatcherServletInitializer --> \t\t<dependency> \t\t\t<groupId>javax.servlet</groupId> \t\t\t<artifactId>javax.servlet-api</artifactId> \t\t\t<version>3.1.0</version> \t\t</dependency> \t\t<!-- Add support for JSP ... get rid of Eclipse error -->\t\t\t\t \t\t<dependency> \t\t\t<groupId>javax.servlet.jsp</groupId> \t\t\t<artifactId>javax.servlet.jsp-api</artifactId> \t\t\t<version>2.3.1</version> \t\t</dependency> \t\t\t\t \t</dependencies> General We create a configuration class as follows: package com.springdemo.config; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.EnableWebMvc; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; // Mark it as a configuration class @Configuration @EnableWebMvc // Enable component scanning in our source code @ComponentScan(\"com.springdemo\") public class DemoAppConfig implements WebMvcConfigurer { } Servlet Initializer We have to specify the configuration of our servlet, for this we extend AbstractAnnotationConfigDispatcherServletInitializer: package com.springdemo.config; import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer; public class MySpringMvcDispatcherServletInitializer extends AbstractAnnotationConfigDispatcherServletInitializer { \t@Override \tprotected Class<?>[] getRootConfigClasses() { \t\t// TODO Auto-generated method stub \t\treturn null; \t} \t@Override \tprotected Class<?>[] getServletConfigClasses() { // Specify our config class \t\treturn new Class[] { DemoAppConfig.class }; \t} \t@Override \tprotected String[] getServletMappings() { \t\treturn new String[] { \"/\" }; \t} } Controller For this we need to create our server with the controller that handles this request: package com.springdemo.rest; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(\"/test\") public class DemoRestController { \t// add code for the \"/hello\" endpoint \t \t@GetMapping(\"/hello\") \tpublic String sayHello() { \t\treturn \"Hello World!\"; \t} \t } "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/index.html",
    "title": "Spring",
    "body": " Back Spring Introduction Core Spring Framework Spring MVC Hibernate Spring REST Spring Boot Thymeleaf Maven Spring Security Aspect Oriented Programming Intro Spring Docs Getting Ready Spring Framework Set Up Core Spring Framework Spring With XML Configuration Inversion of Control Dependency Injection Bean Scopes and Life cycle Spring With Java Annotations Java Annotations Spring With Only Java Spring Configuration with Java Code Spring MVC Overview Configuration Controller View Read HTML Form Data Model Add CSS and JS Request Params and Request Mappings Form Tags Form Validation Hibernate Overview Configuration Annotations Usage Sessions Database Operations Advanced Annotations Concepts OneToOne OneToMany Eager vs Lazy Loading ManyToMany Spring REST JSON Data Binding Spring Rest Controller POJOs as JSON Exception Handling Spring Boot Overview Controller Spring Boot Project Structure Spring Boot Starters Spring Boot DevTools Spring Boot Actuator Application Properties JPA Spring Data JPA Spring Data REST Thymeleaf Overview Tables Maven Overview POM File Structure Maven Archetypes Additional Repositories Private Repositories Spring Security Overview Java Configuration Basic Security Custom Login Form Log Out Cross Site Request Forgery Display User and Roles Authorization JDBC Database Authentication Aspect Oriented Programming (AOP) Overview Before Advice Pointcut Expressions Pointcut Declarations Control Aspect Order JoinPoints AfterReturning Advice AfterThrowing Advice After Advice Around Advice "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/IoC/Inversion of Control.html",
    "title": "Inversion of Control",
    "body": " Back Inversion of Control The Spring container (generally known as ApplicationContext) has two main functions: Create and manage objects (Inversion of control) Inject object's dependencies (Dependency Injection) So Inversion Control is externalizing the construction and management of objects which will be handled by and object factory. This is illustrated in the following image: MyApp has the main method MyApp asks Spring to retrieve the appropiate object based on a configuration file or an annotation, instead of having to code it manually like: package com.springdemo; public class MyApp { \tpublic static void main(String[] args) { \t\tCoach theCoach = new TrackCoach(); \t\t \t\t// call methods on the bean \t\tSystem.out.println(theCoach.getDailyWorkout()); \t} } Where we have defined an interface Coach that is implemented by both TrackCoach and BaseballCoach package com.springdemo; public interface Coach { \tpublic String getDailyWorkout(); \t } package com.springdemo; public class TrackCoach implements Coach { \t@Override \tpublic String getDailyWorkout() { \t\treturn \"Run a hard 5k\"; \t} } To avoid this approach we create a Spring container. To configure a Spring container we can use: XML configuration file (legacy) Java Annotations Java Source Code However what is a Spring Bean? A \"Spring Bean\" is simply a Java object. When Java objects are created by the Spring Container, then Spring refers to them as \"Spring Beans\". Spring Beans are created from normal Java classes just like Java objects. Why do we specify the Coach interface in getBean()? When we pass the interface to the method, behind the scenes Spring will cast the object for you. context.getBean(\"myCoach\", Coach.class) However, there are some slight differences than normal casting. Behaves the same as getBean(String), but provides a measure of type safety by throwing a BeanNotOfRequiredTypeException if the bean is not of the required type. This means that ClassCastException can't be thrown on casting the result correctly, as can happen with getBean(String). "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Dependency Injection/Setter Injection.html",
    "title": "Setter Injection",
    "body": " Back Setter Injection Inject dependencies by calling setter methods on your class Create Dependency Object Refer to Create Dependency Object Define dependency We include a setter method that takes the dependency as an argument like: package com.springdemo; public class CricketCoach implements Coach { \tprivate FortuneService fortuneService;\t \t \t// create a no-arg constructor \tpublic CricketCoach() { \t\tSystem.out.println(\"CricketCoach: inside no-arg constructor\"); \t} \t \t// our setter method \tpublic void setFortuneService(FortuneService fortuneService) { \t\tSystem.out.println(\"CricketCoach: inside setter method - setFortuneService\"); \t\tthis.fortuneService = fortuneService; \t} \t@Override \tpublic String getDailyWorkout() { \t\treturn \"Practice fast bowling for 15 minutes\"; \t} \t@Override \tpublic String getDailyFortune() { \t\treturn fortuneService.getFortune(); \t} } Configuration File <?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"> <!-- Define your beans here --> <!-- define the dependency --> <bean id=\"myFortuneService\" class=\"com.springdemo.HappyFortuneService\"> </bean> <bean id=\"myCoach\" \tclass=\"com.springdemo.TrackCoach\">\t \t<!-- set up constructor injection --> \t<constructor-arg ref=\"myFortuneService\" /> </bean> <bean id=\"myCricketCoach\" class=\"com.springdemo.CricketCoach\"> <!-- set up setter injection --> <!-- ref: references the id of the bean we define previously --> <!-- name: name of the setter method set<name>, where the first letter of the name is capitalized --> <property name=\"fortuneService\" ref=\"myFortuneService\" /> </bean> </beans> Behind the scenes, Spring framework does: package com.springdemo; public class MyApp { \tpublic static void main(String[] args) { \t\t// Create object \t\t// From the bean with id = myFortuneService in the config file \t\tHappyFortuneService myFortuneService = new HappyFortuneService(); \t\t \t\t// From the bean with id = myCricketCoach in the config file \t\tCricketCoach myCricketCoach = new CricketCoach(fortuneService); \t\t// Add dependency via setter \t\tmyCricketCoach.setFortuneService(myFortuneService); \t} } Main Method Now, on the main method of our Spring App, we create the object by reading the config file, and Spring automatically injects the dependency via the setter method: package com.springdemo; import org.springframework.context.support.ClassPathXmlApplicationContext; public class SetterDemoApp { \tpublic static void main(String[] args) { \t\t// load the spring configuration file \t\tClassPathXmlApplicationContext context = \t\t\t\tnew ClassPathXmlApplicationContext(\"applicationContext.xml\"); \t\t \t\t// retrieve bean from spring container \t\tCricketCoach theCoach = context.getBean(\"myCricketCoach\", CricketCoach.class); \t\t \t\t// call methods on the bean \t\tSystem.out.println(theCoach.getDailyWorkout()); \t\t \t\tSystem.out.println(theCoach.getDailyFortune()); \t\t\t\t\t\t \t\t// close the context \t\tcontext.close(); \t} } "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Dependency Injection/Dependency Injection.html",
    "title": "Dependency Injection",
    "body": " Back Dependency Injection The dependencies of the objects are managed by the Spring container object factory: So instead of having to build the object and all of its dependencies, the spring factory will do this work for you. Injection Types There are several injection types in Spring. The more common are: Constructor Injection Setter Injection Injecting Literal Values Inject Values From a Properties File "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Dependency Injection/Inject Values From a Properties File.html",
    "title": "Inject Values from the Properties Files",
    "body": " Back Inject Values from the Properties Files Create the properties file Let's define our properties inside a properties file sport.properties: foo.email=myeasycoach@email.com foo.team=Royal Challengers Bangalore Load the properties file Now we load the properties file using the context tag inside our config file: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"> <!-- load the properties file: sport.properties --> <context:property-placeholder location=\"classpath:sport.properties\"/> <!-- Define your beans here --> <!-- define the dependency --> <bean id=\"myFortuneService\" class=\"com.springdemo.HappyFortuneService\"> </bean> <bean id=\"myCoach\" \tclass=\"com.springdemo.TrackCoach\">\t \t<!-- set up constructor injection --> \t<constructor-arg ref=\"myFortuneService\" /> </bean> <bean id=\"myCricketCoach\" class=\"com.springdemo.CricketCoach\"> <!-- set up setter injection --> <!-- ref: references the id of the bean we define previously --> <!-- name: name of the setter method set<name>, where the first letter of the name is capitalized --> <property name=\"fortuneService\" ref=\"myFortuneService\" /> <!-- inject literal values, where name is the name of the attribute in the bean and value is the value to set the value to --> <!-- Note that we are now referencing the values from the properties file --> <property name=\"emailAddress\" value=\"${foo.email})\" /> <property name=\"team\" value=\"${foo.team}\" /> </bean> </beans> Main Method In the main method, we create our object as usual, and if we invoke the getter methods, we retrieve the values passed in the property file: package com.springdemo; import org.springframework.context.support.ClassPathXmlApplicationContext; public class SetterDemoApp { \tpublic static void main(String[] args) { \t\t// load the spring configuration file \t\tClassPathXmlApplicationContext context = \t\t\t\tnew ClassPathXmlApplicationContext(\"applicationContext.xml\"); \t\t \t\t// retrieve bean from spring container \t\tCricketCoach theCoach = context.getBean(\"myCricketCoach\", CricketCoach.class); \t\t \t\t// retrieve attribute values from property file \t\tSystem.out.println(theCoach.getTeam()); \t\tSystem.out.println(theCoach.getEmailAddress()); \t\t\t\t\t\t \t\t// close the context \t\tcontext.close(); \t} } "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Dependency Injection/Constructor Injection.html",
    "title": "Constructor Injection",
    "body": " Back Constructor Injection Now we will show an example where the BaseballCoach has FortuneService as a dependency. So, first we create the dependency interface as follows: Create Dependency Object package com.springdemo; public interface FortuneService { \tpublic String getFortune(); \t } Next we create the dependency class than implements the interface: package com.springdemo; public class HappyFortuneService implements FortuneService { \t@Override \tpublic String getFortune() { \t\treturn \"Today is your lucky day!\"; \t} } Establish Dependency Let's also update the Coach Interface to add a method getDailyFortune (note that all classes that implement this interface have to implement this new method): package com.springdemo; public interface Coach { \tpublic String getDailyWorkout(); \t \tpublic String getDailyFortune(); } Now create a constructor for the dependency in the class that has the dependency package com.springdemo; public class BaseballCoach implements Coach { \t// define a private field for the dependency \tprivate FortuneService fortuneService; \t \t// define a constructor for dependency injection \tpublic BaseballCoach(FortuneService theFortuneService) { \t\tfortuneService = theFortuneService; \t} \t \t@Override \tpublic String getDailyWorkout() { \t\treturn \"Spend 30 minutes on batting practice\"; \t} \t@Override \tpublic String getDailyFortune() {\t\t \t\t// use my fortuneService to get a fortune\t\t \t\treturn fortuneService.getFortune(); \t} } Configuration File Finally define the dependency in the configuration file: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"> <!-- Define your beans here --> <!-- define the dependency --> <bean id=\"myFortuneService\" class=\"com.springdemo.HappyFortuneService\"> </bean> <!-- Bean with the dependency --> <bean id=\"myCoach\" class=\"com.springdemo.TrackCoach\">\t <!-- Set up constructor injection, note ref=id of bean --> <constructor-arg ref=\"myFortuneService\" /> </bean> </beans> Behind the scenes, Spring framework does: package com.springdemo; public class MyApp { \tpublic static void main(String[] args) { \t\t// Create object \t\t// From the bean with id = myFortuneService in the config file \t\tHappyFortuneService myFortuneService = new HappyFortuneService(); \t\t \t\t// Add dependency via constructor \t\t// From the bean with id = myCoach in the config file \t\tTrackCoach myCoach = new TrackCoach(fortuneService); \t} } Main Method We do not need to make any modifications to the app, when we create the Coach bean using Spring, the framework deals with the dependency injection: package com.luv2code.springdemo; import org.springframework.context.support.ClassPathXmlApplicationContext; public class HelloSpringApp { \tpublic static void main(String[] args) { \t\t// load the spring configuration file \t\tClassPathXmlApplicationContext context = \t\t\t\tnew ClassPathXmlApplicationContext(\"applicationContext.xml\"); \t\t\t\t \t\t// retrieve bean from spring container (with the dependency) \t\tCoach theCoach = context.getBean(\"myCoach\", Coach.class); \t\t \t\t// call methods on the bean \t\tSystem.out.println(theCoach.getDailyWorkout()); \t\t \t\t// let's call our new method for fortunes \t\tSystem.out.println(theCoach.getDailyFortune()); \t\t \t\t// close the context \t\tcontext.close(); \t} } "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Dependency Injection/Injecting Literal Values.html",
    "title": "Injecting Literal Values",
    "body": " Back Injecting Literal Values To inject concrete attributes into our beans: Define the Attributes First we define the attributes emailAddress and team in the object. Also we create the set and get methods for both of them: package com.luv2code.springdemo; public class CricketCoach implements Coach { \tprivate FortuneService fortuneService; \t \t// add new fields for emailAddress and team \tprivate String emailAddress; \tprivate String team; \t \t\t \tpublic CricketCoach() { \t\tSystem.out.println(\"CricketCoach: inside no-arg constructor\"); \t} \t /* SETTERS AND GETTERS */ \tpublic String getEmailAddress() { \t\treturn emailAddress; \t} \tpublic void setEmailAddress(String emailAddress) { \t\tSystem.out.println(\"CricketCoach: inside setter method - setEmailAddress\"); \t\tthis.emailAddress = emailAddress; \t} \tpublic String getTeam() { \t\treturn team; \t} \tpublic void setTeam(String team) { \t\tSystem.out.println(\"CricketCoach: inside setter method - setTeam\"); \t\tthis.team = team; \t} /* Setter Injection */ \tpublic void setFortuneService(FortuneService fortuneService) { \t\tSystem.out.println(\"CricketCoach: inside setter method - setFortuneService\"); \t\tthis.fortuneService = fortuneService; \t} \t@Override \tpublic String getDailyWorkout() { \t\treturn \"Practice fast bowling for 15 minutes\"; \t} \t@Override \tpublic String getDailyFortune() { \t\treturn fortuneService.getFortune(); \t} } Configuration File Now we define the properties in the configuration file: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"> \t<!-- Define your beans here --> \t<!-- define the dependency --> \t<bean id=\"myFortuneService\" class=\"com.springdemo.HappyFortuneService\"> \t</bean> \t \t<bean id=\"myCoach\" \t\tclass=\"com.springdemo.TrackCoach\">\t \t\t<!-- set up constructor injection --> \t\t<constructor-arg ref=\"myFortuneService\" /> \t</bean> \t \t<bean id=\"myCricketCoach\" class=\"com.springdemo.CricketCoach\"> \t <!-- set up setter injection --> \t <!-- ref: references the id of the bean we define previously --> \t <!-- name: name of the setter method set<name>, where the first \t letter of the name is capitalized --> \t <property name=\"fortuneService\" ref=\"myFortuneService\" /> \t\t<!-- inject literal values, where name is the name of the attribute in the bean \t\tand value is the value to set the value to --> \t <property name=\"emailAddress\" value=\"email@email.com\" /> \t <property name=\"team\" value=\"Best Team\" /> \t</bean> </beans> Main Method Now in the main method of our app we can call the getters and setters for these new attributes: package com.springdemo; import org.springframework.context.support.ClassPathXmlApplicationContext; public class SetterDemoApp { \tpublic static void main(String[] args) { \t\t// load the spring configuration file \t\tClassPathXmlApplicationContext context = \t\t\t\tnew ClassPathXmlApplicationContext(\"applicationContext.xml\"); \t\t \t\t// retrieve bean from spring container \t\tCricketCoach theCoach = context.getBean(\"myCricketCoach\", CricketCoach.class); \t\t \t\t// retrieve attribute values \t\tSystem.out.println(theCoach.getTeam()); \t\tSystem.out.println(theCoach.getEmailAddress()); \t\t\t\t\t\t \t\t// close the context \t\tcontext.close(); \t} } "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Set Up.html",
    "title": "Set Up",
    "body": " Back Set Up Requirements: JDK Java Application Server (i.e. Tomcat) Java Integrated Development Environment (IDE) Spring 5 JAR files (download manually or use Maven) "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Hibernate/Annotations.html",
    "title": "Configure Hibernate with Annotations",
    "body": " Back Configure Hibernate with Annotations Add Hibernate Configuration File We create the following hibernate.cfg.xml file: <!DOCTYPE hibernate-configuration PUBLIC \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"> <hibernate-configuration> <!-- A session factory allows us to get sessions objects to connect to the database --> <session-factory> <!-- JDBC Database connection settings --> <property name=\"connection.driver_class\">com.mysql.cj.jdbc.Driver</property> <property name=\"connection.url\">jdbc:mysql://localhost:3306/hb_student_tracker?useSSL=false&amp;serverTimezone=UTC</property> <property name=\"connection.username\">hbstudent</property> <property name=\"connection.password\">hbstudent</property> <!-- JDBC connection pool settings ... using built-in test pool --> <property name=\"connection.pool_size\">1</property> <!-- Select our SQL dialect --> <property name=\"dialect\">org.hibernate.dialect.MySQLDialect</property> <!-- Echo the SQL to stdout --> <property name=\"show_sql\">true</property> <!-- Set the current session context --> <property name=\"current_session_context_class\">thread</property> </session-factory> </hibernate-configuration> Annotate Java Class Hibernate deals with the concept of Entity, which is basically a Java Class with its attributes, setters and getters, that is mapped to a database table with the help of annotations. Note that there are two ways of configuring the mapping: XML Config file (legacy) Java Annotations (modern, preferred) With Java Annotations we have to follow these steps: Map the class to a database table // Let spring know this is an entity we want to map to a database table @Entity // Provides the actual name of the table (observe in this case it is optional // because the name of the class = the name of the database table) @Table(name=\"student\") public class Student { ... } Map the fields to database columns public class Student { // Primary key @Id // How to generate primary key @GeneratedValue(strategy=GenerationType.IDENTITY) // Column name (also not needed if the name in the database and the name here are the same) @Column(name=\"id\") private int id; @Column(name=\"first_name\") private String firstName; @Column(name=\"last_name\") private String lastName; @Column(name=\"email\") private String email; ... } Some other ID Generation Strategies are: AUTO: pick the appropiate strategy for the given database IDENTITY: assign primary keys using database identidy column SEQUENCE: assign primary keys using a database sequence TABLE: assign primary keys using an uderlying database table to ensure uniqueness You can also create your custom generator "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Hibernate/ManyToMany.html",
    "title": "Many To Many Relationship",
    "body": " Back Many To Many Relationship Here we demonstrate how to implement a many to many relationship between two entities. For this we need a join table: Well, first of all you have to define the two database tables corresponding to these two entities. And then we define a intermediate table to act as the join table called course_student. Entities We now code the two entities: package com.hibernate.demo.entity; // annotate the class as an entity and map to db table @Entity @Table(name=\"course\") public class Course { // define the fields // annotate the fields with db column names @Id @GeneratedValue(strategy=GenerationType.IDENTITY) @Column(name=\"id\") private int id; @Column(name=\"title\") private String title; // Set up one to many relationship @ManyToOne(cascade= // On delete course, do not delete instructor {CascadeType.PERSIST, CascadeType.MERGE, CascadeType.DETACH, CascadeType.REFRESH}) @JoinColumn(name=\"instructor_id\") private Instructor instructor; // Set up unidirectional one to many relationship @OneToMany(fetch=FetchType.LAZY, cascade=CascadeType.ALL) \t@JoinColumn(name=\"course_id\") \tprivate List<Review> reviews; // Set up many to many relationship with lazy loading // so only Courses are retrieved, and the students associated // are obtained only if needed \t@ManyToMany(fetch=FetchType.LAZY, \t\t\tcascade= {CascadeType.PERSIST, CascadeType.MERGE, \t\t\t CascadeType.DETACH, CascadeType.REFRESH}) // Specifying the join table, and the corresponding // foreign keys @JoinTable( // table name name=\"course_student\", // this entity's pk joinColumns=@JoinColumn(name=\"course_id\"), // related entity's pk inverseJoinColumns=@JoinColumn(name=\"student_id\") ) private List<Student> students; public Course() { }\t\t ... // Setters and getters } And now the Student: package com.hibernate.demo.entity; @Entity @Table(name=\"student\") public class Student { @Id @GeneratedValue(strategy=GenerationType.IDENTITY) @Column(name=\"id\") private int id; @Column(name=\"first_name\") private String firstName; @Column(name=\"last_name\") private String lastName; @Column(name=\"email\") private String email; // Set up many to many relationship with lazy loading // so only Students are retrieved, and the courses associated // are obtained only if needed @ManyToMany(fetch=FetchType.LAZY, \t\tcascade= {CascadeType.PERSIST, CascadeType.MERGE, \t\t CascadeType.DETACH, CascadeType.REFRESH}) // Specifying the join table, and the corresponding // foreign keys @JoinTable( // table name \t\tname=\"course_student\", // this entity's pk \t\tjoinColumns=@JoinColumn(name=\"student_id\"), // related entity's pk \t\tinverseJoinColumns=@JoinColumn(name=\"course_id\") \t\t)\t private List<Course> courses; // constructor, getters, setters .... Main App To test our code, we are going to get a Course and add it to a Student: package com.hibernate.demo; public class CreateDemo { public static void main(String[] args) { // create session factory // ... // create session Session session = factory.getCurrentSession(); try {\t\t // start a transaction session.beginTransaction(); // get the student mary from database int studentId = 2; Student tempStudent = session.get(Student.class, studentId); // create more courses Course tempCourse1 = new Course(\"Rubik's Cube - How to Speed Cube\"); Course tempCourse2 = new Course(\"Atari 2600 - Game Development\"); \t\t\t // add student to courses tempCourse1.addStudent(tempStudent); tempCourse2.addStudent(tempStudent); \t\t\t // save the courses session.save(tempCourse1); session.save(tempCourse2); // commit transaction session.getTransaction().commit(); } finally { session.close(); \tfactory.close(); } } } "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Hibernate/Concepts.html",
    "title": "Database Concepts",
    "body": " Back Database Concepts Cascade: perform an operations on related entities On save: if we save an object, if it is related to another object, we need to also save that other object On delete: if we delete an object that is related to another object, we might need to delete that other object (depends on the use case) Fetch types: when we fetch data, should we retrieve everything? Eager: will retrieve everything Lazy: will retrieve on request Cascade Types PERSIST: if entity is persisted/saved, the related entity will also be persisted REMOVE: if entity is removed/deleted, the related entity will also be deleted REFRESH: if entity is refreshed, the related entity will also be refreshed DETACH: if entity is detached (not associated with session), the related entity will also be detached MERGE: if entity is merged, the related entity will also be merged ALL: all of the above cascade types By default, no operations are cascaded. "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Hibernate/Sessions.html",
    "title": "Sessions",
    "body": " Back Sessions There are two key components when it comes to session handling: SessionFactory: reads the hibernate configuration file, creates sessions objects, and is created only once in the application and reused over and over again Session: is a wrapper around a JDBC connection, which is the main object used to save/retrieve objects. This object is created multiple times. So to create a SessionFactory and then create Session from it: public class Demo { public static void main(String[] args) { // create session factory SessionFactory factory = new Configuration() // configuration file in src/ (if it is not specified, hibernate will look for a file named hibernate.cfg.xml) .configure(\"hibernate.cfg.xml\") // Class that was annotated to be mapped .addAnnotatedClass(Student.class) // You can add multiple classes .addAnnotatedClass(...) // Create the factory .buildSessionFactory(); // create session Session session = factory.getCurrentSession(); try {\t\t\t // Use session object to perform CRUD operations\t } finally { // Delete session factory factory.close(); } } } "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Hibernate/OneToOne.html",
    "title": "One To One Relationship",
    "body": " Back One To One Relationship Unidirectional Bidirectional Unidirectional Here we demonstrate how to implement a unidirectional one to one relationship between two entities: Well, first of all you have to define the two database tables corresponding to these two entities. Entities We now code the two entities: package com.hibernate.demo.entity; /* annotate the class as an entity and map to db table */ @Entity @Table(name=\"instructor\") public class Instructor { // define the fields and annotate the fields // with db column names @Id @GeneratedValue(strategy=GenerationType.IDENTITY) @Column(name=\"id\") private int id; @Column(name=\"first_name\") private String firstName; @Column(name=\"last_name\") private String lastName; @Column(name=\"email\") private String email; // Set up mapping to InstructorDetail entity // Note the cascade type @OneToOne(cascade=CascadeType.ALL) // Define the foreign key @JoinColumn(name=\"instructor_detail_id\") private InstructorDetail instructorDetail; public Instructor() { \t } ... // Setters and getters } Note the specification of the Cascade Type. And now the InstructorDetail: package com.hibernate.demo.entity; // annotate the class as an entity and map to db table @Entity @Table(name=\"instructor_detail\") public class InstructorDetail { \t// define the fields \t// annotate the fields with db column names \t \t@Id \t@GeneratedValue(strategy=GenerationType.IDENTITY) \t@Column(name=\"id\") \tprivate int id; \t \t@Column(name=\"youtube_channel\") \tprivate String youtubeChannel; \t \t@Column(name=\"hobby\") \tprivate String hobby; \t \tpublic InstructorDetail() { }\t\t ... // Setters and getters } Main App To test our code, we are going to create an Instructor object and an InstructorDetail object and save them. The test main app is the following: package com.hibernate.demo; public class CreateDemo { public static void main(String[] args) { // create session factory // ... // create session Session session = factory.getCurrentSession(); try {\t\t\t // create the objects Instructor tempInstructor = \t\tnew Instructor(\"Madhu\", \"Patel\", \"madhu@mail.com\"); InstructorDetail tempInstructorDetail = \t\tnew InstructorDetail( \t\t\t\t\"http://www.youtube.com\", \t\t\t\t\"Guitar\");\t\t // associate the objects tempInstructor.setInstructorDetail(tempInstructorDetail); // start a transaction session.beginTransaction(); // save the instructor // // Note: this will ALSO save the details object // because of CascadeType.ALL // session.save(tempInstructor);\t\t\t\t\t // commit transaction session.getTransaction().commit(); } finally { \tfactory.close(); } } } Bidirectional Now we will define the following Bidirectional One To One relationship: Let's now see how to code a bidirectional relationship: Entities package com.hibernate.demo.entity; /* annotate the class as an entity and map to db table */ @Entity @Table(name=\"instructor\") public class Instructor { // define the fields and annotate the fields // with db column names @Id @GeneratedValue(strategy=GenerationType.IDENTITY) @Column(name=\"id\") private int id; @Column(name=\"first_name\") private String firstName; @Column(name=\"last_name\") private String lastName; @Column(name=\"email\") private String email; // Set up mapping to InstructorDetail entity // Note the cascade type @OneToOne(cascade=CascadeType.ALL) // Define the foreign key @JoinColumn(name=\"instructor_detail_id\") private InstructorDetail instructorDetail; public Instructor() { \t } ... // Setters and getters And now the InstructorDetail: package com.hibernate.demo.entity; // annotate the class as an entity and map to db table @Entity @Table(name=\"instructor_detail\") public class InstructorDetail { // define the fields // annotate the fields with db column names @Id @GeneratedValue(strategy=GenerationType.IDENTITY) @Column(name=\"id\") private int id; @Column(name=\"youtube_channel\") private String youtubeChannel; @Column(name=\"hobby\") private String hobby; \t // add @OneToOne annotation // mappedBy refers to the instructorDetail property // in the Instructor class // This uses the information from the Instructor class in @JoinColumn // to define the mapping @OneToOne(mappedBy=\"instructorDetail\", // Different cascade types cascade={ CascadeType.DETACH, CascadeType.MERGE, CascadeType.PERSIST, CascadeType.REFRESH}) private Instructor instructor; public InstructorDetail() { }\t\t ... // Setters and getters } Main App In our test main app we are going to search for an InstructorDetail object, and we are going to retrieve the related Instructor object: package com.hibernate.demo; public class GetInstructorDetailDemo { \tpublic static void main(String[] args) { session = factory.getCurrentSession(); try { // start a transaction session.beginTransaction(); // get the instructor detail object int theId = 2999; InstructorDetail tempInstructorDetail = \t\tsession.get(InstructorDetail.class, theId); \t\t\t // print the associated instructor System.out.println(\"the associated instructor: \" + \t\t\t\t\ttempInstructorDetail.getInstructor()); // commit transaction session.getTransaction().commit(); } catch(Exception exc){ exc.printStackTrace(); } finally { // Finish session \t\t\tsession.close(); \t\t // Remove factory\t \t\t\tfactory.close(); } } } "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Hibernate/Database Operations.html",
    "title": "Database Operations",
    "body": " Back Database Operations Save Java Object To save a Java Object: public ... { try {\t\t\t \t// create a student object \tStudent tempStudent = new Student(\"Paul\", \"Doe\", \"paul@luv2code.com\"); \t \t// start a transaction \tsession.beginTransaction(); \t \t// save the student object \tsession.save(tempStudent); \t \t// commit transaction \tsession.getTransaction().commit(); } finally { \tfactory.close(); } } Read Java Object public ... { try {\t\t\t // From the student created and saved previously // find out the student's id: primary key // now get a new session and start transaction session = factory.getCurrentSession(); session.beginTransaction(); // retrieve student based on the id: primary key System.out.println(\"\\nGetting student with id: \" + tempStudent.getId()); // Get from the DB by the primary key of the student Student myStudent = session.get(Student.class, tempStudent.getId()); // commit the transaction session.getTransaction().commit(); } finally { \tfactory.close(); } } Query Java Object Hibernate has a query language for retrieving objects: HQL which is similar to SQL. public class QueryStudentDemo { public static void main(String[] args) { // create session factory ... // create session Session session = factory.getCurrentSession(); try {\t\t\t // start a transaction session.beginTransaction(); // Note we use the Java object name for the table name // and the name of the attribute in the class for the name // of the column (firstName istd of first_name) // query students: lastName='Doe' OR firstName='Daffy' theStudents = session.createQuery(\"from Student s where\" + \" s.lastName='Doe' OR s.firstName='Daffy'\").getResultList(); // query students where email LIKE '%gmail.com' theStudents = session.createQuery(\"from Student s where\" \t\t+ \" s.email LIKE '%gmail.com'\").getResultList(); // commit transaction session.getTransaction().commit(); } finally { \tfactory.close(); } } Update Java Objects public class UpdateStudentDemo { public static void main(String[] args) { // create session factory ... // create session Session session = factory.getCurrentSession(); try {\t\t\t\t\t\t\t\t // Update one student int studentId = 1; // now get a new session and start transaction session = factory.getCurrentSession(); session.beginTransaction(); Student myStudent = session.get(Student.class, studentId); // Update name of student myStudent.setFirstName(\"Scooby\"); // commit the transaction session.getTransaction().commit(); // Update several students session = factory.getCurrentSession(); session.beginTransaction(); // update email for all students System.out.println(\"Update email for all students\"); session.createQuery(\"update Student set email='foo@gmail.com'\") \t.executeUpdate(); \t\t\t // commit the transaction session.getTransaction().commit(); } finally { \tfactory.close(); } } } Delete Java Objects public class DeleteStudentDemo { public static void main(String[] args) { // create session factory ... // create session Session session = factory.getCurrentSession(); try {\t\t\t\t\t\t\t\t int studentId = 1; \t\t\t // now get a new session and start transaction session = factory.getCurrentSession(); session.beginTransaction(); // retrieve student based on the id: primary key Student myStudent = session.get(Student.class, studentId); // delete the student session.delete(myStudent); // delete student id=2 session.createQuery(\"delete from Student where id=2\").executeUpdate(); // commit the transaction session.getTransaction().commit(); } finally { \tfactory.close(); } } } "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Hibernate/index.html",
    "title": "index",
    "body": " Back Hibernate Is a framework for persisting/saving Java objects in a database Handles all of the low-level SQL Minimizes the amount JDBC code to develop Provides the Object-to-Relational Mapping (ORM): The developer defines a mapping between a Java class and a database table Hibernate uses JDBC for all database communications: "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Hibernate/Eager vs Lazy Loading.html",
    "title": "Eager vs Lazy Loading",
    "body": " Back Eager vs Lazy Loading Eager: fetches all data all at once (with dependencies of the entity) Lazy: fetches required data only Lazy loading is usually preferred, that is only load data when absolutely needed. The flow of Lazy Loading is: Load the main entity first Load dependent entities on demand Note than when using Lazy Loading you need an open Hibernate session, else if you close the session and try to retrieve the data Hibernate will throw an exception. Default Fetch Types Mapping Defaul Fetch Type @OneToOne FetchType.EAGER @OneToMany FetchType.LAZY @ManyToOne FetchType.EAGER @ManyToMany FetchType.LAZY Specify Fetch Type on Entity We can specify the fetching type on the Entity as follows: @Entity @Table(name=\"instructor\") public class Instructor { \t@Id \t@GeneratedValue(strategy=GenerationType.IDENTITY) \t@Column(name=\"id\") \tprivate int id; \t \t@OneToOne(cascade=CascadeType.ALL) \t@JoinColumn(name=\"instructor_detail_id\") \tprivate InstructorDetail instructorDetail; \t // Specify fetch type (only load the courses on demand, their retrieval // is delayed) \t@OneToMany(fetch=FetchType.LAZY, \t\t\t mappedBy=\"instructor\", \t\t\t cascade= {CascadeType.PERSIST, CascadeType.MERGE, \t\t\t\t\t\t CascadeType.DETACH, CascadeType.REFRESH}) \tprivate List<Course> courses; ... Avoid Closed Session Exception To avoid the error we use the JOIN FETCH (we do override lazy loading with eager loading) of HQL: public class FetchJoinDemo { public static void main(String[] args) { // create session factory SessionFactory factory = ... // create session Session session = factory.getCurrentSession(); try {\t\t\t // start a transaction session.beginTransaction(); // Hibernate query with HQL to avoid exception of lazy loading when closing session // get the instructor from db int theId = 1; Query<Instructor> query = \t\tsession.createQuery(\"select i from Instructor i \" \t\t\t\t\t\t+ \"JOIN FETCH i.courses \" \t\t\t\t\t\t+ \"where i.id=:theInstructorId\", \t\t\t\tInstructor.class); // set parameter on query query.setParameter(\"theInstructorId\", theId); // execute query and get instructor Instructor tempInstructor = query.getSingleResult(); System.out.println(\"luv2code: Instructor: \" + tempInstructor);\t // commit transaction session.getTransaction().commit(); // close the session session.close(); System.out.println(\"\\nluv2code: The session is now closed!\\n\"); // get courses for the instructor System.out.println(\"luv2code: Courses: \" + tempInstructor.getCourses()); System.out.println(\"luv2code: Done!\"); } finally { // add clean up code session.close(); factory.close(); } } } "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Hibernate/OneToMany.html",
    "title": "One To Many Relationship",
    "body": " Back One To Many Relationship Unidirectional Bidirectional Unidirectional Here we demonstrate how to implement a unidirectional one to many relationship between two entities: Well, first of all you have to define the two database tables corresponding to these two entities. Entities We now code the two entities: package com.hibernate.demo.entity; // annotate the class as an entity and map to db table @Entity @Table(name=\"course\") public class Course { // define the fields // annotate the fields with db column names @Id @GeneratedValue(strategy=GenerationType.IDENTITY) @Column(name=\"id\") private int id; @Column(name=\"title\") private String title; // Set up one to many relationship @ManyToOne(cascade= // On delete course, do not delete instructor {CascadeType.PERSIST, CascadeType.MERGE, CascadeType.DETACH, CascadeType.REFRESH}) @JoinColumn(name=\"instructor_id\") private Instructor instructor; // Set up unidirectional one to many relationship @OneToMany(fetch=FetchType.LAZY, cascade=CascadeType.ALL) \t@JoinColumn(name=\"course_id\") \tprivate List<Review> reviews; public Course() { }\t\t ... // Setters and getters } And now the Review: package com.hibernate.demo.entity; @Entity @Table(name=\"review\") public class Review { \t@Id \t@GeneratedValue(strategy=GenerationType.IDENTITY) \t@Column(name=\"id\") \tprivate int id; \t \t@Column(name=\"comment\") \tprivate String comment; \t \tpublic Review() { \t\t \t} Note that there is no reference in the Review to the Course. Main App To test our code, we are going to get a Course and the list of Review objects associated. The test main app is the following: package com.hibernate.demo; public class CreateDemo { public static void main(String[] args) { // create session factory // ... // create session Session session = factory.getCurrentSession(); try {\t\t // start a transaction session.beginTransaction(); // get the course int theId = 10; Course tempCourse = session.get(Course.class, theId); // Get reviews tempCourse.getReviews(); // commit transaction session.getTransaction().commit(); } finally { session.close(); \tfactory.close(); } } } Bidirectional Now we will define the following relationship: Let's now see how to code a bidirectional relationship: Entities package com.hibernate.demo.entity; /* annotate the class as an entity and map to db table */ @Entity @Table(name=\"instructor\") public class Instructor { // define the fields and annotate the fields // with db column names @Id @GeneratedValue(strategy=GenerationType.IDENTITY) @Column(name=\"id\") private int id; @Column(name=\"first_name\") private String firstName; @Column(name=\"last_name\") private String lastName; @Column(name=\"email\") private String email; // Set up mapping to InstructorDetail entity // Note the cascade type @OneToOne(cascade=CascadeType.ALL) // Define the foreign key @JoinColumn(name=\"instructor_detail_id\") private InstructorDetail instructorDetail; // Bidirectional relationship with courses // the mapping information is in the instructor // property in the Course class @OneToMany(mappedBy=\"instructor\", // On delete instructor, do not delete courses cascade= {CascadeType.PERSIST, CascadeType.MERGE, CascadeType.DETACH, CascadeType.REFRESH}) private List<Course> courses; public Instructor() { \t } ... // Setters and getters } And now the Course class: package com.hibernate.demo.entity; // annotate the class as an entity and map to db table @Entity @Table(name=\"course\") public class Course { // define the fields // annotate the fields with db column names @Id @GeneratedValue(strategy=GenerationType.IDENTITY) @Column(name=\"id\") private int id; @Column(name=\"title\") private String title; // Set up one to many relationship @ManyToOne(cascade= // On delete course, do not delete instructor {CascadeType.PERSIST, CascadeType.MERGE, CascadeType.DETACH, CascadeType.REFRESH}) @JoinColumn(name=\"instructor_id\") private Instructor instructor; public Course() { }\t\t ... // Setters and getters } Main App In our test main app we are going to search for an InstructorDetail object, and we are going to retrieve the related Instructor object: package com.hibernate.demo; public class GetInstructorDetailDemo { public static void main(String[] args) { session = factory.getCurrentSession(); try { // start a transaction session.beginTransaction(); // get the instructor from db int theId = 1; Instructor tempInstructor = session.get(Instructor.class, theId);\t\t // create some courses Course tempCourse1 = new Course(\"Air Guitar - The Ultimate Guide\"); Course tempCourse2 = new Course(\"The Pinball Masterclass\"); // add courses to instructor tempInstructor.add(tempCourse1); tempInstructor.add(tempCourse2); // save the courses session.save(tempCourse1); session.save(tempCourse2); // commit transaction session.getTransaction().commit(); } catch(Exception exc){ exc.printStackTrace(); } finally { // Finish session session.close(); // Remove factory\t factory.close(); } } } "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Spring/Spring Framework.html",
    "title": "Spring Framework",
    "body": " Back Spring Framework Components: Core Container Beans (define entities) Core (management of beans) SpEL: Spring Expression Language (annotations) Context (store entities) AOP (Aspect Oriented Programming): allows you to create application wide services like messaging, logging, security, etc. and add this functionality to your objects in a declarative fashion. Data Access Layer: establishes the connection with the database JDBC Helper classes ORM: provides hook to Hibernate Transactions OXM JMS (Java Message Service) for async messages Web Layer: all web related classes, holds all of the Spring MVC framework Servlet WebSocket Web Portlet Test Layer: supports TDD: Unit Integration Mock Spring Projects Spring modules built on top of the core Spring Framework: Spring Boot Spring Cloud Spring Batch etc Spring Projects "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/React/Start in indexjs.html",
    "title": "Start in index.js",
    "body": " Back Start in index.js Keep in mind, index.js is the entry point: First of all refer to File Structure, and then basically remove everything from index.js, and replace it for: import React from 'react'; import ReactDom from 'react-dom'; // CSS import './index.css'; We use the ReactDom module to make use of the React DOM API, which let's us render components, etc. Next we call ReactDom.render() to output our HTML: import React from 'react'; import ReactDom from 'react-dom'; // CSS import './index.css'; function Component() { return ( <h4> HI! </h4> ); } ReactDom.render( <Component/>, document.getElementbyId(\"root\") ) Note The function must start with a capital letter The tag that encloses the component must be closed, so either: <Component/> or <Component></ Component> We use document.getElementbyId(\"root\"), this tells React where to place the component inside the HTML "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/React/PropTypes.html",
    "title": "PropTypes",
    "body": " Back PropTypes PropTypes allows us to validate our props. import React from 'react' import Product from './Product' import { useFetch } from './useFetch' const url = 'https://course-api.com/react-prop-types-example' const Index = () => { const { products } = useFetch(url) return ( <div> <h2>products</h2> <section className='products'> {products.map((product) => { // Pass the props return <Product key={product.id} {...product} /> })} </section> </div> ) } export default Index In this Product component we show how to use propTypes to parametrize the props, and how to use conditional render to avoid getting an error when some of the props are missing. import React from 'react'; import PropTypes from 'prop-types'; import defaultImage from './assets/default-image.jpeg'; const Product = ({ image, name, price }) => { const url = image && image.url; return ( <article className='product'> {/*Use conditional rendering in case the data does not exist */} <img src={url || defaultImage} alt={name || 'default name'} /> <h4>{name}</h4> <p>${price || 3.99}</p> </article> ); }; // Define the propTypes for the object Product.propTypes = { image: PropTypes.object.isRequired, name: PropTypes.string.isRequired, price: PropTypes.number.isRequired, }; export default Product; Default Props In this other Product component, we show how to use defaultProps instead of conditional rendering. import React from 'react'; import PropTypes from 'prop-types'; import defaultImage from './assets/default-image.jpeg'; const Product = ({ image, name, price }) => { return ( <article className='product'> {/*Use conditional rendering in case the data does not exist */} <img src={image.url} alt={name} /> <h4>{name}</h4> <p>${price}</p> </article> ); }; // Define the propTypes for the object Product.propTypes = { image: PropTypes.object.isRequired, name: PropTypes.string.isRequired, price: PropTypes.number.isRequired, }; Product.defaultProps = { name: 'default name', price: 3.99, image: defaultImage, }; export default Product; "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/React/File Structure.html",
    "title": "File Structure",
    "body": " Back File Structure node_modules: folder that contains all of the dependencies package.json: is the manifest file for the project scripts start: runs the development server build: creates a production version for the project inside a folder called build, where the optimized files resulting of the build are stored. The rest of the files created by create-react-app are mostly useless: App.js App.css App.test.js logo.svg serviceWorker.js setupTests.js Also all of the contents of index.js can be removed. "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/React/Reducer.html",
    "title": "Reducers and Actions",
    "body": " Back Reducers and Actions Let's now see an example of a reducer, more concretely the reducer of the user slice we defined previously: // Use create slice to define the slice import { createSlice } from \"@reduxjs/toolkit\"; // Define initial state const initialStateValue = { name: \"\", age: 0, email: \"\" }; export const userSlice = createSlice({ // Name of slice name: \"user\", // Initial state of reducer initialState: { value: initialStateValue }, // Possible reducers reducers: { login: (state, action) => { state.value = action.payload; }, logout: (state) => { state.value = initialStateValue; }, }, }); // De-structure actions export const { login, logout } = userSlice.actions; // Export reducer export default userSlice.reducer; We now "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/React/Props.html",
    "title": "Props",
    "body": " Back Props In React to define parameters in our components, we do as follows: import React from 'react' // This are the props const Book = (props) => { return ( <article className='book'> <img src={props.img} alt='' /> <h1>{props.title}</h1> <h4>{props.author}</h4> </article> ); }; export default Book Another way (more readable), is to spread the object: import React from 'react' // This are the props const Book = ({ title, author }) => { return ( <article className='book'> <h1>{title}</h1> <h4>{author}</h4> </article> ); }; export default Book Now, to pass these props we do: import React from 'react'; import ReactDom from 'react-dom'; // CSS import './index.css'; import Book from './Book' ReactDom.render( <Book title='Book title' author='Book author'/>, document.getElementById('root') ); Spread operator Let's define an object singleBook that contains all of the book's properties and pass it to the Book component: import React from 'react'; import ReactDom from 'react-dom'; // CSS import './index.css'; import Book from './Book' const singleBook = { title: 'Book title', author: 'Book author' } ReactDom.render( // Use the spread operator <Book {...singleBook}/>, document.getElementById('root') ); "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/React/useRef.html",
    "title": "useRef",
    "body": " Back useRef useRef returns a mutable ref object whose .current property is initialized to the passed argument. Some properties: Preserves the value of the object Does not trigger re-render Assigned to DOM nodes/elements import React, { useEffect, useRef } from 'react'; const UseRefBasics = () => { // Create the container const refContainer = useRef(null); const handleSubmit = (e) => { e.preventDefault(); // Print the value inside the input console.log(refContainer.current.value); }; useEffect(() => { // Focus on the input element whenever we render the application refContainer.current.focus(); }); return ( <> <form className='form' onSubmit={handleSubmit}> <div> {/*The refContainer points to the input element*/} <input type='text' ref={refContainer} /> </div> <button type='submit'>submit</button> </form> </> ); }; export default UseRefBasics; "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/React/useState.html",
    "title": "useState",
    "body": " Back useState Error In the next piece of code we show how, if we change the value of a variable in React, it does not change in our web app because it is not re-rendered: import React from 'react'; const ErrorExample = () => { let title = 'random title'; const handleClick = () => { title = 'hello people'; console.log(title); }; return ( <React.Fragment> <h2>{title}</h2> <button type='button' onClick={handleClick}> change title </button> </React.Fragment> ); }; export default ErrorExample; That is why we will need to use the hook useState, so we change handle state changes. import React, { useState } from 'react'; const UseStateBasics = () => { const [text, setText] = useState('random title'); const handleClick = () => { if (text === 'random title') { setText('hello world'); } else { setText('random title'); } }; return ( <React.Fragment> <h1>{text}</h1> <button type='button' onClick={handleClick}> change title </button> </React.Fragment> ); }; export default UseStateBasics; When we invoke useState we have to pass as an argument the initial value of the state variable. useState is a function that returns an array: The first element: the state variable The second element: the handler that controls the value of the state value When using useState with objects, whenever you update one property of the object, you have to pass the object to the handler (with the spread operator), and then override the property you want to update: import React, { useState } from 'react'; const UseStateObject = () => { // Object const [person, setPerson] = useState({ name: 'peter', age: 24, message: 'random message', }); const changeMessage = () => { // Pass the person object with the spread operator // and override the message property setPerson({ ...person, message: 'hello world' }); }; return ( <> <h3>{person.name}</h3> <h3>{person.age}</h3> <h4>{person.message}</h4> <button className='btn' onClick={changeMessage}> change message </button> </> ); }; export default UseStateObject; Asynchronous functions If we want to update a value asynchronally, and fetch the value of the state variable when the change happens, and not when the function is defined, then: import React, { useState } from 'react'; const UseStateCounter = () => { const [value, setValue] = useState(0); const reset = () => { setValue(0); }; const complexIncrease = () => { setTimeout(() => { // value is the value of the state variable when the timeout is defined // if you call it multiple times consecutively you get the same value, because they all get value = 0 // setValue(value + 1); // prevState is the value of the state variable when the timeout finished // if you call it multiple times consecutively you get different values, because value has already been updated // by another setTimeout. // if you call it multiple times setValue((prevState) => { return prevState + 1; }); }, 2000); }; return ( <> <section style={{ margin: '4rem 0' }}> <h2>more complex counter</h2> <h1>{value}</h1> <button className='btn' onClick={complexIncrease}> increase later </button> </section> </> ); }; export default UseStateCounter; "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/React/npm.html",
    "title": "npm",
    "body": " Back npm It is the Node Package Manager: Create package.json (manifest) file, with the list of dependencies $ npm init Install package locally and add it to package.json, under the keyword \"dependencies\" $ npm install <package name> Install package globally (requires sudo) $ npm install -g <package name> Install package only for development $ npm install <package name> --save-dev The packages installed with be saved under the file node_modules To install all the dependencies listed in package.json, just run: $ npm install Where the package.json is. "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/React/useEffect.html",
    "title": "useEffect",
    "body": " Back useEffect This hook is used for any work needed to be made outside of the component: fetch data, changing the document title, signing up for a subscription, setting up an event listener. Runs after every re-render Cleanup function Second parameter import React, { useState, useEffect } from 'react'; const UseEffectBasics = () => { // Callback called whenever the component is rendered useEffect(() => { document.title = `New Messages(${value})`; }); return ( <> <h1>{value}</h1> <button className='btn'}> click me </button> </> ); }; export default UseEffectBasics; Dependencies The useEffect definition allows you to pass an array of dependencies: If it is specified as []: useEffect will only be triggered in the first render If it is an array of state variables: it will be triggered every time the state variable is updated. import React, { useState, useEffect } from 'react'; const UseEffectBasics = () => { const [value, setValue] = useState(0); // Only trigger on first render // useEffect(() => { // document.title = `New Messages(${value})`; // }, []); // Call whenever value is updated useEffect(() => { document.title = `New Messages(${value})`; }, [value]); return ( <> <h1>{value}</h1> <button className='btn'}> click me </button> </> ); }; export default UseEffectBasics; Clean up Function useEffect lets us define a function that is invoked once we exit the function: import React, { useState, useEffect } from 'react'; const UseEffectCleanup = () => { const [size, setSize] = useState(window.innerWidth); const checkSize = () => { setSize(window.innerWidth); }; useEffect(() => { console.log('useEffect'); window.addEventListener('resize', checkSize); // Clean up function return () => { console.log('cleanup'); window.removeEventListener('resize', checkSize); }; }, []); console.log('render'); return ( <> <h1>window</h1> <h2>{size} PX</h2> </> ); }; export default UseEffectCleanup; Fetch Data Up next we will show how to get data using useEffect. Note, if we do not specify the restriction of only triggering on the first render: useEffect calls getUsers getUsers updates the state, and so the component re-renders Because there is a re-render, useEffect is called again Thus, we end in an infinite loop import React, { useState, useEffect } from 'react'; const url = 'https://api.github.com/users'; const UseEffectFetchData = () => { const [users, setUsers] = useState([]); const getUsers = async () => { const response = await fetch(url); const users = await response.json(); setUsers(users); }; useEffect(() => { getUsers(); // Specify [] so we only run useEffect on the first render. }, []); return ( <> <h3>github users</h3> <ul className='users'> {users.map((user) => { const { id, login, avatar_url, html_url } = user; return ( <li key={id}> <img src={avatar_url} alt={login} /> <div> <h4>{login}</h4> <a href={html_url}>profile</a> </div> </li> ); })} </ul> </> ); }; export default UseEffectFetchData; "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/React/Performance Optimization.html",
    "title": "Performance Optimization",
    "body": " Back Performance Optimization Even though React is fast by default (you do not need to use it), we can use different optimization techniques (mind, they do add their own cost): React.memo React.memo stores a component, and only re-renders if the props of the component change (it memoizes the component). In the next example, that means that we only re-render BigList if products change, thus, we do not re-render any SingleProduct component unless products change. import React, { useState, useCallback, useMemo } from 'react' // Custom hook import { useFetch } from 'useFetch' const url = 'https://course-api.com/javascript-store-products' const Index = () => { const { products } = useFetch(url) const [count, setCount] = useState(0) return ( <> <h1>Count : {count}</h1> <button className='btn' onClick={() => setCount(count + 1)}> click me </button> <BigList products={products} /> </> ) } // Each time a prop or the state changes, the component re-renders, so all // the elements of the list are processed again. // However if we use React.memo we only re-render the component if products change const BigList = React.memo(({ products }) => { return ( <section className='products'> {products.map((product) => { return ( <SingleProduct key={product.id} {...product} ></SingleProduct> ) })} </section> ) }) const SingleProduct = ({ fields }) => { let { name, price } = fields price = price / 100 const image = fields.image[0].url return ( <article className='product'> <img src={image} alt={name} /> <h4>{name}</h4> <p>${price}</p> </article> ) } export default Index useCallback What happens if we pass a function to BigList, well if the state changes (whichever variable of the state) then the function is created again, and so the function is different. Which means the props of BigList list changes, and causes React.memo to re-render the entire component. That is why we use useCallback. useCallback allows us to define when to create a function, by specifying the dependencies like we did with useEffect: If the dependency is []: then only create in the first render If there are variables in the []: create whenever those variables change If there is nothing: create always. Refer to Customs Hooks for an use case of useCallback inside the custom hook useFetch. import React, { useState, useCallback, useMemo } from 'react' // Custom hook import { useFetch } from 'useFetch' const url = 'https://course-api.com/javascript-store-products' const Index = () => { const { products } = useFetch(url); const [count, setCount] = useState(0); const [cart, setCart] = useState(0); // We only create this function when we update the cart value // That is we memoize the function const addToCart = useCallback(() => { setCart(cart + 1) }, [cart]) return ( <> <h1>Count : {count}</h1> <button className='btn' onClick={() => setCount(count + 1)}> click me </button> <BigList products={products} addToCart={addToCart}/> </> ) } // Each time a prop or the state changes, the component re-renders. Because now // addToCart is define with useCallback, the re-render is not triggered const BigList = React.memo(({ products, addToCart }) => { return ( <section className='products'> {products.map((product) => { return ( <SingleProduct key={product.id} {...product} addToCart={addToCart} ></SingleProduct> ) })} </section> ) }) const SingleProduct = ({ fields, addToCart }) => { let { name, price } = fields price = price / 100 const image = fields.image[0].url return ( <article className='product'> <img src={image} alt={name} /> <h4>{name}</h4> <p>${price}</p> <button onClick={addToCart}>add to cart</button> </article> ) } export default Index; useMemo Note that this hook deals with values (which is the traditional functionality of the idea of memoizing), whilst React.memo look for changes in the props. In the next example we create a function that returns a value, and we memoize the function, so it only computes the value whenever the products change (the argument of the function), else it returns the value stored before: import React, { useState, useCallback, useMemo } from 'react' // Custom hook import { useFetch } from 'useFetch' const url = 'https://course-api.com/javascript-store-products' // Define the function we are going to memoize const calculateMostExpensive = (data) => { return ( data.reduce((total, item) => { const price = item.fields.price if (price >= total) { total = price } return total }, 0) / 100 ) } const Index = () => { const { products } = useFetch(url); const [count, setCount] = useState(0); const [cart, setCart] = useState(0); const addToCart = useCallback(() => { setCart(cart + 1) }, [cart]) // Memoize the function with useMemo const mostExpensive = useMemo(() => calculateMostExpensive(products), [ products, ]) return ( <> <h1>Count : {count}</h1> <button className='btn' onClick={() => setCount(count + 1)}> click me </button> <!-- Show most expensive product --> <h1>Most Expensive : ${mostExpensive}</h1> <BigList products={products} addToCart={addToCart}/> </> ) } const BigList = React.memo(({ products, addToCart }) => { return ( <section className='products'> {products.map((product) => { return ( <SingleProduct key={product.id} {...product} addToCart={addToCart} ></SingleProduct> ) })} </section> ) }) const SingleProduct = ({ fields, addToCart }) => { let { name, price } = fields price = price / 100 const image = fields.image[0].url return ( <article className='product'> <img src={image} alt={name} /> <h4>{name}</h4> <p>${price}</p> <button onClick={addToCart}>add to cart</button> </article> ) } export default Index; "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/React/Context API.html",
    "title": "Context API",
    "body": " Back Context API Context API and useContext allows us to resolve the issue of the prop drilling. The context has two components: The provider: works as a distributer The consumer We use them as follows: import React, { useState, useContext } from 'react'; import { data } from '../../../data'; // Create context object const PersonContext = React.createContext(); const ContextAPI = () => { // State saved in the context const [people, setPeople] = useState(data); // Event handler saved in the context const removePerson = (id) => { setPeople((people) => { return people.filter((person) => person.id !== id); }); }; return ( {/*Wrap the components in the context provider, so all the nested components have access to the variables defined in the context object*/} <PersonContext.Provider value={{ removePerson, people }}> <h3>Context API / useContext</h3> <List /> </PersonContext.Provider> ); }; const List = () => { // Obtain data from the context with the useContext hook const mainData = useContext(PersonContext); return ( <> {mainData.people.map((person) => { return <SinglePerson key={person.id} {...person} />; })} </> ); }; const SinglePerson = ({ id, name }) => { // Obtain data from the context with the useContext hook const { removePerson } = useContext(PersonContext); return ( <div className='item'> <h4>{name}</h4> <button onClick={() => removePerson(id)}>remove</button> </div> ); }; export default ContextAPI; "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/React/Dispatch.html",
    "title": "Dispatch",
    "body": " Back Dispatch In order to dispatch actions in our reducers we do as follows: import React from \"react\"; // Get dispatch hook import { useDispatch } from \"react-redux\"; // Get actions import { login, logout } from \"../features/user\"; function Login() { // Initialize dispatch hook const dispatch = useDispatch(); return ( <div> <button onClick={() => { // Dispatch login action dispatch(login({ name: \"Pedro\", age: 20, email: \"pedro@gmail.com\" })); }} > Login </button> <button onClick={() => { // Dispatch logout action dispatch(logout()); }} > LOGOUT </button> </div> ); } export default Login; "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/React/Children in Props.html",
    "title": "Children in Props",
    "body": " Back Children in Props You can nest content inside your component. If we have the following: import React from 'react'; import ReactDom from 'react-dom'; // CSS import './index.css'; import Book from './Book' const singleBook = { title: 'Book title', author: 'Book author' } ReactDom.render( <Book {...singleBook}> <p> I am nested!</p> </Book>, document.getElementById('root') ); You can access the nested object from your component: import React from 'react' // De-structure the children prop const Book = ({ title, author, children }) => { return ( <article className='book'> <h1>{title}</h1> <h4>{author}</h4> {children} </article> ); }; export default Book "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/React/Conditional Rendering.html",
    "title": "Conditional Rendering",
    "body": " Back Conditional Rendering In the following example we show how we can have React display different elements conditionally: import React, { useState, useEffect } from 'react'; const url = 'https://api.github.com/users/QuincyLarson'; const MultipleReturns = () => { const [isLoading, setIsLoading] = useState(true); const [isError, setIsError] = useState(false); const [user, setUser] = useState('default user'); // Fetch data useEffect(() => { fetch(url) .then((resp) => { if (resp.status >= 200 && resp.status <= 299) { return resp.json(); } else { // Update the control state variables setIsLoading(false); setIsError(true); throw new Error(resp.statusText); } }) .then((user) => { const { login } = user; setUser(login); // Update the control state variables setIsLoading(false); }) .catch((error) => console.log(error)); }, []); // Different display depending on the state of the get if (isLoading) { return ( <div> <h1>Loading...</h1> </div> ); } if (isError) { return ( <div> <h1>Error....</h1> </div> ); } return ( <div> <h1>{user}</h1> </div> ); }; export default MultipleReturns; Short Circuit Evlauation Now, let's see an example of Short Circuit Evaluation in action: import React, { useState } from 'react'; const ShortCircuit = () => { const [text, setText] = useState(''); const [isError, setIsError] = useState(false); // If text is falsy, then return 'hello world' // else return text // const firstValue = text || 'hello world'; // If text is true, then return 'hello world' // else return text // const secondValue = text && 'hello world'; return ( <> {/*If text is false, return h1 with 'john doe value'*/} <h1>{text || 'john doe'}</h1> {/*If text is true, return h1 with 'john doe value'*/} {text && <h1>'john doe'</h1>} </> ); }; export default ShortCircuit; Ternary operators We can also use ternary operators to render conditionally in React. import React, { useState } from 'react'; const ShortCircuit = () => { const [isError, setIsError] = useState(false); return ( <> <button className='btn' onClick={() => setIsError(!isError)}> toggle error </button> {/*Check the value of isError, if is error is true, return the first value after the ? else return the second value*/} {isError ? ( <p>there is an error...</p> ) : ( <div> <h2>there is no error</h2> </div> )} </> ); }; export default ShortCircuit; "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/React/CSS in JSX.html",
    "title": "CSS in JSX",
    "body": " Back CSS in JSX We can define the style inside JSX, for that we use the prop style. The first curly braces takes us back to javascript, and the second are to specify the creation of an object. Also note that we do not write font-size but we use the React convention of writing fontSize const Author = () => ( <h4 style={{fontSize: '1px'}}> Test </h4> ); This level has higher preference (overrides) than the CSS imported from a CSS file. "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/React/Event Basics.html",
    "title": "Event Basics",
    "body": " Back Event Basics List of all possible events To define an event we have to specify: attribute: like onClick, onMouseHover, etc. eventHandler: the function to apply. This can be specified as a reference or as an in-line function. Next, we present an example: import React from 'react' const Book = ({ title, author }) => { const clickHandler = () => {alert('Hello!!')} return ( <article className='book'> <!-- Here we have the eventHandler as an in-line function --> <h1 onClick={() => alert('Hello!!')}>{title}</h1> <h4>{author}</h4> <!-- Here we have the eventHandler as a reference --> <button type=\"button\" onClick={clickHandler}>This is a button</button> </article> ); }; export default Book To pass an argument to the eventHandler we have to use a lambda function, else when we load the application will invoke the function clickHandler(author) import React from 'react' const Book = ({ title, author }) => { const clickHandler = (author) => {alert(author)} return ( <article className='book'> <h1 onClick={() => alert('Hello!!')}>{title}</h1> <h4>{author}</h4> <!-- Wrap function with an in-line function --> <button type=\"button\" onClick={() => clickHandler(author)}>This is a button</button> </article> ); }; export default Book We can also access the event object from within the function, like: import React from 'react' const Book = ({ title, author }) => { // You can always access the event object from an eventHandler const clickHandler = (author, e) => {console.log(e)} return ( <article className='book'> <h1 onClick={() => alert('Hello!!')}>{title}</h1> <h4>{author}</h4> <button type=\"button\" onClick={() => clickHandler(author)}>This is a button</button> </article> ); }; export default Book "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/React/create-react-app.html",
    "title": "create-react-app",
    "body": " Back create-react-app You do not need create-react-app to create a React app, but it makes it way easier: npx create-react-app <app-name> cd <app-name> npm start "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/React/Prop Drilling.html",
    "title": "Prop Drilling",
    "body": " Back Prop Drilling Prop Drilling refers to the scenario where we have to pass props to anidated components recursively. Next up, we show and example import React, { useState } from 'react'; // Data import { data } from '../../../data'; // Outer component const PropDrilling = () => { // State passed as a prop const [people, setPeople] = useState(data); // Event handler passed as a prop const removePerson = (id) => { setPeople((people) => { return people.filter((person) => person.id !== id); }); }; return ( <section> <h3>prop drilling</h3> {/* Pass props to the list elements */} <List people={people} removePerson={removePerson} /> </section> ); }; // Middle component const List = ({ people, removePerson }) => { return ( <> {people.map((person) => { {/* Pass props to the SinglePerson elements */} return ( <SinglePerson key={person.id} {...person} removePerson={removePerson} /> ); })} </> ); }; // Inner component const SinglePerson = ({ id, name, removePerson }) => { return ( <div className='item'> <h4>{name}</h4> <button onClick={() => removePerson(id)}>remove</button> </div> ); }; export default PropDrilling; In these cases we can use the Context API "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/React/List of components.html",
    "title": "List of Components",
    "body": " Back List of Components React has one restriction for list of objects, and that is: they have to have a key. So, for example: import React from 'react'; import ReactDom from 'react-dom'; // CSS import './index.css'; import Book from './Book' // Data to create book object const books = [ { id: '1', title: 'Book title', author: 'Book author' }, { id: '2', title: 'Book title', author: 'Book author' }, ] const bookList = books.map((book) => { // De-structure book object return <Book key={book.id} {...book} />; }) ReactDom.render( <div> bookList </div>, document.getElementById('root') ); "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/React/Properties Hooks.html",
    "title": "Properties of Hooks",
    "body": " Back Properties of Hooks All the hooks have the following properties: They start with the word use The component where they are created must be named in uppercase They cannot be invoked inside a function/component body. You cannot call hooks conditionally "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/React/React Router.html",
    "title": "React Router",
    "body": " Back React Router In React routing behaves differently than in traditional HTML applications: It does not fetch the HTML page from the server, it is done in the client side. There is no re-rendering even though we change the url. Here we have an example: import React from 'react'; // react router import { BrowserRouter as Router, Route, Switch } from 'react-router-dom'; // pages import Home from './Home'; import About from './About'; import People from './People'; import Error from './Error'; import Person from './Person'; // Navbar import Navbar from './Navbar'; const ReactRouterSetup = () => { return ( <Router> <Navbar /> <!-- With the switch component only the first one that matches is displayed --> <Switch> <!-- Match the path exactly, else this will be rendered always along the other components --> <Route exact path='/'> <!-- Component to display --> <Home /> </Route> <!-- Match the path --> <Route path='/about'> <About /> </Route> <!-- Match the path --> <Route path='/people'> <People /> </Route> <!-- Match the path and pass id as a parameter --> <!-- Specify children property because it will be a list of components --> <Route path='/person/:id' children={<Person />}></Route> <!-- Match any path (this is only displayed when the other paths do not match if we use the switch component)--> <Route path='*'> <Error /> </Route> </Switch> </Router> ); }; export default ReactRouterSetup; Links How do we navigate through our application, well by using Links. So, for example, in the Navbar: import React from 'react'; import { Link } from 'react-router-dom'; const Navbar = () => { return ( <nav> <ul> <li> <!-- Specify the path --> <Link to='/'>Home</Link> </li> <li> <!-- Specify the path --> <Link to='/about'>About</Link> </li> <li> <!-- Specify the path --> <Link to='/people'>People</Link> </li> </ul> </nav> ); }; export default Navbar; To pass a parameter to the link we can do the following: import React, { useState } from 'react'; import { data } from '../../../data'; import { Link } from 'react-router-dom'; const People = () => { // List of people const [people, setPeople] = useState(data); return ( <div> <h1>People Page</h1> {people.map((person) => { return ( <div key={person.id} className='item'> <h4>{person.name}</h4> <!-- Specify the path and pass the id of the current person as a parameter --> <Link to={`/person/${person.id}`}>Learn More</Link> </div> ); })} </div> ); }; export default People; Now in the Person component, we can fetch the parameter: import React, { useState, useEffect } from 'react'; import { data } from '../../../data'; import { Link, useParams } from 'react-router-dom'; const Person = () => { // State const [name, setName] = useState('default name'); // useParams hook to fetch the parameter // the name of the parameter (id), is specified in the \"Route\" component // in our case the path to person was: /person/:id const { id } = useParams(); useEffect(() => { const newPerson = data.find((person) => person.id === parseInt(id)); setName(newPerson.name); }, []); return ( <div> <h1>{name}</h1> <!-- Go to the previous page of the list of people --> <Link to='/people' className='btn'> Back To People </Link> </div> ); }; export default Person; "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/React/Index.html",
    "title": "Index file",
    "body": " Back Index file In the following piece of code we create our store object, where we are going to save the state of our application. As you may note, in this store there are three slices defined. That is because we differentiate three different states (slices). So our store is defined as: { user: {...} theme: {...} } import { configureStore } from \"@reduxjs/toolkit\"; // Different slices import userSlice from \"./features/userSlice.js\"; import themeSlice from \"./features/themeSlice.js\"; // Create store const store = configureStore({ reducer: { // In each case obtain the reducer user: userSlice.reducer, theme: themeSlice.reducer, }, }); export default store; Now, we have to wrap our application with our store: import React from \"react\"; import ReactDOM from \"react-dom\"; import App from \"./App\"; // Import our store as a provider import { Provider } from \"react-redux\"; import store from \"./store\"; ReactDOM.render( <React.StrictMode> <Provider store={store}> <App /> </Provider> </React.StrictMode>, document.getElementById(\"root\") ); "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/React/index.html",
    "title": "React",
    "body": " Back React Basic React npm create-react-app Babel File Structure Start in indexjs JSX Rules CSS in JSX Props Children in Props List of components Event Basics Advanced React Properties Hooks useState useEffect Conditional Rendering Controlled Inputs useRef useReducer Prop Drilling Context API Custom Hooks PropTypes React Router Performance Optimization Redux Basics Index Reducers and Actions Get State Dispatch "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/React/JSX Rules.html",
    "title": "JSX Rules",
    "body": " Back JSX Rules Always return something Always return a single element or div, section, article or React.Fragment (does not create a div) enclosing the element Use camelCase for HTML attribute Use className instead of class Close every element "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/React/useReducer.html",
    "title": "useReducer",
    "body": " Back useReducer An alternative to useState. Accepts a reducer of type (state, action) => newState, and returns the current state paired with a dispatch method. useReducer is usually preferable to useState when you have complex state logic that involves multiple sub-values or when the next state depends on the previous one. useReducer also lets you optimize performance for components that trigger deep updates because you can pass dispatch down instead of callbacks. For example: import React, { useState, useReducer } from 'react'; // Components import Modal from './Modal'; // Data import { data } from '../../../data'; // Reducer dispatch function import { reducer } from './reducer'; // Initial state for the reducer const defaultState = { people: [], isModalOpen: false, modalContent: '', }; const Index = () => { // Define state variables const [name, setName] = useState(''); // Define reducer: (dispatch fuction, initial state) const [state, dispatch] = useReducer(reducer, defaultState); const handleSubmit = (e) => { // Avoid the re-rendering caused by the submit event e.preventDefault(); if (name) { const newItem = { id: new Date().getTime().toString(), name }; // Call reducer to update state dispatch({ type: 'ADD_ITEM', payload: newItem }); setName(''); } else { // Call reducer to update state dispatch({ type: 'NO_VALUE' }); } }; const closeModal = () => { // Call reducer to update state dispatch({ type: 'CLOSE_MODAL' }); }; return ( <> {/*Render Modal component conditionally */} {state.isModalOpen && ( <Modal closeModal={closeModal} modalContent={state.modalContent} /> )} {/* Form to add a new person to the reducer state variable */} <form onSubmit={handleSubmit} className='form'> <div> <input type='text' value={name} onChange={(e) => setName(e.target.value)} /> </div> <button type='submit'>add </button> </form> {/* Show the people stored in the reducer state variable */} {state.people.map((person) => { return ( <div key={person.id} className='item'> <h4>{person.name}</h4> <button onClick={() => // Call reducer to update state dispatch({ type: 'REMOVE_ITEM', payload: person.id }) } > remove </button> </div> ); })} </> ); }; export default Index; Now, let's see the reducer function: /* Reducer function */ export const reducer = (state, action) => { // Define logic for each type of action if (action.type === 'ADD_ITEM') { // Add new person (action.payload) to existing people array (state.people) const newPeople = [...state.people, action.payload]; return { // Always copy the value from the previous state ...state, // Update the people array people: newPeople, isModalOpen: true, modalContent: 'item added', }; } if (action.type === 'NO_VALUE') { // Always copy the value from the previous state return { ...state, isModalOpen: true, modalContent: 'please enter value' }; } if (action.type === 'CLOSE_MODAL') { return { ...state, isModalOpen: false }; } if (action.type === 'REMOVE_ITEM') { // Filter people array, by removing the person const newPeople = state.people.filter( (person) => person.id !== action.payload ); // Copy the previous state (...state) and update the people the array (newPeople) return { ...state, people: newPeople }; } throw new Error('no matching action type'); }; "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/React/Controlled Inputs.html",
    "title": "Controlled Inputs",
    "body": " Back Controlled Inputs Let's see how to handle inputs in a form using React: import React, { useState } from 'react'; const ControlledInputs = () => { const [firstName, setFirstName] = useState(''); const [people, setPeople] = useState([]); const handleSubmit = (e) => { // Avoid the default behaviour in submit which re-renders the page e.preventDefault(); // Our own logic for the submit action if (firstName) { // Create new person object const person = { id: new Date().getTime().toString(), firstName }; // Update our state (remember you need to spred the people state variable we have before, else the you would // override the people state variable and it would be assigned to only the person object) setPeople((people) => { return [...people, person]; }); // Set to empty, so the value of the input is the empty string setFirstName(''); } else { // No values to create new person console.log('empty values'); } }; return ( <> <article> {/*Event handler for the submit event*/} <form onSubmit={handleSubmit}> <div > <label htmlFor='firstName'>Name : </label> <input type='text' id='firstName' name='firstName' {/*Set the value of the input, it updates every time we change the input*/} value={firstName} {/*Event handler for the change event: use a lambda function to pass the event e and get the value in the input*/} onChange={(e) => setFirstName(e.target.value)} /> </div> <button type='submit'>add person</button> </form> {/*Show each person in the people array */} {people.map((person, index) => { const { id, firstName } = person; return ( <div className='item' key={id}> <h4>{firstName}</h4> </div> ); })} </article> </> ); }; export default ControlledInputs; Multiple inputs How can we define an event handler for the OnChange event that is generic, instead of defining one for each input? To showcase this scenario, we will use the same code as before, but with two new inputs. All of the inputs have the same OnChange event handler. import React, { useState } from 'react'; const ControlledInputs = () => { // Create a new state variable person, that holds the properties of the person we are currently creating const [person, setPerson] = useState({ firstName: '', email: '', age: '' }); // Array of people we have already created const [people, setPeople] = useState([]); // Generic event handler const handleChange = (e) => { // Obtain the name of the input/state variable const name = e.target.name; // Obtain the new value for the input const value = e.target.value; // Update the value of the property for the current person setPerson({ ...person, [name]: value }); }; const handleSubmit = (e) => { e.preventDefault(); if (person.firstName && person.email && person.age) { const newPerson = { ...person, id: new Date().getTime().toString() }; setPeople([...people, newPerson]); setPerson({ firstName: '', email: '', age: '' }); } }; return ( <> <article className='form'> <form> <div className='form-control'> <label htmlFor='firstName'>Name : </label> <input type='text' id='firstName' name='firstName' // Access the firstName of the person object value={person.firstName} // Generic event handler onChange={handleChange} /> </div> <div className='form-control'> <label htmlFor='email'>Email : </label> <input type='email' id='email' name='email' // Access the email of the person object value={person.email} // Generic event handler onChange={handleChange} /> </div> <div className='form-control'> <label htmlFor='age'>Age : </label> <input type='number' id='age' name='age' // Access the age of the person object value={person.age} // Generic event handler onChange={handleChange} /> </div> <button type='submit' className='btn' onClick={handleSubmit}> add person </button> </form> </article> <article> {people.map((person) => { const { id, firstName, email, age } = person; return ( <div key={id} className='item'> <h4>{firstName}</h4> <p>{email}</p> <p>{age}</p> </div> ); })} </article> </> ); }; export default ControlledInputs; "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/React/Babel.html",
    "title": "Babel",
    "body": " Back Babel Babel is a Javascript compiler that converts ES7, ES6 to E5 so it can run smoothly in older browsers. This way we can use new features of ES7 and ES6 while maintaining compatibility. "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/React/Get State.html",
    "title": "Get State",
    "body": " Back Get State In order to access the state saved in our state, we do the following: import React from \"react\"; import { useSelector } from \"react-redux\"; function Profile() { // Use the useSelector hook const user = useSelector((state) => state.user.value); return ( <div style={{ color: themeColor }}> <h1> Profile Page</h1> <!--Obtain the user state--> <p> Name: {user.name} </p> <p> Age: {user.age}</p> <p> Email: {user.email}</p> </div> ); } export default Profile; "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/React/Basics.html",
    "title": "Basics",
    "body": " Back Basics Redux is a complex state management tool, with a single store (javascrip object) as a CDS (Central Data Storage). Components Store: object that holds the state Reducers: events handler that manages the state and returns the new updated state. The reducers get the arguments and return the state modified. Actions: describe the event handler by the reducer and has two properties: Type: is the identifier of the action Payload: holds the data Dispatch: is used to send actions to update the data So Redux is composed by: Handle an action The process of handling an action is the following: We create an action object and dispatch it: The store forwards the action to the reducer: The reducer updates the state and returns it The store notifies the UI components of the change of the state Install Redux $ npm install redux react-redux First steps Inside src create a store folder Inside the store folder create an index.js that holds all of the React states in this file "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/React/Custom Hooks.html",
    "title": "Custom Hooks",
    "body": " Back Custom Hooks Customs hooks allow us to avoid duplicating code that uses hooks and essentially in different places of your code. For example, the fetching function is very common, so we create a useFetch hook. When you define a custom hook, that is, if you define a function outside a component that uses hooks, you will have to name it use<FunctionName>, else you will get an error. import React, { useState, useEffect } from 'react' // Import custom hook import { useFetch } from './2-useFetch' const url = 'https://course-api.com/javascript-store-products' const Example = () => { // Values returned by useFetch const { loading, products } = useFetch(url) return ( <div> <h2>{loading ? 'loading...' : 'data'}</h2> </div> ) } export default Example import { useState, useEffect, useCallback } from 'react'; export const useFetch = (url) => { // State within the hook const [loading, setLoading] = useState(true); const [products, setProducts] = useState([]); // Functionality of the hook const getProducts = useCallback(async () => { const response = await fetch(url); const products = await response.json(); setProducts(products); setLoading(false); }, [url]); // Run whenever the url or the getProducts function changes useEffect(() => { getProducts(); }, [url, getProducts]); // Values returned by the custom hook return { loading, products }; }; Note we are using the hook useCallback (refer to Performance Optimization), we do this because we are specifying getProducts as a dependency for useEffect. However getProducts is created every time the state changes. So when we call useEffect, we change the state, and therefore create the function getProducts, which triggers useEffect, thus the state changes, and we create getProducts, and so on and so forth. To avoid this, we use useCallback, which will create the function whenever any of the dependencies in the list change. So this means, now getProducts is only created when the url changes. This allows us to avoid the infinite loop we ran into before. "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/MongoDB/index.html",
    "title": "MongoDB",
    "body": " Back MongoDB MongoDB Commands "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/MongoDB/commands.html",
    "title": "MongoDB Commands",
    "body": " Back MongoDB Commands To log into MongoDB with the created user and database: $ mongo -u <your username> -p <your password> \\\\ --authenticationDatabase <your database name> Or $ mongo -u <your username> \\\\ --authenticationDatabase <your database name> To connect to the database use the following URI: mongodb://YourUsername:YourPasswordHere@127.0.0.1:27017/your-database-name "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/NodeJS/route_params.html",
    "title": "Route Params",
    "body": " Back Route Params If, for example, we have a list of products, and we want to get a certain product by its id, we use route params. They can have any name, and are specified by :param. This is then stored in the request object. app.get('/api/products/:productID', (req, res) => { \t // De-structure param const { productID } = req.params // Filter products by id const singleProduct = products.find( (product) => product.id === Number(productID) ) \t // If it does not exist if (!singleProduct) { return res.status(404).send('Product Does Not Exist') } return res.json(singleProduct) }) Note that the route params are always strings, in our case we had to convert it to a Number. We can also have more that one route parameter like so: app.get('/api/products/:productID/reviews/:reviewID', (req, res) => { res.send('hello world') }) Where we define productID and reviewID as route parameters, and can, therefore, filter by them. "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/NodeJS/jwt.html",
    "title": "JSON Web Tokens",
    "body": " Back JSON Web Tokens Installation $ npm install jsonwebtoken Example of Usage We first create our Express application and so, we import express and jsonwebtoken. And then we start the server. const express = require(\"express\"); const jwt = require(\"jsonwebtoken\"); const app = express(); app.listen(3000, () => { console.log(\"nodejs app running...\"); }); Now, we define two new endpoints: /api and /api/login. app.get(\"/api\", (req , res) => { res.json({ mensaje: \"Nodejs and JWT\" }); }); app.post(\"/api/login\", (req , res) => { const user = { id: 1, nombre : \"Henry\", email: \"henry@email.com\" } jwt.sign({user}, 'secretkey', {expiresIn: '32s'}, (err, token) => { res.json({ token }); }); }); Where we use the sign method to create a new token. So, if we want to define an endpoint that requires authentication we do: // Middleware function verifyToken(req, res, next){ const bearerHeader = req.headers['authorization']; if(typeof bearerHeader !== 'undefined'){ const bearerToken = bearerHeader.split(\" \")[1]; req.token = bearerToken; next(); }else{ res.sendStatus(403); } } app.post(\"/api/posts\", verifyToken, (req , res) => { jwt.verify(req.token, 'secretkey', (error, authData) => { if(error){ res.sendStatus(403); }else{ res.json({ mensaje: \"Post fue creado\", authData }); } }); }); Where verifyToken is a middleware function that gets the token from the header, and then we use the verify method to check if the token is valid. "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/NodeJS/routes.html",
    "title": "Routes",
    "body": " Back Routes Set Up In order to set up the routes for our project, we first create a folder called routes that will contain all the javascript files that control routing functionality. In this example we create two files within routes, people.js and auth.js. Once we have created them, we include them as middleware to the specific endpoints (/api/people for people.js and /login for auth.js), as follows: const express = require('express') const app = express() const people = require('./routes/people') const auth = require('./routes/auth') app.use('/api/people', people) app.use('/login', auth) app.listen(5000, () => { console.log('Server is listening on port 5000....') }) Router Let's focus now on people.js than controls the routing of /api/people. For that we import the controller of this endpoint and we specify the functions to execute for the different HTTP methods and for the different routes. /: This is the default endpoint /api/people there we specify that the logic for a get request is contained in the getPeople function. /:d: This endpoint allows for specifying an id as a parameter. const express = require('express') const router = express.Router() const { getPeople, createPerson, createPersonPostman, updatePerson, deletePerson, } = require('../controllers/people') router.route('/').get(getPeople).post(createPerson) router.route('/:id').put(updatePerson).delete(deletePerson) module.exports = router Controller The people controller contains: let { people } = require('../data') const getPeople = (req, res) => { res.status(200).json({ success: true, data: people }) } const createPerson = (req, res) => { const { name } = req.body if (!name) { return res .status(400) .json({ success: false, msg: 'please provide name value' }) } res.status(201).send({ success: true, person: name }) } const createPersonPostman = (req, res) => { const { name } = req.body if (!name) { return res .status(400) .json({ success: false, msg: 'please provide name value' }) } res.status(201).send({ success: true, data: [...people, name] }) } const updatePerson = (req, res) => { const { id } = req.params const { name } = req.body const person = people.find((person) => person.id === Number(id)) if (!person) { return res .status(404) .json({ success: false, msg: `no person with id ${id}` }) } const newPeople = people.map((person) => { if (person.id === Number(id)) { person.name = name } return person }) res.status(200).json({ success: true, data: newPeople }) } const deletePerson = (req, res) => { const person = people.find((person) => person.id === Number(req.params.id)) if (!person) { return res .status(404) .json({ success: false, msg: `no person with id ${req.params.id}` }) } const newPeople = people.filter( (person) => person.id !== Number(req.params.id) ) return res.status(200).json({ success: true, data: newPeople }) } module.exports = { getPeople, createPerson, createPersonPostman, updatePerson, deletePerson, } "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/NodeJS/mock_mongo.html",
    "title": "Mocking MongoDB",
    "body": " Back Mocking MongoDB We will now use the node library MongoMemoryServer in order to mock our MongoDB database using Node.js inside a Docker container. MongoMemoryServer As we have mentioned we need MongoMemoryServer, so we install it as a development depencendy. For that we head to our node app's root folder and we execute: $ npm install mongodb-memory-server-core --save-dev Docker So, now we create our Dockerfile, which holds our app source code, and where we install mongodb: FROM alpine:latest MAINTAINER albamr09 # Install dependencies RUN apk add --no-cache nodejs npm # Install mongodb RUN echo 'http://dl-cdn.alpinelinux.org/alpine/v3.6/main' >> /etc/apk/repositories RUN echo 'http://dl-cdn.alpinelinux.org/alpine/v3.6/community' >> /etc/apk/repositories RUN apk update RUN apk add mongodb RUN apk add mongodb-tools RUN mkdir -p /data/db/ RUN chmod -R 777 /data/db # Add common user RUN adduser -D user #RUN useradd --create-home --shell /bin/bash user # Create app directory WORKDIR /home/user/src/ # Change permissions RUN chown -R user:user /home/user/src/ RUN chmod -R 755 /home/user/src/ USER user # Copy with user as owner COPY --chown=user:user ./package*.json ./ # Install app dependencies RUN npm install # Copy and override src folder COPY . . Note that this version of MongoDB is 3.4.4, mainly because we are using the alpine image. This version may not coincide with our MongoDB Docker image, and is not desirable. So make sure (or force) that you are installing the save versions. MongoMemoryServer Configuration Also, we only need to install it for those images that are not supported by MongoDB. Furthermore, if instead of the package mongo-memory-server-core we install mongo-memory-server, the latter will include a post-install hook that will install MongoDB if it is not already installed on the system. In case of manually installing MongoDB we have to let know MongoMemoryServer where the binary lays. So, within our package.json file we add: \"config\": { \"mongodbMemoryServer\": { \"systemBinary\": \"/usr/bin/mongod\", \"version\": \"3.4.4\" } Example of Usage We, now, exemplify how to mock our database in our tests: const { MongoMemoryServer } = require('mongodb-memory-server-core'); const mongoose = require('mongoose'); const UserModel = require('../../models/user'); const userData = { 'name': 'test', 'email': 'test@test.com', 'password': 'test1234', 'username': 'testname' }; describe('User Model Tests', ()=> { let mongoServer; beforeAll(async () => { mongoServer = await MongoMemoryServer.create(); await mongoose.connect(mongoServer.getUri(), { useNewUrlParser: true, useUnifiedTopology: true, }).catch(error => console.log(error)); }); afterAll(async () => { await mongoServer.stop(); await mongoose.connection.close(); }); afterEach(() => { mongoose.connection.collections['users'].drop( function() {}); }); it('Create a new user', async ()=> { const user = new UserModel(userData); const savedUser = await user.save(); expect(savedUser._id).toBeDefined(); expect(savedUser.name).toBe(userData.name); expect(savedUser.email).toBe(userData.email); expect(savedUser.password).toBe(userData.password); expect(savedUser.username).toBe(userData.username); }) it('Create a user with invalid fields', async ()=> { var invalidUserData = {...userData}; delete invalidUserData.email; const user = new UserModel(invalidUserData); let error; try{ const savedUser = await user.save(); error = savedUser; }catch(err){ error = err; } expect(error).toBeInstanceOf(mongoose.Error.ValidationError); expect(error.errors.email).toBeDefined(); }) it('Create user that already exists', async ()=>{ await new UserModel(userData).save(); let error; try{ const repeatedUser = new UserModel(userData); await repeatedUser.save(); }catch(err){ error = err; } expect(error).toBeDefined(); expect(error.code).toBe(11000); }) it('Create user with undefined fields', async ()=>{ var newUserData = {...userData}; delete newUserData.name; const user = new UserModel(newUserData); await user.save(); expect(user._id).toBeDefined(); expect(user.name).toBeUndefined(); }) } "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/NodeJS/http.html",
    "title": "HTTP",
    "body": " Back HTTP HTTP Messages Request Message: what the user sends Response Message: what the server sends The messages have the following parts: Info about the request: Request URL, Request Method (GET is the default method), Status Code, etc. Headers: meta information about the request/response, (e.g. \"Content type: application/json\" tells the browser that the body is json) Body: which is the request payload, or the content of the response. "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/NodeJS/globals.html",
    "title": "Globals",
    "body": " Back Globals Some global variables available __dirname: path of current directory __filename require: function to use modules module: info about current module process: info about the environment where the program is bein executed Note that in Node there is no window object like in Javascript. "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/NodeJS/npm.html",
    "title": "NPM",
    "body": " Back NPM The Node Package Manager allows us to: Reuse our own code in other projects Use code written by other developers and Share our own solutions. This tool is installed along node. Npm calls the reusable code a package (also modules or dependencies), that is basically a folder that contains some js code. Note that there is no quality control applied to the packages that are published, so it is the developer's responsibility to check whether the package is secure or not. Installing packages You can install a package locally within your project as a local dependency: $ nmp i <packageName> Or you can install the package globally, so it can be accessed from any project: $ npm install -g <packageName> If you want to specify a version for the package: $ npm install <packageName>@1.0.0 Package.json This file stores important information about the project and the packages, it can be conceived as a manifest file. There are two ways to create it: Manually: create package.json in the root folder of the project and define the properties of the project/packages. Using npm following the guide (add -y to skip the questions of the guide): \t \t $ npm init \t When the project is initialized, the package.json file is as follows: { \"name\": \"08_project\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\" }, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\" } Where all those properties are set up during the guide of npm init or set as default with the flag -y. After installing a dependency $ npm i lodash The following property is added: \"dependencies\": { \"lodash\": \"^4.17.21\" } And npm creates the folder node_modules, if it does not already exist, which stores the dependencies code. Also, in case of wanting to install dependencies needed only during the development process: $ npm i <package> -D $ npm i <package> --save-dev And so, the property devDependencies is created in pakage.json. Scripts The object scripts, which is a property of package.json, can contain the definition of different actions, for example: \"scripts\": { \"start\": \"node app.js\" } So when running npm start our app.js will be executed. For some commands you will need to specify run and the command name as follows: $ npm run dev Nodemon This is a package that lets you hot reload your project without having to execute your app constantly. For that, after installing nodemon as a local or global dependency, we specify on package.json: \"scripts\": { \"dev\": \"nodemon app.js\" } If we want to run it: $ npm run dev Package-lock.json This file stores the dependencies version of the packages installed as dependencies, as to avoid installing newer version that can be the cause of bugs. Because within the package.json only our project's dependencies' versions are specified. Uninstalling packages In order to uninstall the package we have a command, that follows the syntax: $ npm uninstall <package> We can also remove it from the dependencies object within package.json. So when you remove package-lock.json and the node_modules folder if you run $ npm install The package that was removed will not be installed. Git When using git or other version control tool, it is desirable to create a .gitignore and to specify to avoid the node_modules folder, since its size can get big very easily. So, by just pushing the source code, including package.json, if we want to install all of the project's dependencies' again, on the root folder we run: $ npm install "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/NodeJS/http_basics.html",
    "title": "HTTP Basics",
    "body": " Back HTTP Basics When answering to a request, node requires a method to signal to the server that all of the response headers and body have been sent, and so the server can consider the message complete. That method is res.end() const http = require('http') const server = http.createServer((req, res) => { res.end('Home page') }) server.listen(5000) We create a server with http.createServer. This method takes a callback as an argument, which is called every time a user hits the server. Next we specify the port on which the server will be listening for requests. The value of this port is somewhat irrelevant in the development environment. Headers If we want to provide the metadata about the response we have to provide headers: const http = require('http') const server = http.createServer((req, res) => { res.writeHead(200, { 'content-type': 'text/html' }) res.write('<h1>home page</h1>') res.end() }) server.listen(5000) With writeHead we specify the headers, in our case we specify the status code (200: OK) and the content type of the response (text/html). The later are called MIME-types or media types. Then we specify the body of the response with write and finally we finalize the message with end. Request Object The request object that is an argument of the createServer method has several attributes: req.method: Allows you to obtain the method of the user's request, i.e. GET, POST, PUT, etc. req.url: Contains the url of the user's request. HTML File As we have seen the method write allows us to define the content of the body as HTML. However we do not need to write the HTML code inside the method we can also pass a file as input and the method will serve it's content to the response. const http = require('http') const { readFileSync } = require('fs') const homePage = readFileSync('./index.html') const server = http.createServer((req, res) => { res.writeHead(200, { 'content-type': 'text/html' }) res.write(homePage) res.end() }) server.listen(5000) Observe that we user readFileSync, we do so because, for one this is an example, and also the file is only read once when the server is created, not every time the user hits the server. External resources When adding external resources to a given HTML file we also need to handle the request to those resources in our server. const http = require('http') const { readFileSync } = require('fs') const homePage = readFileSync('./index.html') const homeStyles = readFileSync('./styles.css') const homeImage = readFileSync('./logo.svg') const server = http.createServer((req, res) => { // home page if (url === '/') { res.writeHead(200, { 'content-type': 'text/html' }) res.write(homePage) res.end() } \t// styles else if (url === '/styles.css') { res.writeHead(200, { 'content-type': 'text/css' }) res.write(homeStyles) res.end() } \t// image/logo else if (url === '/logo.svg') { res.writeHead(200, { 'content-type': 'image/svg+xml' }) res.write(homeImage) res.end() } }) Note that the content types differ every time, with css we use text/css, with images we use image/svg+xml. "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/NodeJS/events_info.html",
    "title": "Events",
    "body": " Back Events In Node.js it the event-driven approach to programming is very commonly used. Meaning the flow of our program is in part controlled by events. Event Emitter All objects which emit events are instances of EventEmitter, which is accessible from the events module: const EventEmitter = require('events') const customEmitter = new EventEmitter() customEmitter.on('response', () => { console.log('some other logic here') }) customEmitter.emit('response') Here we can see that we create an EventEmitter object and we listen for the response event with customEmitter.on(). The latter function takes the name of the event as its first argument and the callback as its second. In order to emit a concrete event we use customEmitter.emit(), which takes the event name as its argument. More Listeners We can have more than one listener: const EventEmitter = require('events') const customEmitter = new EventEmitter() customEmitter.on('response', (name, id) => { console.log(`data recieved user ${name} with id:${id}`) }) customEmitter.on('response', () => { console.log('some other logic here') }) customEmitter.emit('response', 'john', 34) Where the second listener define a callback that takes name and id as arguments. So when emitting the event we can pass those arguments to the emit function. Take into account that the functions' order matter, if you emit and event before you listen for it, the event will never be registered. HTTP Events Because http.Server extends net.Server which then extends EventEmitter, we can use the methods discussed above. So we can listen for the event request to handle requests from the browser. const http = require('http') // Using Event Emitter API const server = http.createServer() // emits request event // subcribe to it / listen for it / respond to it server.on('request', (req, res) => { res.end('Welcome') }) server.listen(5000) "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/NodeJS/modules.html",
    "title": "Modules",
    "body": " Back Modules Encapsulated code, as to only share what we want. Node uses CommonJS so every file is treated as a module by default. In any .js file we have the global object module: console.log(module) Module { id: '.', path: '/home/alba/Desktop/NodeJs', exports: {}, filename: '/home/alba/Desktop/NodeJs/02_constants.js', loaded: false, children: [], paths: [ '/home/alba/Desktop/NodeJs/node_modules', '/home/alba/Desktop/node_modules', '/home/alba/node_modules', '/home/node_modules', '/node_modules' ] } Exporting So we can treat the attribute exports as an object and pass it whatever values we would like to show to other app that import our module: module.exports = { value1: 'value1', value2: 'value2' } Where value1 is the key of the attribute and 'value1' is its value, e.g.: const name = 'John' const surname = 'Tuckey' module.exports = { Name: name, Surname: surname } Also, if we only export one object it is sufficient to type: const name = 'John' module.exports = name Another way to export is to define explicitly the name of the attributes to export: module.exports.items = ['item1', 'item2'] const person = { name: 'bob' } module.exports.singlePerson = person Importing Now, a module can be imported with the keyword require as follows: const externalModule = require('./module') console.log(externalModule) { Name: 'John', Surname: 'Tukey' } Another type of syntax could be unrolling the attributes of the export object: const { Name, Surname } = require('./module') Built-in Modules Some built-in modules are: OS PATH FS (Filesystem) HTTP Even though there are several more built-in modules. OS To import the OS built-in module we do: const os = require('os') And we call it by: console.log(`The system uptime is ${os.uptime()} seconds`) FS We can also interact with the file system via the FS module. There are two ways to do so: Asynchronously, which is non-blocking Synchronously, that is blocking Synchronous To exemply both setups, we first de-structure the read and write synchronous methods from the FS module, and then we read and write files. const { readFileSync, writeFileSync } = require('fs') // Read file with a given path and the corresponding encoding const first = readFileSync('./file.txt', 'utf8') const second = readFileSync('./file2.txt', 'utf8') // Write to a file given a path, the content is overwritten writeFileSync('./writeFile', 'This content will be written') // Write to a file given a path, the content is appended writeFileSync('./writeFile', 'This content will be written', {flag: 'a'}) Asynchronous Now, in order to access the file system asynchronously, we need a callback, and so we do: const { readFileSync, writeFileSync } = require('fs') readFile('./file', 'utf8', (error, result) => { if(error){ console.log(error) return } else{ console.log(result) const first = result // Here we can add another read call } }) writeFile('./file', 'This is the content', (error, result) => { if(error){ console.log(error) return }else{ console.log(result) } }) Where we specify a callback function with the ES6 syntax. Its first parameter is the error parameter and the second is the result of the operation. The problem with synchronous calls is that they can be very time consuming and they halt the execution, which can be critical when working on time sensitive tasks or when several user call upon these type of functions at a time. HTTP To show the bare basics, we will set up a server: const http = require('http') const server = http.createServer((request, response) => { response.write('This is the index!') response.end() }) // Define the port server.listen(5000) That can be accessed on localhost:5000. Next, we can code something a little more complex, where the content handed as a response depends on the request: const http = require('http') const server = http.createServer((request, response) => { if(request.url === '/'){ response.end('This is the index') }else if(request.url === '/about'){ response.end('This is the about') }else{ response.end('404') } }) // Define the port server.listen(5000) "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/NodeJS/async_patterns.html",
    "title": "Asynchronous Patterns",
    "body": " Back Asynchronous Patterns Blocking Code Imagine we have the following piece of code: const http = require('http') const server = http.createServer((req, res) => { if (req.url === '/') { res.end('Home Page') } if (req.url === '/about') { // blocking code for (let i = 0; i < 1000; i++) { for (let j = 0; j < 1000; j++) { console.log(`${i} ${j}`) } } res.end('About Page') } res.end('Error Page') }) server.listen(5000, () => { console.log('Server listening on port : 5000....') }) Because inside the second conditional we have a nested for loop which is computationally expensive, when a user accesses the about page, the server is blocked, and so it prevents other users from loading any other page. That is essentially because JavaScript is single threaded, so by running the nested conditional, the thread is occupied for a period of time, during which the server will not be able to answer to any other request until it is freed. Promises A Promise is an object that represents the eventual completion (or failure) of an asynchronous operation and its resulting value. So, we can wrap the asynchronous readFile function with a Promise: const { readFile, writeFile } = require('fs') const getText = (path) => { return new Promise((resolve, reject) => { readFile(path, 'utf8', (err, data) => { if (err) { reject(err) } else { resolve(data) } }) }) } The result of a Promise can be accessed as follows: getText('./content/first.txt') .then((result) => console.log(result)) .catch((err) => console.log(err)) And then, we can define an asynchronous function start that will wait for the execution of getText: const start = async () => { try { const first = await getText('./content/first.txt') const second = await getText('./content/second.txt') console.log(first, second) } catch (error) { console.log(error) } } Where you can see that we surround the call with a try-catch statement, which allows us to have more control over the execution flow Node's Native Promises We can use the utils module in order to wrap functions with the Promise object: const { readFile, writeFile } = require('fs') const util = require('util') const readFilePromise = util.promisify(readFile) const writeFilePromise = util.promisify(writeFile) const start = async () => { try { const first = await readFilePromise('./content/first.txt', 'utf8') const second = await readFilePromise('./content/second.txt', 'utf8') \t\tawait writeFilePromise( './content/result-mind-grenade.txt', `THIS IS AWESOME : ${first} ${second}`, { flag: 'a' } ) console.log(first, second) } catch (error) { console.log(error) } } But, we can also avoid importing the utils module, by adding .promises when importing the asynchronous functions: const { readFile, writeFile } = require('fs').promises const start = async () => { try { const first = await readFile('./content/first.txt', 'utf8') const second = await readFile('./content/second.txt', 'utf8') await writeFile( './content/result-mind-grenade.txt', `THIS IS AWESOME : ${first} ${second}`, { flag: 'a' } ) console.log(first, second) } catch (error) { console.log(error) } } start() "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/NodeJS/intro.html",
    "title": "NodeJS",
    "body": " Back NodeJS NodeJS in an environment to run Javascript outside of the browser that was build on top of Chrome's V8 JS Engine. It allows for easy development of full stack apps, since both the frontend and the backend are build in the same language, Javascript. Differences between to the browser and NodeJS Browser NodeJS DOM No Dom Window No Window Interactive Apps Server Side Apps No Filesystem Filesystem Fragmentation Versions ES6 Modules CommonJS How to get Node to evaluate our code REPL (Read, Eval, Print Loop) $ node Welcome to Node.js v16.9.1. Type \".help\" for more information. > CLI executable $ node 00_app.js large number hey it is my first node app "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/NodeJS/query_strings.html",
    "title": "Query Strings",
    "body": " Back Query Strings We can use the query attribute from the request object in order to further filter our data. So whenever the user types localhost:5000/whateverendpoint?name=john, the request object passed as an argument of the callback defined for whateverendpoint will have the object {name: 'john'} stored in request.query. app.get('/whateverendpoint', (req, res) => { console.log(req.query) }) Now we code the way to filter by the keywords search and limit: app.get('/api/v1/query', (req, res) => { \t \t// De-structure keys const { search, limit } = req.query // Get a copy of the products let sortedProducts = [...products] // If search was specified if (search) { \t // Return only the products whose name start with sortedProducts = sortedProducts.filter((product) => { return product.name.startsWith(search) }) } // If limit was specified if (limit) { // Return as many products as the limit specified sortedProducts = sortedProducts.slice(0, Number(limit)) } // If no product matched the search if (sortedProducts.length < 1) { return res.status(200).json({ sucess: true, data: [] }) } \t // Return the products filtered res.status(200).json(sortedProducts) }) So now, if we go to localhost:5000/api/v1/query?search=a&limit=2 the server will return a JSON object that contains at most 2 products whose name start with an \"a\". Observe, that in order to avoid error for sending more than one response (note that we have two res.json() in our function), we must add the return keyword after sending each response, then the method exits. "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/NodeJS/express.html",
    "title": "Express",
    "body": " Back Express Express is a minimal and flexible Node.js web app framework that allows us to develop and design web sites and APIs much faster. To install: $ npm install express --save They suggest including the flag --save because in earlier versions of Express if it was not specified the package would not be saved as a dependency on package.json. Initializing Express App In order to do so we import the express module, and the we create the instance, more or less like we did with our HTTP servers: const express = require('express') const app = express() App Methods The app instance we just created has several methods, we now list the most common: app.get: HTTP method to read data. app.get('/', (req, res) => { res.status(200).send('Home Page') }) app.post: HTTP method to insert data. app.put: HTTP method to update data. app.delete: HTTP method to delete data. app.all: Usually used to respond when we cannot locate a resource on the server. app.all('*', (req, res) => { res.status(404).send('<h1>resource not found</h1>') }) app.use: It is responsible for the middleware. app.listen: This method listens for any requests made to the server. app.listen(5000, () => { console.log('server is listening on port 5000...') }) Send HTML files To send HTML files as a response instead of plain text we have to use the sendFile method: const express = require('express') const path = require('path') const app = express() app.get('/', (req, res) => { res.sendFile(path.resolve(__dirname, './index.html')) }) app.listen(5000, () => { console.log('server is listening on port 5000...') }) Now, we have to import the external resources needed by the HTML file: const express = require('express') const path = require('path') const app = express() app.use(express.static('./public')) app.get('/', (req, res) => { res.sendFile(path.resolve(__dirname, './index.html')) }) app.listen(5000, () => { console.log('server is listening on port 5000...') }) So we invoke app.use as to tell the server that there are static resources stored in the public folder. However, because in this case index.html is also a static file we can remove the sendFile method if we store index.html inside the public folder: const express = require('express') const path = require('path') const app = express() app.use(express.static('./public')) app.listen(5000, () => { console.log('server is listening on port 5000...') }) "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/NodeJS/json.html",
    "title": "JSON",
    "body": " Back JSON The method res.json() allows us to return a array of objects as the body of the HTTP response: const express = require('express') const app = express() app.get('/', (req, res) => { res.json([{name: 'john'}, {name: 'susan'}]) }) app.listen(5000, () => { console.log('Server is listening on port 5000....') }) We can also pass a JSON file to res.json(): const express = require('express') const app = express() const { products } = require('./data') app.get('/', (req, res) => { res.json(products) }) app.listen(5000, () => { console.log('Server is listening on port 5000....') }) Where data.js contains: const products = [ { id: 1, name: 'albany sofa', image: 'product-3.jpg', price: 39.95, desc: `I'm baby direct trade farm-to-table hell of`, }] module.exports = products "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/NodeJS/http_methods.html",
    "title": "HTTP Methods",
    "body": " Back HTTP Methods In this section we will show a few examples of the different HTTP methods in Express, take into account that we are not using a database. GET app.get('/api/people', (res, req) => { res.status(200).json({ success: true, data: people }) }) POST Observe that we use a middleware provided by Express that lets us parse incoming requests with urlencoded payload, and another middleware function to parse json. app.use(express.urlencoded({ extended: false })) app.use(express.json()) app.post('/api/people', (res, req) => { const { name } = req.body if(!name){ return res .status(400) .json({ success: false, msg: 'Please provide a name'}) } // Send array of people adding the new person (this is not permanent) res.status(201).json({ success: true, data: [...data, { name, id: data.length + 1}] }) }) PUT app.put('/api/people/:id', (res, req) => { // De-structure params const { id } = req.params const { name } = req.body const person = people.find((person) => person.id === Number(id)) // The person does not exist if(!person){ return res .status(400) .json({ success: false, msg: `no person with id: ${id}`}) } // Update the person data const newPeople = people.map((person) => { if(person.id === Number(id)){ person.name = name } return person }) res.status(200).json({ success: true, data: newPeople }) }) DELETE app.delete('/api/people/:id', (res, req) => { // De-structure params const { id } = req.params const { name } = req.body const person = people.find((person) => person.id === Number(id)) // The person does not exist if(!person){ return res .status(400) .json({ success: false, msg: `no person with id: ${id}`}) } // Filter the person data const newPeople = people.filter((person) => person.id !== id) res.status(200).json({ success: true, data: newPeople }) }) "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/NodeJS/index.html",
    "title": "Node.js",
    "body": " Back Node.js Node.js Intro Globals Modules NPM Event Loop Asynchronus Patterns Events Streams HTTP Express HTTP Basics Express API vs SSR JSON Route Params Query Strings Middleware HTTP Methods Routes View Engines MongoDB Mock MongoDB Environment Variables JSON Web Tokens Projects Books Directory Basic Users System Real-time Chat Application Collaborative Drawing App Email Sender Video Streaming Platform Web Scraper "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/NodeJS/api_ssr.html",
    "title": "API vs SSR",
    "body": " Back API vs SSR In Express when we talk about APIs we are talking about HTTP interfaces to interact our data. The main differences between APIs and Server Side Rendering (SSR) are:   API SSR Content type JSON Template What is sent Send data Send template Method res.json() res.render() "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/NodeJS/middleware.html",
    "title": "Middleware",
    "body": " Back Middleware When we are talking about Middleware we are typically talking about any type of code and function between getting a certain request and sending the corresponding respond. Express allows us to pass middleware as an argument to the app methods. Note that middleware runs from top to bottom in our server, so order does matter when specifying middleware. const express = require('express') const app = express() const logger = (req, res, next) => { const method = req.method const url = req.url const time = new Date().getFullYear() console.log(method, url, time) next() } app.get('/', logger, (req, res) => { res.send('Home') }) app.get('/about', logger, (req, res) => { res.send('About') }) app.listen(5000, () => { console.log('Server is listening on port 5000....') }) Here we have defined a logger function that tells us some information about the request made. This function is passed as an argument to the app.get() method, and then Express passes req, res and next as arguments for the middleware. The next argument is a function that is needed in order to pass the flow to the next middleware and it always has to be invoked, unless the current middleware sends a response and so finishes the message. In any other case, if the next method is not invoked then the browser will be stuck loading because the program flow was halted by not calling the next middleware. The middleware functions that we can use can be ones we code ourselves, express functions or third party software. Apply Middleware with app.use In order to apply a certain middleware to all the routes we first save the logger on a separate file named logger.js, then we import it into our main app, and we specify its usage as a middleware by app.use. const express = require('express') const logger = require('./logger') const app = express() app.use(logger) With this our logger will be executed every time the user accesses our server. We can also specify an argument like so: const express = require('express') const logger = require('./logger') const app = express() app.use('/api/', logger) This tells Express to only use the middleware for the /api route and all its subdomains (i.e. /api/*). Apply Multiple Middleware We now define a new middleware function, that goes by the name of authorize.js, we import it into our app.js and we add it as middleware by using an array. const express = require('express') const logger = require('./logger') const authorize = require('./authorize') const app = express() app.use([logger,authorize]) Note that the order matters, meaning the first middleware executed is logger, in this instance, and then the control flow is passed to authorize. We can also define more than one middleware function on one concrete end-point: app.get('/api', [logger, authorize], (req, res) => { res.send('API Home Page') }) As we can see, we have specified two middleware functions, namely logger and authorize by using an array. Example const authorize = (req, res, next) => { // De-structure user object const { user } = req.query if(user == 'alice'){ req.user = { name: 'alice', id: 3 } // Yield control flow next() \t} else{ res.status(401).send('Unauthorized') } } As you can see the authorize middleware function creates a new object within the request object, which can be accessed from the next middleware, or from the server. "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/NodeJS/mongodb.html",
    "title": "MongoDB",
    "body": " Back MongoDB Intro It is a NoSQL which is structured in collections, where each collection would be used to store a particular type of data in the form of documents: Blog Collection Blog document Blog document Blog document Here each document represent a single item of data, for example, each Blog document represents one blog. The data is contained inside the documents in a very similar fashion to JSON objects, so the documents consist of key-value pairs like so: { \"id\": ObjectId(12345), \"title\": \"Opening party\", \"snippet\": \"All about...\", \"body\": \"Lorem ipsum\" } Set Up We can either install MongoDB locally or we can use a cloud database which is already hosted for us. For the latter we will use MongoDB Atlas. There we create a cluster and inside this new cluster we create a new collection called Blog. Then we create a user accessing the Security -> Database Access section. Once we have our user created, we specify a way to connect to the database, by heading to Clusters -> Connect your application. We then copy the Connection String that we will use as the database URI. Observe that this URI needs you to input your password. Mongoose Now we need to actually connect to the database, we could use the MongoDB API package and use the MongoDB API, however we will use Mongoose that makes it easier to interact with the database. Mongoose is a ODM (Object Document Mapping) library, which means that it maps the standard MongoDB API providing a much easier way to connect to and interact with the database. It does this by allowing us to create simple data models which have query methods to create, get, delete and update database documents. For that we first have to create a Schema for the document which define the structure of a type of data or document. For example: Blog Schema: - title(string), required - snippet(string), required - body(string), required Next, what we do is to create a Model based on that Schema, the Model is what actually allows us to communicate with a particular database collection. Each Model has static methods get, save, delete, etc, that allow us to manage the data. Installing $ npm install mongoose Connect to MongoDB So, now, we import the Mongoose package and we use our database URI to connect to it, remember to change password and cluster_name to the values you specified for your database. const express = require('express'); const morgan = require('morgan'); const mongoose = require('mongoose'); // express app const app = express(); // connect to mongodb & listen for requests const dbURI = \"mongodb+srv://user:<password>@test.mongodb.net/<cluster_name> mongoose.connect(dbURI, { useNewUrlParser: true, useUnifiedTopology: true }) .then(result => app.listen(3000)) .catch(err => console.log(err)); The connect method is an asynchronous function, so it will execute a callback function when it finished connecting, or an error if the connection failed. In our case, we proceed to start our server when the database is ready. Create Models & Schemas Once we have successfully connected to our database, we will create our Blog Schema. For that, we first create a folder called models and inside it we create blog.js that will contain the following code: const mongoose = require('mongoose'); const Schema = mongoose.Schema; const blogSchema = new Schema({ title: { type: String, required: true, }, snippet: { type: String, required: true, }, body: { type: String, required: true }, }, { timestamps: true }); const Blog = mongoose.model('Blog', blogSchema); module.exports = Blog; As you can see, we first import mongoose and the Schema object that we use to define the Blog Schema. In order to create a new Blog Schema we create a new Schema object and we specify the different properties and restrictions. We also set and object of options, where we specify that we want MongoDB to save the timestamps of updates, creations, etc. Next we created a model that is based in the Schema we just created with the function model and we pass it the Model name (this name is then pluralized, as to then look up the collection that matches it) and the Schema instance. Getting/Saving Data In order to work we data, we must import the Model we just created. const express = require('express'); const morgan = require('morgan'); const mongoose = require('mongoose'); const Blog = require('./models/blog'); // express app const app = express(); // connect to mongodb & listen for requests const dbURI = \"mongodb+srv://user:<password>@test.mongodb.net/<cluster_name> mongoose.connect(dbURI, { useNewUrlParser: true, useUnifiedTopology: true }) .then(result => app.listen(3000)) .catch(err => console.log(err)); app.get('/blogs', (req, res) => { Blog.find() .then(result => { res.send(result); }) .catch(err => { console.log(err); }); }); app.get('/blogs/:id', (req, res) => { const id = req.params.id; Blog.findById(id) .then(result => { res.send(result); }) .catch(err => { console.log(err); }); }); Here we use the find and findById methods to interact with our database. In order to create or delete new Blogs: app.post('/blogs', (req, res) => { const blog = new Blog(req.body); blog.save() .then(result => { res.redirect('/blogs'); }) .catch(err => { console.log(err); }); }); app.delete('/blogs/:id', (req, res) => { const id = req.params.id; Blog.findByIdAndDelete(id) .then(result => { res.json({ redirect: '/blogs' }); }) .catch(err => { console.log(err); }); }); In the POST method we create a new Blog object using the objects from the request body, and then we save it in our database. On the other hand, in order to delete a Blog we pass the id as a parameter, we search for it on the database and we delete it. "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/NodeJS/env.html",
    "title": "Environment Variables",
    "body": " Back Environment Variables Installing In order to pass environment variables, like MongoDB credentials, to our app we can use a third party package called cross-env: $ npm install --save-dev cross-env And then we can pass environment variables as arguments to our node application like so: npx cross-env NODE_ENV=development node app.js And the environment variables can be accessed from our app as follows: console.log(process.env.NODE_ENV) Command To make it easier we can modify our package.json scripts to pass these variables for us: { \"name\": \"project\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"app.js\", \"scripts\": { \"dev\": \"npx cross-env NODE_ENV=development node app\" }, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\" } And we start the application with: $ npm dev File Another way to do it is using a .env file: NODE_ENV=development PORT=3000 HOST=localhost To pass those variables to Node.js we use the eval command: $ eval $(cat .env) node app And we can also include it to package.json. { \"name\": \"project\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"app.js\", \"scripts\": { \"dev\": \"eval $(cat .env) node app\" }, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\" } dotenv In case of not wanting to use commands that are exclusive to our operative system, we can use the package dotenv $ npm install --save-dev dotenv And in our app we do: require('dotenv').config() "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/NodeJS/streams.html",
    "title": "Streams",
    "body": " Back Streams Streams are used to read or write sequentially. There are different types: Writeable Readable Duplex: for both writing and reading. Transform: to modify data while writing or reading. They are used in order to read files which are too big to store on variables, as it would pose an error. const { createReadStream } = require('fs') const stream = createReadStream('./content/big.txt') stream.on('data', (result) => { console.log(result) }) When logging result when listening on the data event we get the amount of data that is being read, as streams read data chunk by chunk, whose default value is 64kb. In order to modify this value we specify, on the options object, the property highWaterMark: const { createReadStream } = require('fs') const stream = createReadStream('./content/big.txt', { highWaterMark: 90000 }) stream.on('data', (result) => { console.log(result) }) stream.on('error', (err) => console.log(err)) So, now we are reading 90kb chunks of data. In order to read the data, we specify the encoding of the file: const { createReadStream } = require('fs') const stream = createReadStream('./content/big.txt', { encoding: 'utf8' }) stream.on('data', (result) => { console.log(result) }) In order to listen for errors: const { createReadStream } = require('fs') const stream = createReadStream('./content/big.txt') stream.on('error', (err) => console.log(err)) Streams on the Web When reading and writing files on servers, it is highly advisable to use chunks instead of the hole file, like so: var http = require('http') var fs = require('fs') http .createServer(function (req, res) { const text = fs.readFileSync('./content/big.txt', 'utf8') res.end(text) }) .listen(5000) Instead of this approach, we use streams, both for reading and for writing: var http = require('http') var fs = require('fs') http .createServer(function (req, res) { const fileStream = fs.createReadStream('./content/big.txt', 'utf8') fileStream.on('open', () => { fileStream.pipe(res) }) fileStream.on('error', (err) => { res.end(err) }) }) .listen(5000) Here, we see that we use the on method to listen for the open event. And then, we use pipe to write on the stream. "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/NodeJS/event_loop.html",
    "title": "Event Loop",
    "body": " Back Event Loop It is what allows Node.js to perform non-blocking I/O operations, despite the fact that JavaScript is single-threaded- by offloading operations to the system kernel whenever possible. The Event Loop follows the next steps: An asynchronous request is made by a user The Event Loop registers the callback of the request When the request is completed and we are ready to execute the callback the Event Loop stores the callback at the end of the execution line, meaning, once the immediate tasks are done (i.e. synchronous code) the callback is executed For example, we have the following code: const { readFile, writeFile } = require('fs') console.log('started a first task') readFile('./content/first.txt', 'utf8', (err, result) => { if (err) { console.log(err) return } console.log(result) console.log('completed first task') }) console.log('starting next task') Which outputs: started first task starting next task Hello this is first text file Completed first task So we can see that the synchronous code is run first, and then the callback of the asynchronous function readFile is called upon finishing reading the file. In the next example: // started operating system process console.log('first') setTimeout(() => { console.log('second') }, 0) console.log('third') // completed and exited operating system process Which outputs: first third second So even though the timeout is initialized to 0, because it is an asynchronous function it is offloaded and so it is put to the end of the execution line, and then it is executed after the synchronous code. It is important to note that the listen function of the http module is also asynchronous. "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/GraphQL/updating.html",
    "title": "Mutations",
    "body": " Back Mutations In order to update, delete or add new data using GraphQL we use Mutations. TypeDef We create the type definition for the Mutation object (which is reserved in GraphQL to modify/add data, much like the Query object). In it, we define all the modifying functions we want, along with the data that must be provided to execute the modification, and also the type of object that is returned. type Mutation { addAnimal( name: String! description: [String!]! parameter: String! category: String! ): Animal removeAnimal(id: ID!): Boolean! } With this we have defined the addAnimal method, which creates and animal by specifying the name, description, URL parameter and the category. This function will return an Animal object. We have also defined the removeAnimal method, that only takes an id as a parameter and returns a Boolean. Resolvers We now define the logic behind both of these methods, so we create a Mutation.js file as follows: const { v4 } = require(\"uuid\") const Mutation = { addAnimal: (parent, { name, description, parameter, category }, { animals }) => { let newAnimal = { id: v4(), name, description, parameter, category, } // Only because this is an object: here we would create in the database animals.push(newAnimal) return newAnimal }, removeAnimal: (parent, { id }, { animals }) => { // Here we would delete in the database let index = animals.findIndex((animal) => { return animal.id === id }); animals.splice(index, 1); return true } } module.exports = Mutation Note that we de-structure the parameters from the args object for readability sake. "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/GraphQL/qtr.html",
    "title": "Queries TypeDefs and Resolvers",
    "body": " Back Queries TypeDefs and Resolvers TypeDefs: define how the data should look. Resolvers: resolve what the actual data is going to be. Here we could introduce some logic, like calling the database or applying validation. Query: defines how we can query our data type Query{ books: [Book] } So the book resolver would return an array of books. Data Specification Arrays: to define an array on TypeDefs or Queries you use []. type Book { author: [String] } Non nullable field: to specify that an attribute cannot be null you use !. type Book { author: String! author: [String]! // the array must not be null author: [String!]! // the elements of the array and the array must not be null } Queries Parameters: on the query object you add an argument between brackets (the ! specifies the argument must be provided). type Animal { id: ID! name: String! description: [String!]! } type Query { animals: [Animal!]! animal(id: String!): Animal } On the resolver we use the arg parameter to retrieve the parameter passed: const resolvers = { Query: { animals: () => animals, animal: (parent, args, ctx) => { let animal = animals.find((animal) => { retunr animal.id === args.id }) return animal } } } "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/GraphQL/client.html",
    "title": "Client",
    "body": " Back Client As well as with the server there are several clients for GraphQL within different languages and frameworks, visit the official page to check them out. We are going to use Apollo Client so for that we need to install apollo and graphql on the client side of our application: $ npm install @apollo/client graphql In our case we are going to connect our client to React (Reference). So, first we import the necessary modules. import React from 'react'; import { render } from 'react-dom'; import { ApolloClient, InMemoryCache, ApolloProvider, useQuery, gql } from \"@apollo/client\"; const client = new ApolloClient({ uri: 'http://localhost:4000', cache: new InMemoryCache() }); function App() { return ( <div> <h2>My first Apollo app 🚀</h2> </div> ); } render( <ApolloProvider client={client}> <App /> </ApolloProvider>, document.getElementById('root'), ); We tell apollo that our GraphQL server is listening for request on our localhost on the port 4000. Where apollo allows us to cache our queries, with the InMemoryCache module. That way we do not need to make the same request twice, because the data is cached in memory. And then, we wrap our app with the ApolloProvider, so all of our components have access to our client. Note that we pass our client as a prop. "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/GraphQL/intro.html",
    "title": "Intro",
    "body": " Back Intro GraphQL is a query language used to communicate to our API and query for data. Difference with APIs Whenever we use REST APIs and we hit specific endpoints, more often than not, we are going to retrieve some data that we have no use for. This is what is called overfetching. For example when you access https://my-rest-api/animals you get an object with a list of animal objects, and you may not need all of the information of every animal. GraphQL solves this problem by: Only having one endpoint. From this endpoint we use the graph query language to select whatever data that we want. For example, to retrieve the same information stated above: query{ animals{ title ratings img price } } Which gets only the specified attributes for each animal. GraphQL also solves underfetching, which is the situation where you cannot get enough data with a call to only one endpoint, forcing you to call a second endpoint. For example, if you want information about the animals and the categories you have to access https://my-rest-api/animals, and https://my-rest-api/categories, however with GraphQL: query{ animals{ title ratings img price } categories{ id title img } } "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/GraphQL/relationships.html",
    "title": "Relationships",
    "body": " Back Relationships One To Many We are now going to illustrate the situation where an animal belongs to only one category whilst a category contains several animals: type Animal { id: ID! category: Category! name: String! parameter: String! } type Category { id: ID! name: String! animals: [Animal!]! parameter: String! } Where we have stored in our database the id of the category as a foreign key of the Animal entity. In order to query for animals from a category we create a new resolver: const resolvers = { Query: { animals: () => animals, animal: (parent, args, ctx) => { let animal = animals.find((animal) => { return animal.paramenter === args.id }) return animal } } Category: { animals: (parent, args, ctx) => { return animals.filter((animal) >= { return animal.category == parent.id }) } } } So if we query for: { category(parameter: \"mammal\"){ category animals { name } } } We get all the names of the animals that are mammals. The parent object symbolizes the object resulting from category(parameter: \"mammal\"), this object will be a Category object and will have an id, that we will use in our resolver to filter the animals. Observe that the animals have a attribute called category, which is *not* the same as the type definition we have made for our Animal object, this attribute is defined on the database. Note that we have created a Category resolver that acts as the query resolver but for queries within the category object. We, now, do the same for the animals, meaning we want to get the Category object that we specified in the Animal object, for that we create a new resolver: Animal: { category: (parent, args, ctx) => { return categories.find((category) => { return category.id === parent.category }) } } So what we do is go through all of the categories until we find the one that has the same id. { animal(parameter: \"cat\"){ name category { name } } And with this query we retrieve the name and the category name of a cat. "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/GraphQL/fetch.html",
    "title": "Fetch Data",
    "body": " Back Fetch Data You can start requesting data with useQuery. useQuery is a React hook that shares GraphQL data with your UI. So for example to fetch the image and the title of the cards: import { useQuery, gql } from '@apollo/client' const FETCH_DATA = gql` { mainCards { image title } } ` function MainHero(){ const mainData = useQuery(FETCH_DATA) return(<div></div>) } Where mainCards is one of our resolvers, and we specify that we want to select the image and the title. So now, we can de-structure the different attributes offered by the ApolloProvider, namely loading, error and data. And therefore control the flow of our application by using them. import { useQuery, gql } from '@apollo/client' const FETCH_DATA = gql` { mainCards { image title } } ` function MainHero(){ const { loading, error, data } = useQuery(FETCH_DATA) return(<div></div>) } Variables In order to make a query by passing parameters we do: const ANIMAL_QUERY = gql` query($slug: String!){ animal(slug: $slug){ title image stock description price } } ` Where $string is the variable we want to pass in, and we specify its type and the fact that it is required with String!. Now to make the query we do: function AnimalPage() { const { slug } = useParameters() const { loading, data, error } = useQuery( variables: { slug: 'cat' } ) } With variables we pass in all of the parameters needed in the query. "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/GraphQL/terminology.html",
    "title": "Terminology",
    "body": " Back Terminology Schema It defines the data associated with an Entity: type Person { id: ID! name: String! email: String! age: Int! phone: String gender: Boolean! } That is to say, it defines the type definitions of the data that conforms a given Entity. Resolver The data that we get back is dependent on the resolvers. They are functions that return data that follow a certain schema, it does not need to follow the schema, but then when querying it, it may throw and error. people(parent, args, ctx, info){ return[ { id: \"1\", name: \"Laith\", email: \"email@email.com\", age: 23, phone: \"623198135\", gender: true } ] } "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/GraphQL/index.html",
    "title": "GraphQL",
    "body": " Back GraphQL Backend Intro Terminoligy GraphQL Server Queries, TypeDefs and Resolvers Relationships File Structure Mutations Frontend GraphQL Client Fetch Data Mutations "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/GraphQL/mutations_client.html",
    "title": "Mutations",
    "body": " Back Mutations In order to execute a mutation from the client side we create a mutation request: const ADD_ANIMAL_MUTATION = gql` mutation( $name: String!, $description: [String!] $parameter: String!, $category: String! ) { addAnimal( name: $name, description: $description, parameter: $parameter, category: $category ) } ` And now we use the useMutation hook to obtain the function that will be called in order to update our animal: import { useMutation, gql } from '@apollo/client' function Animal(){ const [addAnimal] = useMutation(ADD_ANIMAL_MUTATION) return( <div> <button onClick={() => addAnimal({ variables: { name: 'cat', description: ['This is a description'], parameter: 'cat', category: 'mammal' } } )}/> </div> ) } With this we get the function addAnimal with the useMutation hook and we use it in our button, so when it is clicked we add a cat to our animal collection. "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/GraphQL/file_structure.html",
    "title": "File Structure",
    "body": " Back File Structure What is best practice is to separate the type definitions and the resolvers: TypeDefs: stored in schema.js for example. Resolvers: stored in a folder called resolvers, and then for each Resolver we create a file, for example for the Query resolver: const Category = { animals: (parent, args, { animals }) => { return animals.filter(animal => { return animal.category === parent.id }) } } module.exports = Category Then we create an index.js inside the resolvers folder where we can import and export all of our Resolvers together: const Query = require('./query') const Category = require('./category') const Animal = require('./animal') module.exports = { Query, Category, Animal } And we put everything together in our index.js inside the root folder: const { ApolloServer } = require('apollo-server'); const { mainCards, animals, categories } = require('./db') const typeDefs = require('./schema') const { Query, Category, Animal } = require('./resolvers/index') const server = new ApolloServer({ typeDefs, resolvers: { Query, Animal, Category }, context: { mainCards, animals, categories } }); // The `listen` method launches a web server. server.listen().then(({ url }) => { console.log(`🚀 Server ready at ${url}`); }); We now use the context object in order to make our \"database\" available to all of the resolvers through ctx. (Note that we de-structure the object to the get animal object). "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/GraphQL/server.html",
    "title": "GraphQL Server",
    "body": " Back GraphQL Server GraphQL supports several languages, and has several servers that do mainly the same. Consult the official page for the one that suits your needs. We are going to use apollo-server to demonstrate how to use GraphQL in a node.js application: So, first, we install the apollo-server along with graphql dependency with npm: $ npm install apollo-server graphql Now we use graphql to define our type definitions: const { ApolloServer, gql } = require('apollo-server'); const typeDefs = gql` type Book { title: String author: String } type Query { books: [Book] } And we also create our resolvers: const resolvers = { Query: { books: () => books, } } Where books is an already defined array of books. Finally we create the actual server: const server = new ApolloServer({typeDefs, resolvers}); server.listen().then(({ url }) => { console.log(`🚀 Server ready at ${url}`); }); "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Django/django_notes.html",
    "title": "<code>Django</code> Notes",
    "body": " Back Django Notes In this section we lay out some concepts about the Django Framework. Apps Models The models can be thought of as objects, in the sense of OOP, that have certain attributes. This objects are then mapped by Django to the database of choice. To define new models, or modify existing model (e.g. the user model) you need to modify the models.py file in the root folder of every app that is created. Alternatively, you can centralize all of your models on the core app. An example of a simple model is the following Tag model: class Tag(models.Model): \"\"\"Tag to be used for a book\"\"\" # Define the attributes of the table name = models.CharField(max_length=255) # Define the relation between the tag and the user user = models.ForeignKey( settings.AUTH_USER_MODEL, on_delete=models.CASCADE, ) # Define the string representation of the Tag def __str__(self): return self.name Once the model is define, it needs to be registered on the admin.py file: admin.site.register(models.Tag) Specifically when modifying existing models, you will need to extend the classes defined by Django (e.g. AbstractBaseUser, UserAdmin). For example: class User(AbstractBaseUser, PermissionsMixin): \"\"\"Custom user model that suppors using email instead of username\"\"\" email = models.EmailField(max_length=255, unique=True) name = models.CharField(max_length=255) is_active = models.BooleanField(default=True) is_staff = models.BooleanField(default=False) objects = UserManager() Which has to be registered as follows: admin.site.register(models.User, UserAdmin) Where UserAdmin is a class define in the admin.py file, that defines the custom User model: class UserAdmin(BaseUserAdmin): ordering = ['id'] list_display = ['email', 'name'] # User edit page fields fieldsets = ( (None, {'fields': ('email', 'password')}), (_('Personal Info'), {'fields': ('name',)}), ( _('Permissions'), {'fields': ('is_active', 'is_staff', 'is_superuser')} ), (_('Important Dates'), {'fields': ('last_login',)}) ) # User create page fields add_fieldsets = ( (None, { 'classes': ('wide',), 'fields': ('email', 'password', 'password2') }), Admin This is the feature that allows you to manage your models, let it be create them, modify them or delete them. The functionality of the admin model is defined within the admin.py file on the root folder of every app that is created. In order to create a superuser execute the following command: $ python manage.py createsuperuser On Docker: $ docker-compose run app sh -c \"python manage.py createsuperuser\" Then, you will be prompted to enter an email and a password. Once you have filled said fields, you can start the server with $ docker-compose up And enter to the admin page located on 127.0.0.1:8000/admin, where you can log in with your credentials. URLs Django allows us to define relative URLs on a very modular way. First off, we have the core file when it comes to URL definition: app/app/urls.py. Here we may have something like this: from django.contrib import admin from django.urls import path, include urlpatterns = [ path('admin/', admin.site.urls), path('api/user/', include('user.urls')), ] This example shows that the urlpatterns variable is a list that holds all of the urls defined in our project. The modularization comes from the way the URLs defined on the user’s app are specified. First we specify the endpoint for these URLs (namely api/user/), and then we pull all the relative URLs from the user’s app, defined on the file app/user/urls.py. Which are then concatenated with api/user/. The URLs defined on the user app are as follows: app_name = 'user' urlpatterns = [ path('create/', views.CreateUserView.as_view(), name='create'), ] This the can be used like this: # Create user api endpoint dinamically CREATE_USER_URL = reverse('user:create') Serializers This files are defined to specify how to serialize (map to the database) the JSON objects received, in our case, from HTTP requests. For that we create, for each model, a class that extends serializers.ModelSerializer. In this class we define an inner class called Meta that tells the framework which fields does the object have and so allows the mapping to take place. You can also add extra arguments to this inner class, for example to restrict or exercise a stronger control on the fields. Next on, we have a simple example of our User Model serializer: from django.contrib.auth import get_user_model from rest_framework import serializers class UserSerializer(serializers.ModelSerializer): \"\"\"Serializer for the users object\"\"\" class Meta: \"\"\"Info about how to serialize the user model\"\"\" model = get_user_model() fields = ('email', 'password', 'name') # Extra requirements for the user model extra_kwargs = {'password': {'write_only': True, 'min_length': 5}} def create(self, validated_data): \"\"\"Create a new user with encrypted password and return it\"\"\" # validation_data: JSON data passed in the HTTP POST return get_user_model().objects.create_user(**validated_data) We can also serialize an object that is not related to a model per se, for example: class AuthTokenSerializer(serializers.Serializer): \"\"\"Serializer for the user authentication object\"\"\" email = serializers.CharField() password = serializers.CharField( style={'input_type': 'password'}, trim_whitespace=False ) Views This is, on simple terms, a Python function that takes a Web request and returns a Web response. In our case, we will mostly use views for our API, so we use pre-make view that allows us to easily make an API that creates, updates, etc an object on the database using the serializer that we specify, for example, the API for creating a user is as follows: class CreateUserView(generics.CreateAPIView): \"\"\"Create a new user in the system\"\"\" serializer_class = UserSerializer In case of wanting to update an object we extend generics.RetrieveUpdateAPIView instead of generics.CreateAPIView. Because this view is private, we need to indicate an authentication mechanism and the level of permissions the user has, in our case the authentication is made via token and the permissions are that the user needs to be logged in. class ManageUserView(generics.RetrieveUpdateAPIView): \"\"\"Manage the authenticated user\"\"\" serializer_class = UserSerializer # Authentication mechanism by which the authentication happens authentication_classes = (authentication.TokenAuthentication,) permission_classes = (permissions.IsAuthenticated,) def get_object(self): \"\"\"Retrieve and return authentication user\"\"\" return self.request.user Actions Start the server Observe that this is executed on the docker-compose configuration file $ python manage.py runserver 0.0.0.0:8000 Sync Django settings (app/app/settings.py) $ python manage.py migrate On docker: $ docker-compose run app sh -c \"python manage.py migrate\" Sync changes made on models $ docker-compose run app sh -c \"python manage.py migrate\" On docker: $ docker-compose run app sh -c \"python manage.py makemigrations\" You can also specify the name off the app that contains the model $ python manage.py makemigrations app_name "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Django/index.html",
    "title": "<code>Django</code>",
    "body": " Back Django Django Notes "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Docker/orchestration.html",
    "title": "Container Orchestration",
    "body": " Back Container Orchestration When in production, it is often needed that several instances of containers are run (because of a heavy load on the application for example). So in these cases you need to monitor the instances as well as the host itself in case any of them crash. For that we use container orchestration that offers a set of tools and scripts that allow us to manage the hosts and containers. The typical approach is to create several instances of containers in different hosts, so if one fails the application can still offer the service. For example: $ docker service create --replicas=100 nodejs Some solutions let us automatically scale the number of containers depending on the demand. Others can help in automatically adding new hosts to support the user load. They also provide complex networking between the containers as well as load balancing user requests across different hosts or sharing storage between the hosts, configuration management or security. There are several solutions: Docker Swarm from Docker Kubernetes from Google MESOS from Apache. "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Docker/setup.html",
    "title": "Set Up",
    "body": " Back Set Up In this first step, we will present how to install the necessary tools to use Docker and Docker Compose in Arch Linux. Install Docker In the current section we will lay out the steps to carry out in order to get docker up and running on an Arch Linux machine. Docker Engine Before installing anything we will update the system as follows $ sudo pacman -Syu When it is done updating we will proceed rebooting the system, and then we enable the loop module: $ sudo tee /etc/modules-load.d/loop.conf <<< \"loop\" $ sudo modprobe loop Install using static binaries For reference go to the official documentation on Docker's website. Firstly we will download the static binary archive on https://download.docker.com/linux/static/stable/. Once the file is downloaded extract it executing the following command, and substituting our docker-20.10.8 for your package's version. $ tar xzvf docker-20.10.8.tgz Copy the binaries to your executable path (/usr/bin or /bin). This is optional. $ sudo cp docker/* /usr/bin/ Start docker's daemon: $ sudo dockerd Finally run to check that the installation was correct (it will download an example image that outputs a message informing the user that the installation was successful, among other things). $ sudo docker run hello-world Official Repo This other approach will allows to have a docker service so we do not have to always run sudo dockerd & to start docker's daemon. We install Docker using pacman: $ sudo pacman -S docker Afterwards, we enable the docker service executing: $ sudo systemctl start docker.service $ sudo systemctl enable docker.service Finally run to check that the installation was correct (it will download an example image that outputs a message informing the user that the installation was successful, among other things). $ sudo docker run hello-world Configure Docker Running as normal user In order to use Docker as a normal user we need to add said user to the docker group. Add the Docker group $ sudo groupadd docker Add your user to the Docker group $ sudo usermod -aG docker $USER Log out, log in and verify that it runs properly $ docker run hello-world Install Docker Compose Download the current stable release of Docker Compose. Mind you, this command downloads the 1.29.2 version, check the official page for new releases. $ sudo curl -L \"https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose Make the binary executable $ sudo chmod +x /usr/local/bin/docker-compose Test the installation $ docker-compose --version docker-compose version 1.29.2, build 5becea4c "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Docker/kubernetes.html",
    "title": "Kubernetes",
    "body": " Back Kubernetes Some of its functionalities are: Running several instances of a service. Scaling up or down the number of instances. Rolling updates. Rolling back from updates. Supports many different network and storage renderers. Provides autoscaling. Helps you test new features of your application by only upgrading a percentage of the instances, which allows for doing AB testing. Architecture A kubernetes cluster consists of several nodes, the worker nodes are where containers will be launched, so even if one node fails the application is still available. Kubernetes clusters are managed by the master, which is a node that watches over worker nodes and is responsible of the orchestration of containers in the worker nodes. Components When you install Kubernetes in your system you are actually installing: API Server: acts as the front-end for Kubernetes, so all of the programs talk to this server to interact with the kubernetes server. etcd: it is the distributed reliable key value store to store all data to manage the cluster. Scheduler: responsible for distributing work. Controller: responsible for noticing/responding to nodes/containers going down. Container Runtime: underline software used to run containers (e.g. Docker). kubelet: is the agent that runs in each node in the cluster, and is responsible of making sure the containers are running on the nodes as expected. One of the command line utilities used by Kubernetes is kubectl, that is the Kubernetes CLI and is used to deploy and manage applications on a kubernetes cluster. "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Docker/engine.html",
    "title": "Docker Engine",
    "body": " Back Docker Engine When you install Docker on your Linux system you are installing: Docker daemon: this is the background process that manages docker objects (i.e. images, containers, volumes and networks). REST API: it is the interface programs can access to provide instructions to the daemon. Docker CLI: command line interface to manage our docker objects. This uses the REST API to interact with the docker daemon. Note that the Docker CLI can be run from a remote machine, that is to say the REST API and the Docker daemon are running on a different machine. So, in order to interact with the API we use the -H flag, indicating the IP where the API and the daemon reside with the 2375 port. $ docker -H=10.123.2.1:2375 <docker-command> $ docker -H=10.123.2.1:2375 run nginx Containerization As we have seen all of our containers run on top of the same operative system, so it is a given that the processes will be handled by the same kernel. This means that the processes of our containers are run along with the rest of processes in the host machine, in other words the PIDs of all the processes must be different. What Docker does to isolate these processes is the container is using namespaces and maps the process id to another process id within the container, and that is visible only on this container. cgroups Because all docker containers share the hosts resources it could be possible that a container takes up all of the machine's resources. So, to restrict the amount of resources used by a container Docker uses cgroups. You can specify the amount of CPU or RAM that the container is allowed to have: $ docker run --cpus=.5 ubuntu $ docker run --memory=100m ubuntu "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Docker/intro.html",
    "title": "Intro",
    "body": " Back Intro What are containers They are completely isolated environments, they have their own processes, network interfaces, etc. However they share the same os kernel. Docker uses LXC containers, which are very low lever, so Docker provides a high level tool that allows us to manage our containers easily. Sharing the Kernel As we have said, Docker uses the system's kernel, so it is capable of running any distributions whose underlying kernel is Linux (e.g. Docker running on Ubuntu can run a container based on Debian, Fedora, etc.) Containers vs Virtual Machines Containers: Application 1 Application 2 Libs/Dependencies 1 Libs/Dependencies 2 Container 1 Container 2 Docker   OS   Hardware   Virtual Machines: Application 1 Application 2 Libs/Dependencies 1 Libs/Dependencies 2 OS 1 OS 2 Virtual Machine 1 Virtual Machine 2 Hypervisor   Hardware   The main differences are the use of Hypervisors in Virtual Machines and how on these, each instance has its own OS. Which results in needing more hardware resources. Also Virtual Machines have total isolation, as they use their own OS, which does not happen with containers, because these do share the same kernel. However the key is combining both technologies, so each virtual machine runs several applications hosted in different containers. Container vs Image An image can be thought as a package or a template that is used to create one or more containers. That is to say, containers are running instances of images that are isolated and have their own environment. "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Docker/registry.html",
    "title": "Docker Registry",
    "body": " Back Docker Registry Public Registry In the following example you are pulling the nginx image, which in reality is stored as nginx/nginx where the first nginx corresponds to the user name, and the second to the image name. image: nginx This is a public image so it is stored in a public registry, usually in docker.io which is the default registry. So a more verbose configuration file would be: image: docker.io/nginx/nginx Private Registry When you have applications that should no be made available to the public private registries are used. To pull or use an image from a private registry: Register into the private registry: $ docker login private-registry.io Run the image indicating the registry: $ docker run private-registry.io/apps/internal-app Deploy Private Registry A private registry is in itself a docker image, so first you have to have your registry image running: $ docker run -p 5000:5000 --name registry registry:2 So now you have your registry running on port 5000. The next step is to assign a tag to your image as follows: $ docker image tag my-image localhost:5000/my-image Where my-image is the name of the image and localhost:5000/my-image is the tag assigned. Finally you push your image to your registry $ docker push localhost:5000/my-image Now you can pull your image: $ docker pull localhost:5000/my-image $ docker pull 192.168.56.100:5000/my-image "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Docker/cmd_vs_entrypoint.html",
    "title": "<code>CMD</code> vs <code>ENTRYPOINT</code>",
    "body": " Back CMD vs ENTRYPOINT CMD A command allows us to append to the command executed when the container start of the base image. For example, Ubuntu's CMD is bash, so if we append sleep 5 our container will sleep for 5 seconds when started and then exit. FROM Ubuntu CMD sleep 5 The command can also be specified as CMD [\"sleep\", \"5\"]. ENTRYPOINT This other instruction also adds to the base image starting command, but this lets us add arguments from the command line, for example, if we define the following Dockerfile: FROM Ubuntu ENTRYPOINT [\"sleep\"] We build the image $ docker build Dockerfile -t ubuntu-sleeper And then we running with 10 as and argument: $ docker run ubuntu-sleeper 10 Our container will sleep for 10 seconds and then exit. To define a default value for sleep, when no argument is passed from the command line, we use both ENTRYPOINT and CMD FROM Ubuntu ENTRYPOINT [\"sleep\"] CMD [\"5\"] To override the ENTRYPOINT command specified in the Dockerfile we use the flag --entrypoint: $ docker run --entrypoint sleep2.0 ubuntu-sleeper 10 Difference When using CMD when running: $ docker run ubuntu-sleeper sleep 10 The argument sleep 10 replaces entirely the starting command. However with ENTRYPOINT if we run: $ docker run ubuntu-sleeper 10 The argument 10 is passed and appended to the ENTRYPOINT command. "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Docker/containers.html",
    "title": "Container",
    "body": " Back Container RUN Basics Run a container from an image, the attached way, (i.e. it is not run on the background). $ docker run nginx If the image is not present on the host it will be downloaded from Docker Hub. When it is downloaded it runs and exits right away, because there is not application running in the container. To run the container in the detach mode, so it run on the background: $ docker run -d nginx To bring the container to the foreground: $ docker attach ( container_id | container_name ) Run a container with a specific tag: $ docker run redis:4.0 This way we run the redis image where redis's version is 4.0. Run a container listening to the standard input (because by default Docker does not listen for input): $ docker run -i <image_name> This way we are running our container in interactive mode. In order to attach a terminal: $ docker run -it <image_name> Port Mapping Each container is assigned a port (e.g. 5000) and an internal IP by default (e.g. 127.17.0.2) but this IP is only accessible from the host. So to access it from outside, we would use our host's IP (e.g. 192.168.1.5), however we still need to map our container's port to a free port in our host. So to map, for example, the port 5000 of our Docker container to the port 80 of our host: $ docker run -p 80:5000 <image_name> And now, we can access the service running in our Docker container by heading to 192.168.1.5:80. This way all traffic in this specific URL will be routed to the port 5000 in our Docker container. Volume Mapping Our container has its own file system, so the changes made to data stored in it are only made in the container. If you want certain data to persist (because when removing the Docker container the files stored within are also removed) you use the flag -v to map a certain file/folder in the container to a certain file/folder in our host: $ docker run -v /opt/datadir:/var/lib/mysql mysql In this particular example we store the data we saved in our MySQL database in a directory in our container (/var/lib/mysql), and we map this directory to a directory in our host (/opt/datadir) This way Docker mounts implicitly the folder in our host to the folder in the container. Linking If we have a web application that connects to a redis instance, we need to tell the web app's container which redis instance to wait for (because there may be multiple). So, first we start the redis container: $ docker run -d --name=redis redis And now we start our web app's container and we link it with the redis container: $ docker run -d --name=vote -p 5000:80 --link redis:redis voting-app The redis before the colon is the name of our redis container, and the redis after the name is the name used in the web app container. This option is soon to be deprecated because new concepts are technologies are being introduced. Information of a Container In order to get more detailed information about a certain container: $ docker inspect ( container_name | container_id ) Logs To see the logs of a container (usually printed to the stdout): $ docker log ( container_name | container_id ) LIST Lists all running containers and some information about it. $ docker ps To see all containers, even if they are not currently running: $ docker ps -a STOP Stop running a container who matches the id or the name provided: docker stop ( container_id | container_name ) REMOVE Removes a container permanently docker rm ( container_id | container_name ) Execute commands To execute a command after creating a new container: $ docker run ubuntu sleep 5 This commands starts the container and run the command sleep 5 and then exits. To execute a command in a currently running container: $ docker exec ( container_id | container_name ) cat /etc/hosts "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Docker/storage.html",
    "title": "Storage",
    "body": " Back Storage The data pertaining Docker is stored within the folder /var/lib/docker/. This includes containers, images, volumes created, etc. Layers Because of Docker's layered architecture when creating very similar images that share a lot of instructions, it uses the cached layers and is, therefore more efficient by not building each image from scratch. For example, when you update your application's source code, only the instructions after the COPY instruction, this one included, from your Dockerfile is run. Image and Container Layers The layers created from each instruction on the Dockerfile constitute the image layers and are all read-only files. When you run your image a new layer is created, denoted by Container Layer which is a writable file which is a writable file. However, when the container is destroyed, this layer is removed. This is the reason why we use volumes for permanent storage. This is needed because all the containers use the same image, so the changes made in the image by the different containers should not affect the image. Copy-on-write Also, the changes made on files stored in the image are not made on the original file. The file is copied to the Container Layer and the changes are made onto this copy. Volumes As we have said, we need volumes to store permanent data. So, first we create the volume: $ docker volume <volume_name> Which is stored in /var/lib/docker/volumes Volume mounting Once we have created the volume, we specify that we want to mount this volume within our container: $ docker run -v <volume_name>:/var/lib/mysql mysql If you run this same command, without creating the volume first, Docker will automatically create the volume for you. Bind mounting If you want to mount another directory that is not inside /var/lib/docker/volumes, then you have to specify the whole directory's (may be an absolute or relative path). $ docker run -v /data/mysql:/var/lib/mysql mysql Mount This is the new way to mount: $ docker run --mount type=bind,source=/data/mysql,target=/var/lib/mysql Which is preferred as it is more verbose. Storage Administration The responsible for all of these operations that happen under the hood are the storage drivers, which are chosen depending on the hosts' OS: AUFS ZFS BTRFS Device Mapper Overlay Overlay2 "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Docker/compose_networks.html",
    "title": "Docker Compose Networks",
    "body": " Back Docker Compose Networks Let's start with an example application, which is made up of five services: voting-app: a front-end application for the user to vote. redis: and in-memory database to store the vote. worker: application in the back-end that processes the vote and stores it in the database. db: database in which the vote is stored. result-app: front-end application that shows the voting results. In this architecture we have two networks: front-end: voting-app and result-app back-end: all the services. Therefore it is desirable to define two networks in our docker-compose and attach the networks to the services: version: 2 services: redis: image: redis networks: - back-end db: image: postgres networks: - front-end vote: image: voting-app networks: - front-end - back-end result: image: result networks: - front-end - back-end worker: image: worker networks: - front-end - back-end networks: - front-end: - back-end: As you can see we define two networks: front-end and back-end (note that we have omitted the configuration of the networks) and then for each service we specify the network to which the service has access (also, observe that the configuration of the services has been trimmed down for readability purposes). "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Docker/swarm.html",
    "title": "Docker Swarm",
    "body": " Back Docker Swarm You can combine multiple docker machines together into a single cluster and Docker Swarm will take care of managing your services. You need to have different hosts with docker installed on them. You must designate one to be the manager, so the rest are the workers. Run the docker swarm init command on the manager and that will initialize the manager. On the workers run docker swarm join <token> where <token> is specified in the output of docker swarm init. Now you can deploy your services in your cluster, and will be run on the nodes (i.e. workers). Docker Service Docker Services are one or more instances of application or services that run along the nodes in the Swarm cluster. $ docker services create --replicas=3 <image-name> This creates three instances of my image and runs them in the nodes of the cluster. This command must be run on the manager node, not on the worker nodes. It is similar to the docker run command in terms of the options to pass (networks, ports, interactive mode, etc.) "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Docker/environmentvar.html",
    "title": "Environment Variables",
    "body": " Back Environment Variables In order to pass an environment variables to our container we run: $ docker run -e ENV_VAR=value <image_name> This way we set up and environment variable within the container. If you inspect a running container, you will be able to see the environment variables defined, inside the \"Env\" object: $ docker inspect <image_name> { . . \"Config\": { \"Hostname\": \"51049352a8ee\", \"Domainname\": \"\", \"User\": \"\", \"AttachStdin\": false, \"AttachStdout\": false, \"AttachStderr\": false, \"ExposedPorts\": { \"3456/tcp\": {}, \"80/tcp\": {} }, \"Tty\": false, \"OpenStdin\": false, \"StdinOnce\": false, \"Env\": [ \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\", \"NGINX_VERSION=1.19.10\", \"NJS_VERSION=0.5.3\", \"PKG_RELEASE=1\" ], \"Cmd\": [ \"nginx\", \"-g\", \"daemon off;\" ] . . . } "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Docker/images_commands.html",
    "title": "Image",
    "body": " Back Image LIST Lists downloaded images: $ docker images Or alternatively: $ docker image ls REMOVE Remove an image $ docker rmi nginx You must stop and remove all the containers that are instances of the image before removing said image. DOWNLOAD To only download an image and not also run a container: $ docker pull nginx Create your own image First create a Dockerfile specifying all of the steps required to set up your application: FROM ubuntu RUN apt-get update RUN apt-get install python RUN pip install flask RUN pip install flask-mysql COPY . /opt/source-code ENTRYPOINT FLASK_APP=/opt/source-code/app.py flask run Then build your image, to store locally: $ docker build Dockerfile -t mycustomapp Here we specify our Dockerfile as input for building the image and the tag of the image with the flag -t. To make it available on the DockerHub: $ docker push mycustomapp Dockerfile This is configuration file that follows a certain syntax and tells Docker how to build the image. The syntax is the following: INSTRUCTION ARGUMENT In the previous example we have: FROM: defines the base image, which can be an OS or another image (every image have to be based off another image). RUN: run a particular command on the base image. COPY: copies files from the host system onto the Docker image. ENTRYPOINT: specifies the command that will be run when the container is started. Layered architecture Docker follows a layered architecture so each INSTRUCTION represents a different layer, which contains only the changes from the layer before, and may serve as a snapshot from which to start the build from a particular layer. Also, Docker caches the layers, so if there is an error, the build would start from the last layer that did not produce a failure. Also, if you were to add additional steps, Docker would not start the build from scratch. "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Docker/index.html",
    "title": "index",
    "body": " Back Docker Intro Set Up Container Image Environment Variables CMD vs ENTRYPOINT Networking Storage Docker Compose Docker Compose Networks Docker Registry Docker Engine Docker on Windows and Mac Container Orchestration Docker Swarm Kubernetes "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Docker/nerworking.html",
    "title": "Networking",
    "body": " Back Networking When you install Docker it creates three networks automatically: Bridge: default network the container get attached to. $ docker run ubuntu none: $ docker run ubuntu --network=none host $ docker run ubuntu --network=host Bridge This is a private internal network created by Docker on the host. All containers can access each other using their internal IP (usually subnets of 172.17.0.3). To access from outside you have to map a port of the container to a port of the host. host Another way to configure the network is to associate the container to the host's network, removing all kind of network isolation between the Docker host and the Docker container. This way when you run a server on port 5000 it would automatically accessible from the host on the port 5000 without needing to map it to a host's port. This prevents you from using the same ports for different applications. none The containers are not attached to any network and are, therefore, isolated from any other containers so they do not have any access to the external network or other containers. User defined networks Because with the default internal network, the containers can access each other, it is sometimes desirable to create new internal networks: $ docker network create --drive bridge --subnet 172.18.0.0/16 <network_name> To list the created networks: $ docker network ls Inspect network In order to see the network configuration use inspect and head to the Networks section: $ docker inspect ( container_name | container_id ) . . . \"MacAddress\": \"aa:bb:cc:dd:ee:ff\", \"Networks\": { \"bridge\": { \"IPAMConfig\": null, \"Links\": null, \"Aliases\": null, \"NetworkID\": \"24af0d...\", \"EndpointID\": \"3449a29...\", \"Gateway\": \"172.17.0.1\", \"IPAddress\": \"172.17.0.3\", \"IPPrefixLen\": 16, \"IPv6Gateway\": \"\", \"GlobalIPv6Address\": \"\", \"GlobalIPv6PrefixLen\": 0, \"MacAddress\": \"02:42:ac:11:00:03\", \"DriverOpts\": null } } . . . Embedded DNS When containers in the same subnet may want to access each other, for that you could hard code the internal IP assigned to the containers. However this is not advisable, as this IP may change when the container is started in another occasion in the future. Because of that all containers in a Docker host can resolve each other using their names. This is possible has a built-in DNS server for this purpose that runs at 172.0.0.11. "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Docker/compose.html",
    "title": "Docker Compose",
    "body": " Back Docker Compose It is used to set up a complex application running multiple services. Docker commands map to Docker Compose as follows: To start the application we run: $ docker-compose up Build If we would like to tell Docker Compose to build a Docker build instead of pulling an image we use the build keyword inside a service instead of the image keyword. And we specify the location of the directory which contains the application code and a Dockerfile. vote: build: ./vote ports: - 5000:80 links: - redis Versions Different Docker Compose versions have different formats and functionality. Version 2 From version 2 on, you must specify the Docker Compose version by adding to the top of the file: version: 2 Also, all of the different containers should be listed under a sevices section. And now, links are no longer needed as Docker creates a virtual network and attaches all of the services to this network with the name of the service. Finally, a depends_on keyword is introduced to force a order of startup. "
  },
  {
    "id": "https://albamr09.github.io/Notes/WebDev/Docker/windows_mac.html",
    "title": "Docker on Windows and Mac",
    "body": " Back Docker on Windows and Mac On these systems we have two options: Docker Toolbox (usually for older PC's): installs Docker along with VirtualBox to create a Linux system on which Docker is run. Hypervirtualization: installs Docker and uses Hyper-V (comes with Windows Server or Professional edition) or Hyperkit on Mac. This allows Docker to create a Linux machine under the hood and run Docker in it. Windows Containers The options just discussed will only work for Linux applications and containers. In 2016 Microsoft announced support for Windows containers, there are two types: Windows Server Container: the containers share the kernel, as regular Linux containers do. Hyper-V isolation: each container is run within a highly optimized virtual machine, so complete kernel isolation between the containers and the underline host is guaranteed. Base Images Where in Linux we had the debian, ubuntu or alpine base images in windows we have two options: Windows Server Core Nano Server: this is a headless deploy of the Windows Server, that is, the lightweight option. "
  },
  {
    "id": "https://albamr09.github.io/Notes/Other/VimWiki/index.html",
    "title": "Vim Wiki",
    "body": " Back Vim Wiki Key Bindings Convert current file to html: ,wh See html file in browser: ,whh More info on VimWiki LaTeX Inline \\(a = 1\\) Equation \\begin{align} A \\end{align} "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/04. Process/Data Cleaning is a Must.html",
    "title": "Data Cleaning is a Must",
    "body": " Back Data Cleaning is a Must Dirty data: data that is incomplete, incorrect or irrelevant to the problem Clean data: data that is complete, correct and relevant to the problem Types of dirty data: Duplicate data: data record that shows up more than once Outdated data: data that is old which should be replaced with newer and more accurate information Incomplete data: data that is missing important fields Incorrect/Inaccurate data: data that is complete but inaccurate Inconsistent data: data that uses different formats to represent the same thing Data validation: tool for checking the accuracy and quality of data before adding or importing it. "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/04. Process/Cleaning Data in Spreadsheets.html",
    "title": "Cleaning Data in Spreadsheets",
    "body": " Back Cleaning Data in Spreadsheets Data Mapping: process of matching fields from one data source to another. Data Cleaning exercise: Boba Tea Shop Data Cleaning "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/04. Process/Data Integrity and Analytics Objectives.html",
    "title": "Data Integrity and Analytics Objectives",
    "body": " Back Data Integrity and Analytics Objectives Data Integrity: accuracy, completeness, consistency and trustworthiness of data throughout its life cycle. Data can be compromised through: Data replication: process of storing data in multiple locations (data can be out of sync) Data transfer: process of copying data from one place to another (data can be incomplete because the copying process was interrupted) Data manipulation: process of changing data "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/04. Process/Begin Cleaning Data.html",
    "title": "Begin Cleaning Data",
    "body": " Back Begin Cleaning Data What and how to clean Data merging: process of combining two or more datasets into a single dataset Data compatibility: describes how well two or more datasets are able to work together "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/04. Process/Manually Cleaning Data.html",
    "title": "Manually Cleaning Data",
    "body": " Back Manually Cleaning Data Verification: process to confirm that the data-cleaning was well-executed and the resulting data is accurate and reliable. Changelog: file containing a chronologically ordered list of modifications made to a project "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/04. Process/index.html",
    "title": "Process Data from Dirty to Clean",
    "body": " Back Process Data from Dirty to Clean First Week > 10/04/2022 - 10/04/2022 Focusing on Integrity Data Integrity and Analytics Objectives Overcoming the Challenges of Insufficient Data Testing your Data Consider the Margin of Error Weekly Challenge Second Week > 10/04/2022 - 10/04/2022 Data Cleaning is a Must Begin Cleaning Data Cleaning Data in Spreadsheets Weekly Challenge Third Week > 10/04/2022 - 11/04/2022 Using SQL to Clean Data Learn Basic SQL Queries Transforming Data Weekly Challenge Fourth Week > 11/04/2022 - 11/04/2022 Manually Cleaning Data Documenting Results and the Cleaning Process Weekly Challenge Fifth Week > 11/04/2022 - 11/04/2022 The Data Analyst Hiring Process Understand the Elements of a Data Analyst Resume Highlighting Experiences on Resumes Exploring Areas of Interest "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/04. Process/Overcoming the Challenges of Insufficient Data.html",
    "title": "Overcoming the Challenges of Insufficient Data",
    "body": " Back Overcoming the Challenges of Insufficient Data Types of insufficient data: Data from only one source Data that keeps updating Outdated data Geographically-limited data Common data errors: Random sampling: way of selecting a sample from a population so that every possible type of the sample has an equal chance of being chosen Margin of error: Since a sample is used to represent a population, the sample’s results are expected to differ from what the result would have been if you had surveyed the entire population. This difference is called the margin of error. Confidence level: How confident you are in the survey results. For example, a 95% confidence level means that if you were to run the same survey 100 times, you would get similar results 95 of those 100 times. Confidence interval: The range of possible values that the population’s result would be at the confidence level of the study. Statistical significance: The determination of whether your result could be due to random chance or not. The greater the significance, the less due to chance. Determine the sample size Don’t use a sample size less than 30. It has been statistically proven that 30 is the smallest sample size where an average result of a sample starts to represent the average result of a population. The confidence level most commonly used is 95%, but 90% can work in some cases. For a higher confidence level, use a larger sample size To decrease the margin of error, use a larger sample size For greater statistical significance, use a larger sample size "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/04. Process/Testing your Data.html",
    "title": "Testing your Data",
    "body": " Back Testing your Data Statistical Power: probability of getting meaningful results from a test (value between 0 and 1, 0.6 means there is 60% chance as statistically significant result) Hypothesis testing: way to see if a survey or experiment has meaningful results Statistically significant: it means the results of the test are real and not an error caused by random chance Sample size calculators Sample size calculator by surveymonkey.com Sample size calculator by raosoft.com "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/04. Process/Using SQL to Clean Data.html",
    "title": "Using <code>SQL</code> to Clean Data",
    "body": " Back Using SQL to Clean Data Differences between Spreadsheets and SQL: Spreadsheets Generated with a program Access to the data you input Stored locally Small datasets Working independently Built-it features SQL A language used to interact with database programs Can pull information from different sources in the database Stored across a database Larger datasets Tracks changes across teams Useful across multiple programs "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/05. Analyze/Data Analysis Basics.html",
    "title": "Data Analysis Basics",
    "body": " Back Data Analysis Basics The four phases of analysis: Organize data Format and adjust data Get input from others Transform data "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/05. Analyze/Use JOINs to Aggregate Data in SQL.html",
    "title": "Use JOINs to Aggregate Data in SQL",
    "body": " Back Use JOINs to Aggregate Data in SQL There are four general ways in which to conduct JOINs in SQL queries: INNER, LEFT, RIGHT, and FULL OUTER. INNER JOIN or JOIN INNER JOIN returns records if the data lives in both tables. LEFT JOIN LEFT JOIN returns all the records from the left table and only the matching records from the right table. The nulls are in the right table, because it returns all of the values in the left table with the joined values (if they exist) in the right table. It might be the case that there is no value in the right table linked to a record in the left, so it is null. RIGHT JOIN RIGHT JOIN returns all records from the right table and the corresponding records from the left table. The nulls are in the left table, same as above. FULL OUTER JOIN FULL OUTER JOIN returns all records from the specified tables. So there are null values in both of the table. "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/05. Analyze/The Data Validation Process.html",
    "title": "The Data Validation Process",
    "body": " Back The Data Validation Process Six types of data validation: Data type: Check that the data matches the data type defined for a field Data range: Check that the data falls within an acceptable range of values defined for the field. Data constraints: Check that the data meets certain conditions or criteria for a field. Data consistency: Check that the data makes sense in the context of other related data. Data structure: Check that the data follows or conforms to a set structure. Code validation: Check that the application code systematically performs any of the previously mentioned validations during user data input. "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/05. Analyze/index.html",
    "title": "Analyze Data to Answer Questions",
    "body": " Back Analyze Data to Answer Questions First Week > 11/04/2022 - 11/04/2022 Let's get organized Data Analysis Basics Organize Data for Analysis Sort Data in Spreadsheets Sort Data using SQL Weekly Challenge Second Week > 11/04/2022 - 11/04/2022 Convert and Format Data Combine Multiple Datasets Get Support during Analysis Weekly Challenge Third Week > 11/04/2022 - 11/04/2022 VLOOKUP for Data Aggregation Use JOINs to Aggregate Data in SQL Work with Subqueries Weekly Challenge Fourth Week > 11/04/2022 - 11/04/2022 Get Started with Data Calculations Pivot Pivot Pivot Learn More SQL Calculations The Data Validation Process Using SQL with Temporary Tables Weekly Challenge Course Challenge "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/05. Analyze/Convert and Format Data.html",
    "title": "Convert and Format Data",
    "body": " Back Convert and Format Data Practice CONCAT function "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/05. Analyze/VLOOKUP for Data Aggregation.html",
    "title": "VLOOKUP for Data Aggregation",
    "body": " Back VLOOKUP for Data Aggregation Data Aggregation: process of gathering data from multiple sources in order to combine it into a single summarized collection Practice VLOOKUP function "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/06. Visualize/index.html",
    "title": "Share Data Through the Art of Visualization",
    "body": " Back Share Data Through the Art of Visualization First Week > 11/04/2022 - 11/04/2022 Communicating your Data Insights Understand Data Visualization Design Data Visualizations Explore Visualization Considerations Second Week > 11/04/2022 - 12/04/2022 "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/01. Foundations/The importance of fair business decisions.html",
    "title": "The importance of fair business decisions",
    "body": " Back The importance of fair business decisions Issue: topic or subject to investigate Question: designed to discover information Problem: obstacle or complication that needs to be worked out. Business task: question or problem data analysis answers for a business "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/01. Foundations/Understanding the data ecosystem.html",
    "title": "Understanding the data ecosystem",
    "body": " Back Understanding the data ecosystem Data is a collection of facts Data ecosystems are made up of elements that interact with one another in order to procude manage store organize analyze and share data. Data analysis is the collection, transformation and organization of data in order to draw conclusions, make predictions, and drive informed decision-making Data analytics is the science of data Data-driven-decision-making is using facts to guide business strategy Data science is a field of study that uses raw data to create new ways of modelling and understanding the unkown Dataset is a collection of data that can be manipulated or analyzed as a unit Subject Matter Experts: people that are familiar with the bussiness problem “How do I define success for this project?” Ask yourserlf: What kind of results are needed? Who will be informed? Am I answering the question being asked? How quickly does a decision need to be made? Data Analysis Life Cycle Ask: Business Challenge/Objective/Question Prepare: Data generation, collection, storage, and data management Process: Data cleaning/data integrity Analyze: Data exploration, visualization, and analysis Share: Communicating and interpreting results Act: Putting your insights to work to solve the problem "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/01. Foundations/Thinking about analytical thinking.html",
    "title": "Thinking about Analytical Thinking",
    "body": " Back Thinking about Analytical Thinking What is analytical thinking? Is identifying and defining a problem and then solving it by using data in an organized, step-by-step manner. The five key aspects to analytical thinking are: Visualization: is the graphical representation of information (helps data analysts understand and explain information more effectively) Strategy: it helps data analysts see what they want to achieve with the data and how to get there. It allows them to stay focused and on track. Problem-orientation: is about keeping the problem as the priority throughout the entire project. Correlation: is about being able to pick up and define relations in data. (Correlation does not equal causation) Big-picture and detail-oriented thinking: is being able to see the big picture as well as the details of a problem Questions frequently asked by data analysts What is the root cause of a problem? Where are the gaps in our process? What did we no consider before? Use the rule of the five \"why's\" to reveal the root cause. This rule consists of asking five times why, once each time an answer is provided. To identify gaps in a process the technique gap analysis is used. It is a method for examining and evaluating how a process works currently in order to get where you want to be in the future. The steps are: Identify where you are now and where you want to be in the future Define the gaps between the two stages Determine how to bridge them "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/01. Foundations/learning-log.html",
    "title": "Learning Log",
    "body": " Back Learning Log Think about data in daily life 01/04/2022 Instructions You can use this document as a template for the learning log activity: Think about data in daily life. We recommend that you save every learning log in one folder and include a date in the file name to help you stay organized. Important information like course number, title, and activity name are already included. After you finish your learning log entry, you can come back and reread your responses later to understand how your opinions on different topics may have changed throughout the courses. Create a list of at least five questions What areas of a city have more pedestrians At what point in their life do people consume less Which places are more likely to return an amazon package Which kind of films tend to get worse/better reviews on letterbox How many women are in stem At what time in the day do i feel more energized How many words do i read every day How does the number of books a read vary throughout the year What type of movie do people tend to enjoy How many hours am i productive Reflection Write 2-3 sentences (40-60 words) in response to each of the questions below What are some considerations or preferences you want to keep in mind when making a decision? First of all you have to look at the problem objectively, without any bias towards the probable solution, as to avoid jumping to less efficient solutions. Also you may want to summarize each solution/option to its core idea, so it will be easier to pick up the advantages and disadvantages What kind of information or data do you have access to that will influence your decision? I may have a journal where I introduce the number of books a read (as in I registry each book I have read as an entry) Are there any other things you might want to track associated with this decision? Other characteristics of the books, other than the time when they were finished may help analyze a trend: the time it took for me to read it, the subject of the book, the language of the book, etc. Consider how data analysts approach tasks 01/04/2022 Instructions You can use this document as a template for the learning log activity: Consider how data analysts approach tasks. We recommend that you save every learning log in one folder and include a date in the file name to help you stay organized. Important information like course number, title, and activity name are already included. After you finish your learning log entry, you can come back and reread your responses later to understand how your opinions on different topics may have changed throughout the courses. Review the 6 phases of data analysis Consider how the data analysts at Google used the data analysis process to break down their analysis project: The analysts asked questions to define both the issue to be solved and what would equal a successful result. Next, they prepared by building a timeline and collecting data with employee surveys, which should be inclusive. They processed the data by cleaning it to make sure it was complete, correct, relevant, and free of errors and outliers. They analyzed the clean employee survey data. Then the analysts shared their findings and recommendations with team leaders. Afterward, leadership acted on the results and focused on improving key areas. Reflection Write 2-3 sentences in response to each of the questions below Did the details of the case study help to change the way you think about data analysis? Why or why not?? Even though I am familiar with the process and steps one has to follow to perform data analysis, I did not really think about the asking part of it, or the showing your results in a way everybody can understand. Did you find anything surprising about the way the data analysts approached their task? Not surprising, every step that was laid out seems to make sense. Also coming from a CS background all the workflow of asking questions to define the needs of the client is very similar. What else would you like to learn about data analysis? I would like to know how to extract/find trends in data, be able to turn a heap of information to something useful Explore data from your daily life 02/04/2022 Instructions Create a list exploring an area of your daily life and include details, such as the date, time, cost, quantity, size, etc: 28/03 - Slept 6 hours, moderately well rested 29/03 - Slept 7 hours, slightly tired 30/03 - Slept 5 hours, very tired 31/03 - Slept 4.5 hours, very tired 01/04 - Slept 7 hours, tired Reflection Are there any trends you noticed in your behavior? Whenever something stressful comes up I get very little sleep. Also because I, one, finished a math book (so I searched a for a new resource to learn) and, two, got a new job (the resource I chose was this one) I suddenly was trying to do everything in a frenzy, and so stayed up until way later than usual. Are there factors that influence your decision-making? I am used to having 2 to 3 hours free before going to sleep, so if I do not manage to have enough time to have that amount of hours, I will just stay up until later, and kind of make the free time even longer because of the anxiety of knowing I should go to sleep. Is there anything you identified that might influence your future behavior? I will sleep better if I can manage better my time (not cram as many tasks a day) and reduce my anxiety whenever a slight change occurs in my life. Reflect on your skills and expectations 02/04/2022 Instructions The table has a row for each essential aspect of analytical skills: Curiosity: a desire to know more about something, asking the right questions Understanding context: understanding where information fits into the “big picture” Having a technical mindset: breaking big things into smaller steps Data design: thinking about how to organize data and information Data strategy: thinking about the people, processes, and tools used in data analysis You will put an X in the column that you think best describes your current level with each aspect. The three ratings are: Strength: This is an area you feel is one of your strengths Developing: You have some experience with this area, but there’s still significant room for growth Emerging: This is new to you, and will gain experience in this area from this course Then update the Comments/Plans/Goals column with a quick note to yourself about why you chose those ratings. Complete the Analytical Skills Table Analytical skills Strength Developing Emerging Comments/Plans/Goals Curiosity     X I am usually not very curious, I more like to have the knowledge than explore the unknown Context   X   I am pretty good at spotting trends Technical mindset X     Coming from a CS background I am very used to try to resolve different types of problems Data Design X     For the same reason as above, I am familiar with having to chose a data structure/design that fits well your needs Data Strategy     X I am not used to having to deal with the people or timeline of a project Reflection What do you notice about the ratings you gave yourself in each area? How did you rate yourself in the areas that appeal to you most? Generally speaking I am most proficient at the one that I have been trained academically in, and are more technical. The ones that require soft skills, I am worse at. If you are asked to rate your experience level in these areas again in a week, what do you think the ratings will be, and why do you think that? I think most of them will stay the same, but maybe I will become better in data strategy with the help of this course. How do you plan on developing these skills from now on? Well curiosity wise, I think the best way for me to go forward is to start projects of my own to see all the caveats a data analysis project can entail. And when it comes to data strategy, my way of improving would be to understand better how to manage a project and also the different tools available to manage data. Organize your data in a table Introduction You have been collecting data from the beginning of the course. Take a moment to consider the data you have gathered in your learning log. Now, determine how you could organize your data in a table. Structuring your data Date Time Asleep Rest level 28/03 6h moderately well rested 29/03 7h slightly tired 30/03 5h very tired 31/03 4.5h very tired 01/04 7h tired Reflection In a new learning log entry, follow the instructions in the template, and add a table to organize your data. Then, write 3-5 sentences (60-100 words) on opportunities in your personal life or current job to organize data into tables. I could gather data about how many hours a day I am productive at my job How many time I spend logging my work, instead of working Generating a chart from a spreadsheet Introduction So far, you have planned a project, identified the data you need, and collected the data. Earlier in this course, you completed a learning log where you recorded some data from your daily life, then took the practical step of organizing it. Now, you’re ready for the most satisfying step of the data analysis project: visualizing your data! For this activity, you will move your data to a spreadsheet and bring it to life in a chart. Chart Sleep data Reflect on the data analysis process Reflect Which part(s) of the data analysis process did you enjoy the most? What did you enjoy about it? I enjoyed both the process, analysis and share steps because I feel it was the more interactive (as asking questions to oneself is not that fun), and allowed me to use the different tools discussed during the course. What were some of the key ideas you learned in this course? The importance of following through each step to obtain a thorough and clear insight on the data you are analyzing. And also, the need of taking into account what the stakeholder hopes for when analyzing the data. Are there concepts or portions of the content that you would like to learn more about? If so, what are they? Which upcoming course do you think would teach you the most about this area? I am so very excited about the visualization part of the data analysis. Because I have never dug deep enough into it, as I may have into the analysis or process step. Now that you've gained experience doing data analysis, how do you feel about becoming a data analyst? Have your feelings changed since you began this course? If so, how? Well, I am mostly doing this course for fun. But sure being a data analyst still sounds exciting enough "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/01. Foundations/Structured Query Language.html",
    "title": "Structured Query Language",
    "body": " Back Structured Query Language Query: a request for data or information from a database. "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/01. Foundations/Embrace your data analyst skills.html",
    "title": "Embrace your data analyst skills",
    "body": " Back Embrace your data analyst skills The five key data analyst skills are Curiosity Understanding context: is the condition in which something exists or happens, could be a structure or environment. Having a technical mindset: is the ability to break things down into smaller steps or pieces and work with them in an orderly and logical way Data design: is how to organize information (typically has to do with databases) Data strategy: is the management of The people: they know how to use the right data to find solutions on the problem you are working on The processes: the path to the solution is clear and accessible The tools: make sure the right technology is being used for the job. Analytical skills: are the qualities and characteristics associated with solving problems using facts "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/01. Foundations/The data analysis toolbox.html",
    "title": "The data analysis toolbox",
    "body": " Back The data analysis toolbox Tools data analysts use: Spreadsheets Query languages for databases: computer programming language that allows you to retrieve and manipulate data from a database (Structured Query Language or SQL) Visualization tools "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/01. Foundations/Follow the data life cycle.html",
    "title": "Follow the data life cycle",
    "body": " Back Follow the data life cycle The life cycle of data is Plan: during planning a business decides: What data is needed How to manage the data throughout its life cycle Who is responsible for the data What is the desired outcome Capture: this is when data is collected from different sources and brought into the company. Manage: refers to how we store the data, the tools we use to keep it secure, and the actions taken to make sure it is maintained properly. Analyze: use the data to solve problems, make good decisions, and reach the company's goals. Archive: means storing data in a place where it is still available, but it may not be used again. Destroy: Remove data from storage and delete any shared copies of the data. A database is a collection of data stored in a computer system. "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/01. Foundations/Transforming Data into insights.html",
    "title": "Transforming Data into insights",
    "body": " Back Transforming Data into insights The six steps of the data analysis process that you have been learning in this program are: ask, prepare, process, analyze, share, and act. Ask: ask effective questions to define the project and what is the desired result Prepare: build a timeline, decide how to gather data, how and when to communicate with your client Process: clean the data, make sure it is complete, correct, relevant free of errors and outliers Analyze: analyze the gathered data to search for solutions, findings, etc. Share: know how to show and display your findings to your team leaders Act: decide how to best implement changes and take action "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/01. Foundations/Outlining the data analysis.html",
    "title": "Outlining the data analysis process",
    "body": " Back Outlining the data analysis process Stakeholder: people who have invested time and resources into a project and are interested in the outcome "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/01. Foundations/index.html",
    "title": "Foundations: Data, Data, Everywhere",
    "body": " Back Foundations: Data, Data, Everywhere Learning Log First Week > 28/03/2022 - 01/04/2022 Get Started Transforming Data into insights Understanding the data ecosystem Program expectations Weekly challenge 1 Second Week > 02/04/2022 - 03/04/2022 Embrace your data analyst skills Thinking about analytical thinking Thinking about outcomes Weekly challenge 2 Third Week > 04/04/2022 - 05/04/2022 Follow the data life cycle Outlining the data analysis The data analysis toolbox Weekly challenge 3 Fourth Week > 06/04/2022 - 06/04/2022 Mastering spreadsheets basics Structured Query Language Data visualization Weekly challenge 4 Fifth Week > 06/04/2022 - 07/04/2022 Data analyst job opportunities The importance of fair business decisions Optional: Exploring your next job Weekly challenge 5 Course challenge "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/01. Foundations/Optional: Exploring your next job.html",
    "title": "Data analyst roles and job descriptions",
    "body": " Back Data analyst roles and job descriptions Data analysts, data scientists, and data specialists sound very similar but focus on different tasks.The table below illustrates some of the overlap and distinctions between them: "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/01. Foundations/Mastering spreadsheets basics.html",
    "title": "Mastering spreadsheets basics",
    "body": " Back Mastering spreadsheets basics Attribute: characteristic or quality of data used to label a column in a table. Observation: all the attributed for something contained in a row of a data table. Formula: set of instructions that performs a specific action using the data in a spreadsheet. "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/index.html",
    "title": "Google Data Analyst Certificate",
    "body": " Back Google Data Analyst Certificate > 28/03/2022 - Foundations: Data, Data, Everywhere Ask Questions to Make Data-Driven Decisions Prepare Data for Exploration Process Data from Dirty to Clean Analyze Data to Answer Questions Share Data Through the Art of Visualization Data Analysis with R Programming Google Data Analytics Capstone_ Complete a Case Study "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/03. Prepare/Working with databases.html",
    "title": "Working with Databases",
    "body": " Back Working with Databases A relational database is a database that contains a series of tables that can be connected to show relationships. Some tables don't require a primary key. For example, a revenue table can have multiple foreign keys and not have a primary key. A primary key may also be constructed using multiple columns of a table. This type of primary key is called a composite key. Ice Cream Dataset Analysis "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/03. Prepare/Data ethics and privacy.html",
    "title": "Data Ethics and Privacy",
    "body": " Back Data Ethics and Privacy Data Ethics: standards of right and wrong about how data is collected, shared and used Aspects of data ethics: Ownership: individuals own the raw data they provide and they have control over the usage, processing and how it is shared. Transaction transparency: all data-processing activities and algorithms should be completely explainable and understood by the individual who provides their data. Consent: individual's right to know how and why their data will be used before agreeing to provide it. Currency: individuals should be aware of financial transactions resulting from the use of their personal data. Privacy: preserving a data subject's information and activity any time a data transaction occurs. Openness: free access usage and sharing of data. Personally identifiable information , or PII , is information that can be used by itself or with other data to track down a person's identity. Data anonymization is the process of protecting people's private or sensitive data by eliminating that kind of information. Open data standards: Availability and access: the data is available as a whole Reuse and redistribution: data is provided under terms that allow it to be reused and redistributed Universal participation: everybody should be able to use the data "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/03. Prepare/Collecting Data.html",
    "title": "Collecting Data",
    "body": " Back Collecting Data These are the key data collection considerations: How the data will be collected Determine the time frame Existing data? Choose the data sources Decide what data to use New data? How much data to collected Select the right data type Type of data collected: First-party data: collected by an individual using their own resources Second-party data: collected by a group directly from its audience and then sold Third-part data: collected from outside sources who did not collect it directly Population: All possible data values in a certain dataset Sample: part of a population that is representative of the population "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/03. Prepare/Explore data credibility.html",
    "title": "Explore Data Credibility",
    "body": " Back Explore Data Credibility Good data is ROCCC: Reliable Original: Check the quality of the data with the original source Comprehensive: contain all critical information needed to find a solution for a problem Current Cited: should be cited by trusted sources Bad data is data that does not satisfies one or more of the characteristics listed above. Some good sources for data are: Vetted public datasets Governmental agency data Academic papers "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/03. Prepare/Sorting and filtering.html",
    "title": "Sorting and Filtering",
    "body": " Back Sorting and Filtering Little exercise of sorting and filtering: Student Performance Data "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/03. Prepare/Working with large datasets in SQL.html",
    "title": "Working with Large Datasets in <code>SQL</code>",
    "body": " Back Working with Large Datasets in SQL Big Query "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/03. Prepare/Understanding open data.html",
    "title": "Understand Open Data",
    "body": " Back Understand Open Data Sites and resources for open data: U.S. government data site U.S. Census Bureau Open Data Network Google Cloud Public Datasets Dataset Search "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/03. Prepare/Effectively organize your data.html",
    "title": "Effectively organize your data",
    "body": " Back Effectively organize your data File naming DO's: Work out your conventions early Align file naming with your team Make sure file names are meaningful Keep file names short and simple "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/03. Prepare/index.html",
    "title": "Prepare for Data Exploration",
    "body": " Back Prepare for Data Exploration First Week > 09/04/2022 - 09/04/2022 Data Exploration Collecting Data Differentiate between data formats and structures Explore data types and values Weekly challenge Second Week > 10/04/2022 - 10/04/2022 Unbiased and objective data Explore data credibility Data ethics and privacy Understanding open data Weekly challenge Third Week > 10/04/2022 - 10/04/2022 Working with databases Managing data with metadata Accessing different data sources Sorting and filtering Working with large datasets in SQL Weekly challenge Fourth Week > 10/04/2022 - 10/04/2022 Effectively organize your data Securing data Weekly challenge Fifth Week > 10/04/2022 - 10/04/2022 Create or enhance our online presence Build a data analytics network Sixth Week > 10/04/2022 - 10/04/2022 Course challenge "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/03. Prepare/Differentiate between data formats and structures.html",
    "title": "Differentiate between data formats and structures",
    "body": " Back Differentiate between data formats and structures Here are some types of data: Discrete data: is counted and has a limited number of values Continuous data: is measured and can have almost any numeric value - Nominal data: type of qualitative data that is categorized without a set order Ordinal data: type of qualitative data that with a set order or scale - Internal data: data that lives within a company's own systems External data: data that lives and is generated outside of an organization - Structured data: data organized in a certain format such as rows and columns Unstructured data: data that is not organized in any easily identifiable manner Data Model: model that is used for organizing data elements and how they relate to one another. Types of data modelling: Conceptual data modelling: gives a high level view of the data structure Logical data modelling: focuses on relationships, attributes and entities in the database. Physical data modelling: shows how a database operates. (column names, table names, data types, etc) "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/03. Prepare/Securing data.html",
    "title": "Securing Data",
    "body": " Back Securing Data Data security: protecting data from unauthorized access or corruption by adopting safety measures Some security measures: Encryption: uses a unique algorithm to alter data and make it unusable by users and applications that don’t know the algorithm. Tokenization: replaces the data elements you want to protect with randomly generated data referred to as a “token”. "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/03. Prepare/Managing data with metadata.html",
    "title": "Managing Data with Metadata",
    "body": " Back Managing Data with Metadata Metadata: is data about data. Types of metadata: Descriptive: describes a piece of data Structural: describes how a piece of data is organized. Administrative: indicates the technical source of a digital asset. Metadata repository: database created to store metadata "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/03. Prepare/Unbiased and objective data.html",
    "title": "Unbiased and Objective Data",
    "body": " Back Unbiased and Objective Data Bias: preference in favor or against a person or thing Data Bias: type of error that systematically skews results in a certain direction Unbiased sampling: when a sample is representative of the population being measured To avoid bias when sampling, make sure to take random samples and make visualizations comparing the population with your sample to check if the sample is representative. Types of bias: Sampling Bias: when a sample is not representative of the population as a whole Observer Bias (experimenter bias/research bias): tendency for different people to observe things differently Interpretation Bias: tendency to always interpret ambiguous situations in a positive or negative way Confirmation Bias: tendency to search for or interpret information in a way that confirms pre-existing beliefs "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/02. Ask/Connecting the data dots.html",
    "title": "Connecting the Data Dots",
    "body": " Back Connecting the Data Dots There are two types of data: Small data: is specific, recorded in a short-time period and used to make day-to-day decisions. (analyze with spreadsheets) Big data: is large and less specific, recorded in a long-time period and used to make big decisions. (analyze with spreadsheets) The three (or four) V words for big data Volume: amount of data. Variety: different kinds of data. Velocity: how fast can it be processed. Veracity: quality and reliability of data. "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/02. Ask/Take action with data.html",
    "title": "Take action with data",
    "body": " Back Take action with data Ask Define the problem you're trying to solve Make sure you fully understand the stakeholder's expectations Focus on the actual problem and avoid any distractions Collaborate with stakeholders and keep an open line of communication Take a step back and see the whole situation in context Prepare You will decide what data you need to collect in order to answer your questions and how to organize it. What metrics to measure Locate data in your database Create security measures to protect that data Process You will need to clean up your data to get rid of any possible errors, inaccuracies, or inconsistencies. Using spreadsheet functions to find incorrectly entered data Using SQL functions to check for extra spaces Removing repeated entries Checking as much as possible for bias in the data Analyze Now you may need to think analytically about your data. You might sort and format your data to make it easier to: Perform calculations Combine data from multiple sources Create tables with your results Share Summarize your results with clear and enticing visuals of your analysis using data via tools like graphs or dashboards. Act Now it’s time to act on your data. You will take everything you have learned from your data analysis and put it to use. This could mean providing your stakeholders with recommendations based on your findings so they can make data-driven decisions. "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/02. Ask/Functions in spreadsheets.html",
    "title": "Functions in spreadsheets",
    "body": " Back Functions in spreadsheets In this activity, you will import a dataset, build a custom data table, and use functions to analyze your data. For this activity, imagine you're a data analyst working for a recruiting agency. This recruiting agency helps all sorts of companies find skilled people to fill open data analytics jobs. The agency has collected data about job applications for opportunities posted on its website for the year 2019. Job Applications Spreadsheet "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/02. Ask/Solve problems with data.html",
    "title": "Solve problems with data",
    "body": " Back Solve problems with data Data analysts typically work with six problem types Making predictions: using data to make an informed decision about how things might be in the future Categorizing things: assigning information to different groups or clusters based on common features Spotting something unusual: identifying data that is different from the norm Identifying themes: Grouping categorized information into broader concepts Discovering connections: finding similar challenges faced by different entities and combining data and insights to address them Finding patterns: using historical data to understand what happened in the past and is therefore likely to happen again "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/02. Ask/Craft effective questions.html",
    "title": "Craft effective questions",
    "body": " Back Craft effective questions Ineffective questions: Lead question: it leads you to answer in a certain way. Close ended: it can be answer with yes or no. Too vague: is too broad an lacks content. Effective questions follow the SMART methodology: Specific: simple and focuses on the problem. Measurable: can be quantified and assessed. Action-oriented: encourage change. Relevant: have significance to the problem at hand. Time-bound: specify the time to be studied. Also question must assure fairness, that is to make sure they do not reinforce bias. Question 1 You are three weeks into your new job as a junior data analyst. The company you work for has just collected data on their weekend sales. Your manager asks you to perform a “deep dive” into this data. Based on the SMART framework, which questions are most important to ask? What is the variation in number of sales between this week and the week before. What products are the ones that are most often purchased. What common characteristics do these products have in common. Which kind of costumers purchase more and most often. At what time of the week are the sales higher. How will these questions clarify the requirements and goals for the project? It will allow us to detect if there was a change in the number of sales, and so to investigate as to why It will guide to explore which products to explore It will allows us to know better our costumers How does asking detailed, specific questions benefit you when planning for a project? Can vague or unclear questions harm a project? It can be used to lay out clearly what our objectives are, without leading to bias. Yes, then can introduce misunderstandings between the clients and the analysts. "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/02. Ask/Understand the power of data.html",
    "title": "Understand the power of data",
    "body": " Back Understand the power of data Data-inspired decision making: explores different data sources to find out what they have in common Data-driven decision making: Note that there is a difference between making a decision with incomplete data and making a decision with a small amount of data. You learned that making a decision with incomplete data is dangerous. But sometimes accurate data from a small test can help you make a good decision. Quantitative data: measures of numerical facts. Qualitative data: subjective measures of qualities and characteristics. "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/02. Ask/learning-log.html",
    "title": "Learning Log",
    "body": " Back Learning Log Consider what data means to you 07/04/2022 What does data mean to you? Now, I usually picture data like a very big table full of attributes and entries. When you come across a problem and you aren’t sure of the answer or solution, what do you do? I tend to search in google for the answer of a problem How do you identify new and interesting problems to begin with? Is there a process you use to identify problems you want to solve? Generally, the problems come from me inserting myself into new technologies. This way I am more likely to come up with a new \"problem\" in the form of a project, for me to develop. "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/02. Ask/Working with spreadsheets.html",
    "title": "Working with spreadsheets",
    "body": " Back Working with spreadsheets Here are the core spreadsheets tasks: Organize your data Pivot table Sort and filter Calculate your data Formulas Functions "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/02. Ask/Follow the evidence.html",
    "title": "Follow the evidence",
    "body": " Back Follow the evidence Let's see two kinds of visual representation tools: Reports: static collection of data given to stakeholders periodically. Dashboards: monitors live incoming data. Reports Pros High level historical data Easy to design Pre-cleaned sorted data Cons Continual maintenance Less visually appealing Static Dashboards Pros Dynamic, automatic, interactive More stakeholder access Low maintenance Cons Labor-intensive design Can be confusing Potentially uncleaned data Pivot table: data summarization tool used in data processing. They are used to summarize, sort, reorganize, group, count, total or average data stored in a database. Metric: quantifiable type of data than can be used for measurement. Types of dashboards: Strategic: focuses on long term goals and strategies at the highest level of metrics Operational: short-term performance tracking and intermediate goals Analytical: consists of the datasets and the mathematics used in these sets "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/02. Ask/Problem-solving and effective questioning.html",
    "title": "Problem-solving and effective questioning",
    "body": " Back Problem-solving and effective questioning Structured thinking: process of: Recognizing the current problem Organizing the available information Revealing gaps and opportunities Identifying options "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/02. Ask/index.html",
    "title": "Ask Questions to Make Data-Driven Decisions",
    "body": " Back Ask Questions to Make Data-Driven Decisions Learning Log First Week > 07/04/2022 - 08/04/2022 Problem-solving and effective questioning Take action with data Solve problems with data Craft effective questions Weekly challenge Second Week > 08/04/2022 - 09/04/2022 Understand the power of data Follow the evidence Connecting the data dots Weekly challenge Third Week > 09/04/2022 - 09/04/2022 Working with spreadsheets Formulas in spreadsheets Functions in spreadsheets Save time with structured thinking Weekly challenge Fourth Week > 09/04/2022 - 09/04/2022 Balance team and stakeholder needs Communication is key Amazing teamwork Weekly challenge Course challenge "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/GoogleDataAnalyst/02. Ask/Save time with structured thinking.html",
    "title": "Save time with structured thinking",
    "body": " Back Save time with structured thinking Problem domain: specific area of analysis that encompasses every activity affecting or affected by the problem Scope of work: outline of the work you are going to perform in a project Deliverables: what things are being created as a result of the project Milestones Timeline Reports: how to give status updates to the stakeholders. "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/(DS0001)_MLStanfordCoursera/Aprendizaje Online.html",
    "title": "Aprendizaje Online",
    "body": " Back Aprendizaje Online En estos tipos de problemas se generan datos de forma continua, tal que para cada nuevo dato: Obtenemos \\((x, y)\\) Actualizamos \\(\\theta\\) utilizando el nuevo ejemplo: \\(\\theta_j = \\theta_j - \\alpha (h_\\theta(x) - y)x_j\\) Ejemplo Aprender a buscar. Supongamos que lo queremos aprender es aquellos resultados que le interesen más al usuario. Si tenemos los siguientes datos: \\(X\\): características del producto \\(y\\): si el usuario hace click Entonces, lo que queremos aprender es \\(P(y= 1|x;\\theta)\\), tal que por ejemplo enseñemos los 10 productos cuya probabilidad es mayor. "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/(DS0001)_MLStanfordCoursera/ExpectationMaximization/Expectation-Maximization Algorithms.html",
    "title": "Expectation Maximization",
    "body": " Back Expectation Maximization Introduction Gaussian Mixture Models EM Algorithm with GMM's E-Step M-Step Optimal Parameters of a GMM Iterative Process Recap: Anomaly Detection Generalized EM Algorithm Jensen's Inequality Motivation E-Step M-Step Putting Everything Together Derive EM for GMM E-Step M-Step Introduction This technique is employed in Density Estimation problems and Anomaly Detection. Such problems aim to represent data in a compact form using a statistical distribution, e.g., Gaussian, Beta, or Gamma. You can think of those problems as a clustering task but from a probabilistic point of view. This is what makes the EM algorithm a probabilistic generative model. Thus, if we are given \\(n\\) samples, we model them with \\(P(x)\\), such that if \\(P(x) < \\epsilon\\), where \\(\\epsilon\\) is some threshold, then we detect an anomaly. However, you may expect that a single Gaussian with its mean and variance cannot map thousands of instances in a dataset into a set of \\(K\\) clusters accurately, so we may assume that there are \\(K\\) distributions that describe the data, hence we use Mixture Models. For example, imagine you have the following dataset: It looks like the data comes from two different Gaussian distributions: So to model this data we use a Mixture of Gaussian Models. Note that if we knew by which distribution each sample was generated, we would simply use MLE, however we do not know this information, therefore we use the Expectation Maximization Algorithm and we introduce the latent variable \\(z\\) in place of the predicted output \\(y\\) we had in supervised learning algorithms. To model the data, first of all, we suppose that there is a latent (hidden/unobserved) random variable \\(z\\), and \\(x^{(i)}, z^{(i)}\\) are distributed (by a joint distribution) like so \\begin{align} P(x^{(i)},z^{(i)}) = P(x^{(i)}|z^{(i)}) P(z^{(i)}) \\end{align} Where \\(z^{(i)} \\sim Multinomial(\\phi)\\), that is \\(z^{(i)}\\) is distributed according to a multinomial distribution. This distribution models for each \\(z^{(i)}\\) the probability of it being equal to \\(1, 2, ..., K\\), where \\(K\\) is the number of clusters. This will denote the probability of a point \\(x^{(i)}\\) being drawn from each of the distributions. And \\(P(x^{(i)}|z^{(i)}=j)\\) is the probability of \\(x^{(i)}\\) being generated by the cluster \\(j\\). Where \\(x^{(i)}|z^{(i)} = j\\) is drawn from a normal distribution \\(\\mathcal{N}(\\mu_j, \\Sigma_j)\\). Gaussian Mixture Models To build a density estimator model, we cannot rely on a simple distribution. Mixture models try to tackle this limitation by combining a set of distributions to create a convex space where we can search for the optimal parameters for such distributions using Maximum Likelihood Estimation (MLE). A Mixture Model is expressed by the following equations: \\begin{align} p(x^{(i)}) = \\sum_{j=1}^K \\phi^{(i)}_j p_j(x^{(i)}) \\tag{1} \\end{align} \\begin{align} 0 \\leq \\phi^{(i)}_j \\leq 1, \\sum_{j=1}^K \\phi^{(i)}_j = 1 \\end{align} Where \\(K\\) is the number of mixture components (clusters), \\(\\phi^{(i)}_j\\)'s are the mixture weights, and \\(p_j(x^{(i)})\\)'s are members of a family of distributions (Gaussian, Poisson, Bernoulli, etc). So for each example \\(x^{(i)}\\) and for each distribution \\(j\\), each weight \\(\\phi^{(i)}_j\\) is between 0 and 1, and the sum over \\(k\\) of the weights \\(\\phi_j^{(i)}\\) for every example \\(x^{(i)}\\) equals one. Consequently, a GMM is a Mixture Model where the \\(p_j(x^{(i)})\\) is a finite combination of Gaussian Distributions. Therefore, a GMM can be precisely defined by the following set of equations: \\begin{align} p(x^{(i)};\\theta) = \\sum_{j=1}^K \\phi^{(i)}_j \\mathcal{N}(x^{(i)};\\mu_j,\\,\\Sigma_j) \\end{align} \\begin{align} 0 \\leq \\phi^{(i)}_j \\leq 1, \\sum_{j=1}^K \\phi^{(i)}_j = 1 \\end{align} Where \\(\\theta\\) is the collection of all the parameters of the model (mixture weights, means, and covariance matrices): \\begin{align} \\theta = \\{\\phi_1, \\cdots, \\phi_K, \\mu_1, \\cdots, \\mu_K, \\Sigma_1, \\cdots, \\Sigma_K\\} \\end{align} For example, the following plot shows what a GMM derived from 3 mixture components looks like: As a consequence, for each data point, \\(x^{(i)}\\) (in red), we can compute the probability that it belongs to each component (\\(P(x^{(i)}|z^{(i)} = j)\\), where \\(j = 1, 2, 3\\))(make a “soft” assignment). This quantity is called “responsibility”. EM Algorithm with GMM's The Expectation Maximization Algorithm is comprised of two steps: Guess the value of the responsibilities \\(w^{(i)}_j\\), that represent the \"amount\" of each \\(x^{(i)}\\) that was generated from the distribution \\(j\\) (or the probability that the \\(j\\)th distribution generated the point \\(x^{(i)}\\)). Compute the values of the parameters of the distributions: \\(\\theta = \\{\\phi, \\mu, \\Sigma\\}\\) according to the \\(MLE\\) (Maximum Likelihood Estimation) with respect to the parameters. Thus, we want to maximize \\(\\mathcal{L}(\\Phi, \\mu, \\Sigma)\\). E-Step In this step, as we have said, we will compute the value of the responsibilities with the given parameters \\(\\phi, \\mu, \\Sigma\\). So for each example \\(i\\) and each component (distribution) \\(j\\), the amount of \\(x^{(i)}\\) that is generated by the component \\(j\\) is given by: \\begin{align} w^{(i)}_j = P(z^{(i)} = j | x^{(i)}; \\phi_j, \\mu_j, \\Sigma_j) \\end{align} By Bayes' Rule, we can rewrite the equation as follows: \\begin{align} w^{(i)}_j = \\frac{P(x^{(i)}|z^{(i)} = j)P(z^{(i)} = j)}{\\sum_{l=1}^K \\left[P(x^{(i)}|z^{(i)} = l)P(z^{(i)} = l)\\right]} \\end{align} Note that the likelihood \\(P(x^{(i)}|z^{(i)} = j)\\) and each likelihood \\(P(x^{(i)}|z^{(i)} = l)\\) come from a Gaussian distribution, therefore: \\begin{align} P(x^{(i)}|z^{(i)} = j) = \\frac{1}{(2\\pi)^{\\frac{n}{2}}|\\Sigma_j|^{\\frac{1}{2}}} \\exp\\left(-\\frac{1}{2}(x^{(i)} - \\mu_j)^T \\Sigma_j^{-1} (x^{(i)} - \\mu_j)\\right) \\tag{2} \\end{align} To simplify notation we will denote \\(P(x^{(i)}|z^{(i)} = j)\\) as \\(\\mathcal{N}(\\mu_j, \\Sigma_j)\\). On the other hand, the prior \\(P(z^{(i)} = j)\\) comes from a Multinomial distribution, hence: \\begin{align} P(z^{(i)} = j) = \\phi_j \\tag{3} \\end{align} Combining all the expressions: \\begin{align} w^{(i)}_j = \\frac{\\phi_j\\mathcal{N}(\\mu_j, \\Sigma_j)}{\\sum_{l=1}^K \\left[\\phi_l\\mathcal{N}(\\mu_l, \\Sigma_l)\\right]} \\tag{4} \\end{align} All that is left to do is plug all of the values into each equation \\((2)\\) and \\((3)\\) (this values are known, given the equations are written in terms of the distributions' parameters) and compute each \\(w^{(i)}_j\\) given \\((4)\\). M-Step In this step what we do is maximize the log likelihood of the distributions' parameters \\(\\theta\\), that is we maximize \\(\\mathcal{L}(\\phi, \\mu, \\sigma)\\). But first, let us see how do we maximize the parameters in GMM. Optimal Parameters of a GMM We are going to show how to maximize the log likelihood of the parameters of a Gaussian Mixture Model. The goal of the GMM is to represent the distribution of the data as accurately as possible using a linear combination of Gaussian Distributions. Given a dataset \\(X\\) of \\(m\\) data points, we assume they are i.i.d (independent and identically distributed), therefore the maximum likelihood estimator over \\(X\\) can be expressed as the product of the individual likelihoods. To simplify the equations, we are going to directly apply the logarithm to the MLE function: \\begin{align} \\log \\mathcal{L}(X|\\theta) = \\log p(X|\\theta) = \\log \\prod_{i=1}^m p(x^{(i)}|\\theta) = \\sum_{i=1}^m \\log p(x^{(i)}|\\theta) \\end{align} By \\((1)\\) we know that \\(p(x^{(i)}|\\theta)\\) is a linear combination of Gaussian distributions, therefore: \\begin{align} \\log \\mathcal{L}(X|\\theta) = \\sum_{i=1}^n \\log \\sum_{j=1}^K \\phi_j^{(i)}\\mathcal{N}(x^{(i)}|\\mu_j, \\Sigma_j) \\end{align} This equation is not tractable, so we won't get an analytical solution by just taking the its derivative with respect to \\(\\theta\\) and setting it to 0. The following set of equations outline how we would evaluate it: \\begin{align} \\frac{\\delta \\mathcal{L}}{\\delta \\mu_j} \\sum_{i=1}^m \\frac{\\delta \\log p(x^{(i)}|\\theta)}{\\delta \\mu_j} = 0^T \\end{align} \\begin{align} \\frac{\\delta \\mathcal{L}}{\\delta \\Sigma_j} \\sum_{i=1}^m \\frac{\\delta \\log p(x^{(i)}|\\theta)}{\\delta \\Sigma_j} = 0 \\end{align} \\begin{align} \\frac{\\delta \\mathcal{L}}{\\delta \\phi_j} \\sum_{i=1}^m \\frac{\\delta \\log p(x^{(i)}|\\theta)}{\\delta \\phi_j} = 0 \\end{align} Observe that the computation of each parameter from \\(\\theta (\\mu, \\Sigma, \\phi)\\) depends on the other parameters in a complex way. To solve those equations, we can use the strategy of optimizing some parameters while keeping the others fixed. Going back to the Expectation Maximization Algorithm, there is a way of updating the individual parameters of a GMM given prior (initialized at random) parameters \\(\\mu, \\Sigma, \\phi\\). This approach works by updating some parameters while keeping the others fixed. So, by solving the derivatives presented above we derive the three following updating rules: \\begin{align} \\hat{\\mu}_j = \\frac{\\sum_{i=1}^m w^{(i)}_jx^{(i)}}{\\sum_{l=1}^m w^{(l)}_j} \\end{align} \\begin{align} \\hat{\\Sigma}_j = \\frac{\\sum_{i=1}^m w^{(i)}_j (x^{(i)} - \\hat{\\mu}_j)(x^{(i)} - \\hat{\\mu}_j)^T}{\\sum_{l=1}^m w^{(l)}_j} \\end{align} \\begin{align} \\hat{\\phi}_j = \\frac{1}{m} \\sum_{i=1}^m w^{(i)}_j \\end{align} To simplify a bit the notation, if \\(N_j = \\sum_{l=1}^m w^{(i)}_l\\): \\begin{align} \\hat{\\mu}_j = \\frac{1}{N_j} \\sum_{i=1}^m w^{(i)}_jx^{(i)} \\end{align} \\begin{align} \\hat{\\Sigma}_j = \\frac{1}{N_j}\\sum_{i=1}^m w^{(i)}_j (x^{(i)} - \\hat{\\mu}_j)(x^{(i)} - \\hat{\\mu}_j)^T \\end{align} \\begin{align} \\hat{\\phi}_j = \\frac{N_j}{m} \\end{align} Note that the update of \\(\\mu, \\Sigma, \\phi\\), all depend on the responsibilities (\\(w^{(i)}_j\\)), which by its turn, depends on \\(\\mu, \\Sigma, \\phi\\). That’s why there's not a closed-form solution to equations. Furthermore these equations do not aim to precisely maximize over \\(\\theta\\) the actual log likelihood. Instead they maximize a proxy function of the log-likelihood over \\(\\theta\\), namely, the expected log-likelihood, which can be derived from the log-likelihood using Jensen's Inequality as follows: \\begin{align} \\hat{\\mathcal{L}}(X|\\theta) = \\sum_{i=1}^m\\sum_{j=1}^K w^{(i)}_j \\log \\left( \\frac{\\phi_j \\mathcal{N}(x^{(i)} | \\mu_j, \\Sigma_j)}{w^{(i)}_j} \\right) \\tag{5} \\end{align} Iterative Process The process consists of an iterative process that alternates between two steps. The first step is to compute the responsibilities (E step) of each mixture component for each data point using the current parameters (\\(\\mu, \\Sigma, \\phi\\)). The second step consists of updating the parameters (M step) in order to maximize the expected log-likelihood given by \\((5)\\) The E and M steps are repeated until there is no significant progress in the proxy function of the log-likelihood computed after the M step. Recap: Anomaly Detection Thus, when the parameters \\(\\theta\\) are optimized, we can compute \\(P(x) = \\sum_{j=1}^K P(x|z = j)\\) and if \\(P(x) < \\epsilon\\) you can flag \\(x\\) as an anomaly. Generalized EM Algorithm Jensen's Inequality Convex function We are going to show what Jensen's Inequality is about. So: Let \\(f\\) be a convex function (e.g. \\(f''(x) > 0\\)) and Let \\(x\\) be a random variable, then \\begin{align} f(E[x]) \\leq E[f(x)] \\end{align} where \\(E\\) is the expected value. Further, if \\(f''(x) > 0\\) (we say f is strictly convex, that is f is not a straight line), then: \\begin{align} E[f(x)] = f(E[x]) \\leftrightarrow \\text{ x is a constant, more formally } X = E[X] \\text{ with probability 1} \\end{align} Concave function We are going to apply the same arguments with a concave function. Note that a concave function equals the negative of a convex function, thus: Let \\(f\\) be a concave function (e.g. \\(f''(x) < 0\\)) and Let \\(x\\) be a random variable, then \\begin{align} f(E[x]) \\geq E[f(x)] \\end{align} where \\(E\\) is the expected value. Further, if \\(f''(x) < 0\\) (we say f is strictly concave), then: \\begin{align} E[f(x)] = f(E[x]) \\leftrightarrow \\text{ x is a constant, more formally } X = E[X] \\text{ with probability 1} \\end{align} Some Intuition Given any convex function (the inverse also applies to concave functions), if we draw a chord between any two points, its middle point (that is the expected value of the function or \\(E[f(x)]\\)) is always above that the value of the expected value under the function (that is \\(f(E[x])\\)). Graphically: Motivation Given a model for \\(P(x, z , \\theta)\\) where \\(\\theta\\) are the parameters of the model. We only observe \\(X = \\{x^{(1)}, \\cdots, x^{(m)}\\}\\). The goal is to obtain by the Maximum Likelihood Estimation the value of \\(\\theta\\) that maximizes the log likelihood, defined as: \\begin{align} \\theta = \\underset{\\theta}{\\arg \\max{l(\\theta)} } = \\sum_{i=1}^m \\log (P(x^{(i)}; \\theta)) \\end{align} If we marginalize \\(z^{(i)}\\): \\begin{align} \\theta = \\underset{\\theta}{\\arg \\max{l(\\theta)} } = \\sum_{i=1}^m \\log \\sum_{z^{(i)}} (P(x^{(i)}, z^{(i)}; \\theta)) \\end{align} E-Step In the E-Step we construct a lower bound from a given theta: so, let's say \\(l(\\theta)\\) is the log likelihood. On the first iteration, the graph would be as follows: And on the second iteration: We iterate until there are no significant changes in the lower bound, that is the algorithm converges to a local optimum (it should be noted the optimum is local not absolute, and it depends on the initialization of the distributions' parameters). M-Step Now, in the M-Step we maximize the log likelihood as follows: \\begin{align} \\underset{\\theta}{\\max{ }} \\sum_{i=1}^m \\log P(x^{(i)}; \\theta) \\end{align} By marginalizing \\(z^{(i)}\\): \\begin{align} \\underset{\\theta}{\\max{ }} \\sum_{i=1}^m \\log \\sum_{z^{(i)}} P(x^{(i)}, z^{(i)}; \\theta) \\end{align} We now introduce a probability distribution over \\(z^{(i)}\\) (thus \\(\\sum_{z^{(i)}}Q(z^{(i)}) = 1\\)), and we multiply by \\(\\frac{Q(z^{(i)})}{Q(z^{(i)})}\\): \\begin{align} \\underset{\\theta}{\\max{ }} \\sum_{i=1}^m \\log \\sum_{z^{(i)}} Q(z^{(i)}) \\frac{P(x^{(i)}, z^{(i)}; \\theta)}{Q(z^{(i)})} \\end{align} Now, by the definition of expected value (Given a sequence of real values \\(a_1, \\cdots, a_n\\) with probabilities \\(p_1, \\cdots, p_n\\), the expected value is defined as: \\(e = \\sum_{i=1}^n p_i a_i\\)), if \\(p_i = Q(z^{(i)})\\) and \\(a_i = \\frac{P(x^{(i)}, z^{(i)}; \\theta)}{Q(z^{(i)})}\\) \\begin{align} \\underset{\\theta}{\\max{ }} \\sum_{i=1}^m \\log E_{z^{(i)}\\sim Q} \\left[\\frac{P(x^{(i)}, z^{(i)}; \\theta)}{Q(z^{(i)})}\\right] \\end{align} If we apply the concave version of Jensen's Inequality we obtain a lower bound of the form: \\begin{align} \\sum_{i=1}^m \\log E_{z^{(i)}\\sim Q} \\left[\\frac{P(x^{(i)}, z^{(i)}; \\theta)}{Q(z^{(i)})}\\right] \\geq \\sum_{i=1}^m E_{z^{(i)} \\sim Q} \\left[\\log \\frac{P(x^{(i)}, z^{(i)}; \\theta)}{Q(z^{(i)})} \\right] \\end{align} If \\(\\log (x) = f(x)\\), then this equation can be mapped to the inequality: \\begin{align} f(E[x]) \\geq E[f(x)] \\end{align} Note that \\(log\\) is a concave function. If we \"unpack\" the expected value: \\begin{align} \\sum_{i=1}^m E_{z^{(i)} \\sim Q} \\left[\\log \\frac{P(x^{(i)}, z^{(i)}; \\theta)}{Q(z^{(i)})} \\right] = \\sum_{i=1}^m \\sum_{z^{(i)}} \\log Q(z^{(i)}) \\left[\\frac{P(x^{(i)}, z^{(i)}; \\theta)}{Q(z^{(i)})}\\right] \\end{align} Make Log Likelihood and Lower Bound Equal on Theta For each \\(\\theta\\) on the E-Step you wan the value of \\(\\theta\\) under the lower bound function to be equal to \\(l(\\theta)\\), which is what guarantees that when you optimize the lower bound you optimize \\(l(\\theta)\\). So, for a given iteration the current value of \\(\\theta\\), denoted by \\(\\hat{\\theta}\\), we want: \\begin{align} \\sum_{i=1}^m \\log E_{z^{(i)}\\sim Q} \\left[\\frac{P(x^{(i)}, z^{(i)}; \\hat{\\theta})}{Q(z^{(i)})}\\right] = \\sum_{i=1}^m E_{z^{(i)} \\sim Q} \\left[\\log \\frac{P(x^{(i)}, z^{(i)}; \\hat{\\theta})}{Q(z^{(i)})} \\right] \\end{align} Remember, by the extension on Jensen's Inequality we know that \\(E[f(x)] = f(E[x])\\) if and only if \\(x\\) is a constant. In this case \\begin{align} x = \\frac{P(x^{(i)}, z^{(i)}; \\hat{\\theta})}{Q(z^{(i)})} = constant \\end{align} For this to hold, we need \\(Q(z^{(i)})\\) to be directly proportional to \\(P(x^{(i)}, z^{(i)}; \\hat{\\theta})\\) (so when one is bigger the other is bigger and vice versa, so the ratio between the two remains constant). So: \\begin{align} Q(z^{(i)}) \\propto P(x^{(i)}, z^{(i)}; \\hat{\\theta}) \\end{align} Because \\(\\sum_{z^{(i)}}Q(z^{(i)}) = 1\\), a way to ensure this is to set each \\(Q^{(i)} = P(x^{(i)}, z^{(i)}; \\hat{\\theta})\\) and then normalize it to make sure the sum of \\(Q\\) over \\(z^{(i)}\\) equals one. Hence: \\begin{align} Q(z^{(i)}) = \\frac{P(x^{(i)}, z^{(i)}; \\hat{\\theta})}{\\sum_{z^{(i)}} P(x^{(i)}, z^{(i)}; \\hat{\\theta})} \\end{align} It turns out you can further derive this equation to be: \\begin{align} Q(z^{(i)}) = P(z^{(i)}|x^{(i)}; \\hat{\\theta}) \\end{align} Putting Everything Together So, after everything we have seen, we can summarize the EM generalized algorithm as follows: If \\(\\theta\\) is the value of the parameters in the current iteration: E-Step: set \\begin{align} Q_i(z^{(i)}) = P(z^{(i)}|x^{(i)}; \\theta) \\end{align} M-Step: set \\begin{align} \\theta := \\underset{\\theta}{\\arg \\max} \\sum_{i=1}^m \\sum_{z^{(i)}} Q_i(z^{(i)}) \\log \\left[\\frac{P(x^{(i)}, z^{(i)};\\theta)}{Q_i(z^{(i)})}\\right] \\end{align} Derive EM for GMM from the Generalized Algorithm Given a model described by: \\(P(x^{(i)}, z^{(i)}) = P(x^{(i)}|z^{(i)}) P(z^{(i)})\\) where \\(z^{(i)} \\sim Multinomial(\\phi)\\) (which means \\(P(z^{(i)} = j) = \\phi_j\\)) and \\(x^{(i)} | z^{(i)} \\sim \\mathcal{N}(\\mu_j, \\Sigma_j)\\) E-Step On the E-Step we compute: \\(Q_i(z^{(i)}) P(z^{(i)} = j | x^{(i)}; \\phi, \\mu, \\Sigma)\\) If we look at E-Step from GMM's we can see that the expression above equals \\(w^{(i)}_j\\). M-Step Now on the M-Step what we do is maximize the lower bound we have constructed in the E-Step. For that we need to compute the value of the parameters \\(\\phi, \\mu, \\Sigma\\) that maximize this function, that is: \\begin{align} \\underset{\\phi, \\mu, \\Sigma}{\\max} \\sum_{i=1}^m \\sum_{z^{(i)}} Q_i(z^{(i)}) \\log \\left( \\frac{P(x^{(i)}, z^{(i)}; \\phi, \\mu, \\Sigma)}{Q_i(z^{(i)})} \\right) = \\end{align} As we know \\(Q_i(z^{(i)}) = w^{(i)}_j\\) and \\(P(x^{(i)}, z^{(i)}) = P(x^{(i)}|z^{(i)}) P(z^{(i)})\\), thus: \\begin{align} = \\sum_{i=1}^m \\sum_{j}^K w^{(i)}_j \\log \\left( \\frac{P(x^{(i)}|z^{(i)} = j, \\mu_j, \\Sigma_j) P(z^{(i)} = j)}{w^{(i)}_j} \\right) \\end{align} We also know that \\(P(z^{(i)} = j) = \\phi_j\\) and \\(x^{(i)} | z^{(i)} \\sim \\mathcal{N}(\\mu_j, \\Sigma_j)\\), therefore: \\begin{align} = \\sum_{i=1}^m \\sum_{j}^K w^{(i)}_j \\log \\left( \\frac{\\mathcal{N}(x^{(i)}; \\mu_j, \\Sigma_j) \\phi_j}{w^{(i)}_j} \\right) \\end{align} Where: \\begin{align} \\mathcal{N}(x^{(i)}; \\mu_j, \\Sigma_j) = \\frac{1}{(2\\pi)^{1/2}|\\Sigma_j|^{1/2}} \\exp \\left( -\\frac{1}{2}(x^{(i)} - \\mu_j)^T \\Sigma_j^{-1}(x^{(i)} - \\mu_j)\\right) \\end{align} From now on we denote \\(\\sum_{i=1}^m \\sum_{j}^K w^{(i)}_j \\log \\left( \\frac{\\mathcal{N}(x^{(i)}; \\mu_j, \\Sigma_j) \\phi_j}{w^{(i)}_j} \\right)\\) as \\(\\mathcal{L}(\\phi, \\mu, \\Sigma)\\): To maximize this formula over \\(\\phi, \\mu\\) and \\(\\Sigma\\) you have to compute the derivatie of the function with respect to each parameter, such that: \\(\\Delta_{\\mu_j} (\\mathcal{L}(\\phi, \\mu, \\Sigma)) = 0\\), then: \\(\\mu_j = \\sum_{i}^m \\frac{w^{(i)}_j x^{(i)}_j}{w^{(i)}_j}\\) (same as in M-Step in GMM's) \\(\\Delta_{\\Sigma_j} (\\mathcal{L}(\\phi, \\mu, \\Sigma)) = 0\\) and \\(\\Delta_{\\phi_j} (\\mathcal{L}(\\phi, \\mu, \\Sigma)) = 0\\) "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/(DS0001)_MLStanfordCoursera/SVM/Optimal Margin Classifier.html",
    "title": "Optimal Margin Classifier",
    "body": " Back Optimal Margin Classifier We use this classifier to categorize datasets that are perfectly separable, that is to say, we use it over data that is linearly separable. This classifier will help us find the green line we saw in the geometric margin. What the optimal margin classifier does is choose the parameters \\(w, b\\) that maximize \\(\\gamma\\) One way to solve this optimization problem is: \\begin{align} \\underset{\\gamma, w, b}{\\max} \\gamma \\end{align} subject to \\begin{align} \\frac{y^{(i)}(w^Tx + b)}{||w||} \\geq \\gamma \\end{align} This will cause the maximization of the geometric margin with respect to the training set. The restriction means that we want to maximize \\(\\gamma\\) while having every example have a geometric margin of at least \\(\\gamma\\). Because this is a non-convex problem, we will transform it. Given \\(\\gamma = \\frac{\\hat{\\gamma}}{||w||}\\), then \\(\\gamma \\cdot ||w|| = \\hat{\\gamma}\\), and so if we multiply in the subject both sides by \\(||w||\\): \\begin{align} \\frac{y^{(i)}(w^Tx + b)}{||w||} \\cdot ||w|| \\geq \\gamma \\cdot ||w|| \\Leftrightarrow y^{(i)}(w^Tx + b) \\geq \\hat{\\gamma} \\end{align} and the optimization problem can be re-written as: \\begin{align} \\underset{\\hat{\\gamma}, w, b}{\\max} \\frac{\\hat{\\gamma}}{||w||} \\end{align} subject to \\begin{align} y^{(i)}(w^Tx + b) \\geq \\hat{\\gamma} \\end{align} However, we are still stuck with a non-convex objective \\(\\frac{\\hat{\\gamma}}{||w||}\\). Because, as we've said previously scaling the functional margin (changing the magnitude of \\(w^Tx + b\\)) does not change the decision boundary itself, we will add an scaling constraint that the functional margin of \\(w, b\\) with respect to the training set must be 1: \\(\\hat{\\gamma} = 1\\) Observe, now, that maximizing \\(\\frac{\\hat{\\gamma}}{||w||} = \\frac{1}{||w||}\\) is like minimizing \\(||w||^2\\), we re-write the optimization problem as follows: \\begin{align} \\underset{w, b}{\\min} ||w||^2 \\end{align} subject to \\begin{align} y^{(i)}(w^Tx + b) \\geq 1 \\end{align} We will revise once more the optimization problem for the Optimal Margin Classifier. First, we have to suppose two facts: By the representer theorem we can assume that \\(w\\) can be expressed as a linear combination of \\(x\\), that is: \\begin{align} w = \\sum_{i=1}^m \\alpha_i x^{(i)} \\end{align} Let's review this claim with logistic regression. We know that we apply stochastic gradient descent (we update \\(\\Theta\\) for every example, instead of summing all the examples) on \\(\\Theta\\) as follows: \\begin{align} \\Theta = \\Theta - \\alpha (h_\\Theta(x^{(i)}) - y^{(i)})x^{(i)} \\end{align} Which means that in every interation we are updating \\(\\Theta\\) by adding or substracting a factor \\(\\alpha_i\\) multiplied by \\(x^{(i)}\\). Therefore we can show by mathematical induction that if we start with \\(\\theta_0 = c\\), where \\(c\\) is a constant and go on adding and substracting \\(Ax^{(i)}\\), where \\(A= \\alpha (h_\\Theta(x^{(i)}) - y^{(i)})\\), then \\(w\\) can be expressed as a linear combination of \\(x\\). You can also derive the gradient descent expression in our optimization problem, and show that in this case \\(w\\) is also a linear combination of \\(x\\). We can rewrite \\(w\\) as follows: \\begin{align} w = \\sum_{i=1}^m \\alpha_i y^{(i)} x^{(i)} \\end{align} Given any decision boundary, the vector \\(w\\) is always orthogonal to the decision boundary: Now, the optimization problem becomes (note \\(w^2 = w^Tw\\)): \\begin{align} \\underset{w, b}{min} \\frac{1}{2}||w||^2 = \\underset{w, b}{min} \\frac{1}{2} (\\sum_{i=1}^m \\alpha_i y^{(i)} x^{(i)})^T(\\sum_{j=1}^m \\alpha_j y^{(j)} x^{(j)}) = \\end{align} \\begin{align} \\underset{w, b}{min} \\frac{1}{2} \\sum_{i=1}^m\\sum_{j=1}^m \\alpha_i \\alpha_j y^{(i)}y^{(j)}(x^{(i)})^Tx^{(j)} \\end{align} We now denote the inner product of \\((x^{(i)})^T x^{(j)}\\) as \\(\\langle x^{(i)}, x^{(j)} \\rangle\\), so: \\begin{align} \\underset{w, b}{min} \\frac{1}{2} \\sum_{i=1}^m\\sum_{j=1}^m \\alpha_i \\alpha_j y^{(i)}y^{(j)} \\langle x^{(i)}, x^{(j)} \\rangle \\end{align} And the restriction of the optimization becomes: \\begin{align} y^{(i)}(w^Tx^{(i)} + b) \\geq 1 \\rightarrow y^{(i)}((\\sum_{j=1}^m \\alpha_j y^{(j)}x^{(j)})^Tx^{(i)} + b) \\geq 1 \\rightarrow \\end{align} \\begin{align} y^{(i)}((\\sum_{j=1}^m \\alpha_j y^{(j)}(x^{(j)})^Tx^{(i)}) + b) \\geq 1 \\rightarrow y^{(i)}((\\sum_{j=1}^m \\alpha_j y^{(j)} \\langle x^{(j)}, x^{(i)} \\rangle) + b) \\geq 1 \\end{align} Applying convex optimization theory you can simplify this optimization problem further to: \\begin{align} \\underset{\\alpha}{max} \\sum_{i=1}^m \\alpha_i - \\frac{1}{2} \\sum_{i=1}^m\\sum_{j=1}^m y^{(i)}y^{(j)}\\alpha_i\\alpha_j\\langle x^{(i)}, x^{(j)}\\rangle \\end{align} subject to \\begin{align} \\alpha_i \\geq 0 \\end{align} \\begin{align} \\sum_{i=1} y^{(i)}\\alpha_i = 0, i=1, \\cdots,m \\end{align} Train the Classifier To train the SVM we have to solve the optimization problem for \\(\\alpha\\) Classify an example To predict an example \\(x\\): \\begin{align} h_{w,b} = g(w^Tx + b) = g\\left(\\left(\\sum_{i=1}^m \\alpha_i y^{(i)}x^{(i)}\\right)^Tx + b\\right) = g\\left(\\left(\\sum_{i=1}^m \\alpha_i y^{(i)} \\langle x^{(i)}, x^{(j)} \\rangle\\right) + b\\right) \\end{align} "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/(DS0001)_MLStanfordCoursera/SVM/Geometric Margin.html",
    "title": "Geometric Margin",
    "body": " Back Geometric Margin Intuition First of all, let's assume we have a dataset that is linearly separable like: Here we have two examples of two decision boundaries that do classify correctly all of the samples. However the red one looks worse than the green one. That is because for the red one there are some examples that are very close to the boundary compared to the rest. Whereas for the green one there is a bigger separation. So, first we define a line by the equation \\(w^Tx + b = 0\\), therefore: every example \\(x\\) that lies to the left of the line satisfies \\(w^Tx + b < 0\\) and every example \\(x\\) that lies to the right of the line satisfies \\(w^Tx + b > 0\\) Furthermore the geometric margin with respect to a single example \\((x^{(i)}, y^{(i)})\\) is the euclidean distance between the point \\((x^{(i)}, y^{(i)})\\) and the line we have defined as \\(w^Tx + b = 0\\). Euclidean distance to the decision boundary The decision boundary corresponding to (w, b) is shown, along with the vector w. Note that w is orthogonal (at 90º) to the separating hyperplane. Consider the point at \\(A\\), which represents the example \\(x^{(i)}\\) with \\(y^{(i)} = 1\\). Its distance to the decision boundary, denoted by \\(\\gamma^{(i)}\\), is given by the line segment \\(AB\\). How do we find \\(\\gamma^{(i)}\\): We know \\(\\frac{w}{||w||}\\) is a unit length vector pointing to the same direction as \\(w\\). Also \\(A = x^{(i)}\\) We also know that the vector between points \\(A\\) and \\(B\\) is defined like \\(A - B\\), in this scenario, \\(A - B = \\gamma^{(i)}\\frac{w}{||w||}\\), where \\(\\gamma^{(i)}\\) is the length of the vector and \\(\\frac{w}{||w||}\\) is the direction of the vector. Thus if we solve for \\(B\\), \\(B = x^{(i)} - \\gamma^{(i)}\\frac{w}{||w||}\\) Furthermore, \\(B\\) lies on the decision boundary, therefore: \\begin{align} w^T(B) + b = 0 \\rightarrow w^T\\left(x^{(i)} - \\gamma^{(i)}\\frac{w}{||w||}\\right) + b = 0 \\end{align} Solving for \\(y^{(i)}\\) yields: \\begin{align} \\gamma^{(i)} = \\frac{w^Tx^{(i)} + b}{||w||} = \\left(\\frac{w}{||w||}\\right)^Tx(i) + \\frac{b}{||w||} \\end{align} Formal definition The geometric margin of the hyperplane \\((w, b)\\) with respect to \\((x^{(i)}, y^{(i)})\\) is defined as: \\begin{align} \\gamma^{(i)} = \\frac{w^T x^{(i)} + b}{||w||} \\end{align} This is the definition for a positive example (\\(y^{(i)} = 1\\)), and measures the euclidean distance from the decision boundary to the example \\((x^{(i)}, y^{(i)})\\). If we generalize, as to compute the geometric margin for both positive and negative examples: \\begin{align} \\gamma^{(i)} = \\frac{y^{(i)} (w^T x^{(i)} + b)}{||w||} \\end{align} Evaluation To evaluate the geometric margin with respect to the training set we make use of the worst case notion: \\begin{align} \\gamma = \\underset{i}{\\min} \\gamma^{(i)} \\end{align} That is, we evaluate how well we are doing in the worst example. "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/(DS0001)_MLStanfordCoursera/SVM/SVM.html",
    "title": "SVM",
    "body": " Back SVM Notation Functional Margin Geometric Margin Functional and Geometric Margin Optimal Margin Classifier SVM Kernels The Kernel Trick Applying Kernels Validity of Kernels Generality of the Kernel Trick L1-Norm Soft Margin SVM Outliers Optimization Kernel Examples The Support Vector Machine allows you to find potential non-linear decision boundaries: SVM provides an algorithm that: Maps a vector of features to a vector of features of a much higher dimension (manually picking the new features is difficult, that is why we automate it with these types of algorithms) \\begin{align} \\begin{bmatrix} x_1 \\\\ x_2 \\\\ \\end{bmatrix} \\rightarrow \\begin{bmatrix} x_1 \\\\ x_2 \\\\ x_1^2 \\\\ x_2^2 \\\\ x_1\\cdot x_2 \\\\ \\vdots \\end{bmatrix} \\end{align} Applies a linear classifier over the high dimensional features (Note: if you apply logistic regression to high dimensional vectors then it can learn non-linear decision boundaries) Notation Labels: \\(y^{(i)} \\in \\{-1, +1\\}\\) Now the hypothesis outputs a \\(1\\) or a \\(-1\\), which means: \\begin{align} g(z) = \\begin{cases} 1, & \\text{ if } z \\geq 0 \\\\ 0, & \\text{ otherwise } \\\\ \\end{cases} \\end{align} That is, now instead of a smooth transition of probabilities from zero to one, we have a hard transition between \\(1\\) and \\(-1\\). Weights: now the weights \\(\\Theta \\in \\mathbb{R}^{(n+1)}\\), where \\(\\theta_0 = 1\\) are divided into: \\(w \\in \\mathbb{R}^{(n)}\\) and \\(b \\in \\mathbb{R}\\). Thus we drop the convention of assigning \\(x_0 = 1\\). Also now the hypothesis function is defined as: \\(h_{w,b}(x) = g(w^Tx + b) = g((\\sum_{i=1}^n w_i x) + b)\\) Functional Margin Functional Margin Geometric Margin Geometric Margin Relationship between Functional Margin and Geometric Margin As you may have picked up we can stablish an equality between both margins: \\begin{align} \\gamma^{(i)} = \\frac{\\hat{\\gamma}^{(i)}}{||w||} \\end{align} Optimal Margin Classifier Optimal Margin Classifier SVM Kernels Kernel Trick To apply kernels first we will lay out the kernel trick: Write the algorithm in terms of the inner products of the training examples \\(\\langle x^{(i)}, x^{(j)} \\rangle=(\\langle x, z \\rangle)\\) Let there be a mapping \\(x \\rightarrow \\phi(x)\\), where \\(\\phi(x)\\) is a high dimensional feature vector. Find a way to compute \\(K(x, z) = \\phi(x)^T\\phi(z)\\), even if \\(x, z\\) are very high dimensional features vectors (which would be very computationally expensive). Where \\(K(x, z)\\) is denoted as the kernel function Replace \\(\\langle x, z \\rangle\\) with \\(K(x, z)\\) Applying Kernels Given \\(x, z \\in \\mathbb{R}^n\\), where: \\begin{align} x = \\begin{bmatrix} x_1 \\\\ \\vdots \\\\ x_n \\\\ \\end{bmatrix} \\end{align} We define the mapping \\(\\phi(x) \\in \\mathbb{R}^{n^2}\\) as follows: \\begin{align} \\phi(x) = \\begin{bmatrix} x_ix_i \\\\ \\end{bmatrix} \\end{align} \\(\\forall i, j\\) with \\(1 \\leq i,j \\leq n\\) So we have \\begin{align} K(x, z) = \\phi(x)^T \\phi(z) = \\sum_{i=1}^{n^2} \\phi(x)_i \\phi(z)_i = \\sum_{i=1}^n \\sum_{j=1}^n (x_ix_j) (z_iz_j) \\end{align} Which would take \\(O(n^2)\\) time to compute. But, observe that: \\begin{align} (x^Tz)^2 = (x^Tz)^T(x^Tz) = \\sum_{i=1}^n\\sum_{j=1}^n (x_iz_i)(x_jz_j) = \\sum_{i=1}^n\\sum_{j=1}^n (x_ix_j)(z_iz_j) \\end{align} whick takes \\(O(n)\\) time to compute. So we conclude that the kernel can be defined as \\(K(x, z) = (x^Tz)^n\\) Given \\(x, z \\in \\mathbb{R}^n\\) \\(K(x, z) = (x^Tz + c)^2\\) Where the mapping function \\(\\phi\\) is defined as: given \\begin{align} x = \\begin{bmatrix} x_1 \\\\ x_2 \\\\ \\end{bmatrix} \\end{align} Then: \\begin{align} \\phi(x) = \\begin{bmatrix} x_1x_1 \\\\ x_1x_2 \\\\ x_2x_1 \\\\ x_2x_2 \\\\ \\sqrt{2c}x_1 \\\\ \\sqrt{2c}x_2 \\\\ \\end{bmatrix} \\end{align} Given \\(x, z \\in \\mathbb{R}^n\\) \\(K(x, z) = (x^Tz+ c)^d\\) Where \\(\\phi(x)\\) contains the \\(\\binom{n+d}{d}\\) combinations of monomials of degree d. (Note: a monomial of degree 3 could be \\(x_1x_2x_3\\) or \\(x_1x_2^2\\), etc) Validity of Kernels To test is a Kernel is valid we use Mercer's Theorem that says: K is a valid kernel function (i.e. \\(\\exists \\phi\\) such that \\(K(x, z) = \\phi(x)^T\\phi(z)\\)) if and only if for any \\(d\\) points \\(\\{x^{(1)}, \\cdots , x^{(d)}\\}\\) the corresponding kernel matrix \\(K\\) is positive semi-definite, that is \\(K \\geq 0\\) We are going to prove the first part of this theorem: Given examples \\(\\{x^{(1)}, \\cdots , x^{(d)}\\}\\), let \\(K \\in \\mathbb{R}^{d\\times d}\\), be the kernel matrix, such that \\begin{align} K_{ij} = K(x^{(i)}, x^{(j)}) \\end{align} Then, if \\(K\\) is a valid kernel: \\begin{align} z^TKz = \\sum_{i=1}^d \\sum_{j=1}^d z_i^T K_{ij} z_j = \\sum_{i=1}^d \\sum_{j=1}^d z_i^T \\phi(x^{(i)})^T \\phi(x^{(j)}) z_j = \\end{align} We expand \\(\\phi(x^{(i)})^T \\phi(x^{(j)})\\) as follows: \\begin{align} = \\sum_{i=1}^d \\sum_{j=1}^d z_i^T \\left[\\sum_{k=1}^d (\\phi(x^{(i)}))_k (\\phi(x^{(j)}))_k\\right] z_j = \\end{align} Now, if we rearrange the sums: \\begin{align} = \\sum_{k=1}^d \\left[\\sum_{i=1}^d z_i (\\phi(x^{(i)}))_k\\right]^2 \\end{align} So, because the power of two of any real number is a positive number, and the sum of positive numbers is positive we derive: \\begin{align} \\sum_{k=1}^d \\left[\\sum_{i=1}^d z_i (\\phi(x^{(i)}))_k\\right]^2 \\geq 0 \\end{align} Which means that \\(K \\geq 0\\), hence \\(K\\) is a positive, semi-definite matrix Generality of the Kernel Trick The kernel trick can be applied to more algorithms, not only in SVM. Because, if you have any algorithm written in terms of \\(\\langle x^{(i)}, x^{(j)} \\rangle\\), you can apply the kernel trick to it. Some of the algorithms that can be re-written like this are: Lineal Regression Logistic Regression GDM PCA etc. L1-Norm Soft Margin SVM It may be the case where you map your data to a very high dimensional space, but it is still not linearly separable, or the decision boundary becomes too complex: In order to avoid this we will use a modification of the basic algorithm called L1-Norm Soft Margin SVM. With this new algorithm the optimization problem becomes \\begin{align} \\underset{w,b,\\xi_i}{min} \\frac{1}{2}||w||^2 + C \\sum_{i=1}^m \\xi_i \\end{align} subject to \\begin{align} y^{(i)}(w^Tx^{(i)} + b) \\geq 1 - \\xi_i \\end{align} \\begin{align} \\xi_i \\geq 0, i = 1, \\cdots, m \\end{align} Note that if \\(x^{(i)}\\) is classified correctly then \\(y^{(i)}(w^Tx^{(i)} + b) \\geq 0\\) and therefore satisfies \\(y^{(i)}(w^Tx^{(i)} + b) \\geq 1 - \\xi_i\\), because \\(\\xi_i \\geq 0\\) Before the modification, the restriction forced the functional margin to be at least 1, however after the modification, because \\(\\xi_i\\) is positive we relax the restriction. Also, we do not want \\(\\xi_i\\) to be too big, that is why it is added to the optimization objective as a cost. Graphical representation With the addition of \\(\\xi_i\\) we are allowing some examples to have a functional margin less than 1, by setting \\(\\xi_i \\geq 0\\). For example look at the example \\(x^{(i)}\\) which has \\(\\xi_i = 0.5\\) Outliers This relaxation on the restriction upong the geometric margin also avoids the following problem. If you have a lot of data that is linearly separable, but you have one outlier the optimal margin classifier allows for the decision boundary to be drastically changed because its optimization is based on the word performing example (which would be the outlier in this case). Thus: However, the L1-Norm Soft Margin SVM allows for this example to be classified incorrectly of be close to the decision boundary without changing the boundary which makes it more robuts to outliers. Optimization Picking up the Optimal Margin Classifier optimization problem, after applying the insight derived from the representer theorem, we have that the only addition needed to implement this algorithm is: \\begin{align} \\underset{\\alpha}{max} \\sum_{i=1}^m \\alpha_i - \\frac{1}{2} \\sum_{i=1}^m\\sum_{j=1}^m y^{(i)}y^{(j)}\\alpha_i\\alpha_j\\langle x^{(i)}, x^{(j)}\\rangle \\end{align} subject to \\begin{align} \\sum_{i=1} y^{(i)}\\alpha_i = 0 \\end{align} \\begin{align} 0 \\leq \\alpha_i \\leq C, i = 1, \\cdots , m \\end{align} The parameter \\(C\\) is a parameter your choose and it determines the level of strictness you want your model to have about some examples being misclassified. Kernel Examples The Gaussian Kernel: \\(K(x, z) = \\exp\\left(\\frac{||x-z||^2}{2\\sigma}\\right)\\) Linear Kernel: \\(K(x, z) = \\phi(x)^T\\phi(z)\\), where \\(\\phi(x) = x\\) Polynomial Kernel: \\(K(x, z) = (x^Tz)^d\\) "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/(DS0001)_MLStanfordCoursera/SVM/Functional Margin.html",
    "title": "Functional Margin",
    "body": " Back Functional Margin Intuition The Functional Margin describes how accurately do we classify an example. For example, for binary classification, given an example x: \\begin{align} h_\\Theta(x) = g(\\Theta x) = \\begin{cases} \\text{ predict } 1 & \\text{ if } \\Theta^T x \\geq 0, \\text{ that is } h_\\Theta(x)=g(\\Theta x) \\geq 0.5\\\\ \\text{ predict } 0 & \\text{ otherwise } \\\\ \\end{cases} \\end{align} Let's distinguish between the two cases when classifying an example \\(x^{(i)}\\): (1) If \\(y^{(i)} = 1\\), then we want \\(h_\\Theta(x) = g(\\Theta x) \\approx 1\\), which means we want \\(\\Theta \\cdot x >> 0\\). (2) If \\(y^{(i)} = 0\\), then we want \\(h_\\Theta(x) = g(\\Theta x) \\approx 0\\), which means we want \\(\\Theta \\cdot x << 0\\). As we can see in the following graph, the bigger \\(z = \\Theta x\\) the closer \\(g(z)\\) is to one and vice versa. Formal Definition The functional margin of the hyperplane defined by \\((w, b)\\) with respect to the example \\((x^{(i)}, y^{(i)})\\) is defined as: \\begin{align} \\hat{\\gamma}^{(i)} = y^{(i)}(w^Tx^{(i)}+b) \\end{align} So, if we modify slightly the two statements above and use the new notation for SVMs: If \\(y^{(i)} = 1\\), then we want \\(w^T \\cdot x + b >> 0\\). If \\(y^{(i)} = 0\\), then we want \\(w^T \\cdot x + b << 0\\). The combination of these two declarations yields the definition of the functional margin. Why?, well: When \\(y^{(i)}\\) is positive, we want to have \\(w^Tx^{(i)} + b >> 0\\) by (1), so \\(\\hat{\\gamma}^{(i)}\\) will be large, because both values are positive When \\(y^{(i)}\\) is negative, we want to have \\(w^Tx^{(i)} + b << 0\\) by (2), so \\(\\hat{\\gamma}^{(i)}\\) will be large, because both values are negative So, given an example \\(x^{(i)}\\), if \\(\\hat{\\gamma}^{(i)} > 0\\) that means either \\(y^{(i)} = 1\\) and \\(w^Tx + b > 0\\) or \\(y^{(i)} = -1\\) and \\(w^Tx + b < 0\\) which shows that the classification is correct. Evaluation To evaluate the functional margin with respect to the training set we make use of the worst case notion: \\begin{align} \\hat{\\gamma} = \\underset{i}{\\min} \\hat{\\gamma}^{(i)} \\end{align} That is, we evaluate how well we are doing in the worst example. Normalizing the Functional Margin Note that the functional margin is very easy to cheat (to increase its value with any meaningful change to the decision boundary). Given our definition for \\(g\\): \\begin{align} g = \\begin{cases} 1, & \\text{ if } z \\geq 0 \\\\ -1, & \\text{ otherwise } \\end{cases} \\end{align} It follows that \\(h_{w,b}(x^{(i)}) = g(2w^Tx^{(i)} + 2b) = g(w^Tx^{(i)} + b)\\), because what matters is the sign, not the magnitude. However, if you scale \\(w\\) and \\(b\\) by a factor of \\(n\\) where \\(n\\) is a positive number then \\(\\gamma \\) increases because: \\begin{align} \\hat{\\gamma}^{(i)} = (w^Tx + b) \\end{align} so, \\begin{align} n \\cdot \\hat{\\gamma}^{(i)} = n \\cdot (w^Tx + b) \\end{align} where, \\begin{align} \\hat{\\gamma}^{(i)} < n \\cdot \\hat{\\gamma}^{(i)} \\end{align} One way to avoid this is to normalize the length of the parameters, that is either: Add a constraint where \\(||w|| = 1\\) or Set \\((w, b)\\) to be \\((\\frac{w}{||w||}, \\frac{b}{||b||})\\) In both cases we are re-scaling the parameters. "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/(DS0001)_MLStanfordCoursera/Grandes Datasets.html",
    "title": "Grandes Datasets",
    "body": " Back Grandes Datasets Cuando los conjuntos de datos son muy grandes los algoritmos son computacionalmente más caros: Varianza elevada: se obtiene mejor rendimiento con más ejemplos. Sesgo/bias elevado: se obtiene mejor rendimiento con más características. Stochastic Gradient Descent El algoritmo de Stochastic Gradient Descent es el siguiente: Reordenar aleatoriamente el conjunto de datos Para cada ejemplo \\(i\\) y cada característica \\(j\\): \\(\\theta_j = \\theta_j - \\alpha (h_\\theta(x^{(i)}) - y^{(i)})x^{(i)}_j\\) Es decir, se ajusta \\(\\theta\\) para cada ejemplo, en lugar de hacer el cálculo sobre todo el conjunto de datos Cada iteración es más rápida No converge como Batch Gradient Descent, llega a una aproximación. Mini Batch Gradient Descent Esta técnica lo que hace el utilizar \\(b\\) ejemplos para calcular el gradiente: Para cada \\(b\\) ejemplos y cada característica \\(j\\): \\(\\theta_j = \\theta_j - \\alpha \\frac{1}{b}(h_\\theta(x^{(i)}) - y^{(i)})x^{(i)}_j\\) Permite vectorización "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/(DS0001)_MLStanfordCoursera/Datos Artificiales.html",
    "title": "Datos Artificiales",
    "body": " Back Datos Artificiales Cómo podemos generar datos? Manualmente Modificando los datos de entrada (añadir ruido en sonido, distorsionar imagen, etc) No obstante, debemos evitar añadir ruido aleatorio, ya que esto no ayuda a extraer características significativas del conjunto de datos. Estos métodos se suelen utilizar si el modelos tiene un sesgo bajo y se produce underfitting, (por lo que hace falta añadir características). "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/(DS0001)_MLStanfordCoursera/Sistemas de Recomendación.html",
    "title": "Sistemas de Recomendación",
    "body": " Back Sistemas de Recomendación Dados los parámetros: \\(n_\\mu\\): número de usuarios \\(n_m\\): número de ítems valorables \\(r(i,j)\\): marcador de si el ítem ha sido valorado, tal que: \\begin{align} r(i, j) = \\begin{cases} 1, & \\text{ si el usuario j ha valorado el ítem i} \\\\ 0, & \\text{ en cualquier otro caso} \\end{cases} \\end{align} \\(y^{(i, j)}\\): valoración del usuario \\(j\\) al ítem \\(i\\). El objetivo de un sistema de recomendación es predecir los valores de las valoraciones donde \\(r(i, j) \\neq 1\\) (es decir predecir las valoraciones de usuarios hacia ítems que no han valorado con anteioridad) Content Based Recommendations Cada ítem está definido por \\(n\\) características. Para cada usuario \\(j\\), debemos obtener \\(\\theta^{(j)} \\in \\mathbb{R}^{n+1}\\), de tal manera que para predecir la valoración de \\(x^{(i)} \\rightarrow h_\\theta(x^{(i)}) = (\\theta^{(j)})^T x^{(i)}\\) Función de coste Sea \\(m^{(j)}\\) el número de ítems valorados por el usuario \\(j\\), entonces la función de coste se define como: \\begin{align} J(\\Theta) = \\frac{1}{2m^{(j)}}\\sum_{j=1}^{n_\\mu} \\sum_{i; r(i, j) = 1} ((\\theta^{(j)})^T x^{(i)} - y^{(i, j)})^2 + \\frac{\\lambda}{2m^{(j)}} \\sum_{k=1}^{n_\\mu} \\theta^{(j)}_k \\end{align} donde \\(\\Theta = \\{\\theta_1, \\cdots, \\theta_{n_\\mu}\\}\\) Es decir queremos minimizar la \"distancia\" entre lo predicho \\((\\theta^{(j)})^T x^{(i)}\\) para el ítem (que ha sido valorado, por lo tanto \\(r(i, j) = 1\\)) y el usuario \\(i\\) y la valoración real \\(y^{(i, j)}\\). Descenso Gradiente Lo que queremos es minimizar el coste, por lo tanto, calculamos \\(\\frac{\\delta J(\\Theta)}{\\delta \\theta_j}\\) para obtener el vector en dirección al mayor incremento en la función, seguidamente, utilizar su opuesto, obtenemos el vector que apunta a la dirección de menor incremento. Es decir, aplicamos descenso gradiente como sigue: Para \\(k = 0\\): \\begin{align} \\theta_k^{(j)} = \\theta_k^{(j)} - \\alpha \\left(\\sum_{i; r(i,j)=1} (\\theta^{(j)})^Tx^{(i)} - y^{(i,j)}x^{(i)}_k \\right) \\end{align} Para \\(k \\neq 0\\): \\begin{align} \\theta_k^{(j)} = \\theta_k^{(j)} - \\alpha \\left(\\sum_{i; r(i,j)=1} (\\theta^{(j)})^Tx^{(i)} - y^{(i,j)}x^{(i)}_k + \\lambda \\theta_k^{(j)} \\right) \\end{align} Collaborative Filtering Collaborative filtering consiste en calcular las características de cada usuario (ejemplo \\(x^{(i)}\\)) en función de los pesos \\(\\theta^{(j)}\\). Una vez hecho esto se calculan los pesos óptimos que que minimizan la función de coste y volvemos a obtener las características de cada usuario en función de estes nuevos pesos. Este proceso se describe más formalmente a continuación: Problema de Optimización El problema de optimización se describe como sigue: Dados \\(\\theta^{(1)}, \\cdots, \\theta^{n_\\mu}\\): Para un ejemplo \\(x^{(i)}\\) \\begin{align} \\underset{x^{(i)}}{\\min{}} \\frac{1}{2} \\sum_{j:r(i,j)=1} ((\\theta^{(j)})^Tx^{(i)} - y^{(i,j)})^2 + \\frac{\\lambda}{2} \\sum_{k=1}^n (x_k^{(i)})^2 \\end{align} Para todos los ejemplos del conjunto \\(x^{0}, \\cdots, x^{(n_m)}\\): \\begin{align} \\underset{x^{(1)}, \\cdots, x^{(n_m)}}{\\min{}} \\frac{1}{2} \\sum_{i=1}^{n_m} \\sum_{j:r(i,j)=1} ((\\theta^{(j)})^Tx^{(i)} - y^{(i,j)})^2 + \\frac{\\lambda}{2} \\sum_{i=1}^{n_m}\\sum_{k=1}^n (x_k^{(i)})^2 \\end{align} Es decir queremos minimizar la \"distancia\" entre lo predicho \\((\\theta^{(j)})^T x^{(i)}\\) para el ítem (que ha sido valorado, por lo tanto \\(r(i, j) = 1\\)) y el usuario \\(i\\) y la valoración real \\(y^{(i, j)}\\). Además como queremos obtener los valores de \\(x\\) que minimizan el coste, los añadimos como coste a problema de optimización para evitar overfitting. Algoritmo El algoritmo consta de los siguientes pasos: Inicializar \\(x^{(1)}, \\cdots, x^{(m)}\\) y \\(\\theta^{(1)}, \\cdots, \\theta^{(n_\\mu)}\\) de forma aleatoria. Calcular \\(X\\) a partir de \\(\\Theta\\) Calcular \\(\\Theta\\) a partir de \\(X\\) Volvemos al paso 2. Es decir, queremos obtener \\(X\\) y \\(\\Theta\\) que optimice el siguiente problema: \\begin{align} \\underset{x^{(1)}, \\cdots, x^{(n_m)}, \\theta^{(1)}, \\cdots, \\theta^{(n_\\mu)}}{\\min{}} \\frac{1}{2} \\sum_{i=1}^{n_m} \\sum_{j:r(i,j)=1} ((\\theta^{(j)})^Tx^{(i)} - y^{(i,j)})^2 + \\frac{\\lambda}{2} \\sum_{i=1}^{n_m}\\sum_{k=1}^n (x_k^{(i)})^2 + \\frac{\\lambda}{2} \\sum_{i=1}^{n_\\mu}\\sum_{k=1}^n (\\theta_k^{(i)})^2 \\end{align} Observa que, como estamos optimizando tanto \\(\\theta\\) como \\(x\\), entonces los añadimos como coste a la función de optimización para evitar overfitting: \\(\\frac{\\lambda}{2} \\sum_{i=1}^{n_m}\\sum_{k=1}^n (x_k^{(i)})^2\\) \\(\\frac{\\lambda}{2} \\sum_{i=1}^{n_\\mu}\\sum_{k=1}^n (\\theta_k^{(i)})^2\\) Para aplicar la optimización utilizamos descenso gradiente: primero en función de \\(x\\) y después en función de \\(\\theta\\): \\begin{align} x^{(i)}_k = x^{(i)}_k - \\alpha \\left( \\sum_{j:r(i, j)=1} ((\\theta^{(j)})^T x^{(i)} - y^{(i, j)}) \\theta_k^{(j)} + \\lambda x^{(i)}_k\\right) \\end{align} \\begin{align} \\theta^{(j)}_k = \\theta^{(j)}_k - \\alpha \\left( \\sum_{i:r(i, j)=1} ((\\theta^{(j)})^T x^{(i)} - y^{(i, j)}) x_k^{(i)} + \\lambda \\theta^{(j)}_k\\right) \\end{align} Buscar ítems Relacionados Si \\(||x^{(i)} - x^{(j)}\\)|| es un valor pequeño entonces los ítems \\(i\\) y \\(j\\) son similares. "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/(DS0001)_MLStanfordCoursera/Map Reduce.html",
    "title": "Map Reduce",
    "body": " Back Map Reduce Map Reduce nos permite paralelizar los algoritmos. Por ejemplo, supongamos que: Tenemos \\(m = 400\\) datos Utilizamos Batch Gradient Descent para resolver el problema de optimización Tenemos un número de PC equivalente a 4 Sea \\(i\\) el índice de un PC Este entrena sobre \\(x^{(i)}, \\cdots, x^{(i+100)}\\) Calculamos el coste parcial para este conjunto de datos como: \\(temp_j^{(k)} = \\sum_{i}^{i+100} (h_\\theta(x^{(i)}) - y^{(i)})x^{(i)}_j\\) Ahora, combinamos todos los pesos y aplicamos descenso gradiente: \\(\\theta_j = \\theta_j - \\alpha \\frac{1}{400} \\left( \\sum_{i}^k temp_j^{(i)}\\right)\\) Este tipo de técnicas se utilizan si los algoritmos de entrenamiento pueden ser utilizamos como la suma de funciones, tanto el coste como el gradiente. También es aplicable a PCs con múltiples cores. "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/(DS0001)_MLStanfordCoursera/Evaluación de modelos.html",
    "title": "Evaluación de modelos",
    "body": " Back Evaluación de modelos Separación de Datos Entrenamiento en Regresión Lineal Entrenamiento en Regresión Logística Selección de Modelos Cross Validation Proceso de Selección Diagnóstico: Sesgo vs Varianza Regresión Lineal con Regularización Curva de Aprendizaje Debugging un Algoritmo de Aprendizaje Medidas de Evaluación Balance entre Precisión y Recall Separación de datos A la hora de entrenar un modelo, separamos los datos en dos conjuntos: Conjunto de entrenamiento: \\(70\\%\\) - \\(80\\%\\) Conjunto de test: \\(30\\%\\) - \\(20\\%\\) Entrenamiento en regresión lineal El proceso de entrenamiento en la regresión lineal consiste en: Entrenar el modelo sobre el conjunto de entrenamiento y obtener la matriz de pesos \\(\\Theta\\) minimizando el coste \\(J(\\Theta)\\) Calcular el coste sobre el conjunto de test \\(J_{test}(\\Theta)\\) \\[%align J_{test}(\\Theta) = \\frac{1}{2m} \\sum_{i=1}^{m_{test}} (h_\\Theta(x^{(i)}_{test}) - y^{(i)}_{test})^2 \\] Entrenamiento en regresión logística El proceso de entrenamiento en la regresión logística consiste en: Entrenar el modelo sobre el conjunto de entrenamiento y obtener la matriz de pesos \\(\\Theta\\) minimizando el coste \\(J(\\Theta)\\) Calcular el coste sobre el conjunto de test \\(J_{test}(\\Theta)\\) \\[%align J_{test}(\\Theta) = - \\frac{1}{m} \\sum_{i=1}^{m_{test}} \\left[y^{(i)}_{test} \\log(h_\\Theta(x^{(i)}_{test})) + (1-y^{(i)}_{test})\\log(1-h_\\Theta(x^{(i)}_{test})) \\right] \\] El error de clasificación en la regresión logística se define como sigue: \\begin{align} error(h_\\Theta(x), y) = \\begin{cases} 1, & \\text{ si } h_\\Theta(x) \\geq 0.5 \\rightarrow \\log(h_\\Theta(x)) = 1 \\text{ e } y = 0 \\\\ 1, & \\text{ si } h_\\Theta(x) < 0.5 \\rightarrow \\log(h_\\Theta(x)) = 0 \\text{ e } y = 1 \\\\ 0, \\text{ en cualquier otro caso } \\\\ \\end{cases} \\end{align} Selección de modelos Supongamos que tenemos \\(n\\) modelos, tal que cada modelo es equivalente al anterior pero con una característica más en sus datos: Modelo 1: \\(h_\\Theta(x) = \\theta_0 + \\theta_1 \\cdot x_1\\) Modelo 2: \\(h_\\Theta(x) = \\theta_0 + \\theta_1 \\cdot x_1 + \\theta_2 \\cdot x_2\\) Modelo n: \\(h_\\Theta(x) = \\theta_0 + \\theta_1 \\cdot x_1 + \\theta_2 \\cdot x_2 + \\cdots + \\theta_n \\cdot x_n\\) Para evaluar los modelos lo que hacemos es escoger el que menor coste obtenga sobre el conjunto de test, tras ser entrenado sobre el conjunto de entrenamiento. \\begin{align} \\begin{bmatrix} \\Theta^{(1)} \\\\ \\Theta^{(2)} \\\\ \\vdots \\\\ \\Theta^{(n)} \\\\ \\end{bmatrix} \\rightarrow \\begin{bmatrix} J_{test}(\\Theta^{(1)}) \\\\ J_{test}(\\Theta^{(2)}) \\\\ \\vdots \\\\ J_{test}(\\Theta^{(n)}) \\\\ \\end{bmatrix} \\end{align} Sin embargo, se puede dar el problema de que el mejor simplemente produzca overfitting sobre el conjunto de test (lo cual es probable cuando el vector de pesos tiene dimensiones grandes). Para solventar este problema: Cross Validation Separaremos el conjunto de datos en tres conjuntos: Conjunto de entrenamiento: \\(60\\%\\) Conjunto de validación cruzada (Cross validation): \\(20\\%\\) Conunto de test: \\(20\\%\\) Por lo tanto ahora la función de coste para cada conjunto tiene la forma: Función de coste para el conjunto de entrenamiento: \\begin{align} J_{train}(\\Theta) = \\frac{1}{2m_{train}} \\sum_{i=1}^{m_{train}} error(h_\\Theta(x^{(i)}), y^{(i)}) \\end{align} Función de coste para el conjunto de test: \\begin{align} J_{test}(\\Theta) = \\frac{1}{2m_{test}} \\sum_{i=1}^{m_{test}} error(h_\\Theta(x^{(i)}), y^{(i)}) \\end{align} Función de coste para el conjunto de validación cruzada: \\begin{align} J_{cv}(\\Theta) = \\frac{1}{2m_{cv}} \\sum_{i=1}^{m_{cv}} error(h_\\Theta(x^{(i)}), y^{(i)}) \\end{align} Proceso de selección Entonces ahora para seleccionar un modelo lo que hacemos que para cada modelo \\(q\\): Minimizamos \\(J_{train}(\\Theta^{(q)})\\) para obtener los pesos \\(\\Theta^{(q)}\\) óptimos. Calculamos el coste sobre el conjunto de validación cruzada \\(J_{cv}(\\Theta^{(q)})\\) Una vez hecho esto para todos, escogemos el modelo que ofrezca el mejor coste sobre el conjunto de validación cruzada y calculamos \\(J_{test}(\\Theta^{(q)})\\) para evaluar la capacidad de generalización del modelo. Diagnóstico: Sesgo vs Varianza Underfitting: cuando se produce underfitting el coste de entrenamiento y el coste de validación tienen valores similares y ambos tiene valores bastante altos Overfitting: cuando se produce overfitting el coste de entrenamiento es mucho menor que el coste de validación cruzada. Regresión lineal con regularización También es importante observar cómo afecta el parámetro de regularización a nuestros modelos. Por ejemplo, en la regresión linear, la función de coste tiene la forma: \\begin{align} J(\\Theta) = \\frac{1}{2m}\\sum_{j=1}^m (h_\\Theta(x_j) - y_j)^2 + \\frac{1}{2m} \\lambda \\sum_{i=1}^n \\theta_i^2 \\end{align} Por lo tanto, el aumentar o reducir \\(\\lambda\\) es directamente proporcional al coste. Si el parámetro de regularización \\(\\lambda\\) es muy grande entonces los pesos van a tender a ser muy pequeños (ya que el coste aumenta al aumentar el valor de \\(\\lambda\\)) Si el parámetro de regularización \\(\\lambda\\) es muy pequeño entonces los pesos van a poder ser grandes (ya que el coste se reduce al reducir el valor de \\(\\lambda\\)) Escoger el parámetro de regularización Para escoger el parámetro de regularización seguimos el mismo proceso que para escoger el mejor modelo, para cada modelo \\(q\\): Minimizamos \\(J_{train}(\\Theta^{(q)})\\) para obtener los pesos \\(\\Theta^{(q)}\\) óptimos. Calculamos el coste sobre el conjunto de validación cruzada \\(J_{cv}(\\Theta^{(q)})\\) Una vez hecho esto para todos, escogemos el modelo que ofrezca el mejor coste sobre el conjunto de validación cruzada y calculamos \\(J_{test}(\\Theta^{(q)})\\) para evaluar la capacidad de generalización del modelo. Curva de aprendizaje A continuación vamos a estudiar cómo afecta el tamaño del conjunto de datos \\(m\\), el sesgo y la varianza a nuestro modelo: Cuanto mayor es el tamaño, más difícil es encontrar una hipótesis que se adapte (\\(J_{train}(\\Theta)\\) es mayor), pero el modelo generaliza mejor (\\(J_{cv}(\\Theta)\\) es menor) Cuando el sesgo (bias) es grande, entonces se produce underfitting y las predicciones de nuestro modelo son malas: El error del modelo es elevado, tanto sobre el conjunto de entrenamiento como sobre el conjunto de validación cruzada Tener más ejemplos ayuda al modelo Cuando la varianza (variance) es grande, entonces se produce overfitting, tal que el error en el conjunto de validación cruzada es muy alto: El modelo se adapta al conjunto de datos, por lo que el error de entrenamiento es menor Tener más muestras ayuda al modelo Debugging un algoritmo de aprendizaje Para arreglar el overfitting que se produce cuando la varianza es elevada: Obtener más datos de entrenamiento Utilizar menos características (reducir el grado del vector de pesos), pero tras un proceso de selección de aquellas más relevantes Intentar aumentar el parámetro de regularización Para arregar el underfitting que se produce cuando el sesgo es elevado: Añadir más características Añadir características polinómicas Intentar reducir el parámetro de regularización En las redes neuronales: Las redes pequeñas tienden a producir underfitting pero son menos costosas computacionalmente Las redes grandes tienen más características, por lo tanto hay una mayor probabilidad de overfitting Gestionar datos sesgados: Hay que ser consciente que a veces, por ejemplo en problemas de clasificación, hay categorías que con más comunes que el resto Medidas de evaluación La precisión y el recall son medidas de evaluación que se complementan:     Resultado Resultado     1 0 Predicción 1 Verdadero positivo (TP) Falso positivo (FP) Predicción 0 Falso negativo (FN) Verdadero negativo (TN) Precisión = \\(\\frac{TP}{\\text{ # positivos predichos }} = \\frac{TP}{TP + FP}\\) Recall = \\(\\frac{TP}{\\text{ # positivos reales }} = \\frac{TP}{TP + FN}\\) Balance entre precisión y recall Cuánto mayor es la precisión menor es el recall y viceversa. Entonces Si queremos un modelo más preciso: \\begin{align} \\begin{cases} \\text{Predecir } 1, \\text{ si } h_\\Theta(x) \\geq 0.7 \\\\ \\text{Predecir } 0, \\text{ si } h_\\Theta(x) < 0.7 \\\\ \\end{cases} \\end{align} Entonces, la precisión es mayor ya que el número de \\(FP\\) es menor, pero el recall es menor, ya que el número de \\(FN\\) es mayor. Lo mismo pasa si queremos evitar falsos negativos, entonces hacemos: \\begin{align} \\begin{cases} \\text{Predecir } 1, \\text{ si } h_\\Theta(x) \\geq 0.5 \\\\ \\text{Predecir } 0, \\text{ si } h_\\Theta(x) < 0.5 \\\\ \\end{cases} \\end{align} Tal que se reduce el número de \\(FN\\), y se aumenta el recall, pero el número de \\(FP\\) es mayor, por lo que se reduce la precisión. Entonces, para encontrar un punto de balance entre las dos medidas tenemos que seleccionar un valor límite, tal que hacemos la predicción en base a \\(h_\\Theta(x) \\geq \\text{ limite }\\). Para calibrar ese límite podemos utilizar dos métricas de evaluación: La media de ambas métricas: \\(\\frac{P + R}{2}\\), funciona mal cuando \\(P >> R\\) o \\(R >> P\\), ya que el valor va a ser alto, pero no se ha encontrado un equilibrio. La puntuación \\(F_1 = 2 \\cdot \\frac{P\\cdot R}{(P + R)}\\), tal que cuanto mayor sea esta puntuación mejor Ahora \\begin{align} \\begin{cases} F_1 \\approx 0, && P >> R \\\\ F_1 \\approx 0, && R >> P \\\\ \\end{cases} \\end{align} Para escoger el límite lo que se hace es calcular la puntuación \\(F_1\\) sobre el conjunto de validación cruzada, y se escoge aquel límite que ofrezca la mayor puntuación. "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/(DS0001)_MLStanfordCoursera/Gradient Checking.html",
    "title": "Gradient Checking",
    "body": " Back Gradient Checking Consiste en la estimación numérica de los gradientes, tal que: \\begin{align} \\frac{\\delta J(\\Theta)}{\\delta \\Theta} \\approx \\frac{J(\\Theta - \\epsilon) - J(\\Theta + \\epsilon)}{2 \\cdot \\epsilon} \\end{align} \\begin{align} \\frac{\\delta J(\\Theta)}{\\delta \\theta_j} \\approx \\frac{J(\\theta_0, ..., \\theta_j - \\epsilon, ..., \\theta_n) - J(\\theta_0, ..., \\theta_j + \\epsilon, ..., \\theta_n)}{2 \\cdot \\epsilon} \\end{align} "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/(DS0001)_MLStanfordCoursera/Clustering.html",
    "title": "Clustering",
    "body": " Back Clustering K-Means Escogemos e inicializamos \\(K\\) centroides que servirán para hacer de clústers. Para cada ejemplo \\(j\\): asignamos el centroide más cercano Una vez asignados todos los ejemplos, resituamos cada centroide en función de los ejemplos asignados al mismo. Volvemos al paso 2. Algoritmo Entrada: Número de clústers \\(K\\) Conjunto de entrenamiento: \\(\\{x^{(0)}, \\cdots, x^{(m)}\\}\\), con \\(x^{(i)} \\in \\mathbb{R}^n\\) Inicializamos los \\(K\\) centroides \\((\\mu_1, \\cdots, \\mu_k) \\in \\mathbb{R}^n\\) de forma aleatoria. Repetimos: Para cada ejemplo \\(x^{(j)}\\), \\(C^{(j)}\\) es el índice del centroide más cercano a \\(x^{(j)}\\): \\(\\underset{i}{min}||x^{(j)} - \\mu_i||\\) Para cada clúster: \\(\\mu_i\\) es la media de los puntos \\(x^{(j)}\\) asignados al centroide \\(i\\): \\(\\mu_i = \\frac{1}{t} \\left[\\sum_{j=1}^t x^{(j)} \\text{ donde } C^{(j)} = i\\right]\\), donde \\(t\\) es el número de ejemplos asignados al centroide \\(i\\). Si el centroide no tiene puntos, se elimina o se vuelve a inicializar de forma aleatoria. Clústers no claramente separables Cuando los datos contienen mucho ruido lo que se hace es resolver el siguiente problema de optimización: \\begin{align} \\underset{C^{(1)}, \\cdots, C^{(m)}, \\mu_1, \\cdots, \\mu_k}{min} J(C^{(1)}, \\cdots, C^{(m)}, \\mu_1, \\cdots, \\mu_k) \\end{align} Donde la función de coste \\(J\\) se define como: \\begin{align} J(C^{(i)}, \\mu_i) = \\frac{1}{m} \\sum_{i=1}^m ||x^{(i)} - \\mu_{C^{(i)}}||^2 \\end{align} Es decir, el coste es equivalente a la suma de la distancia entre el ejemplo \\(x^{(i)}\\) y su clúster asignado \\(\\mu_{C^{(i)}}\\), para cada ejemplo. El algoritmo de optimización lo que hace es: Minimiza el coste con respecto a \\(C\\) Minimiza el coste con respecto a \\(\\mu\\) Inicialización aleatoria Debemos escoger un número de centroides \\(K\\) menor que el número de ejemplos \\(m\\). Inicializamos cada centroide equivalente a un ejemplo aleatorio del conjunto de entrenamiento: \\(\\mu_i = x^{(j)}\\) Hay que tener en cuenta que, en función de la inicialización de los centroides, se pueden obtener distintos resultados en el problema de optimización, por ello lo que se hace es: Aplicar el algoritmo muchas veces Escoger el modelo que obtuvo menor coste Este proceso es viable si el número de clústers es pequeño. Parametrización de Clústering Una forma de escoger el número de clústers \\(K\\) es utilizando el método del codo: Se aplica el modelo con un número distinto de clústers Se evalúa con alguna métrica el rendimiento (coste) del modelo y Se elige el ofrece una mayor mejora con respecto a un número de clústers menor "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/(DS0001)_MLStanfordCoursera/Regresión Lineal.html",
    "title": "Regresión Lineal",
    "body": " Back Regresión Lineal Descripción de los datos Hipótesis Funcion de coste Descenso gradiente Descripción de los datos \\(X = (x_{ij})\\) una matriz \\(n \\times m\\) donde cada \\(x_{ij}\\) es la característica \\(i\\) del ejemplo \\(j\\), tal que \\begin{align} X = \\begin{bmatrix} x_{11} & \\cdots & x_{1m} \\\\ \\cdots & \\ddots & \\cdots \\\\ x_{n1} & \\cdots & x_{nm} \\\\ \\end{bmatrix} \\end{align} Cada columna es un ejemplo En cada fila están los valores de una característica \\(\\Theta = (\\theta_i)\\) es un vector fila \\(1\\times n\\) donde cada \\(\\theta_i\\) es el peso de la característica \\(i\\), tal que: \\begin{align} \\Theta = \\begin{bmatrix} \\theta_1 & \\cdots & \\theta_n\\end{bmatrix} \\end{align} \\(Y = (y_j)\\) es un vector fila \\(1\\times m\\) donde cada \\(y_j\\) es la salida real para el ejemplo \\(j\\), tal que: \\begin{align} Y = \\begin{bmatrix} y_1 & \\cdots & y_m\\end{bmatrix} \\end{align} Hipótesis Dado un ejemplo, es decir un vector columna \\(x\\), de dimensiones \\(n \\times 1\\), la hipótesis se define como: \\begin{align} h_\\Theta(x) = \\sum_{i=1}^n \\theta_i \\cdot x_i \\end{align} Dado un conjunto de \\(m\\) datos, es decir matriz \\(X\\), de dimensiones \\(n \\times m\\), la hipótesis se define como: \\begin{align} h_\\Theta(x) = \\Theta\\cdot X = \\begin{bmatrix}\\sum_{i=1}^n \\theta_i \\cdot x_{i1} & \\cdots & \\sum_{i=1}^n \\theta_i \\cdot x_{im}\\end{bmatrix} \\end{align} El resultado es un vector fila \\(1 \\times m\\), es decir como el vector de salidas \\(Y\\) Funcion de coste Se define la función de coste, \\(J(\\Theta)\\) como: \\begin{align} J(\\Theta) = \\frac{1}{2m}\\sum_{j=1}^m (h_\\Theta(x_j) - y_j)^2 \\end{align} Esta función de coste se denomina Mínimos cuadrados. Regularización Con regularización, se define la función de coste, \\(J(\\Theta)\\) como: \\begin{align} J(\\Theta) = \\frac{1}{2m}\\sum_{j=1}^m (h_\\Theta(x_j) - y_j)^2 + \\frac{1}{2m} \\lambda \\sum_{i=1}^n \\theta_i^2 \\end{align} Descenso gradiente Para actualizar el vector de pesos \\(\\Theta\\) aplicamos el descenso gradiente. Para cada peso \\(\\theta_i\\): \\begin{align} \\theta_i = \\theta_i - \\alpha \\left( \\frac{\\delta J(\\Theta)}{\\delta \\theta_i}\\right) \\end{align} La derivada del coste en función del peso \\(\\theta_i\\) se calcula como sigue: Sustituimos la función de coste \\begin{align} \\frac{\\delta J(\\Theta)}{\\delta \\theta_i} = \\frac{\\delta}{\\delta \\theta_i} \\left(\\frac{1}{2m}\\sum_{j=1}^m (h_\\Theta(x_j) - y_j)^2\\right) = \\end{align} Sacamos el factor constante de la derivada \\begin{align} = \\frac{1}{2m} \\frac{\\delta}{\\delta \\theta_i} \\left(\\sum_{j=1}^m (h_\\Theta(x_j) - y_j)^2\\right) \\end{align} Aplicamos la propiedad que dice que la derivada de una suma equivale a la suma de las derivadas \\begin{align} = \\frac{1}{2m} \\left(\\sum_{j=1}^m \\frac{\\delta}{\\delta \\theta_i}(h_\\Theta(x_j) - y_j)^2\\right) \\end{align} Aplicamos la regla de la cadena \\begin{align} = \\frac{1}{2m} \\left(\\sum_{j=1}^m \\frac{\\delta(h_\\Theta(x_j) - y_j)^2}{\\delta (h_\\Theta(x_j) - y_j)} \\frac{\\delta (h_\\Theta(x_j) - y_j)}{\\delta \\theta_i}\\right) \\end{align} Aplicamos aritmética \\begin{align} = \\frac{1}{2m} \\left(\\sum_{j=1}^m 2(h_\\Theta(x_j) - y_j) \\left[\\frac{\\delta (h_\\Theta(x_j))}{\\delta \\theta_i} - \\frac{\\delta (y_j)}{\\delta \\theta_i}\\right]\\right) \\end{align} Como la derivada de \\(y_i\\) es función de \\(\\theta_i\\) es cero, procedemos a calcular la derivada de \\(h_\\Theta(x_j)\\): \\begin{align} \\frac{\\delta h_\\Theta(x_j)}{\\delta \\theta_i} = \\frac{\\delta}{\\delta \\theta_i} \\sum_{k=1}^n \\theta_k x_{kj} = \\sum_{k=1}^n \\frac{\\delta}{\\delta \\theta_i} \\theta_k x_{kj} \\end{align} Donde \\begin{align} \\frac{\\delta}{\\delta \\theta_i} \\theta_k x_{kj} = \\begin{cases} x_{kj}, & k = i \\\\ 0, & k \\neq i \\\\ \\end{cases} \\end{align} Como para todo \\(k\\), con \\(1 \\leq k \\leq n\\) sólo hay un \\(k\\), tal que \\(k = i\\), entonces: \\begin{align} \\frac{\\delta h_\\Theta(x_j)}{\\delta \\theta_i} = x_{kj} \\end{align} Volemos a la derivada del peso, con \\(\\frac{\\delta h_\\Theta(x_j)}{\\delta \\theta_i} = x_{kj}\\) y \\(\\frac{\\delta y_j}{\\delta \\theta_i} = 0\\): \\begin{align} = \\frac{1}{2m} \\left(\\sum_{j=1}^m 2(h_\\Theta(x_j) - y_j) \\left[x_{ij} - 0\\right]\\right) \\end{align} \\begin{align} = \\frac{1}{2m} \\left(\\sum_{j=1}^m 2(h_\\Theta(x_j) - y_j) \\cdot x_{ij}\\right) \\end{align} Sacamos el factor constante 2 como factor común que se elimina con 1/2 \\begin{align} = \\frac{1}{m} \\left(\\sum_{j=1}^m (h_\\Theta(x_j) - y_j) \\cdot x_{ij}\\right) \\end{align} Finalmente, sustituimos todo en la función del gradiente: \\begin{align} \\theta_i = \\theta_i - \\alpha \\left( \\frac{\\delta J(\\Theta)}{\\delta \\theta_i}\\right) = \\theta_i - \\alpha \\left[\\frac{1}{m} \\left(\\sum_{j=1}^m (h_\\Theta(x_j) - y_j) \\cdot x_{ij}\\right)\\right] \\end{align} Regularización Con regularización debemos derivar la función que coste que incluye el parámetro de regularización: \\begin{align} \\theta_i = \\theta_i - \\alpha \\left( \\frac{\\delta J(\\Theta)}{\\delta \\theta_i}\\right) + \\frac{\\lambda}{2m} \\sum_{k=1}^n \\theta_k^2 \\end{align} El primer término ya lo hemos derivado, por lo tanto procedemos a derivar el segundo término: \\begin{align} \\frac{\\delta}{\\delta \\theta_i} \\left(\\frac{\\lambda}{2m} \\sum_{k=1}^n \\theta_k^2\\right) = \\frac{\\lambda}{2m} \\left(\\sum_{k=1}^n \\frac{\\delta}{\\delta \\theta_i} \\theta_k^2\\right) \\end{align} Donde \\begin{align} \\frac{\\delta}{\\delta \\theta_i} \\theta_k^2 = \\begin{cases} 2 \\theta_k, & k = i \\\\ 0, & k \\neq i \\end{cases} \\end{align} Como para todo \\(k\\), con \\(1 \\leq k \\leq n\\) sólo hay un \\(k\\), tal que \\(k = i\\), entonces: \\begin{align} \\frac{\\delta}{\\delta \\theta_i} \\left(\\frac{\\lambda}{2m} \\sum_{k=1}^n \\theta_k^2\\right) = \\frac{\\lambda}{2m} 2\\theta_i = \\frac{\\lambda}{m} \\theta_i \\end{align} Por lo tanto la función del descenso gradiente equivale a: \\begin{align} \\theta_i = \\theta_i - \\alpha \\left( \\frac{\\delta J(\\Theta)}{\\delta \\theta_i}\\right) = \\theta_i - \\alpha \\left[\\frac{1}{m} \\left(\\sum_{j=1}^m (h_\\Theta(x_j) - y_j) \\cdot x_{ij}\\right) + \\frac{\\lambda}{m}\\theta_i\\right] \\end{align} "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/(DS0001)_MLStanfordCoursera/Regresión Logística.html",
    "title": "Regresión Logística",
    "body": " Back Regresión Logística Descripción de los datos Hipótesis Funcion de coste Descenso gradiente Descripción de los datos \\(X = (x_{ij})\\) una matriz \\(n \\times m\\) donde cada \\(x_{ij}\\) es la característica \\(i\\) del ejemplo \\(j\\), tal que \\begin{align} X = \\begin{bmatrix} x_{11} & \\cdots & x_{1m} \\\\ \\cdots & \\ddots & \\cdots \\\\ x_{n1} & \\cdots & x_{nm} \\\\ \\end{bmatrix} \\end{align} Cada columna es un ejemplo En cada fila están los valores de una característica \\(\\Theta = (\\theta_i)\\) es un vector fila \\(1\\times n\\) donde cada \\(\\theta_i\\) es el peso de la característica \\(i\\), tal que: \\begin{align} \\Theta = \\begin{bmatrix} \\theta_1 & \\cdots & \\theta_n\\end{bmatrix} \\end{align} \\(Y = (y_j)\\) es un vector fila \\(1\\times m\\) donde cada \\(y_j\\) es la salida real para el ejemplo \\(j\\), tal que: \\begin{align} Y = \\begin{bmatrix} y_1 & \\cdots & y_m\\end{bmatrix} \\end{align} Donde cada salida \\(y_j\\), para un clasificador de dos clases sólo puede tener los valores \\(0\\) o \\(1\\). Hipótesis Para un valor \\(z\\), la función sigmoide \\(g\\) se define como: \\begin{align} g(z) = \\frac{e^z}{(1+e^z)} = \\frac{1}{(1 + e^{-z})} \\end{align} Sea \\(g\\) la función sigmoide. Dado un ejemplo, es decir un vector columna \\(x\\), de dimensiones \\(n \\times 1\\), la hipótesis se define como: \\begin{align} h_\\Theta(x) = g\\left(\\sum_{i=1}^n \\theta_i \\cdot x_i\\right) = \\begin{cases} 0, & h_\\Theta(x) < 0.5 \\\\ 1, & h_\\Theta(x) \\geq 0.5 \\\\ \\end{cases} \\end{align} Dado un conjunto de \\(m\\) datos, es decir matrix \\(X\\), de dimensiones \\(n \\times m\\), la hipótesis se define como: \\begin{align} h_\\Theta(x) = \\Theta\\cdot X = \\begin{bmatrix}g(\\sum_{i=1}^n \\theta_i \\cdot x_{i1}) & \\cdots & g(\\sum_{i=1}^n \\theta_i \\cdot x_{im})\\end{bmatrix} \\end{align} El resultado es un vector fila \\(1 \\times m\\), es decir como el vector de salidas \\(Y\\) Funcion de coste Se define la función de coste, \\(J(\\Theta)\\) como: \\begin{align} J(\\Theta) = \\frac{1}{m}\\sum_{j=1}^m \\text{coste}(h_\\Theta(x_j)) \\end{align} Donde \\(\\text{coste}\\) es una función definida como sigue: \\begin{align} \\text{coste}(h_\\Theta(x_j)) = [-y_j \\log(h_\\Theta(x_j))] - [(1-y_j)\\log(1-h_\\Theta(x_j))] \\end{align} Regularización Con regularización, se define la función de coste, \\(J(\\Theta)\\) como: \\begin{align} J(\\Theta) = -\\frac{1}{m}\\sum_{j=1}^m [y_j \\log(h_\\Theta(x_j))] + [(1-y_j)\\log(1-h_\\Theta(x_j))] + \\frac{1}{2m} \\lambda \\sum_{i=1}^n \\theta_i^2 \\end{align} Descenso gradiente Para actualizar el vector de pesos \\(\\Theta\\) aplicamos el descenso gradiente. Para cada peso \\(\\theta_i\\): \\begin{align} \\theta_i = \\theta_i - \\alpha \\left( \\frac{\\delta J(\\Theta)}{\\delta \\theta_i}\\right) \\end{align} La derivada del coste en función del peso \\(\\theta_i\\) se calcula como sigue: Sustituimos la función de coste \\begin{align} \\frac{\\delta J(\\Theta)}{\\delta \\theta_i} = \\frac{\\delta}{\\delta \\theta_i} \\left(-\\frac{1}{m}\\sum_{j=1}^m [y_j \\log(h_\\Theta(x_j))] + [(1-y_j)\\log(1-h_\\Theta(x_j))]\\right) = \\end{align} Sacamos el factor constante \\(\\frac{1}{m}\\) y aplicamos la propiedad \"La derivada de una suma equivale a la suma de las derivadas\", tal que: \\begin{align} \\frac{\\delta J(\\Theta)}{\\delta \\theta_i} = -\\frac{1}{m}\\sum_{j=1}^m \\frac{\\delta}{\\delta \\theta_i} \\left([y_j \\log(h_\\Theta(x_j))] + [(1-y_j)\\log(1-h_\\Theta(x_j))]\\right) = \\end{align} \\begin{align} \\frac{\\delta J(\\Theta)}{\\delta \\theta_i} = -\\frac{1}{m}\\sum_{j=1}^m \\left(\\frac{\\delta}{\\delta \\theta_i} [y_j \\log(h_\\Theta(x_j))]\\right) + \\left(\\frac{\\delta}{\\delta \\theta_i}[(1-y_j)\\log(1-h_\\Theta(x_j))]\\right) = \\end{align} Sacamos los factores constantes \\(y_j\\) y \\(1-y_j\\) y aplicamos la regla de la cadena: \\begin{align} \\frac{\\delta J(\\Theta)}{\\delta \\theta_i} = -\\frac{1}{m}\\sum_{j=1}^m \\left(y_j\\frac{\\delta\\log(h_\\Theta(x_j))}{\\delta h_\\Theta(x_j)} \\frac{\\delta h_\\Theta(x_j)}{\\delta \\theta_i}\\right) + \\left((1-y_j)\\frac{\\delta\\log(1-h_\\Theta(x_j))}{\\delta (1- h_\\Theta(x_j))}\\frac{\\delta (1- h_\\Theta(x_j))}{\\delta \\theta_i}\\right) = \\end{align} Tenemos que, para el último término: \\begin{align} \\frac{\\delta (1- h_\\Theta(x_j))}{\\delta \\theta_i} = \\frac{\\delta(1)}{\\delta \\theta_i} - \\frac{\\delta h_\\Theta(x_j)}{\\delta \\theta_i} = - \\frac{\\delta h_\\Theta(x_j)}{\\delta \\theta_i} \\end{align} Por lo tanto, si sustituimos: \\begin{align} \\frac{\\delta J(\\Theta)}{\\delta \\theta_i} = -\\frac{1}{m}\\sum_{j=1}^m \\left(y_j\\frac{\\delta\\log(h_\\Theta(x_j))}{\\delta h_\\Theta(x_j)} \\frac{\\delta h_\\Theta(x_j)}{\\delta \\theta_i}\\right) + \\left((1-y_j)\\frac{\\delta\\log(1-h_\\Theta(x_j))}{\\delta (1- h_\\Theta(x_j))}(-1)\\frac{\\delta h_\\Theta(x_j)}{\\delta \\theta_i}\\right) = \\end{align} Aplicamos la regla \\(\\frac{\\delta \\log(x)}{\\delta x} = \\frac{1}{x}\\), sacamos la expresión \\(\\frac{\\delta h_\\Theta(x_j)}{\\delta \\theta_i}\\) como factor común y hacemos negativo el segundo término: \\begin{align} \\frac{\\delta J(\\Theta)}{\\delta \\theta_i} = -\\frac{1}{m}\\sum_{j=1}^m \\left(\\frac{y_j}{h_\\Theta(x_j)} \\right) - \\left(\\frac{(1 - y_j)}{1-h_\\Theta(x_j)}\\right) \\frac{\\delta h_\\Theta(x_j)}{\\delta \\theta_i} = \\end{align} Aplicamos operationes aritméticas: \\begin{align} \\frac{\\delta J(\\Theta)}{\\delta \\theta_i} = -\\frac{1}{m}\\sum_{j=1}^m \\left(\\frac{(y_j)(1-h_\\Theta(x_j)) - (1-y_j)(h_\\Theta(x_j))}{h_\\Theta(x_j)(1-h_\\Theta(x_j))} \\right)\\frac{\\delta h_\\Theta(x_j)}{\\delta \\theta_i} = \\end{align} Centrémonos ahora en \\(\\frac{\\delta h_\\Theta(x_j)}{\\delta \\theta_i}\\). Para calcular esta derivada, primero expresamos la hipótesis utilizando la función sigmoide: \\begin{align} \\frac{\\delta h_\\Theta(x_j)}{\\delta \\theta_i} = \\frac{\\delta}{\\delta \\theta_i} g(\\Theta x_j) \\end{align} Aplicamos la regla de la cadena \\begin{align} \\frac{\\delta h_\\Theta(x_j)}{\\delta \\theta_i} = \\frac{\\delta g(\\Theta x_j)}{\\delta \\Theta x_j} \\frac{\\delta \\Theta x_j}{\\delta \\theta_i} \\end{align} Sabemos que la derivada del segundo término \\(\\frac{\\delta \\Theta x_j}{\\delta \\theta_i}\\) equivale a \\(x_{ij}\\), por lo tanto, calcularemos sólo \\(\\frac{\\delta g(\\Theta x_j)}{\\delta \\Theta x_j}\\) Sea: \\begin{align} g(\\Theta x_j) = \\frac{1}{1 + e^{-\\Theta x_j}} = (1 + e^{-\\Theta x_j})^{-1} \\end{align} Aplicamos la regla de la cadena \\begin{align} \\frac{\\delta g(\\Theta x_j)}{\\delta \\Theta x_j} = \\frac{\\delta(1 + e^{-\\Theta x_j})^{-1}}{\\delta(1+e^{-\\Theta x_j})}\\frac{\\delta(1+e^{-\\Theta x_j})}{\\delta \\Theta x_j} \\end{align} Resolvemos la primera derivada aplicando las propiedades de las derivadas sobre los polinomios y volvemos a aplicar la propiedad de que la derivada de una suma equivale a la suma de las derivadas en el segundo término: \\begin{align} \\frac{\\delta g(\\Theta x_j)}{\\delta \\Theta x_j} = (-1)(1 + e^{-\\Theta x_j})^{-2}\\left[\\frac{\\delta (1)}{\\delta \\Theta x_j} + \\frac{\\delta e^{-\\Theta x_j}}{\\delta \\Theta x_j} \\right] \\end{align} Como \\(\\frac{\\delta (1)}{\\delta \\Theta x_j}\\) equivale a cero: \\begin{align} \\frac{\\delta g(\\Theta x_j)}{\\delta \\Theta x_j} = (-1)(1 + e^{-\\Theta x_j})^{-2} \\frac{\\delta e^{-\\Theta x_j}}{\\delta \\Theta x_j} \\end{align} Resolvemos la última derivada, sabiendo que \\(\\frac{\\delta e^x}{\\delta x} = e^x\\) \\begin{align} \\frac{\\delta g(\\Theta x_j)}{\\delta \\Theta x_j} = (-1)(1 + e^{-\\Theta x_j})^{-2} (-1) e^{-\\Theta x_j} = (1 + e^{-\\Theta x_j})^{-2} e^{-\\Theta x_j} = \\frac{e^{-\\Theta x_j}}{(1 + e^{-\\Theta x_j})^2} \\end{align} Como \\(\\frac{e^{-\\Theta x_j}}{(1 + e^{-\\Theta x_j})^2} = \\left(\\frac{1}{1+e^{-\\Theta x_j}}\\right)\\left(1 - \\frac{1}{1 + e^{-\\Theta x_j}}\\right)\\), entonces: \\begin{align} \\frac{\\delta g(\\Theta x_j)}{\\delta \\Theta x_j} = \\frac{e^{-\\Theta x_j}}{(1 + e^{-\\Theta x_j})^2} = \\left(\\frac{1}{1+e^{-\\Theta x_j}}\\right)\\left(1 - \\frac{1}{1 + e^{-\\Theta x_j}}\\right) = h_\\Theta(x_j) (1- h_\\Theta(x_j)) \\end{align} Ya que según la definición de la hipótesis \\(h_\\Theta(x_j) = \\frac{1}{1 + e^{-\\Theta x_j}}\\) Por lo tanto, juntado los resultados, tenemos que: \\begin{align} \\frac{\\delta h_\\Theta(x_j)}{\\delta \\theta_i} = \\frac{\\delta g(\\Theta x_j)}{\\delta \\Theta x_j} \\frac{\\delta \\Theta x_j}{\\delta \\theta_i} = h_\\Theta(x_j) (1- h_\\Theta(x_j)) x_{ij} \\end{align} Volvemos, entonces, a la derivada de la función de coste y sustituimos \\(\\frac{\\delta h_\\Theta(x_j)}{\\delta \\theta_i}\\) \\begin{align} \\frac{\\delta J(\\Theta)}{\\delta \\theta_i} = -\\frac{1}{m}\\sum_{j=1}^m \\left(\\frac{(y_j)(1-h_\\Theta(x_j)) - (1-y_j)(h_\\Theta(x_j))}{h_\\Theta(x_j)(1-h_\\Theta(x_j))} \\right) h_\\Theta(x_j) (1- h_\\Theta(x_j)) x_{ij} = \\end{align} Los términos \\(h_\\Theta(x_j) (1- h_\\Theta(x_j))\\) se cancelan tal que: \\begin{align} \\frac{\\delta J(\\Theta)}{\\delta \\theta_i} = -\\frac{1}{m}\\sum_{j=1}^m \\left((y_j)(1-h_\\Theta(x_j)) - (1-y_j)(h_\\Theta(x_j)) \\right) x_{ij} = \\end{align} Aplicamos operaciones aritméticas: \\begin{align} \\frac{\\delta J(\\Theta)}{\\delta \\theta_i} = -\\frac{1}{m}\\sum_{j=1}^m (y_j - y_jh_\\Theta(x_j) - h_\\Theta(x_j) + y_jh_\\Theta(x_j)) x_{ij} \\end{align} El término \\(y_jh_\\Theta(x_j)\\) se cancela, tal que: \\begin{align} \\frac{\\delta J(\\Theta)}{\\delta \\theta_i} = -\\frac{1}{m}\\sum_{j=1}^m (y_j - h_\\Theta(x_j)) x_{ij} \\end{align} Finalmente movemos el \\((-1)\\) dentro del sumatorio: \\begin{align} \\frac{\\delta J(\\Theta)}{\\delta \\theta_i} = \\frac{1}{m}\\sum_{j=1}^m (h_\\Theta(x_j)-y_j) x_{ij} \\end{align} Por lo tanto la función del descenso gradiente equivale a: \\begin{align} \\theta_i = \\theta_i - \\alpha \\left( \\frac{\\delta J(\\Theta)}{\\delta \\theta_i}\\right) = \\theta_i - \\alpha \\left[\\frac{1}{m} \\left(\\sum_{j=1}^m (h_\\Theta(x_j) - y_j) \\cdot x_{ij}\\right) \\right] \\end{align} Observa que tiene la misma forma que para la regresión lineal, pero la hipótesis para la regresión logística está definida en términos de la función sigmoide Regularización Con regularización debemos derivar la función de coste que incluye el parámetro de regularización: \\begin{align} \\theta_i = \\theta_i - \\alpha \\left( \\frac{\\delta J(\\Theta)}{\\delta \\theta_i}\\right) + \\frac{\\lambda}{2m} \\sum_{k=1}^n \\theta_k^2 \\end{align} El primer término ya lo hemos derivado, por lo tanto procedemos a derivar el segundo término: \\begin{align} \\frac{\\delta}{\\delta \\theta_i} \\left(\\frac{\\lambda}{2m} \\sum_{k=1}^n \\theta_k^2\\right) = \\frac{\\lambda}{2m} \\left(\\sum_{k=1}^n \\frac{\\delta}{\\delta \\theta_i} \\theta_k^2\\right) \\end{align} Donde \\begin{align} \\frac{\\delta}{\\delta \\theta_i} \\theta_k^2 = \\begin{cases} 2 \\theta_k, & k = i \\\\ 0, & k \\neq i \\end{cases} \\end{align} Como para todo \\(k\\), con \\(1 \\leq k \\leq n\\) sólo hay un \\(k\\), tal que \\(k = i\\), entonces: \\begin{align} \\frac{\\delta}{\\delta \\theta_i} \\left(\\frac{\\lambda}{2m} \\sum_{k=1}^n \\theta_k^2\\right) = \\frac{\\lambda}{2m} 2\\theta_i = \\frac{\\lambda}{m} \\theta_i \\end{align} Por lo tanto la función del descenso gradiente equivale a: \\begin{align} \\theta_i = \\theta_i - \\alpha \\left( \\frac{\\delta J(\\Theta)}{\\delta \\theta_i}\\right) = \\theta_i - \\alpha \\left[\\frac{1}{m} \\left(\\sum_{j=1}^m (h_\\Theta(x_j) - y_j) \\cdot x_{ij}\\right) + \\frac{\\lambda}{m}\\theta_i\\right] \\end{align} Al igual que antes, observa que tiene la misma forma que para la regresión lineal, pero la hipótesis para la regresión logística está definida en términos de la función sigmoide "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/(DS0001)_MLStanfordCoursera/Ceiling Analysis.html",
    "title": "Ceiling Analysis",
    "body": " Back Ceiling Analysis Supongamos que tenemos un pipeline que conforma todo nuestro sistema de aprendizaje automático y está formado por: Obtención de la imagen Detección de texto Segmentación de caracteres Reconocimiento de caracteres Lo que hacemos es determinar una o varias métricas de evaluación, por ejemplo nosotros utilizaremos la precisión. Entonces, ahora creamos una tabla indicando el valor de métrica para cada parte del sistema así como para el sitema completo: Componente Precisión Detección del texto 82% Segmentación de caracteres 90% Reconocimiento de caracteres 100% Total 72% A partir de esta tabla podemos comprobar que mejorar la Detección en el texto y la Segmentación de caracteres mejora el rendimiento del modelo. "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/(DS0001)_MLStanfordCoursera/DimensionalityReduction/Dimensionality Reduction.html",
    "title": "Dimensionality Reduction",
    "body": " Back Dimensionality Reduction Standardize Data PCA Find Underlying Space Represent the Subspace Algorithm Layout Performing Eigen Decomposition ICA Intuition Solution Given examples \\(\\{x^{(i)}\\}_{i=1}^n\\) where \\(x^{(i)} \\in \\mathbb{R}^d\\), we want to find out if our data lives is a low dimensional space. Look at the next example: We can see that the two features are correlated, and we can project the points onto a line, reducing the space from two dimensions to one. So it might be the case that some features are highly correlated, and so de d-dimensional space can be as a k-dimensional space where \\(0 < k < d\\): \\begin{align} \\begin{bmatrix} x_{11} & \\cdots & x_{1d} \\\\ \\vdots & \\ddots & \\vdots \\\\ x_{n1} & \\cdots & x_{nd} \\\\ \\end{bmatrix} \\rightarrow \\begin{bmatrix} x_{11} & \\cdots & x_{1k} \\\\ \\vdots & \\ddots & \\vdots \\\\ x_{n1} & \\cdots & x_{nk} \\\\ \\end{bmatrix} \\end{align} Standardize Data A lot of the times the units of each feature in the data make the values in one column (feature) be much bigger than the values in another column. Thus, the first step is to standardize your data: Center data Have it have variance equal to one So we transform our data as follows: \\begin{align} x_j^{(i)} = \\frac{x_j^{(i)} - \\mu_j}{\\sigma_j} \\end{align} Where: \\(u_j\\) is the mean of the feature \\(j\\) over the \\(n\\) examples, such that \\(u_j = \\frac{1}{n}\\sum_{i=1}^nx^{(i)}_j\\) \\(\\sigma_j\\) is the standard deviation of the feature \\(j\\) over the \\(n\\) examples, where \\(\\sigma_j^2 = \\frac{1}{n}\\sum_{i=1}^n(x^{(i)}_j - \\mu_j)^2\\) PCA Find Underlying Space To reduce the dimensionality of our data we first define a subspace and then we project each point onto the subspace. This projection is the closes point in the subspace to the point we are trying to project, this has as a consequence that the \"line\" connecting the point to its projection is always perpendicular to the subspace: The goal is to choose the subspace that maximizes the variance of the projected points, to retain the maximum possible variance of the data. As you can see if we choose the blue line as the subspace the variance is much bigger that if we choose the red line: Represent the Subspace Let us suppose the subspace is defined by a basis vector \\(u \\in \\mathbb{R}^d\\) where \\(u\\) is a unit vector, then projection of \\(\\overrightarrow{x^{(i)}}\\) on to the space spanned by \\(u\\) will be: \\begin{align} Proj(u)\\overrightarrow{x^{(i)}} \\end{align} Where \\(Proj(u)\\) is the projection matrix and \\(x^{(i)} \\in \\mathbb{R}^d\\). So, because \\(Proj(u) = \\frac{uu^T}{u^Tu}\\), then the projected point is defined as: \\begin{align} Proj(u)\\overrightarrow{x^{(i)}} = \\frac{uu^T}{u^Tu} \\overrightarrow{x^{(i)}} = ((x^{(i)})^Tu)u \\end{align} Where \\(((x^{(i)})^Tu)\\) is an scalar. So, now our goal is to find a \\(u\\) that maximizes the variance across the \\(n\\) examples. That is, we want to maximize the sum of the square of the norms of the projected points: More formally: \\begin{align} u = \\underset{u}{\\arg \\max} \\frac{1}{n}\\sum_{i=1}^n ||Proj(u)x^{(i)}||^2 = \\frac{1}{n}\\sum_{i=1}^n ||((x^{(i)})^Tu)u||^2 \\end{align} Because the norm of a unit vector multiplied by a scalar is just the square of the scalar (for \\(3 \\cdot \\begin{pmatrix} 1 & 0 & 0 \\end{pmatrix}\\): \\(||\\begin{pmatrix} 3 & 0 & 0 \\end{pmatrix}|| = (\\sqrt{3^2 + 0^2 + 0^2})^2 = 3^2\\)): \\begin{align} u = \\underset{u}{\\arg \\max} \\frac{1}{n}\\sum_{i=1}^n ((x^{(i)})^Tu)^2 = \\frac{1}{n}\\sum_{i=1}^n ((x^{(i)})^Tu)^T((x^{(i)})^Tu) = \\frac{1}{n}\\sum_{i=1}^n u^T x^{(i)} (x^{(i)})^T u \\end{align} Because \\(u, u^T\\) are a common factor in the sum: \\begin{align} u = \\underset{u}{\\arg \\max} \\left[u^T \\left(\\frac{1}{n}\\sum_{i=1}^n x^{(i)} (x^{(i)})^T \\right) u\\right] \\end{align} Now, we know that given the optimization problem of the form \\(\\underset{u}{\\arg \\max} \\left[u^T A u\\right]\\), the solution \\(u\\) is the eigenvector corresponding to the largest eigenvalue of \\(A\\). In this scenario, \\(A = \\left(\\frac{1}{n}\\sum_{i=1}^n x^{(i)} (x^{(i)})^T \\right)\\), which equals the sample covariance matrix, which is defined as: \\begin{align} \\frac{1}{n} \\sum_{i=1}^n (x^{(i)} - \\mu)^T (x^{(i)} - \\mu) = \\frac{1}{n} \\sum_{i=1}^n (x^{(i)} - 0)^T (x^{(i)} - 0) = \\frac{1}{n} \\sum_{i=1}^n (x^{(i)})^T x^{(i)} \\end{align} Note that, because our data is now centered after standardizing it, the mean \\(\\mu\\) equals zero. Hence, we want to calculate the eigenvectors of the sample covariance matrix of x. Mind you, we have derived this solution for a space defined by only one vector \\(u\\). However given basis vectors \\((u_1, \\cdots, u_k)\\) the optimization problem holds and the solution are the \\(k\\) eigenvectors corresponding to the \\(k\\) largest eigenvalues of \\(A\\). Algorithm Layout The steps of PCA are the following: Calculate the sample covariance matrix as \\(x^Tx\\) Calculate the eigenvector and eigenvalues of \\(x^Tx\\), such that: \\begin{align} \\begin{matrix} (\\lambda_1, u_1) \\\\ (\\lambda_2, u_2) \\\\ \\vdots \\\\ (\\lambda_d, u_d) \\\\ \\end{matrix} \\end{align} Are the \\(d\\) eigenvectors (\\(u_i\\)) and eigenvalues (\\(\\lambda_i\\)). We assume the tuples are ordered in decreasing order with respect to the eigenvalues, such that if \\(i > j\\) then \\(\\lambda_i > \\lambda_j\\). Find \\(k\\) such that we satisfy a confidence level with respect to the variance, i.e. suppose you want to preserve 95% of the variance of the original data then: \\begin{align} \\frac{\\sum_{i=1}^k \\lambda_i}{\\sum_{j=1}^d \\lambda_j} = 95\\% \\end{align} Choose the \\(k\\) eigenvectors with the largest corresponding eigenvalues. Performing Eigen-decomposition First of all, let us present two properties regarding eigen-decompositions of a matrix \\(X\\): If \\(X\\) is a square matrix and symmetric then \\(X\\) has orthogonal eigenvectors and real eigenvalues. If \\(X\\) is also positive semi-definite then the eigenvalues are positive. In our case, the eigen-decomposition is done over \\(x^Tx\\), therefore this matrix is guaranteed to be a square matrix, symmetric and positive semi-definite. Then, performing the eigen decomposition of \\(x^Tx\\) is equivalent to performing singular value decomposition (SVD) over \\(x\\), such that the single values equal the square root of the eigenvalues. Large Datasets To perform PCA on large datasets we use a technique called Power Iteration, which consists on: For \\(i=0\\), initialize \\(U^{(i)}\\) to random values other than zero Set \\(i = i+1\\), and \\(U^{(i)} = (X^TX)U^{(i-1)}\\) Re-scale \\(U^{(i)}\\) to have unit length such that: \\(U^{(i)}=\\frac{(X^TX)U^{(i-1)}}{||(X^TX)U^{(i-1)}||}\\) Go to step 2. Eventually it will converge to the largest eigenvector. Rephrasing PCA Another way to describe the problem solved by PCA, equivalent to the maximization variance perspective, is: Find a subspace such that the projection of the points are as close to the original data as possible, that is minimize the sum of the distances between the projected points and the original points. ICA This algorithm pretends to solve what is commonly known as the source separation problem, where we are given a dataset \\(X\\) that is a mixture of some source data \\(S\\). We then use these mixed sources \\(X\\) to construct a unmixing matrix \\(W\\) to recover the source \\(S\\). Intuition Imagine there are \\(d\\) speakers and \\(d\\) microphones randomly distributed in a room, such that: \\(s \\in \\mathbb{R}^d\\) is the representation of what a speaker says. So \\(S_j^{(i)}\\) is what the \\(j\\) speaker said in moment \\(i\\). \\(x \\in \\mathbb{R}^d\\) is the representation of what a microphone records. So \\(x_j^{(i)}\\) is what the \\(j\\) microphone recorded in moment \\(i\\). For example, given two speaker, what they say is represented as follows: Meanwhile the recordings of the microphones are the following: We are only given \\(X\\), and the goal is to recover the original speech signal spoken by each speaker. We assume that \\(X\\) is a linear combination of what each speaker says, thus \\(X = AS\\), where \\(A\\) is a quare matrix \\(d \\times d\\) and is called the mixing matrix. What we want to do is to compute the inverse of \\(A\\), \\(W\\) such that \\(W = A^{-1}\\), where \\(W\\) is called the unmixing matrix. Then: \\begin{align} A^{-1}X = A^{-1}AS \\rightarrow A^{-1}X = S \\rightarrow WX = S \\rightarrow S = WX \\end{align} Solution To solve this problem we make the following assumptions: The number of sources \\(S\\) are equal to the number of \"examples\" in the mixed dataset \\(X\\) \\(X\\) is a linear combination of \\(S\\), such that \\(S = WX\\) \\(S_j\\) is independent of \\(S_k\\), whenever \\(j \\neq k\\). That is to say, each belongs to a different probability distribution, and are two independent random variables. Each \\(S_j\\) is not Gaussian. Intuition Suppose we are given a random variable \\(X\\) such that \\(X ~ Unif [0,1]\\), then the probability density function is: Let us define a new distribution as follows \\(y=2x\\), then the probability density function is: Note, that the function is \"stretched\" as to always satisfy the condition that the integral of \\(PDF\\) must equal 1, which is the same as saying the area under the function is 1. So now, \\(P_y (y) = P_x(x) \\cdot \\frac{1}{2} = P_x(\\frac{y}{2})\\cdot\\frac{1}{2}\\), because \\(x = \\frac{y}{2}\\). But what happens in a higher dimension? That is, what happens when we multiply \\(x \\in \\mathbb{R}^d\\) by a mixing matrix \\(W \\in \\mathbb{R}^{d \\times d}\\). Well, given \\(y \\in \\mathbb{R}^{d \\times d}\\), such that \\(y=WX\\), then to perform a change of random variable we use the Jacobian: \\begin{align} P_y(y) = P_x(X)\\frac{1}{|W|} = P_x(W^{-1}Y)\\frac{1}{|W|} \\end{align} Where \\(|W|\\) is the determinant of \\(W\\). First of all we define the distribution of the mixed dataset as follows: \\begin{align} P_X(x) = \\prod_{j=1}^d P_S (S_j) |W| = \\prod_{j=1}^d P_S (W_j^TX) |W| \\end{align} Note that \\(S_j=(W_j)^TX\\). We also assume that \\(P_S\\) is distributed according to a logistic distribution, thus: Cumulative Distribution Function (CDF): \\(\\frac{1}{1+e^{-x}} = \\sigma(x)\\) Probability Density Function (pdf): \\(\\sigma(x)\\sigma(1-x)\\) So, we obtain the likelihood of \\(W\\) as follows: \\begin{align} l(W) = \\sum_{i=1}^n \\left[\\left(\\sum_{j=1}^d \\log[\\sigma(x^{(i)})(1-\\sigma(x^{(i)}))]\\right) + \\log{|W|}\\right] \\end{align} Where \\(W\\) is the parameter we are trying to obtain. So, to solve the optimization problem: We define the maximization of the likelihood as the objective We compute the derivative of \\(l(W)\\) and perform gradient descent, such that the update step is as follows: \\begin{align} W = W - \\alpha \\left\\{\\begin{bmatrix} (1- 2\\sigma(W_1^Tx^{(i)})) \\\\ (1- 2\\sigma(W_2^Tx^{(i)})) \\\\ \\vdots \\\\ (1- 2\\sigma(W_d^Tx^{(i)})) \\\\ \\end{bmatrix} (x^{(i)})^T + (W^T)^{-1} \\right\\} \\end{align} "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/(DS0001)_MLStanfordCoursera/Ecuación Normal.html",
    "title": "Ecuación Normal",
    "body": " Back Ecuación Normal Descripción de los datos Hipótesis Funcion de coste Minimización del coste Anotaciones Descripción de los datos \\(X = (x_{ij})\\) una matriz \\(m \\times (n + 1)\\) donde cada \\(X_{i}\\) es un vector fila \\(1 \\times (n+1)\\), que incluye los valores de todas las características para el ejemplo \\(i\\). \\begin{align} X = \\begin{bmatrix} X_1 \\\\ \\vdots \\\\ X_i \\\\ \\vdots \\\\ X_m \\\\ \\end{bmatrix} \\end{align} Cabe destacar que \\(X_{i0} = 1\\), es el término independiente. \\(\\Theta = (\\theta_i)\\) es un vector columna \\((n+1)\\times 1\\) donde cada \\(\\theta_i\\) es el peso de la característica \\(i\\), tal que: \\begin{align} \\Theta = \\begin{bmatrix} \\theta_0 \\\\ \\vdots \\\\ \\theta_n\\end{bmatrix} \\end{align} \\(Y = (y_j)\\) es un vector columna \\(m\\times 1\\) donde cada \\(y_j\\) es la salida real para el ejemplo \\(j\\), tal que: \\begin{align} Y = \\begin{bmatrix} y_1 \\\\ \\cdots \\\\ y_m\\end{bmatrix} \\end{align} Hipótesis Dado un conjunto de \\(m\\) datos, es decir matriz \\(X\\), de dimensiones \\(m \\times (n+1)\\), la hipótesis se define como: \\begin{align} h_\\Theta(x) = X \\cdot \\Theta = \\begin{bmatrix} X_1 \\cdot \\Theta = \\sum_{i=0}^{n+1} \\theta_i x_{1i} \\\\ \\vdots \\\\ X_j \\cdot \\Theta = \\sum_{i=0}^{n+1} \\theta_i x_{ji} \\\\ \\vdots \\\\ X_m \\cdot \\Theta = \\sum_{i=0}^{n+1} \\theta_i x_{mi} \\\\ \\end{bmatrix} \\end{align} Observa que ahora \\(X\\) y \\(\\Theta\\) están colocados de forma inversa a como lo hacíamos en la regresión lineal y la regresión logística. Esto es debido a que hemos transpuesto las matrices \\(X\\) y \\(\\Theta\\), con respecto a como las habíamos definido en las secciones anteriores. El cálculo es el mismo. Funcion de coste Se define la función de coste, \\(J(\\Theta)\\) como: \\begin{align} J(\\Theta) = \\frac{1}{2m} (X\\Theta - Y)^T(X\\Theta - Y) \\end{align} La expresión \\((X\\Theta - Y)^T(X\\Theta - Y)\\) es equivalente a \\((h_\\Theta(x) - y)^2\\), que se utilizaba en la función de coste de la regresión lineal. Regularización Con regularización, se define la función de coste, \\(J(\\Theta)\\) como: \\begin{align} J(\\Theta) = \\frac{1}{2m} (X\\Theta - Y)^T(X\\Theta - Y) + \\frac{1}{2m} \\lambda \\Theta^T\\Theta \\end{align} Minimización del coste Con la ecuación normal, en lugar de actualizar el vector de pesos \\(\\Theta\\) de forma iterativa, lo que hacemos es igualar la derivada del coste en base a los pesos a cero utilizando derivación matricial: \\[%align \\Delta_\\Theta J(\\Theta) = \\begin{bmatrix} \\frac{\\delta J(\\Theta)}{\\delta \\theta_0} \\\\ \\vdots \\\\ \\frac{\\delta J(\\Theta)}{\\delta \\theta_i} \\\\ \\vdots \\\\ \\frac{\\delta J(\\Theta)}{\\delta \\theta_n} \\\\ \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ \\vdots \\\\ 0 \\\\ \\vdots \\\\ 0 \\\\ \\end{bmatrix} = \\overrightarrow{0} \\] A continuación exponemos cómo se calcula la derivada: Sustituímos la función de coste: \\[%align \\Delta_\\Theta J(\\Theta) = \\Delta_\\Theta \\frac{1}{2m}(X \\Theta - Y)^T (X \\Theta - Y) \\] Aplicamos la propiedad \\((A + B)^T = A^T + B^T\\) \\[%align \\Delta_\\Theta J(\\Theta) = \\Delta_\\Theta \\frac{1}{2m}((X\\Theta)^T - Y^T) (X \\Theta - Y) \\] Sacamos el factor constante de la derivada y realizamos la multiplicación: \\[%align \\Delta_\\Theta J(\\Theta) = \\frac{1}{2m} \\Delta_\\Theta (X\\Theta)^T(X\\Theta) - (X\\Theta)^TY -Y^TX\\Theta + Y^TY \\] Aplicamos la propiedad \\(AB = B^TA^T\\), tal que \\(Y^T(X\\Theta) = (X\\Theta)^T((Y)^T)^T = (X\\Theta)^TY\\) \\[%align \\Delta_\\Theta J(\\Theta) = \\frac{1}{2m} \\Delta_\\Theta (X\\Theta)^T(X\\Theta) - (X\\Theta)^TY - (X\\Theta)^TY + Y^TY \\] Agrupamos términos compatibles: \\[%align \\Delta_\\Theta J(\\Theta) = \\frac{1}{2m} \\Delta_\\Theta (X\\Theta)^T(X\\Theta) - 2(X\\Theta)^TY + Y^TY \\] Como \\(\\Delta_\\Theta Y^TY=0\\): \\[%align \\Delta_\\Theta J(\\Theta) = \\frac{1}{2m} \\Delta_\\Theta (X\\Theta)^T(X\\Theta) - 2(X\\Theta)^TY \\] Finalmente calculamos la derivada matricial: \\[%align \\Delta_\\Theta J(\\Theta) = \\frac{1}{2m} 2X^T(X\\Theta) - 2X^TY = \\frac{1}{m} X^T(X\\Theta) - X^TY \\] Ahora igualamos la expresión obtenida a cero: \\[%align \\Delta_\\Theta J(\\Theta) = \\frac{1}{m} [X^TX\\Theta - X^TY] = 0 \\] Multiplicamos por \\(m\\) en ambos lados de la ecuación: \\[%align X^TX\\Theta - X^TY = 0 \\] Sumamos \\(X^TY\\) en ambos lados de la ecuación: \\[%align X^TX\\Theta - X^TY + X^TY= X^TY \\] \\[%align X^TX\\Theta = X^TY \\] Multiplicamos por \\((X^TX)^{-1}\\) por la izquierda en ambos lados de la ecuación: \\[%align (X^TX)^{-1}X^TX\\Theta = (X^TX)^{-1}X^TY \\] \\[%align I\\Theta = (X^TX)^{-1}X^TY \\] \\[%align \\Theta = (X^TX)^{-1}X^TY \\] De tal manera que ahora hemos calculado el vector de pesos óptimo que minimiza el coste. Regularización Con regularización debemos derivar la función que coste que incluye el parámetro de regularización: \\begin{align} J(\\Theta) = \\frac{1}{2m} (X\\Theta - Y)^T(X\\Theta - Y) + \\frac{1}{2m} \\lambda \\Theta^T\\Theta \\end{align} El primer término ya lo hemos derivado, por lo tanto procedemos a derivar el segundo término: \\[%align \\Delta_\\Theta \\frac{1}{2m} \\lambda \\Theta^T\\Theta \\] Sacamos el factor constante \\(\\frac{\\lambda}{2m}\\) fuera de la derivada \\[%align \\frac{\\lambda}{2m} \\Delta_\\Theta [\\Theta^T\\Theta] \\] Llevamos a cabo la derivada matricial: \\[%align \\frac{\\lambda}{2m} 2 \\Theta = \\frac{\\lambda}{m} \\Theta \\] Juntamos las derivadas de ambos términos: \\[%align \\Delta_\\Theta J(\\Theta) = \\frac{1}{m} [X^TX\\Theta - X^TY] + \\frac{\\lambda}{m} \\Theta \\] Sacamos \\(\\frac{1}{m}\\) como factor común e igualamos a cero \\[%align \\Delta_\\Theta J(\\Theta) = \\frac{1}{m} (X^TX\\Theta - X^TY + \\lambda\\Theta) = 0 \\] Multiplicamos por \\(m\\) en ambos lados de la ecuación: \\[%align X^TX\\Theta - X^TY + \\lambda\\Theta = 0 \\] Sumamos \\(X^TY\\) en ambos lados de la ecuación: \\[%align X^TX\\Theta - X^TY + X^TY + \\lambda\\Theta = X^TY \\] \\[%align X^TX\\Theta + \\lambda\\Theta = X^TY \\] Sacamos \\(\\Theta\\) como factor común \\[%align (X^TX + \\lambda I)\\Theta = X^TY \\] Donde \\(I\\) es la matriz identidad e dimensiones \\((n+1) \\times (n+1)\\). Multiplicamos \\((X^TX + \\lambda I)^{-1}\\) por la izquierda en ambos lados de la ecuación: \\[%align (X^TX + \\lambda I)^{-1}(X^TX + \\lambda I)\\Theta = (X^TX + \\lambda I)^{-1}X^TY \\] \\[%align I\\Theta = (X^TX + \\lambda I)^{-1}X^TY \\] \\[%align \\Theta = (X^TX + \\lambda I)^{-1}X^TY \\] De tal forma que hemos calculado el \\(\\Theta\\) óptimo que minimiza el coste, utilizando regularización. Anotaciones No se debe utilizar la ecuación normal cuando el número de ejemplos \\(m\\) es muy grande, ya que es rendimiento del algoritmo es malo Hay que tener cuidado con si las matrices son inversibles Si \\(m \\leq n\\), entonces las matrices no son invertibles. Si \\(\\lambda > 0\\), entonces aseguramos la inversibilidad de las matrices. "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/(DS0001)_MLStanfordCoursera/index.html",
    "title": "Machine Learning Stanford Coursera",
    "body": " Back Machine Learning Stanford Coursera Apredizaje supervisado Regresión Lineal Regresión Logística Ecuación Normal Neural Networks Gradient Checking Inicialización aleatoria Evaluación de modelos SVM Aprendizaje no supervisado En el aprendizaje no supervisado, los ejemplos de entrenamiento no tienen etiquetas (\\(y\\)). Se utilizan para buscar correlación y patrones en los ejemplos de entrenamiento. Clustering Dimensionality Reduction Expectation-Maximization Algorithms Sistemas de Recomendación Grandes Datasets Aprendizaje Online Map Reduce Datos Artificiales Ceiling Analysis "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/(DS0001)_MLStanfordCoursera/Inicialización aleatoria.html",
    "title": "Inicialización aleatoria",
    "body": " Back Inicialización aleatoria Cuando creamos una red neuronal, si inicializamos todos los pesos \\(\\theta\\) a cero, entonces todos los nodos serán iguales. Por ello se inicializa \\(\\theta\\) con valores aleatorios dentro de un rango \\([- \\epsilon, \\epsilon]\\) "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/(DS0001)_MLStanfordCoursera/NeuralNetworks/Anexo/Explicación de la retropropagación.html",
    "title": "Explicación de la retropropagación",
    "body": " Back Explicación de la retropropagación Descenso Gradiente Derivada del Error Gradiente Capa de salida Retropropagación del Gradiente Gradiente Acumulado Derivadas de las Funciones de Activación Componentes: \\(w_j^k\\): peso de la neurona \\(j=1...I_k\\) en la capa \\(k=1...H\\) \\(a_{ij}^k=(w_j^k)^Th_i^{k-1}+b_j^k\\): \\(i=1...N\\) (patrón), \\(k=1...H\\)(capa), \\(j=1...I_k\\) (neurona de la capa \\(k\\)). \\(h_i^{k-1}\\): salida de la capa \\(k-1\\) con \\(I_{k-1}\\) valores (uno por cada neurona \\(j=1...I_{k-1}\\) para cada patrón \\(x_i\\). \\(h_i^k\\): salida de la capa \\(k\\) para cada patrón \\(x_i\\): \\(h_{ij}=f(a_{ij}^k)\\) con \\(j=1...I_k\\) \\(y_{ij}\\): salida verdadera de la neurona de salida \\(j\\) y el patrón \\(x_i\\). Descenso gradiente \\begin{align} \\Delta w_j^k=-\\mu \\frac{\\delta J}{\\delta w_j^k} \\end{align} \\begin{align} \\Delta b_j^k=-\\mu \\frac{\\delta J}{\\delta b_j^k} \\end{align} Para \\(k=1...H\\). De tal forma que se actualizan los pesos \\(w_j^k\\) y el offset \\(b_j^k\\) de la capa \\(k\\) y de la neurona \\(j\\). Tenemos que la capa de salida está compuesta de \\(I_H\\) neuronas que se recorren con el índice \\(j\\). Accedemos a la salida verdadera del ejemplo \\(i\\) para la neurona \\(j\\) (\\(y_{ij}\\)) y restamos la salida predicha \\(h_{ij}^H\\) que hace referencia a la salida de la función de activación de la capa \\(H\\) para la neurona \\(j\\) y el ejemplo \\(i\\). La diferencia se eleva al cuadrado para obtener MSE. También se puede vectorizar restando los vectores \\(y_i\\) y \\(h_i^H \\in \\mathbb{R}^j\\). De esta manera obtenemos el error para el patrón \\(x_i\\): \\(J_i\\). Derivada del error Aplicamos la regla de la cadena sobre \\(J_i\\), ya que este depende de \\(a_{ij}^k\\): \\begin{align} \\frac{\\delta J_i}{\\delta w_j^k}=\\frac{\\delta J_i}{\\delta a_{ij}^k}\\frac{\\delta a_{ij}^k}{\\delta w_j^k} \\end{align} \\begin{align} \\frac{\\delta J_i}{\\delta b_j^k}=\\frac{\\delta J_i}{\\delta a_{ij}^k}\\frac{\\delta a_{ij}^k}{\\delta b_j^k} \\end{align} Definimos: \\begin{align} \\delta_{ij}^k \\equiv \\frac{\\delta J_i}{\\delta a_{ij}^k} \\end{align} Este indica el gradiente de la capa siguiente, para evitar tener que calcularlo. \\begin{align} \\frac{\\delta a_{ij}^k}{\\delta w_j^k} = h_i^{k-1} \\end{align} \\begin{align} \\frac{\\delta a_{ij}^k}{\\delta b_j^k} = 1 \\end{align} Debido a que el valor de \\(a_{ij}^k\\) es la combinación lineal de la entradas y los pesos, donde las entradas son las salidas de la capa anterior (\\(k-1\\)), es decir \\(h_i^{k-1}\\), de tal manera que: \\begin{align} a_{ij}^k = (w_j^k)^Th_i^{k-1}+b_j^k \\end{align} Por lo que la derivada en función de \\(w_j^k\\) se corresponde con \\(h_i^{k-1}\\) y la derivada en función de \\(b_j^k\\) es 1. Gradiente Si sustituimos \\(\\delta_{ij}^k \\equiv \\frac{\\delta J_i}{\\delta a_{ij}^k}\\) y \\(\\frac{\\delta a_{ij}^k}{\\delta w_j^k} = h_i^{k-1}\\) en \\(\\frac{\\delta J_i}{\\delta w_j^k}=\\frac{\\delta J_i}{\\delta a_{ij}^k}\\frac{\\delta a_{ij}^k}{\\delta w_j^k}\\) obtenemos: \\begin{align} \\Delta w_j^k=-\\mu \\frac{\\delta J}{\\delta w_j^k} \\end{align} \\begin{align} \\Delta w_j^k=-\\mu \\sum_{i=1}^N \\frac{\\delta J_i}{\\delta a_{ij}^k}\\frac{\\delta a_{ij}^k}{\\delta w_j^k} = -\\mu \\sum_{i=1}^N\\delta_{ij}^kh_i^{k-1} \\end{align} Hacemos los mismo para el offset sustituyendo \\(\\delta_{ij}^k \\equiv \\frac{\\delta J_i}{\\delta a_{ij}^k}\\) y \\(\\frac{\\delta a_{ij}^k}{\\delta b_j^k} = 1\\) en \\(\\frac{\\delta J_i}{\\delta b_j^k}=\\frac{\\delta J_i}{\\delta a_{ij}^k}\\frac{\\delta a_{ij}^k}{\\delta b_j^k}\\) obtenemos: \\begin{align} \\Delta b_j^k=-\\mu \\frac{\\delta J}{\\delta b_j^k} \\end{align} \\begin{align} \\Delta b_j^k= -\\mu \\sum_{i=1}^N\\frac{\\delta J_i}{\\delta a_{ij}^k}\\frac{\\delta a_{ij}^k}{\\delta b_j^k}=-\\mu \\sum_{i=1}^N\\delta_{ij}^k \\end{align} Capa de salida Calculamos \\(\\delta_{ij}^k\\) en la capa de salida (\\(k=H\\)), cuyo valor se va a propagar hacia las capas anteriores. Lo que vamos a calcular es \\(\\delta_{ij}^k \\equiv \\frac{\\delta J_i}{\\delta a_{ij}^k}\\). Tenemos que la función de coste para el patrón \\(i\\), \\(J_i\\) viene definida por: \\begin{align} J_i=\\frac{1}{2}\\sum_{j=1}^{I_H}(y_{ij}-h_{ij}^H)^2=\\frac{|y_i-h_i^H|^2}{2} \\end{align} Además el valor de \\(a_{ij}^k\\), que es la combinación lineal de las entradas (salidas de las neuronas capa anterior, \\(k-1\\)) y los pesos junto con el offset: \\begin{align} a_{ij}^k=(w_j^k)^Th_i^{k-1}+b_j^k \\end{align} Por lo tanto en la capa final: \\begin{align} \\frac{\\delta J_i}{\\delta a_{ij}^H}=\\frac{1}{2}\\frac{\\delta (y_{ij}-h_{ij}^H)^2}{\\delta (y_{ij}-h_{ij}^H)}\\frac{\\delta (y_{ij}-h_{ij}^H)}{\\delta a_{ij}^H} \\end{align} Donde: \\begin{align} \\frac{\\delta (y_{ij}-h_{ij}^H)^2}{\\delta (y_{ij}-h_{ij}^H)}=2(y_{ij}-h_{ij}^H) \\end{align} \\begin{align} \\frac{\\delta (y_{ij}-h_{ij}^H)}{\\delta a_{ij}^H}=\\frac{\\delta y_{ij}}{\\delta a_{ij}^H}-\\frac{\\delta h_{ij}^H}{\\delta a_{ij}^H}=0-f'(a_{ij}^H) \\end{align} Ya que sabemos que \\(h_{ij}^H=f(a_{ij}^H)\\), por lo que: \\begin{align} \\frac{\\delta h_{ij}^H}{\\delta a_{ij}^H}=\\frac{\\delta f(a_{ij}^H)}{\\delta a_{ij}^H}=f'(a_{ij}^H) \\end{align} Una vez desarrollado todo esto sustiuimos los resultados en \\(\\frac{\\delta J_i}{\\delta a_{ij}^H}\\): \\begin{align} \\frac{\\delta J_i}{\\delta a_{ij}^H}=\\frac{1}{2}2(y_{ij}-h_{ij}^H)(-f'(a_{ij}^H))=(y_{ij}-h_{ij}^H)f'(a_{ij}^H) \\end{align} De tal forma que: \\begin{align} \\delta_{ij}^H=\\frac{\\delta J_i}{\\delta a_{ij}^H}=(y_{ij}-h_{ij}^H)f'(a_{ij}^H)=\\epsilon_{ij}^Hf'(a_{ij}^H) \\end{align} Donde se define \\(\\epsilon_{ij}^H\\) como: \\begin{align} \\epsilon_{ij}^H=y_{ij}-h_{ij}^H \\end{align} Finalmente obtenemos que el antigradiente en la última capa \\(H\\) viene dado por: \\begin{align} \\Delta w_j^H=-\\mu \\sum_{i=1}^N\\delta_{ij}^Hh_i^{H-1}=-\\mu\\sum_{i=1}^N\\epsilon_{ij}^Hf'(a_{ij}^H)h_i^{H-1} \\end{align} \\begin{align} \\Delta b_j^H=-\\mu \\sum_{i=1}^N\\delta_{ij}^H=-\\mu\\sum_{i=1}^N\\epsilon_{ij}^Hf'(a_{ij}^H) \\end{align} Retropropagación del gradiente Para las capas anteriores a la capa de salida (\\(k<H\\)): \\begin{align} \\delta_{ij}^k=\\frac{\\delta J_i}{\\delta a_{ij}^k}=\\sum_{l=1}^{I_{k+1}}\\frac{\\delta J_i}{\\delta a_{il}^{k+1}}\\frac{\\delta a_{il}^{k+1}}{\\delta a_{ij}^k}=\\sum_{l=1}^{I_{k+1}}\\delta_{il}^{k+1}\\frac{\\delta a_{il}^{k+1}}{\\delta a_{ij}^k} \\end{align} En este caso se utiliza la regla de la cadena para obtener \\(\\delta_{ij}^k\\) de modo que se tienen en cuenta todas las combinaciones del gradiente acumulado \\(\\delta a_{il}^{k+1}\\) con la neurona actual (\\(\\delta a_{ij}^k\\)) donde \\(l=1...I_{k+1}\\), es decir se tienen encuenta todas las neuronas de la capa siguiente. Con grafos, la regla de la cadena se puede interpretar como todos los caminos posibles desde la capa de salida hasta la neurona \\(j\\) en la capa \\(k\\). Cada camino une cada neurona \\(l\\) de la capa siguiente: \\(\\delta_{il}^{k+1}\\) (el cual ya tiene el gradiente acumulado de las capas siguientes) con una neurona \\(j\\) de la capa actual: \\(\\delta a_{ij}^k\\) de la siguiente forma: \\(\\delta_{il}^{k+1}\\frac{\\delta a_{il}^{k+1}}{\\delta a_{ij}^k}\\). Además se suman todas las combinación posibles: \\(\\sum_{l=1}^{I_{k+1}}\\). Esto nos permite utilizar el gradiente acumulado calculado en la capa siguiente que se propaga hacia atrás en la red neuronal, lo que evita tener que calcular \\(\\frac{\\delta J_i}{\\delta a_{ij}^k}\\). Por otro lado tenemos: \\begin{align} a_{il}^{k+1}=(w_l^{k+1})^Th_i^{k}+b_l^{k+1} \\end{align} Que es el cálculo de la neurona \\(l\\) de la capa siguiente, por lo que utiliza como entradas las salidas de la neurona de esta capa \\(h_i^{k}\\). Esta es la versión vectorizada del cálculo, si lo expresamos como sumatorio: \\begin{align} a_{il}^{k+1}=\\sum_{m=1}^{I_k}w_{lm}^{k+1}h_{im}^{k}+b_{lm}^{k+1}=\\sum_{m=1}^{I_k}w_{lm}^{k+1}f(a_{im}^{k})+b_{lm}^{k+1} \\end{align} De tal forma que se multiplican los \\(I_k\\) pesos de la capa siguiente (\\(w_{lm}^{k+1}\\)) con las \\(I_k\\) salidas de la capa actual (\\(h_{im}^{k}\\)) y sumamos los offset (\\(b_{lm}^{k+1}\\)). Además sabemos que \\(h_{im}^{k}=f(a_{im}^{k})\\). Por lo tanto: \\begin{align} \\frac{\\delta a_{il}^{k+1}}{\\delta a_{ij}^k}=\\sum_{m=1}^{I_k}(\\frac{\\delta(w_{lm}^{k+1}f(a_{im}^{k}))}{\\delta a_{ij}^k}+\\frac{\\delta b_{lm}^{k+1}}{\\delta a_{ij}^k}) \\end{align} La primera derivada tiene la siguiente forma: \\begin{align} \\frac{\\delta(w_{lm}^{k+1}f(a_{im}^{k}))}{\\delta a_{ij}^k}=w_{lm}^{k+1}\\frac{\\delta f(a_{im}^{k})}{\\delta a_{ij}^k} \\end{align} \\begin{align} \\frac{\\delta f(a_{im}^{k})}{\\delta a_{ij}^k} =\\begin{cases} f'(a^k_{im})=f'(a^k_{ij}) & m=j\\\\ 0 & m \\ne j \\end{cases} \\end{align} Por lo que podemos eliminar el sumatorio sobre \\(m\\) y la derivada sobre el offset ya que su valor es nulo: \\begin{align} \\frac{\\delta a_{il}^{k+1}}{\\delta a_{ij}^k}=w_{lj}^{k+1}f'(a^k_{ij}) + 0 \\end{align} Gradiente acumulado Si volvemos a \\(\\delta_{ij}^k=\\frac{\\delta J_i}{\\delta a_{ij}^k}=\\sum_{l=1}^{I_{k+1}}\\delta_{il}^{k+1}\\frac{\\delta a_{il}^{k+1}}{\\delta a_{ij}^k}\\). Sustituimos \\(\\frac{\\delta a_{il}^{k+1}}{\\delta a_{ij}^k}\\) obteniendo: \\begin{align} \\delta_{ij}^k=\\frac{\\delta J_i}{\\delta a_{ij}^k}=\\sum_{l=1}^{I_{k+1}}\\delta_{il}^{k+1}w_{lj}^{k+1}f'(a^k_{ij}) \\end{align} Podemos extraer \\(f'(a^k_{ij})\\) ya que esta no depende de \\(l\\): \\begin{align} \\delta_{ij}^k=f'(a^k_{ij})\\sum_{l=1}^{I_{k+1}}\\delta_{il}^{k+1}w_{lj}^{k+1} \\end{align} Si definimos: \\begin{align} \\epsilon_{ij}^k=\\sum_{l=1}^{I_{k+1}}\\delta_{il}^{k+1}w_{lj}^{k+1} \\end{align} Tenemos que: \\begin{align} \\delta_{ij}^k=f'(a^k_{ij})\\epsilon_{ij}^k \\end{align} Derivadas de las funciones de activación La derivada de la función sigmoide: \\begin{align} f'(t)=af(t)(1-f(t)) \\end{align} "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/(DS0001)_MLStanfordCoursera/NeuralNetworks/Anexo/Ejemplo Cálculo Función de Coste.html",
    "title": "Ejemplo Cálculo Función de Coste",
    "body": " Back Ejemplo Cálculo Función de Coste Utilizamos como ejemplo la figura de multiclasificación donde tenemos que \\(c=3\\), y la hipótesis tiene los valores: \\begin{align} h_\\Theta(x_1) = \\begin{bmatrix} 0.02 \\\\ 0.1 \\\\ 0.88 \\\\ \\end{bmatrix} \\end{align} y la salida real para el ejemplo \\(x_1\\) tiene los valores: \\begin{align} y_1 = \\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\\\ \\end{bmatrix} \\end{align} Entonces la función de coste se calcularía como (observa que esto es sólo para un ejemplo, por lo que obviamos el primer sumatorio): \\begin{align} J(\\Theta) = - \\sum_{i=1}^c [y_{ij}\\cdot \\log(h_\\Theta(x_j)_i)] + [(1-y_{ij})\\cdot \\log(1-(h_\\Theta(x_j)_i))] \\end{align} \\begin{align} J(\\Theta) = - \\{[(y_{11}\\cdot\\log(h_\\Theta(x_1)_{1})) + (1-y_{11})\\cdot\\log(1-h_\\Theta(x_1)_{1})] + \\end{align} \\begin{align} + [(y_{21}\\cdot\\log(h_\\Theta(x_1)_{2})) + (1-y_{21})\\cdot\\log(1-h_\\Theta(x_1)_{2})] + \\end{align} \\begin{align} + [(y_{31}\\cdot\\log(h_\\Theta(x_1)_{3})) + (1-y_{31})\\cdot\\log(1-h_\\Theta(x_1)_{3})]\\} \\end{align} Sustituimos los valores de cada vector: \\begin{align} J(\\Theta) = - \\{ [(0\\cdot\\log(0.02)) + (1-0)\\cdot\\log(1-0.02)] + \\end{align} \\begin{align} + [(0\\cdot\\log(0.1)) + (1-0)\\cdot\\log(1-0.1)] + \\end{align} \\begin{align} + [(1\\cdot\\log(0.88)) + (1-1)\\cdot\\log(1-0.88)] \\} = \\end{align} Calculamos los valores: \\begin{align} J(\\Theta) = - (\\log(0.98) + \\log(0.9) + \\log(0.88)) \\end{align} \\begin{align} J(\\Theta) = - (-0.009 - 0.046 -0.056) = - (-0.111) = 0.111 \\end{align} "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/(DS0001)_MLStanfordCoursera/NeuralNetworks/Anexo/Derivadas capas intermedias.html",
    "title": "Derivadas capas intermedias",
    "body": " Back Derivada capas intermedias Donde \\(q\\) denota la capa, con \\(1 \\leq q \\leq (k-1)\\). Pues lo que tenemos que hacer es, de nuevo, aplicar la regla de la cadena, entre el peso \\(\\theta_{it}^{(q)}\\) (peso \\(t\\) del nodo \\(i\\) de la capa \\(q\\)) y todo nodo \\(a_{lj}^{(q+1)}\\)(es decir para el nodo \\(l\\) en la capa \\(q+1\\) para el ejemplo \\(j\\)). \\[%align \\frac{\\delta J(\\Theta)}{\\delta \\theta_{it}^{(q)}} = \\frac{J(\\Theta)}{\\delta a^{(q+1)}_{1j}}\\frac{\\delta a_{1j}^{(q+1)}}{\\delta \\theta_{it}^{(q)}} + \\cdots + \\frac{J(\\Theta)}{\\delta a^{(q+1)}_{(S_(q+1))j}}\\frac{\\delta a_{(S_(q+1))j}^{(q+1)}}{\\delta \\theta_{it}^{(q)}} \\] Donde \\(S_{(q+1)}\\) es el número de nodos en la capa \\(q+1\\). Para cada término \\(l\\) de la suma, debemos volver a aplicar la regla de la cadena, tal que: \\[%align \\frac{\\delta J(\\Theta)}{\\delta \\theta_{it}^{(q)}} = \\frac{J(\\Theta)}{\\delta a^{(q+1)}_{lj}}\\frac{\\delta a_{lj}^{(q+1)}}{\\delta a_{lj}^{(q)}}\\frac{\\delta a_{lj}^{(q)}}{\\delta \\theta_{it}^{(q)}} \\] Es decir: \\[%align \\frac{\\delta J(\\Theta)}{\\delta \\theta_{it}^{(q)}} = \\sum_{l=1}^{S_{(q+1)}} \\frac{J(\\Theta)}{\\delta a^{(q+1)}_{lj}}\\frac{\\delta a_{lj}^{(q+1)}}{\\delta a_{lj}^{(q)}}\\frac{\\delta a_{lj}^{(q)}}{\\delta \\theta_{it}^{(q)}} \\] Cabe destacar que \\(\\frac{\\delta a_{lj}^{(q)}}{\\delta \\theta_{it}^{(q)}} = \\frac{\\delta g(z_{lj}^{(q)})}{\\delta z_{lj}^{(q)}} \\frac{\\delta z_{lj}^{(q)}}{\\delta \\theta_{it}^{(q)}}\\) (explicado en Derivada de la función del coste). Entonces, si generalizamos para todos los ejemplos, \\(m\\): \\[%align \\frac{\\delta J(\\Theta)}{\\delta \\theta_{it}^{(q)}} = \\sum_{j=1}^m\\sum_{l=1}^{S_{(q+1)}} \\frac{J(\\Theta)}{\\delta a^{(q+1)}_{lj}}\\frac{\\delta a_{lj}^{(q+1)}}{\\delta a_{lj}^{(q)}}\\frac{\\delta a_{lj}^{(q)}}{\\delta \\theta_{it}^{(q)}} \\] "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/(DS0001)_MLStanfordCoursera/NeuralNetworks/Anexo/index.html",
    "title": "Anexo",
    "body": " Back Anexo Clasificación múltiple Función de coste Retropropagación Algoritmo Clasificación múltiple Para crear una red neuronal que permita trabajar con \\(c\\) clases lo que hacemos es hacer que la red neuronal tenga \\(c\\) nodos en su capa de salida. Esto se ilustra en la siguiente imagen: De tal manera que ahora, cada salida \\(y_j\\) será un vector columna \\(c\\times1\\), donde existe un valor por cada categoría, al igual que la hipótesis para el ejemplo \\(j\\), \\(h_\\Theta(x_j)\\), es un vector columna \\(c\\times1\\). Como podemos ver, los valores de \\(y_j\\) indican claramente a qué clase pertenece el ejemplo \\(j\\) (clase 3), mientras que la hipótesis \\(h_\\Theta(x_j)\\) ofrece, para cada clase (columna) la probabilidad de que el ejemplo \\(j\\) pertenezca a esa clase. Función de coste Notación Como ya hemos visto en función del número de clases la salida tendrá distinta forma: Clasificación binaria: para cada ejemplo \\(j\\), \\(y_j \\in \\{0, 1\\}\\), \\(h_\\Theta(x_j) \\in \\mathbb{R}\\) Clasificación múltiple: para cada ejemplo \\(j\\), \\(y \\in \\mathbb{R}^c\\), \\(h_\\Theta(x_j) \\in \\mathbb{R}^c\\), donde \\(c\\) es el número de clases Sea \\(k\\) el número de capas y \\(S_i\\) el número de nodos en la capa \\(i\\). Sea \\(Y=(y_{ij})\\) una matriz \\(c\\times m\\), donde \\(m\\) es el número de ejemplos y cada \\(y_{j}\\) es el vector columna \\(c\\times1\\) de salida para el ejemplo \\(j\\). Definimos la función de coste como sigue: \\begin{align} J(\\Theta) = - \\frac{1}{m} \\left\\{ \\sum_{j=1}^m \\sum_{i=1}^c [y_{ij}\\cdot \\log(h_\\Theta(x_j)_i)] + [(1-y_{ij})\\cdot \\log(1-(h_\\Theta(x_j)_i))]\\right\\} \\end{align} El primer sumatorio que va de 1 a \\(m\\) se encarga de calcular el coste para cada ejemplo \\(j\\). Mientras que el segundo sumatorio, que va de 1 a \\(c\\), se encarga de calcular el coste para cada nodo de salida. Esta función se aplica sobre los \\(k\\) nodos en la capa de salida. Ejemplo Cálculo Función de Coste Regularización Definimos la función de coste introduciendo regularización como sigue: \\begin{align} J(\\Theta) = - \\frac{1}{m} \\left\\{ \\sum_{j=1}^m \\sum_{i=1}^c [y_{ij}\\cdot \\log(h_\\Theta(x_j)_i)] + [(1-y_{ij})\\cdot \\log(1-(h_\\Theta(x_j)_i))]\\right\\} + \\frac{\\lambda}{2m} \\sum_{q=1}^k \\sum_{i=1}^{S_q}\\sum_{j=1}^{S_{q+1}} (\\theta_{ji}^{(q)})^2 \\end{align} Antes de nada, recordar que \\(S_q\\) denota el número de nodos en la capa \\(q\\). Entonces, el primer término de la función es igual que cuando no se aplicaba regularización. Expliquemos el segundo término. La regularización, en este caso, consiste en sumar todos los pesos de la red neuronal, por lo tanto: Por cada capa \\(q\\), con \\(1 \\leq q \\leq k\\), sumamos todos los elementos de la matriz de pesos \\(\\Theta^{q}\\), que como sabemos tiene dimensiones \\(S_{q} \\times S_{q-1}\\) Dada la matriz \\(\\Theta^{(q)}\\) Recorremos cada columna \\(i\\), con \\(1 \\leq i \\leq S_{q-1}\\) Recorremos cada elemento \\(j\\) de la columna \\(i\\), con \\(1 \\leq j \\leq S_{q}\\) Sumamos al total cada elemento de la matriz \\(\\Theta^{(q)}_{ji}\\) Una vez se han sumado todas las matrices de pesos obtenemos un escalar, que multiplicamos por \\(\\frac{\\lambda}{2m}\\) Múltiple Ejemplos La salida de cada capa \\(q\\) es una matriz \\(S_q \\times m\\), donde \\(S_q\\) denota el número de nodos en la capa \\(q\\) y \\(m\\) denota el número de ejemplos. Como vimos en nuestras figuras, donde se presentaban los cálculos sólo para un ejemplo, en cada capa \\(q\\) podemos mapear la salida de los \\(S_q\\) nodos a un vector columna \\(S_q \\times 1\\). Si generalizamos esto a \\(m\\) ejemplos tenemos que la salida de cada capa es una matriz \\(S_q \\times m\\). Esto se ilustra en la siguiente imagen: Retropropagación Vamos, ahora a explicar cómo se aplica la retropropagación. Lo primero que debemos tener en cuenta es que este proceso se basa en la misma idea de optimización que la Regresión Lineal y la Regresión Logística, es decir, lo que queremos hacer es minimizar el coste, \\(J(\\Theta)\\) Sea \\(c\\) el número de nodos en la última capa, \\(\\theta_{it}\\) el peso \\(t\\) del nodo \\(i\\) de la última capa \\(k\\), \\(a_{ij}^{(k)}\\) la salida del nodo \\(i\\) para el ejemplo \\(j\\) en la capa \\(k\\): Calculamos el gradiente de la última capa \\(k\\) como: \\(\\frac{\\delta J(\\Theta)}{\\delta \\theta_{it}^{(k)}} = \\frac{\\delta J(\\Theta)}{\\delta a_{1j}^{(k)}}\\frac{\\delta a_{1j}^{(k)}}{\\delta \\theta_{it}^{(k)}}\\) Calculamos el gradiente en capas intermedias utilizando la regla de la cadena como: \\(\\frac{\\delta J(\\Theta)}{\\delta \\theta_{it}^{(q)}} = \\sum_{i=1}^{S_{(q+1)}} \\frac{\\delta J(\\Theta)}{\\delta a_{ij}^{(q+1)}}\\frac{\\delta a_{ij}^{(q+1)}}{\\delta a_{ij}^{(q)}}\\frac{\\delta a_{ij}^{(q)}}{\\delta \\theta_{it}^{(q)}}\\) Normalmente en las capas intermedias, \\(q\\), nos referimos al término \\(\\frac{\\delta J(\\Theta)}{\\delta a_{ij}^{(q+1)}}\\) como \\(\\Delta^{(q+1)}_{ij}\\). Explicación de la retropropagación Derivada de la función de coste A continuación explicamos cómo derivar la función de coste (Paso 1). Derivada de la función de coste Capas intermedias Veamos, ahora, cómo llevar a cabo el Paso 2: ¿cómo calculamos el gradiente (o lo que contribuye el peso \\(it\\) en el error) para los pesos de las capas intermedias?, es decir, cómo calculamos: \\[%align \\frac{\\delta J(\\Theta)}{\\delta \\theta_{it}^{(q)}} \\] Derivadas capas intermedias Ejemplo de retropropagación Ejemplo de retropropagación Algoritmo Partes del algoritmo en python Notación Época: iteración en el entrenamiento Pesos (\\(w_j^k, b_j^k\\)): se inicializan de forma aletoria (evitar simetría) y con valores bajos. Criterios de finalización \\(J\\) o gradiente de \\(J\\) inferior a un umbral Número máximo de épocas Velocidad de apredizaje \\(\\mu\\) intermedia: evita lentitud en las oscilaciones Caída en mínimos locales que pueden tener \\(J\\) elevado. Es por ello que se ejecuta varias veces el entrenamiento y se selecciona aquel que obtenga mejor resultado. Actualización de pesos patrón a patrón en lugar de tras computar el error sobre todo el dataset. Puede evitar mínimos locales y converge antes. Función de activación sigmoide para clasificación o linear para regresión Pseudocódigo "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/(DS0001)_MLStanfordCoursera/NeuralNetworks/Anexo/Ejemplo de retropropagación.html",
    "title": "Ejemplo de retropropagación",
    "body": " Back Ejemplo de retropropagación Por ejemplo, supongamos que tenemos una red con tres capas, entonces \\(k=3\\), dado un ejemplo \\(x_j\\). En este caso tenemos que Capa 3 La derivada en la última capa, para el único vector de pesos \\(\\theta^{(3)}_1\\) que tiene \\(n\\) elementos (features o características), es: \\(\\frac{\\delta J(\\Theta)}{\\delta \\theta_{1t}^{(3)}}\\), para cada \\(t\\), \\(0 \\leq t \\leq n\\) Como: \\begin{align} J(\\Theta) = E^{(3)}(a_1^{(3)}) = E^{(3)}(g(z_1^{(3)})) = E^{(3)}(g(\\Theta^{(3)}\\cdot a^{(2)})) \\end{align} Donde denotamos la función que calcula el error entre lo predicho y la salida real como \\(E\\), y \\(g\\) es la función de activación. Entonces, aplicamos la regla de la cadena para cada elemento \\(t\\) en el vector de pesos: \\begin{align} \\frac{\\delta J(\\Theta)}{\\delta \\theta_{1t}^{(3)}} = \\frac{\\delta J(\\Theta)}{\\delta a_1^{(3)}}\\frac{\\delta a_1^{(3)}}{\\delta z_1^{(3)}}\\frac{\\delta z_1^{(3)}}{\\delta \\theta_{1t}^{(3)}} \\end{align} Si vectorizamos: \\begin{align} \\frac{\\delta J(\\Theta)}{\\delta \\theta_{1}^{(3)}} = \\frac{\\delta J(\\Theta)}{\\delta a_1^{(3)}}\\frac{\\delta a_1^{(3)}}{\\delta z_1^{(3)}}\\frac{\\delta z_1^{(3)}}{\\delta \\theta_{1}^{(3)}} \\end{align} Capa 2 Si ahora queremos obtener la derivada para uno de los vectores de pesos en la capa \\(2\\), volvemos a aplicar la regla de la cadena. Tenemos ahora que desestructurar la función de coste todavía más, hasta obtener la expresión que incluye las salidas de la capa \\(1\\), \\(a^{(1)}\\). \\begin{align} J(\\Theta) = E^{(3)}(g(\\Theta^{(3)}\\cdot a^{(2)})) = E^{(3)}(g(\\Theta^{(3)}\\cdot g(z^{(2)}))) = E^{(3)}(g(\\Theta^{(3)}\\cdot g(\\Theta^{(2)} \\cdot a^{(1)}))) \\end{align} Sea \\(\\Delta^{(3)}_{1j}\\): \\begin{align} \\Delta^{(3)}_{1j} = \\frac{\\delta J(\\Theta)}{\\delta a_{1j}^{(3)}}\\frac{\\delta a_{1j}^{(3)}}{\\delta z_{1j}^{(3)}} \\end{align} Entonces, aplicamos la regla de la cadena para cada nodo \\(i\\) de la capa \\(2\\) y para cada elemento \\(t\\): \\begin{align} \\frac{\\delta J(\\Theta)}{\\delta \\theta_{it}^{(2)}} = \\sum_{l=1}^{S_{(3)}} \\Delta_{lj}^{(3)}\\frac{\\delta z_{lj}^{(3)}}{\\delta a_{lj}^{(2)}}\\frac{\\delta a_{lj}^{(2)}}{\\delta z_{lj}^{(2)}}\\frac{\\delta z_{lj}^{(2)}}{\\delta \\theta_{it}^{(2)}} = \\Delta_{1j}^{(3)}\\frac{\\delta z_{1j}^{(3)}}{\\delta a_{1j}^{(2)}}\\frac{\\delta a_{1j}^{(2)}}{\\delta z_{1j}^{(2)}}\\frac{\\delta z_{1j}^{(2)}}{\\delta \\theta_{it}^{(2)}} \\end{align} Si vectorizamos: \\begin{align} \\frac{\\delta J(\\Theta)}{\\delta \\theta_{i}^{(2)}} = \\Delta_{j}^{(3)}\\frac{\\delta z^{(3)}}{\\delta a_{j}^{(2)}}\\frac{\\delta a_{j}^{(2)}}{\\delta z_{j}^{(2)}}\\frac{\\delta z_{j}^{(2)}}{\\delta \\theta_{i}^{(2)}} \\end{align} Capa 1 Para la capa \\(1\\), volvemos a expandir la función de coste para ver cómo aplicar la regla de la cadena: \\begin{align} J(\\Theta) = E^{(3)}(g(\\Theta^{(3)}\\cdot g(\\Theta^{(2)} \\cdot a^{(1)}))) = E^{(3)}(g(\\Theta^{(3)}\\cdot g(\\Theta^{(2)} \\cdot g(z^{(1)})))) = \\end{align} \\begin{align} = E^{(3)}(g(\\Theta^{(3)}\\cdot g(\\Theta^{(2)} \\cdot g(\\Theta^{(1)} x_j)))) \\end{align} Para simplificar la notación: sea, para cada nodo \\(l\\) de la capa \\(2\\) \\begin{align} \\Delta^{(2)}_{lj} = \\Delta_{1j}^{(3)}\\frac{\\delta z_1^{(3)}}{\\delta a_{lj}^{(2)}}\\frac{\\delta a_{lj}^{(2)}}{\\delta z_{lj}^{(2)}} \\end{align} Aplicamos la regla de la cadena, tal que para cada nodo \\(l\\) de la capa \\(2\\): \\begin{align} \\frac{\\delta J(\\Theta)}{\\delta \\theta_{it}^{(1)}} = \\sum_{l=1}^{S_{(2)}} \\Delta_{lj}^{(2)}\\frac{\\delta z_{lj}^{(2)}}{\\delta a_{lj}^{(1)}}\\frac{\\delta a_{lj}^{(1)}}{\\delta z_{lj}^{(1)}}\\frac{\\delta z_{lj}^{(1)}}{\\delta \\theta_{it}^{(1)}} \\end{align} Si vectorizamos: \\begin{align} \\frac{\\delta J(\\Theta)}{\\delta \\theta_{i}^{(1)}} = \\Delta_{j}^{(2)}\\frac{\\delta z_{j}^{(2)}}{\\delta a_{j}^{(1)}}\\frac{\\delta a_{j}^{(1)}}{\\delta z_{j}^{(1)}}\\frac{\\delta z_{j}^{(1)}}{\\delta \\theta_{i}^{(1)}} \\end{align} El procedimiento se ilustra en la siguiente figura: "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/(DS0001)_MLStanfordCoursera/NeuralNetworks/Anexo/Partes del algoritmo en python.html",
    "title": "Algoritmo",
    "body": " Back Algoritmo Dado un conjunto de entrenamiento \\(X\\), donde \\(X\\) es una matriz \\((n + 1) \\times m\\) con \\(m\\) ejemplos: Propagación hacia adelante def feed_forward(self, theta=None, capa=None, test=False): if theta is None: # Si no se introduce theta como argumento theta = self.theta # Inicializar theta con el almacenado en el objeto if test: # Si se indica utilizar X_test a = self.X_test n, m = self.X_test.shape # Guardar dimensiones de test else: a = self.X # La primera entrada es X n, m = self.X.shape # Guardar dimensiones de train if capa is not None: # Si se ha indicado una capa if capa <= len(theta) and capa >= 0: # Chequeamos que la capa esta dentro de los limites for i in range(capa): # Recorremos las capas a = self.sigmoid(theta[i], a) # Calculamos la salida de la capa a = np.concatenate((np.matrix(np.ones(m)), a)) # Añadimos una fila de unos return a else: print(\"El número de capa no es válido\") # Mensaje de error else: for elemento in theta: a = self.sigmoid(elemento, a) # Calculamos la salida de la capa actual a = np.concatenate((np.matrix(np.ones(m)), a)) # Añadimos una fila de unos h = a[1:, :] # Eliminamos los 1 en la última capa return h Calculo del coste en la última capa def calculo_coste(self, theta=None, unrolled=False): if theta is None: # Si no se introduce theta como argumento theta = self.theta # Inicializar theta con el almacenado en el objeto if unrolled: # Si theta se ha flatten en un vector de una dimension theta = self._roll_theta(theta) # Crear lista con matriz theta de capa capa h = self.feed_forward(theta) # Obtener la salida para todos los ejemplo coste = -np.sum(np.diagonal(self.y_hot_enc.T.dot(np.log(h)) + (1 - self.y_hot_enc.T).dot(np.log(1 - h))))/self.m # Calcular el error con la matriz codificada de y if self.reg: # Si se ha indicado que se aplica regularizacion reg_parcial = 0 # Inicializamos la variable temporal for elemento in theta: # Para capa reg_parcial += np.sum(np.power(elemento[:, 1:], 2)) # No sumar el término independiente en cada nodo: primera fila reg_result = self.reg_par/(2*self.m)*(reg_parcial) # Calcular la regularizacion coste = coste + reg_result return coste Actualizar los pesos con propagación hacia atrás: def back_propagation(self, theta=None, unrolled=False, unroll=False): if theta is None: # Si no se ha indicado ningun theta como argumento theta = self.theta # Inicializar theta con el almacenado en el objeto if unrolled: theta = self._roll_theta(theta) # Creamos una lista del array delta = [] # Inicializamos las lista temporal que contendra el delta de cada nodo delta_sum = [] # Inicializamos la lista temporal que contendra el sumatorio delta gradientes = [] # Inicializamos la lista que contendrá los gradientes de cada capa h = self.feed_forward(theta=theta) # Calculamos el valor del la salida para empezar a propagar hacia atras delta_next = h - self.y_hot_enc # Calculamos el primer delta: el de la ultima capa delta.append(delta_next) # Lo añadimos a la lista temporal indice = self.numero_capas - 1 # El indice indica hasta que capa calcular la salida for elemento in reversed(theta[1:]): # Recorremos las capas de atras hacia adelante h = self.feed_forward(theta=theta, capa=indice) # Calculamos la salida de la capa actual delta_aux = np.multiply(elemento.T.dot(delta_next), self.sigmoid_gradient(elemento, h)) # Aplicamos la formula del gradiente delta_next = delta_aux[1:, :] # No cogemos el elemento independiente delta.append(delta_next) # Lo añadimos a la lista de delta indice -= 1 # Actualizamos el indice delta.reverse() # Damos la vuelta a la lista for indice in range(len(delta)): h = self.feed_forward(theta=theta, capa=indice) # Obtenemos la salida de cada capa delta_sum.append(delta[indice].dot(h.T)) # Añadimos (delta * a) a la lista de delta_mayuscula -> sumatorio for indice in range(len(delta_sum)): gradiente = (1/self.m) * delta_sum[indice] # Calculamos el grandiente: delta_mayuscula / m if self.reg: gradiente[1:, :] += (self.reg_par/self.m) * theta[indice][1:, :] # Si se indica regularizacion aplicarla: no regularizan primer elemento gradientes.append(gradiente) # Lo añadimos a la lista coste = self.calculo_coste(theta=theta) if unroll: # Si se ha indicado que se quiere hacer flatten a un vector de una dimension return coste, self._unroll_theta(gradientes) else: return coste, gradientes "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/(DS0001)_MLStanfordCoursera/NeuralNetworks/Anexo/Derivada de la función de coste.html",
    "title": "Derivada de la función de coste",
    "body": " Back Derivada de la Función de Coste Sabemos que la función de coste: \\[%align J(\\Theta) = - \\frac{1}{m} \\left\\{ \\sum_{j=1}^m\\sum_{i=1}^c (y_{ij}\\cdot \\log(h_\\Theta(x_j)_i)) + [(1-y_{ij})\\log(1-h_\\Theta(x_j)_i)]\\right\\} \\] Donde \\(\\theta_{it}^{(k)}\\) es el peso que conecta el nodo \\(i\\) de la capa \\(k\\) con el nodo \\(t\\) de la capa \\((k-1)\\), es decir, es el elemento en la fila \\(i\\) columna \\(t\\) de la matriz de pesos de la capa \\(k\\), \\(\\Theta^{(k)}\\). Por la regla de la cadena, separamos la derivada de la función del coste en función de los pesos en dos términos: \\begin{align} \\frac{\\delta J(\\Theta)}{\\delta \\theta_{it}^{(k)}} = \\sum_{j=1}^m \\sum_{i=1}^c \\frac{\\delta E^{(k)}}{\\delta a_{ij}^{(k)}} \\frac{\\delta a_{ij}^{(k)}}{\\delta \\theta_{it}^{(k)}} \\end{align} Capa de salida Procedemos a calcular la derivada: \\[%align \\frac{\\delta J(\\Theta)}{\\delta \\theta_{it}^{(k)}} = \\frac{\\delta}{\\delta \\theta_{it}^{(k)}} \\left(- \\frac{1}{m}\\right) \\left\\{ \\sum_{j=1}^m\\sum_{i=1}^c (y_{ij}\\cdot \\log(h_\\Theta(x_j)_i)) + [(1-y_{ij})\\log(1-h_\\Theta(x_j)_i)]\\right\\} \\] Sacamos el término constante de la derivada y aplicamos la propiedad: \"La derivada de una suma equivale a la suma de las derivadas\" \\[%align \\frac{\\delta J(\\Theta)}{\\delta \\theta_{it}^{(k)}} = \\left(- \\frac{1}{m}\\right) \\sum_{j=1}^m\\sum_{i=1}^c \\frac{\\delta}{\\delta \\theta_{it}^{(k)}} \\left\\{(y_{ij}\\cdot \\log(h_\\Theta(x_j)_i)) + [(1-y_{ij})\\log(1-h_\\Theta(x_j)_i)]\\right\\} \\] Sea \\(h_\\Theta(x_j) = a^{(k)}_j\\), es decir la salida de la última capa para el ejemplo \\(j\\). \\[%align \\frac{\\delta J(\\Theta)}{\\delta \\theta_{it}^{(k)}} = \\left(- \\frac{1}{m}\\right) \\sum_{j=1}^m\\sum_{i=1}^c \\frac{\\delta}{\\delta \\theta_{it}^{(k)}} \\left\\{(y_{ij}\\cdot \\log(a^{(k)}_{ij})) + [(1-y_{ij})\\log(1-a^{(k)}_{ij})]\\right\\} \\] Sacaremos el término \\(y_{ij}\\) de la derivada y juntemos todas las expresiones: \\[%align \\frac{\\delta J(\\Theta)}{\\delta \\theta_{it}^{(k)}} = \\left(- \\frac{1}{m}\\right) \\sum_{j=1}^m\\sum_{i=1}^c \\left\\{y_{ij} \\left(\\frac{\\delta}{\\delta \\theta_{it}^{(k)}} \\log(a^{(k)}_{ij}) \\right) + (1-y_{ij}) \\left(\\frac{\\delta}{\\delta \\theta_{it}^{(k)}} \\log(1-a^{(k)}_{ij})\\right)\\right\\} \\] Aplicamos la regla de la cadena sobre el logaritmo: \\[%align \\frac{\\delta J(\\Theta)}{\\delta \\theta_{it}^{(k)}} = \\left(- \\frac{1}{m}\\right) \\sum_{j=1}^m\\sum_{i=1}^c \\left\\{y_{ij} \\left(\\frac{\\delta \\log(a_{ij}^{(k)})}{\\delta a_{ij}^{(k)}} \\frac{\\delta a_{ij}^{(k)}}{\\delta \\theta_{it}^{(k)}} \\right) + (1-y_{ij}) \\left(\\frac{\\delta \\log(1-a^{(k)}_{ij})}{\\delta (1-a^{(k)}_{ij})} \\frac{\\delta (1-a^{(k)}_{ij})}{\\delta \\theta_{it}^{(k)}} \\right)\\right\\} \\] Como sabemos: \\(\\frac{\\delta (1)}{\\delta \\theta_{it}^{(k)}} = 0\\), entonces \\(\\frac{\\delta(1-a_{ij}^{(k)})}{\\delta \\theta_{it}^{(k)}} = \\frac{\\delta (1)}{\\delta \\theta_{it}^{(k)}} - \\frac{\\delta a_{ij}^{(k)}}{\\delta \\theta_{it}^{(k)}} = 0 + (-1) \\frac{\\delta a_{ij}^{(k)}}{\\delta \\theta_{it}^{(k)}}\\) Entonces \\[%align \\frac{\\delta J(\\Theta)}{\\delta \\theta_{it}^{(k)}} = \\left(- \\frac{1}{m}\\right) \\sum_{j=1}^m\\sum_{i=1}^c \\left\\{y_{ij} \\left(\\frac{\\delta \\log(a_{ij}^{(k)})}{\\delta a_{ij}^{(k)}} \\frac{\\delta a_{ij}^{(k)}}{\\delta \\theta_{it}^{(k)}} \\right) + (1-y_{ij}) \\left((-1)\\frac{\\delta \\log(1-a^{(k)}_{ij})}{\\delta (1-a^{(k)}_{ij})} \\frac{\\delta a^{(k)}_{ij}}{\\delta \\theta_{it}^{(k)}} \\right)\\right\\} \\] Sacamos \\(\\frac{\\delta a_{ij}^{(k)}}{\\delta \\theta_{it}^{(k)}}\\) como factor común y aplicamos el \\((-1)\\): \\[%align \\frac{\\delta J(\\Theta)}{\\delta \\theta_{it}^{(k)}} = \\left(- \\frac{1}{m}\\right) \\sum_{j=1}^m\\sum_{i=1}^c \\frac{\\delta a_{ij}^{(k)}}{\\delta \\theta_{it}^{(k)}}\\left\\{y_{ij} \\frac{\\delta \\log(a_{ij}^{(k)})}{\\delta a_{ij}^{(k)}} - \\left((1-y_{ij})\\frac{\\delta \\log(1-a^{(k)}_{ij})}{\\delta (1-a^{(k)}_{ij})} \\right)\\right\\} \\] Sustituimos \\(\\frac{\\delta E^{(k)}}{\\delta a_{ij}^{(k)}} = \\left\\{y_{ij} \\frac{\\delta \\log(a_{ij}^{(k)})}{\\delta a_{ij}^{(k)}} - \\left((1-y_{ij})\\frac{\\delta \\log(1-a^{(k)}_{ij})}{\\delta (1-a^{(k)}_{ij})} \\right)\\right\\}\\) \\[%align \\frac{\\delta J(\\Theta)}{\\delta \\theta_{it}^{(k)}} = \\left(- \\frac{1}{m}\\right) \\sum_{j=1}^m\\sum_{i=1}^c \\frac{\\delta E^{(k)}}{\\delta a_{ij}^{(k)}} \\frac{\\delta a_{ij}^{(k)}}{\\delta \\theta_{it}^{(k)}} \\] Si resolvemos las derivadas de los logaritmos obtenemos: \\[%align \\frac{\\delta E^{(k)}}{\\delta a_{ij}^{(k)}} = y_{ij} \\frac{\\delta \\log(a_{ij}^{(k)})}{\\delta a_{ij}^{(k)}} - (1-y_{ij})\\frac{\\delta \\log(1-a_{ij}^{(k)})}{\\delta (1-a_{ij}^{(k)})} \\] Nos centraremos ahora en la derivada que nos falta \\(\\frac{\\delta a_{ij}^{(k)}}{\\delta \\theta_{it}^{(k)}}\\): Sabemos que, vectorizando la operación, \\(a^{(k)}_j = g(z^{(k)}_j)\\), donde \\(g\\) es la función de activación (en este caso sigmoide). Además: \\[%align z^{(k)}_j = \\Theta^{k} \\cdot a^{(k-1)}_j \\] Por lo tanto, para cada nodo \\(i\\) en la última capa \\(k\\): \\[%align z^{(k)}_{ij} = \\sum_{l=1}^{S_{(k-1)}} \\theta^{(k)}_{il} \\cdot a^{(k-1)}_{lj} \\] Donde \\(S_{(k-1)}\\) es el número de nodos en la capa \\(k-1\\). Entonces, aplicamos de nuevo la regla de la cadena: \\[%align \\frac{\\delta a_{ij}^{(k)}}{\\delta \\theta_{it}^{(k)}} = \\frac{\\delta g(z_{ij}^{(k)})}{\\delta z_{ij}^{(k)}} \\frac{\\delta z_{ij}^{(k)}}{\\delta \\theta_{it}^{(k)}} \\] Resolvemos la derivada para el segundo término: \\[%align \\frac{\\delta z_{ij}^{(k)}}{\\delta \\theta_{it}^{(k)}} = \\sum_{l=1}^{S_{(k-1)}} \\frac{\\delta}{\\delta \\theta_{it}^{(k)}} \\theta^{(k)}_{il} \\cdot a^{(k-1)}_{lj} \\] Tal que: \\[%align \\frac{\\delta}{\\delta \\theta_{it}^{(k)}} \\theta^{(k)}_{il} \\cdot a^{(k-1)}_{lj} = \\begin{cases} a_{lj}^{(k-1)}, & t = l \\\\ 0, & t \\neq l \\\\ \\end{cases} \\] Por lo tanto, como sólo hay un \\(l\\) con \\(l = t\\) donde \\(1 \\leq l \\leq S_{(k-1)}\\), entonces: \\[%align \\frac{\\delta z_{ij}^{(k)}}{\\delta \\theta_{it}^{(k)}} = a_{lj}^{(k-1)} = a_{tj}^{(k-1)} \\] Juntamos ambos términos de la derivada inicial, con \\(\\frac{\\delta g(z_{ij}^{(k)})}{\\delta z_{ij}^{k}} = \\sigma'(z_{ij}^{(k)})\\) \\[%align \\frac{\\delta a_{ij}^{(k)}}{\\delta \\theta_{it}^{(k)}} = \\frac{\\delta g(z_{ij}^{(k)})}{\\delta z_{ij}^{(k)}} \\frac{\\delta z_{ij}^{(k)}}{\\delta \\theta_{it}^{(k)}} = \\sigma'(z_{ij}^{(k)}) a_{tj}^{(k-1)} \\] Vamos a resumir lo que tenemos hasta ahora. Por la regla de la cadena, separamos la derivada de la función del coste en función de los pesos en dos términos: \\begin{align} \\frac{\\delta J(\\Theta)}{\\delta \\theta_{it}^{(k)}} = \\sum_{j=1}^m \\sum_{i=1}^c \\frac{\\delta E^{(k)}}{\\delta a_{ij}^{(k)}} \\frac{\\delta a_{ij}^{(k)}}{\\delta \\theta_{it}^{(k)}} \\end{align} Si sustituimos ambos términos, para la capa de salida \\(k\\): \\[%align \\frac{\\delta J(\\Theta)}{\\delta \\theta_{it}^{(k)}} = \\left(- \\frac{1}{m}\\right) \\sum_{j=1}^m\\sum_{i=1}^c \\sigma'(z_{ij}^{(k)}) a_{tj}^{(k-1)}\\left\\{ \\frac{y_{ij}}{a_{ij}^{(k)}} - \\left(\\frac{(1-y_{ij})}{(1-a^{(k)}_{ij})} \\right)\\right\\} \\] "
  },
  {
    "id": "https://albamr09.github.io/Notes/DataScience/(DS0001)_MLStanfordCoursera/NeuralNetworks/Neural Networks.html",
    "title": "Neural Networks",
    "body": " Back Neural Networks Architecture Algorithm Output Layer Forward Propagation Parameters Outputs Graphical Representation Optimization Problem Loss Function Optimization Back-Propagation Vectorization Improving a Neural Network Activation Functions Initialization Techniques Anexo Architecture Input: Given any input \\(X\\) the first thing we do is flatten it. For example if \\(X\\) is a rgb image of \\(64 \\times 64\\), then \\(X \\in \\mathbb{R}^{64 \\times 64 \\times 3}\\) (for each of the \\(64 \\times 64\\) pixels we have three color channels: red, green, blue), is flattened into a vector in \\(\\mathbb{R}^{(64*64*3) \\times 1}\\) Neuron: is an operation that has two parts: Linear part: we denote the linear part like \\(z^{[i]}\\), where \\(i\\) is the current layer. Activation part Layer: a layer is a compound of neurons that are not connected with each other. Algorithm The principal steps of the algorithm are: Initialize the weights \\(w\\) and biases \\(b\\) randomly Find the optimal \\(w, b\\) Use the optimized \\(w, b\\) to predict the output by using the formula \\(\\hat{y} = \\sigma(wx +b)\\) Output Layer Sigmoid The output layer will be different depending on the problem we are tackling. For example if we want to discriminate between 3 classes then the output layer could be as follows: So now the output is a vector \\(\\hat{y} \\in \\mathbb{R}^{c \\times 1}\\) where \\(c\\) is the number of classes. Softmax The previous classifier allows for outputting multiples classes in the result, that is we can obtain a predicted output of the form \\(\\hat{y} = \\begin{bmatrix} 1 \\\\1 \\\\ 0 \\end{bmatrix}\\). What if we want to add a constraint such that only one class can be predicted. Then we use the softmax function as the activation function on the output layer: Thus, instead of a probability for each class what we obtain is a probability distribution for all the classes. ReLU On linear regression we do not want the activation function to be linear, because then the whole network becomes a very large linear regression. Instead we use as an activation function the ReLU function (Rectified Linear Unit), whose output is zero if the input value is negative and linear otherwise. Loss Function The loss function when using the sigmoid function on the output layer is as follows: \\begin{align} \\mathcal{L} = - \\frac{1}{Q} \\sum_{k=1}^Q [y^{(k)} \\log(\\hat{y}^{(k)}) + (1- y^{(k)})\\log(1-\\hat{y}^{(k)})] \\end{align} Where \\(\\hat{y}^{(k)}\\) are the predicted values and \\(Q\\) is the total number of neurons on the output layer. However, if we use the softmax function as the activation function on the last layer we have to use a different derivative because this function does depend on the outputs of the other neurons. Thus, we make use of a function called cross entropy loss: \\begin{align} \\mathcal{L}_{CE} = - \\sum_{k=1}^Q y^{(k)} \\log(\\hat{y}^{(k)}) \\end{align} For linear regression we use as the loss function the L1-Norm or the L2-Norm. The latter is defined as follows: \\begin{align} \\mathcal{L} = || \\hat{y} - y ||_2^2 \\end{align} Forward Propagation The forward propagation equations are the following: \\begin{align} z^{[i]} = w^{[i]} a^{[i-1]} + b^{[i]} \\tag{1} \\end{align} Where \\(i\\) is the layer with \\(i \\geq 1\\), and the first layer equals the input matrix, that is \\(a^{[0]} = X\\). By applying the activation function over \\((1)\\): \\begin{align} a^{[i]} = g(z^{[i]}) \\end{align} Where \\(g\\) is the activation function (e.g \\(\\sigma(z^{[i]})\\)). Now, what are the shapes of these matrices? \\(z^{[i]} \\in \\mathbb{R}^{S_i \\times m}\\) \\(a^{[i]} \\in \\mathbb{R}^{S_i \\times m}\\) Where \\(S_i\\) is the number of neurons on the ith layer and \\(m\\) is the number of examples. Note that the shape of the final layer changes depending on the task. So if \\(K\\) is the number of layers: In linear regression: \\(\\hat{y} = a^{[K]} \\in \\mathbb{R}^{1 \\times m}\\) In multi-class classification: \\(\\hat{y} = a^{[K]} \\in \\mathbb{R}^{c \\times m}\\), where \\(c\\) is the number of classes. Also the shape of the weights are \\(w[i] \\in \\mathbb{R}^{S_i \\times S_{i-1}}\\), that is, this matrix is compatible with the outputs of the previous layer (\\(a^{[i-1]} \\in \\mathbb{R}^{S_{i-1} \\times m}\\)) and the linear part of the next layer (\\(z^{[i]} \\in \\mathbb{R}^{S^i \\times m}\\)). However, the bias are \\(b^{[i]} \\in \\mathbb{R}^{S^i \\times 1}\\), therefore we cannot perform an element wise summation because the shape of \\((w^{[i]} a^{[i-1]}) \\in \\mathbb{R}^{S_i \\times m}\\) and \\(b^{[i]}\\) are not compatible. To avoid this problem we apply a technique called broadcasting to \\(b\\), such that we replicate \\(b^{[i]}\\) \\(m\\) times: \\begin{align} \\hat{b}^{[i]} = \\begin{bmatrix} | & | & \\cdots & | \\\\ b^{[i]} & b^{[i]} & \\cdots & b^{[i]} \\\\ | & | & \\cdots & | \\\\ \\end{bmatrix} \\in \\mathbb{R}^{S_i \\times m} \\end{align} To sum up, the shapes of the data and the parameters on each layer \\(i\\) are: Parameters \\begin{align} \\hat{b}^{[i]} = \\begin{bmatrix} | & | & \\cdots & | \\\\ b^{[i]} & b^{[i]} & \\cdots & b^{[i]} \\\\ | & | & \\cdots & | \\\\ \\end{bmatrix} \\in \\mathbb{R}^{S_i \\times m} \\end{align} \\begin{align} w^{[i]} = \\begin{bmatrix} | & | & \\cdots & | \\\\ w^{[i](1)} & w^{[i](2)} & \\cdots & w^{[i](S_{i-1})} \\\\ | & | & \\cdots & | \\\\ \\end{bmatrix} \\in \\mathbb{R}^{S_i \\times S_{i-1}} \\end{align} Outputs Note that for each example \\(j\\) on layer \\(i\\) \\(z^{[i](j)} = (w^{[i]} a^{[i-1](j)} + \\hat{b}^{[i]})\\), then: \\begin{align} z^{[i]} = \\begin{bmatrix} | & | & \\cdots & | \\\\ z^{[i](1)} & z^{[i](2)} & \\cdots & z^{[i](m)} \\\\ | & | & \\cdots & | \\\\ \\end{bmatrix} \\in \\mathbb{R}^{S_i \\times m} \\end{align} \\begin{align} a^{[i]} = \\begin{bmatrix} | & | & \\cdots & | \\\\ g(z^{[i](1)}) & g(z^{[i](2)}) & \\cdots & g(z^{[i](m)}) \\\\ | & | & \\cdots & | \\\\ \\end{bmatrix} \\in \\mathbb{R}^{S_i \\times m} \\end{align} Graphical Representation Now we present a small example of how forward propagation works on neural networks: Optimization Problem What we want to do is find the parameters \\(w^{[i]}, b^{[i]}\\) for each layer \\(i\\) that minimize the cost. Loss Function So first of all we define a cost function for the objective \\(\\mathcal{L}(\\hat{y}, y)\\), where \\(\\hat{y}\\) is the predicted output and \\(y\\) is the real output. The cost function will depend on the type of problem (classification, regression). Optimization The we optimize the loss function we defined by using backward propagation. For each layer \\(l=1, \\cdots, K\\), where \\(K\\) is the number of layers, we apply Batch Gradient Descent (not mandatory, but here it is convenient as we can vectorize the derivatives) as follows: \\begin{align} w^{[l]} = w^{[l]} - \\alpha \\frac{\\delta \\mathcal{L}(\\hat{y}, y)}{\\delta w^{[l]}} \\end{align} \\begin{align} b^{[l]} = b^{[l]} - \\alpha \\frac{\\delta \\mathcal{L}(\\hat{y}, y)}{\\delta b^{[l]}} \\end{align} Back-propagation To compute the derivatives of the cost function with respect to \\(w^{[l]}\\) and \\(b^{[l]}\\) we use the chain rule. Output Layer Suppose we have \\(K\\) layers, then we start by calculating \\(\\frac{\\delta \\mathcal{L}(\\hat{y}, y)}{\\delta w^{[K]}}\\) and \\(\\frac{\\delta \\mathcal{L}(\\hat{y}, y)}{\\delta b^{[K]}}\\), that is, the derivatives on the last layer. Thus, to update \\(w^{[K]}\\) (we apply the same logic for \\(b^{[K]}\\)): \\begin{align} \\frac{\\delta \\mathcal{L}(\\hat{y}, y)}{\\delta w^{[K]}} = \\sum_{i=1}^m \\frac{\\delta \\mathcal{L}(\\hat{y^{(i)}}, y^{(i)})}{\\delta w^{[K]}} = \\end{align} Because \\(\\hat{y^{(i)}} = (a^{[K]})^{(i)}\\): \\begin{align} = \\sum_{i=1}^m \\frac{\\delta \\mathcal{L}((a^{[K]})^{(i)}, y^{(i)})}{\\delta w^{[K]}} \\end{align} We apply the chain rule on the derivative, therefore: \\begin{align} = \\sum_{i=1}^m \\frac{\\delta \\mathcal{L}((a^{[K]})^{(i)}, y^{(i)})}{\\delta (a^{[K]})^{(i)}} \\frac{\\delta (a^{[K]})^{(i)}}{\\delta w^{[K]}} \\end{align} Because \\((a^{[K]})^{(i)} = g((z^{[K]})^{(i)})\\), where \\(g\\) is the activation function: \\begin{align} = \\sum_{i=1}^m \\frac{\\delta \\mathcal{L}((a^{[K]})^{(i)}, y^{(i)})}{\\delta (a^{[K]})^{(i)}} \\frac{\\delta g((z^{[K]})^{(i)})}{\\delta w^{[K]}} \\end{align} We apply the chain rule on the last derivative, therefore: \\begin{align} = \\sum_{i=1}^m \\frac{\\delta \\mathcal{L}((a^{[K]})^{(i)}, y^{(i)})}{\\delta (a^{[K]})^{(i)}} \\frac{\\delta g((z^{[K]})^{(i)})}{\\delta (z^{[K]})^{(i)}} \\frac{\\delta (z^{[K]})^{(i)}}{\\delta w^{[K]}} \\end{align} Hidden Layers What about the previous layer \\(K-1\\)? \\begin{align} \\frac{\\delta \\mathcal{L}(\\hat{y}, y)}{\\delta w^{[K-1]}} = \\sum_{i=1}^m \\frac{\\delta \\mathcal{L}(\\hat{y^{(i)}}, y^{(i)})}{\\delta w^{[K-1]}} = \\end{align} Because \\(\\hat{y^{(i)}} = (a^{[K]})^{(i)}\\): \\begin{align} = \\sum_{i=1}^m \\frac{\\delta \\mathcal{L}((a^{[K]})^{(i)}, y^{(i)})}{\\delta w^{[K-1]}} \\end{align} We apply the chain rule on the derivative, therefore: \\begin{align} = \\sum_{i=1}^m \\frac{\\delta \\mathcal{L}((a^{[K]})^{(i)}, y^{(i)})}{\\delta (a^{[K]})^{(i)}} \\frac{\\delta (a^{[K]})^{(i)}}{\\delta w^{[K-1]}} \\end{align} Because \\((a^{[K]})^{(i)} = g((z^{[K]})^{(i)})\\), where \\(g\\) is the activation function: \\begin{align} = \\sum_{i=1}^m \\frac{\\delta \\mathcal{L}((a^{[K]})^{(i)}, y^{(i)})}{\\delta (a^{[K]})^{(i)}} \\frac{\\delta g((z^{[K]})^{(i)})}{\\delta w^{[K-1]}} \\end{align} We apply the chain rule on the last derivative, therefore: \\begin{align} = \\sum_{i=1}^m \\frac{\\delta \\mathcal{L}((a^{[K]})^{(i)}, y^{(i)})}{\\delta (a^{[K]})^{(i)}} \\frac{\\delta g((z^{[K]})^{(i)})}{\\delta (z^{[K]})^{(i)}} \\frac{\\delta (z^{[K]})^{(i)}}{\\delta w^{[K-1]}} \\end{align} \\begin{align} = \\sum_{i=1}^m \\frac{\\delta \\mathcal{L}((a^{[K]})^{(i)}, y^{(i)})}{\\delta (a^{[K]})^{(i)}} \\frac{\\delta (a^{[K]})^{(i)}}{\\delta (z^{[K]})^{(i)}} \\frac{\\delta (z^{[K]})^{(i)}}{\\delta w^{[K-1]}} \\end{align} As you can see the first two derivatives are the same as the derivatives on the layer \\(K\\), let's denote \\((\\Delta^{[K]})^{(i)} = \\frac{\\delta \\mathcal{L}((a^{[K]})^{(i)}, y^{(i)})}{\\delta (a^{[K]})^{(i)}} \\frac{\\delta (a^{[K]})^{(i)}}{\\delta (z^{[K]})^{(i)}}\\) the accumulated gradient on layer \\(K\\) for example \\(i\\), then: \\begin{align} = \\sum_{i=1}^m (\\Delta^{[K]})^{(i)} \\frac{\\delta (z^{[K]})^{(i)}}{\\delta w^{[K-1]}} \\end{align} Because \\((z^{[K]})^{(i)} = w^{[K]} (a^{[K-1]})^{(i)} + b^{[k]}\\): \\begin{align} = \\sum_{i=1}^m (\\Delta^{[K]})^{(i)} \\frac{\\delta (w^{[K]} (a^{[K-1]})^{(i)} + b^{[k]})}{\\delta w^{[K-1]}} \\end{align} \\begin{align} = \\sum_{i=1}^m (\\Delta^{[K]})^{(i)} \\frac{\\delta (z^{[K-1]})^{(i)}}{\\delta (a^{[K-1]})^{(i)}} \\frac{\\delta (a^{[K-1]})^{(i)}}{\\delta w^{[K-1]}} \\end{align} Because \\((a^{[K-1]})^{(i)} = g((z^{[K-1]})^{(i)})\\) \\begin{align} = \\sum_{i=1}^m (\\Delta^{[K]})^{(i)} \\frac{\\delta (z^{[K-1]})^{(i)}}{\\delta (a^{[K-1]})^{(i)}} \\frac{\\delta g((z^{[K-1]})^{(i)})}{\\delta (z^{[K-1]})^{(i)}} \\frac{\\delta (z^{[K-1]})^{(i)}}{\\delta w^{[K-1]}} \\end{align} We apply the chain rule on the last derivative, hence: \\begin{align} = \\sum_{i=1}^m (\\Delta^{[K]})^{(i)} \\frac{\\delta (z^{[K-1]})^{(i)}}{\\delta (a^{[K-1]})^{(i)}} \\frac{\\delta g((z^{[K-1]})^{(i)})}{\\delta (z^{[K-1]})^{(i)}} \\frac{\\delta (z^{[K-1]})^{(i)}}{\\delta w^{[K-1]}} \\end{align} \\begin{align} = \\sum_{i=1}^m (\\Delta^{[K]})^{(i)} \\frac{\\delta (z^{[K-1]})^{(i)}}{\\delta (a^{[K-1]})^{(i)}} \\frac{\\delta (a^{[K-1]})^{(i)}}{\\delta (z^{[K-1]})^{(i)}} \\frac{\\delta (z^{[K-1]})^{(i)}}{\\delta w^{[K-1]}} \\end{align} Vectorization Output Layer Accumulated gradient for layer \\(K\\): \\(\\Delta_w^{[K]} = \\frac{\\delta \\mathcal{L}(\\hat{y}, y)}{\\delta a^{[K]}} \\frac{\\delta a^{[K]}}{\\delta z^{[K]}}\\) Gradient for layer \\(K\\): \\(\\frac{\\delta \\mathcal{L}(\\hat{y}, y)}{\\delta w^{[K]}} = \\Delta_w^{[K]} \\frac{\\delta z^{[K]}}{\\delta w^{[K]}}\\) Hidden Layer Accumulated gradient for layer \\(K-1\\): \\(\\Delta_w^{[K-1]} = \\Delta_w^{[K]} \\frac{\\delta z^{[K]}}{\\delta a^{[K-1]}} \\frac{\\delta a^{[K-1]}}{\\delta z^{[K-1]}}\\) Gradient for layer \\(K-1\\): \\(\\frac{\\delta \\mathcal{L}(\\hat{y}, y)}{\\delta w^{[K-1]}} = \\Delta_w^{[K-1]} \\frac{\\delta z^{[K-1]}}{\\delta w^{[K-1]}}\\) Graphical Representation On the following image we show how to obtain the gradient of the first element of the first layer's first neuron's weights \\(w^{[1]}_{11}\\) on the first layer: Improving a Neural Network Activation Functions Why do we need activation functions? Well, suppose you have the following network where the activation function is the identity function. That is \\(a^{[i]} = g(z^{[i]}) = z^{[i]}\\): Then: \\begin{align} \\hat{y} = a^{[3]} = z^{[3]} = w^{[3]} a^{[2]} + b^{[3]} = w^{[3]} z^{[2]} + b^{[3]} = w^{[3]} (w^{[2]} a^{[1]} + b^{[2]}) + b^{[3]} \\end{align} \\begin{align} = w^{[3]} (w^{[2]} z^{[1]} + b^{[2]}) + b^{[3]} = w^{[3]} (w^{[2]} (w^{[1]} x + b^{[1]}) + b^{[2]}) + b^{[3]} \\end{align} \\begin{align} = w^{[3]} (w^{[2]} w^{[1]} x + w^{[2]} b^{[1]} + b^{[2]}) + b^{[3]} \\end{align} \\begin{align} = w^{[3]} w^{[2]} w^{[1]} x + w^{[3]} w^{[2]} b^{[1]} + w^{[3]} b^{[2]} + b^{[3]} \\end{align} If \\begin{align} W = w^{[3]} w^{[2]} w^{[1]} \\end{align} \\begin{align} B = w^{[3]} w^{[2]} b^{[1]} + w^{[3]} b^{[2]} + b^{[3]} \\end{align} Then: \\begin{align} \\hat{y} = WX + B \\end{align} As you can see if we do not use activation functions, it does not mater how deep your network is, it is going to be equivalent to a linear regression. Depending on the task at hand we use different activation functions: Sigmoid: \\(\\sigma(z) = \\frac{1}{1 + e^{-z}}\\), it maps \\(z \\in (-\\infty, \\infty)\\) to \\((0, 1)\\) It is good for classification Works well when the values are in the linear region of the function However when the values are on the extremes the gradient (slope) is very small, therefore it ends up vanishing in the network. ReLU: \\(ReLU(z) = \\begin{cases}0 & z \\leq 0 \\\\ 1 & z > 0\\end{cases}\\) tanh: \\(tanh(z) = \\frac{e^z - e^{-z}}{(e^z + e^{-z})}\\) Initialization Techniques Usually we normalize the input to avoid having saturated activation functions. To normalize: \\begin{align} x^{(i)}_j = \\frac{x^{(i)}_j - \\mu_j}{\\sigma_j} \\end{align} For every example \\(i\\) and feature \\(j\\). Where: \\(\\mu_j\\) is the mean of the \\(j\\) feature, thus: \\(\\mu_j = \\frac{1}{m} \\sum_{i=1}^m x^{(i)}_j\\) \\(\\sigma_j^2\\) is the variance of the \\(j\\) feature, thus: \\(\\sigma_j^2 = \\frac{1}{m} \\sum_{i=1}^m (x^{(i)}_j - \\mu_j)^2\\) Vanishing/Exploding Gradients Suppose you have the following network, where the activation function is the identity function and \\(b=0\\). Then \\(\\hat{y} = w^{[L]} a^{[L-1]} = w^{[L]} w^{[L-1]} a^{[L-2]} = \\cdots = w^{[L]} w^{[L-1]} \\cdots w^{[1]} x\\) Therefore, if: \\begin{align} w^{[L]} = \\begin{bmatrix} 1.5 & 0 \\\\ 0 & 1.5 \\\\ \\end{bmatrix} \\end{align} then: \\begin{align} \\hat{y} = \\begin{bmatrix} 1.5^L & 0 \\\\ 0 & 1.5^L \\\\ \\end{bmatrix} \\end{align} Which means we end up with an exploding gradient. The inverse happens when: \\begin{align} w^{[L]} = \\begin{bmatrix} 0.5 & 0 \\\\ 0 & 0.5 \\\\ \\end{bmatrix} \\end{align} then: \\begin{align} \\hat{y} = \\begin{bmatrix} 0.5^L & 0 \\\\ 0 & 0.5^L \\\\ \\end{bmatrix} \\end{align} Which results in a vanishing gradient. To avoid this somewhat, we need to initialize the weights properly. What we want is for the weights to be very close to one to avoid the exploding/diminishing problem. Intuition Given a single neuron: Then \\(a = g(z)\\) and \\(z = w_1 x_1 + \\cdots + w_n x_n\\). We can see that \\(z\\) will increase if \\(n\\) increases, therefore we would want \\(w_i\\) to be as small as \\(n\\) is large, that is: \\begin{align} w_i = \\frac{1}{n} \\end{align} Initialization Techniques If we want the value of \\(w^{[L]}\\) to be proportional to the number of inputs coming from the layer \\(L\\) (\\(n^{[L-1]}\\)). It works very well for sigmoid activation: w[k] = np.random.randn(shape)*np.sqrt(1/n[L-1]) For ReLU: w[k] = np.random.randn(shape)*np.sqrt(2/n[L-1]) Xavier initialization (used with tanh): \\(w^{[L]} \\sim \\sqrt{\\frac{1}{n^{[L-1]}}}\\) Her initialization: \\(w^{[L]} \\sim \\sqrt{\\frac{2}{n^{[L]} + n^{[L-1]}}}\\) Also you need to initialize the weights randomly, else you will run into the symmetry problem, where all neurons learn the same thing (that is they update very similarly). Optimization Mini Batch Gradient Descent Mini Batch Gradient Descent is a trade off between batch gradient descent and stochastic gradient descent. Also, because Mini Batch Gradient Descent is an approximation it introduces some noise on the loss function: However Mini Batch Gradient Descent is more used because Batch Gradient Descent can be very computationally expensive. Momentum Algorithm This algorithm combines Gradient Descent and momentum. Suppose you have the following contour plot, where the horizontal axis is much more extended that the vertical axis. By default on Gradient Descent the gradient of the loss will be orthogonal to the contour at the given point, as we can see: However, what we would like, so it would converge faster, is to make it move more horizontally than vertically. In order to do that we use a technique called momentum. It takes intro account past updates to find the right way to go. If you take an average of past updates, then: Vertical axis: it practically cancels itself because it oscillates a lot Horizontal axis: its value it's maintained because the past and present gradients go in the same direction To update the weights we apply the following equation: \\begin{align} \\upsilon = \\beta \\upsilon + (1 - \\beta) \\frac{\\delta \\mathcal{L}(\\hat{y}, y)}{\\delta w} \\end{align} Where: \\(\\upsilon\\): stores past updates \\(\\frac{\\delta \\mathcal{L}(\\hat{y}, y)}{\\delta w}\\): stores the current update We average with \\(\\beta\\) and \\((1 - \\beta)\\) Finally we update the weights: \\begin{align} w = w - \\alpha \\upsilon \\end{align} Anexo For more info about cost function and how to derive them: Anexo "
  },
  {
    "id": "https://albamr09.github.io/Notes/index.html",
    "title": "Notes",
    "body": " Back Notes Web Development Frameworks Front React Back Node.js Django Spring Technologies Docker GraphQL DB MongoDB Data Science Google Data Analyst Machine Learning Stanford Coursera Other VimWiki "
  },
  {
    "id": "https://albamr09.github.io/index.html",
    "title": "Registry Index",
    "body": " Registry Index Notes Study "
  },
  {
    "id": "https://albamr09.github.io/Study/Math/index.html",
    "title": "Math",
    "body": " Back Math First Year First semester Dicrete Maths Discrete Mathematics with Applications, 2nd edition by Susanna S. Epp Discrete Mathematics Structures, 4th edition by Kolman, Busby and Ross Proof writing (very advanced, do not expect to master anything in these books) Mathematical Proofs: A transition to advanced mathematics by Gary Chartrand et. al (This one is better than the next one) An introduction to Abstract Mathematics by Robert J. Bond and Wiliam J. Keane Second semester Pre-algebra (refresh really basic math) AGS Pre-Algebra (has solutions) Fearon's Pre-Algebra (this one is better) College Algebra (after the pre-algebra one, if the pre-algebra books are too easy skip onto these ones) College Algebra by Kaufmann (more begginer friendly) College Algebra by Blitzer Second Year First semester Pre-calculus (once you are done with college algebra. If you know some basic algebra you can skip the college algebra and start in this section) A Graphical Approach to Algebra and Trigonometry by Hornsby, Lial, and Rockswold. 6th edition (Get the instructor's edition) Second semester Calculus Calculus by James Stewart, 5th edition (Very famous book, to learn basic calculus. It has a lot of problems. Used to teach calculus I, II and III) Calculus by Michael Spivak, 3rd edition (It has less material but it is more advanced) Third Year First semester Differential equations A First Course in Differential Equations by Zill Ordinary Differential Equations with Applications by Andrews (It is easier, good for beginners) Linear Algebra (try to learn as much as possible) Elementary Linear Algebra by Howard Anton (Beginner friendly, with exercises) Linear Algebra by Friedgber, Insel, and Spence (It is harder and more difficult to read. It is proof based) Second semester Statistics Mathematical Statistics by Wackerly, Mendenhall, and Scheaffer A First Course in Probability by Ross Complex analysis (Calculus with complex numbers. Both are pretty much the same, very good beginner books) Fundamentals of Complex Analysis by Saff and Snider, 3rd edition Complex Variables and Applications by Brown and Churchill, 7th edition Fourth Year First semester Real analysis (one of the hardest subjects) Analysis 1 and Analysis 2 by Terrance Tao (Easier to read, but the other two are standard) Advanced Calculus by Fitzpatrick Principles of Mathematical Analysis by Rudin Elements ofAnalysis by Ross (Expends a lot of time for proofs) Abstract algebra (study of groups, rings and fields. Very proof based) Abstract Algebra by Saracino (Very good for beginners) Contemporary Abstract Algebra by Gallian (Also good for beginners) Second semester Topology (optional) Introduction to Topology by Gamelin and Greene (It has full solutions for all of the problems) Combinatorics (optional) Applied Combinatorics by Tucker Naive set theory (optional) Naive Set Theory by Halmos Functional analysis (optional) Functional Analysis by Kreyszig Graph Theory (optional) Graph Theory by Gould "
  },
  {
    "id": "https://albamr09.github.io/Study/DataScience/google-analytics.html",
    "title": "Google Data Analyst Certificate",
    "body": " Back Google Data Analyst Certificate Source Foundations: Data, Data, Everywhere Introducing data analytics All about analytical thinking The wonderful world of data Set up your toolbox Endless career possibilities Ask Questions to Make Data-Driven Decisions Effective questions Data driven decisions More spreadsheets basics Always remember the stakeholder Prepare Data for Exploration Data types and structures Bias, credibility, privacy, ethics and access Databases: Where data lives Organizing and protecting your data Optional: Engaging in the data community Process Data from Dirty to Clean The importance of integrity Sparkling-clean data Cleaning data with SQL Verify and report on your cleaning results Optional: Adding data to your resume Course challenge Analyze Data to Answer Questions Organizing data to begin analysis Formatting and adjusting data Aggregating data for analysis Performing data calculations Share Data Through the Art of Visualization Visualizing Data Creating data visualization with Tableau Crafting data stories Developing presentations and slideshows Data Analysis with R Programming Programming and data analytics Programming using RStudio Working with data in R More about visualizations, aesthetics, and annotations Documentations and reports Google Data Analytics Capstone: Complete a Case Study Learn about capstone basics Optional: Building your portfolio Optional: Using your portfolio Putting your certificate to work "
  },
  {
    "id": "https://albamr09.github.io/Study/DataScience/ibm-analytics.html",
    "title": "IBM Data Science Certificate",
    "body": " Back IBM Data Science Certificate Source "
  },
  {
    "id": "https://albamr09.github.io/Study/DataScience/index.html",
    "title": "Data Science Study Guide",
    "body": " Back Data Science Study Guide Practical courses Google Data Analyst Certificate (absolutely useless) IBM Data Analyst Certificate freecodecamp Kaggle courses Topics Mainly covered in Mathematics for Machine Learning: Optimization Linear algebra (orthogonal matrices) Books To study in this order: Mathematics for Machine Learning Pattern Recognition and Machine Learning "
  },
  {
    "id": "https://albamr09.github.io/Study/DataScience/freecodecamp.html",
    "title": "FreeCodeCamp",
    "body": " Back FreeCodeCamp Source There are data visualization, machine learning, data analysis in python courses "
  },
  {
    "id": "https://albamr09.github.io/Study/CS/Databases.html",
    "title": "Databases",
    "body": " Back Databases Start with the recording and the go through the book (paper compilation) Video Lectures CS186B Berkley Book Readings in Database Systems Data Modelling Book: Data and Reality: A Timeless Perspective on Perceiving and Managing Information in Our Imprecise World. "
  },
  {
    "id": "https://albamr09.github.io/Study/CS/Programming.html",
    "title": "Programming",
    "body": " Back Programming Books Structure and Interpretation of Computer Programs Video Lectures Brian Harvey’s SICP lectures Resources for the berkley course Code online on Scheme Scheme on Arch (Download MIT/GNU Scheme) Plan 1 Notes Notes We recommend working through at least the first three chapters of SICP and doing the exercises. For additional practice, work through a set of small programming problems like those on exercism. Alternatives Same course but with python instead of Scheme (Stk) Books: Composing Programs Lectures: 61A taught by John DeNero at Berkley. "
  },
  {
    "id": "https://albamr09.github.io/Study/CS/Languages and Compilers.html",
    "title": "Languages and Compilers",
    "body": " Back Languages and Compilers Books Introductory: Crafting Interpreters As supplementary reference for video lectures: Compilers: Principles, Techniques & Tools Video Lecutres Alex Aiken’s, on edX Notes For introductory book: We suggest taking the time to work through the whole thing, attempting whichever of the \"challenges\" sustain your interest. "
  },
  {
    "id": "https://albamr09.github.io/Study/CS/Distributed Systems.html",
    "title": "Distributed Systems",
    "body": " Back Distributed Systems Books Practice oriented: Designing Data-Intensive Applications More traditional: Distributed Systems, 3rd Edition "
  },
  {
    "id": "https://albamr09.github.io/Study/CS/Computer Architecture.html",
    "title": "Computer Architecture",
    "body": " Back Computer Architecture First go to the alternative and then go to the main book. Books Computer Systems: A Programmer's Perspective Most courses go from chapter 1 to 6. Alternatives Each chapter involves building a small piece of the overall system, from writing elementary logic gates in HDL, through a CPU and assembler, all the way to an application the size of a Tetris game. The Elements of Computing Systems (Nand2Tetris) We recommend reading through the first six chapters of the book and completing the associated projects. This will develop your understanding of the relationship between the architecture of the machine and the software that runs on it. In seeking simplicity and cohesiveness, Nand2Tetris trades off depth. In particular, two very important concepts in modern computer architectures are pipelining and memory hierarchy, but both are mostly absent from the text. "
  },
  {
    "id": "https://albamr09.github.io/Study/CS/Operating Systems.html",
    "title": "Operating Systems",
    "body": " Back Operating Systems Books Operating Systems: Three Easy Pieces Labs: xv6 labs "
  },
  {
    "id": "https://albamr09.github.io/Study/CS/Mathematics for Computer Science.html",
    "title": "Mathematics for Computer Science",
    "body": " Back Mathematics for Computer Science Books MIT Lecture Notes Video Lectures MIT Video Lectures "
  },
  {
    "id": "https://albamr09.github.io/Study/CS/index.html",
    "title": "Computer Science",
    "body": " Back Computer Science Source Programming Computer Architecture Algorithms and Data Structures Mathematics for Computer Science Operating Systems Computer Networking Databases Languages and Compilers Distributed Systems AI and Machine Learning AI and Machine Learning Check the source. "
  },
  {
    "id": "https://albamr09.github.io/Study/CS/Algorithms and Data Structures.html",
    "title": "Algorithms and Data Structures",
    "body": " Back Algorithms and Data Structures Books The Algorithm Design Manual Video Lectures Skiena's or Tim's on Coursera Practice: Leetcode Problem solving book after the manual: How to Solve It "
  },
  {
    "id": "https://albamr09.github.io/Study/CS/Computer Networking.html",
    "title": "Computer Networking",
    "body": " Back Computer Networking Books Computer Networking: A Top-Down Approach Video Lectures Standford: Introduction to Computer Networking course Labs: Wireshark labs "
  },
  {
    "id": "https://albamr09.github.io/Study/index.html",
    "title": "Study",
    "body": " Back Study Study Guides Math CS DataScience Web Development Course Plan Current Copy ML notes (at least 1h a day) Look into NN in books Look into NN in College subject on Machine Learning Review all notes of College subject on Machine Learning Review all homework of College subject on Machine Learning (add snippets to notes) Review React Do the React Crash Course. Do the Redux Crash Course Choose the Markdown previewer or the 25 + 5 clock (or both!!!! or neither!!!) Finish SICP Berkeley (at least 1h a day) Future Ordered by priority, one choose one at a time Backend Dev Spring Boot (List of courses): Do the Spring Course (max 2 weeks) Projects Do the Back End Dev course from freecodecamp (max a week) Continue the Bookish project (add GraphQL) Learn C++ Tutorialspoints course (max a week) Search for projects, some are: Data Structure Data Analysis with Python Course from freecodecamp Data Visualization Course from freecodecamp College Algebra: Start from chapter 2 To search for more project go to Project Ideas, there are project listings for a lot of languages, frameworks. "
  }
]