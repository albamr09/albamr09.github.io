<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Alba&#39;s Notes – Camera</title>
    <link>//localhost:1313/notes/cs/rtgw/04/</link>
    <description>Recent content in Camera on Alba&#39;s Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    
	  <atom:link href="//localhost:1313/notes/cs/rtgw/04/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Transformations</title>
      <link>//localhost:1313/notes/cs/rtgw/04/01_transformations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/notes/cs/rtgw/04/01_transformations/</guid>
      <description>
        
        
        &lt;h2&gt;Vertex Transformations&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;vertex-transformations&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#vertex-transformations&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Each transformation is encoded by a $4$x$4$ matrix. We multiply vertices that have three components, $(x, y, z)$, by this $4$x$4$ matrix by adding a fourth component to each vertex called the Homogeneous coordinate.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://jsantell.com/model-view-projection&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;This&lt;/a&gt; article has a great visualization for each space:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;World Space&lt;/li&gt;
&lt;li&gt;Camera Space&lt;/li&gt;
&lt;li&gt;Clip Space&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Homogeneous Coordinates&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;homogeneous-coordinates&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#homogeneous-coordinates&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;Until now, we only considered 3D vertices as a $(x,y,z)$ triplet. Let’s introduce $w$. Homogeneous coordinates make it possible to represent &lt;strong&gt;affine transformations&lt;/strong&gt; (such as rotation, scaling, shear, and translation) and projective transformations as $4$x$4$ matrices.&lt;/p&gt;
&lt;p&gt;In Homogeneous coordinates, vertices have four components: $x, y, z$, and $w$. The first three components are the &lt;strong&gt;vertex coordinates&lt;/strong&gt; in &lt;strong&gt;Euclidian Space&lt;/strong&gt;. The fourth is the &lt;strong&gt;perspective component&lt;/strong&gt;. So $(x, y, z, w)$ take us to a new space: the &lt;strong&gt;Projective Space&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;This will be more clear soon, but for now, just remember this:&lt;/p&gt;
&lt;p&gt;If $w == 1$, then the vector $(x,y,z,1)$ is a position in space.
If $w == 0$, then the vector $(x,y,z,0)$ is a direction.&lt;/p&gt;
&lt;p&gt;What difference does this make? Well, for a rotation, it doesn’t change anything. When you rotate a point or a direction, you get the same result. However, for a translation (when you move the point in a certain direction), things are different. What could mean “translate a direction”? Not much. Homogeneous coordinates allow us to use a single mathematical formula to deal with these two cases.&lt;/p&gt;
&lt;p&gt;Homogeneous coordinates make it possible to solve a system of linear equations where each equation represents a line that is parallel with all the others in the system. Remember that in Euclidian Space, a system like that does not have solutions, because there are no intersections. However, in Projective Space, this system has a solution—the lines will intersect at infinity. This fact is represented by the perspective component having a value of $0$.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../assets/projection_space.png&#34; alt=&#34;Projective Space&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;It&amp;rsquo;s easy to convert from Homogeneous coordinates to non-Homogeneous, old-fashioned, Euclidean coordinates by dividing each coordinate by $w$:&lt;/p&gt;
$$
\begin{aligned}
h(x, y, z, w) = v(\frac{x}{w}, \frac{y}{w}, \frac{z}{w})
\end{aligned}
$$&lt;p&gt;Consequently, if you want to go from Euclidean to Projective space, you add the fourth component, $w$, and make it $1$:&lt;/p&gt;
$$
\begin{aligned}
v(x, y, z) = h(x, y, z, 1)
\end{aligned}
$$&lt;p&gt;In fact, this is what we&amp;rsquo;ve been doing throughout the first three chapters:&lt;/p&gt;
&lt;div class=&#34;hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code&#34;&gt;
  

&lt;div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;#&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;version&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;300&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;es&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;precision&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mediump&lt;/span&gt; &lt;span class=&#34;kr&#34;&gt;float&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;uniform&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mat4&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;uModelViewMatrix&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;uniform&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mat4&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;uProjectionMatrix&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;uniform&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mat4&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;uNormalMatrix&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;vec3&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;aVertexPosition&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;gl_Position&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;uProjectionMatrix&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;**&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;uModelViewMatrix&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;**&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;vec4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;aVertexPosition&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;1.0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0&#34;&gt;
  &lt;button
    class=&#34;hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50&#34;
    title=&#34;Copy code&#34;
  &gt;
    &lt;div class=&#34;copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
    &lt;div class=&#34;success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
  &lt;/button&gt;
&lt;/div&gt;

  
&lt;/div&gt;
&lt;p&gt;There is one more thing to note about Homogeneous coordinates: while vertices have a Homogeneous coordinate, $w = 1$, vectors have a Homogeneous coordinate, $w = 0$. This is because in the Phong vertex shader, the line that processes the normals looks like this:&lt;/p&gt;
&lt;div class=&#34;hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code&#34;&gt;
  

&lt;div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;vVertexNormal&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;vec3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;uNormalMatrix&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;vec4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;aVertexNormal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;0.0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0&#34;&gt;
  &lt;button
    class=&#34;hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50&#34;
    title=&#34;Copy code&#34;
  &gt;
    &lt;div class=&#34;copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
    &lt;div class=&#34;success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
  &lt;/button&gt;
&lt;/div&gt;

  
&lt;/div&gt;
&lt;h3&gt;Transformations&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;transformations&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#transformations&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;h4&gt;Translation Matrices&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;translation-matrices&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#translation-matrices&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;These are the most simple tranformation matrices to understand. A translation matrix look like this:&lt;/p&gt;
$$
\begin{aligned}
\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; X \\
0 &amp; 1 &amp; 0 &amp; Y \\
0 &amp; 0 &amp; 1 &amp; Z \\
0 &amp; 0 &amp; 0 &amp; 1 \\
\end{bmatrix}
\end{aligned}
$$&lt;p&gt;where $X,Y,Z$ are the values that you want to add to your position.&lt;/p&gt;
&lt;p&gt;So if we want to translate the vector $(10,10,10,1)$ of $10$ units in the X direction, we get:&lt;/p&gt;
$$
\begin{aligned}
\begin{bmatrix}
1 &amp; 0 &amp; 0 &amp; 10 \\
0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 \\
\end{bmatrix}
*
\begin{bmatrix}
10 \\
10 \\
10 \\
1 \\
\end{bmatrix} =
\begin{bmatrix}
1 ** 10 + 0 ** 10 + 0 ** 10 + 10 ** 1 \\
0 ** 10 + 1 ** 10 + 0 ** 10 + 0 ** 1 \\
0 ** 10 + 0 ** 10 + 1 ** 10 + 0 ** 1 \\
0 ** 10 + 0 ** 10 + 0 ** 10 + 1 ** 1 \\
\end{bmatrix} =
\begin{bmatrix}
20 \\
10 \\
10 \\
1 \\
\end{bmatrix}
\end{aligned}
$$&lt;p&gt;and we get a $(20,10,10,1)$ homogeneous vector! Remember, the $1$ means that it is a position, not a direction. So our transformation didn’t change the fact that we were dealing with a position, which is good.&lt;/p&gt;
&lt;h4&gt;Scaling matrices&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;scaling-matrices&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#scaling-matrices&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;Scaling matrices are quite easy too:&lt;/p&gt;
$$
\begin{aligned}
\begin{bmatrix}
x &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; y &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; z &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 \\
\end{bmatrix}
\end{aligned}
$$&lt;p&gt;So if you want to scale a vector (position or direction, it doesn’t matter) by $2.0$ in all directions:&lt;/p&gt;
$$
\begin{aligned}
\begin{bmatrix}
2 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 2 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 2 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 \\
\end{bmatrix}
*
\begin{bmatrix}
x \\
y \\
z \\
w \\
\end{bmatrix} =
\begin{bmatrix}
2 ** x + 0 ** y + 0 ** z + 0 ** w \\
0 ** x + 2 ** y + 0 ** z + 0 ** w \\
0 ** x + 0 ** y + 2 ** z + 0 ** w \\
0 ** x + 0 ** y + 0 ** z + 1 ** w \\
\end{bmatrix} =
\begin{bmatrix}
2x \\
2y \\
2z \\
w \\
\end{bmatrix}
\end{aligned}
$$&lt;h4&gt;Rotation Matrices&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;rotation-matrices&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#rotation-matrices&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;&lt;a href=&#34;https://www.opengl-tutorial.org/intermediate-tutorials/tutorial-17-quaternions/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;TBC&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;Cumulating transformations&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;cumulating-transformations&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#cumulating-transformations&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;So now we know how to rotate, translate, and scale our vectors. It would be great to combine these transformations. This is done by multiplying the matrices together:&lt;/p&gt;
&lt;div class=&#34;hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code&#34;&gt;
  

&lt;div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;TransformedVector&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;TranslationMatrix&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;RotationMatrix&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ScaleMatrix&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;OriginalVector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0&#34;&gt;
  &lt;button
    class=&#34;hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50&#34;
    title=&#34;Copy code&#34;
  &gt;
    &lt;div class=&#34;copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
    &lt;div class=&#34;success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
  &lt;/button&gt;
&lt;/div&gt;

  
&lt;/div&gt;
&lt;p&gt;This actually performs the scaling FIRST, and THEN the rotation, and THEN the translation. This is how matrix multiplication works.&lt;/p&gt;
&lt;h2&gt;Transposing Transformation or Projection Matrices&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;transposing-transformation-or-projection-matrices&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#transposing-transformation-or-projection-matrices&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;It can be confusing to determine whether you should transpose your matrix before passing it to the graphics pipeline. According to the WebGL specifications, matrices are conventionally written in column-major order. Row-major order is what is conventionally used on mathematics to define matrices, and throughout all this chapter we define the matrices on row-major order, therefore to avoid this before passing them to WebGL we need to transpose them, either we do it manually, or we can use:&lt;/p&gt;
&lt;div class=&#34;hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code&#34;&gt;
  

&lt;div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;gl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;uniformMatrix4fv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;uModelViewMatrix&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;modelViewMatrix&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;toFloatArray&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0&#34;&gt;
  &lt;button
    class=&#34;hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50&#34;
    title=&#34;Copy code&#34;
  &gt;
    &lt;div class=&#34;copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
    &lt;div class=&#34;success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
  &lt;/button&gt;
&lt;/div&gt;

  
&lt;/div&gt;
&lt;p&gt;Where the second argument determines whether we want to transpose the matrix or not.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Model, View and Projection Transform</title>
      <link>//localhost:1313/notes/cs/rtgw/04/02_model_view/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/notes/cs/rtgw/04/02_model_view/</guid>
      <description>
        
        
        &lt;h2&gt;The Model Matrix&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;the-model-matrix&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#the-model-matrix&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;A model is defined by a set of vertices. The $X,Y,Z$ coordinates of these vertices are defined relative to the object’s center: that is, if a vertex is at $(0,0,0)$, it is at the center of the object.&lt;/p&gt;
&lt;p&gt;We&amp;rsquo;d like to be able to move this model (you just learnt to do so: &lt;code&gt;translation**rotation**scale&lt;/code&gt;, and done. You apply this matrix to all your vertices at each frame and everything moves. Something that doesn&amp;rsquo;t move will be at the center of the world.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../assets/model_transform.png&#34; alt=&#34;Model Transform&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Your vertices are now in World Space. We went from &lt;strong&gt;Model Space&lt;/strong&gt; (all vertices defined relatively to the center of the model) to &lt;strong&gt;World Space&lt;/strong&gt; (all vertices defined relatively to the center of the world). See figure below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../assets/world_coordinates.png&#34; alt=&#34;World Coordinates&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;h2&gt;The View Matrix&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;the-view-matrix&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#the-view-matrix&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;It you want to view a moutain from another angle, you can either move the camera&amp;hellip; or move the mountain.&lt;/p&gt;
&lt;p&gt;So initially your camera is at the origin of the World Space. In order to move the world, you simply introduce another matrix. Let’s say you want to move your camera of $3$ units to the right ($+X$). This is equivalent to moving your whole world $3$ units to the left ($-X$).&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../assets/view_transform.png&#34; alt=&#34;View Transform&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;We went from &lt;strong&gt;World Space&lt;/strong&gt; (all vertices defined relatively to the center of the world, as we made so in the previous section) to &lt;strong&gt;Camera Space&lt;/strong&gt; (all vertices defined relatively to the camera). The figure below shows how we go from model/object coordinates to world coordinates and finally to camera coordinates.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../assets/camera_coordinates.png&#34; alt=&#34;Camera Coordinates&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;h2&gt;The Model-View Matrix&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;the-model-view-matrix&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#the-model-view-matrix&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;The Model-View matrix allows us to perform &lt;strong&gt;affine transformations&lt;/strong&gt; in our scene. Affine is a mathematical name that describes transformations that do not change the structure of the object undergoing such transformations. In our 3D world scene, such transformations are rotation, scaling, reflection shearing, and translation. Let&amp;rsquo;s take a look at how the Model-View matrix is constructed.&lt;/p&gt;
&lt;h3&gt;Spatial Encoding of the World&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;spatial-encoding-of-the-world&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#spatial-encoding-of-the-world&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;By default, when you render a scene, you are looking at it from the origin of the world in the negative direction of the z-axis. As shown in the following diagram, the z-axis is coming out of the screen:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../assets/spatial_world_encoding.png&#34; alt=&#34;Spatial World Encoding&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;h4&gt;Rotation Matrix&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;rotation-matrix&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#rotation-matrix&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;The intersection of the first three rows with the first three columns defines the 3x3 Rotation matrix. This matrix contains information about rotations around the standard axis.&lt;/p&gt;
$$
\begin{aligned}
\begin{bmatrix}
m_1 &amp; m_2 &amp; m_3 \\
m_5 &amp; m_6 &amp; m_7 \\
m_9 &amp; m_{10} &amp; m_{11}
\end{bmatrix}
\end{aligned}
$$&lt;h4&gt;Translation Vector&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;translation-vector&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#translation-vector&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;The intersection of the first three rows with the last column defines a three-component Translation vector.&lt;/p&gt;
$$
\begin{aligned}
\begin{bmatrix}
m_{13} &amp; m_{14} &amp; m_{15}
\end{bmatrix}
\end{aligned}
$$&lt;h4&gt;The Mysterious Fourth Row&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;the-mysterious-fourth-row&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#the-mysterious-fourth-row&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;The fourth row does not have any special meaning.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The $m_4$, $m_8$, and $m_{12}$ elements are always $0$.&lt;/li&gt;
&lt;li&gt;The $m_{16}$ element (the Homogeneous coordinate) will always be $1$.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;The Projection Matrix&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;the-projection-matrix&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#the-projection-matrix&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Projection matrices are specialized $4$x$4$ matrices designed to transform a 3D point in camera space into its projected counterpart on the canvas. Essentially, when you multiply a 3D point by a projection matrix, you determine its 2D coordinates on the canvas within NDC (Normalized Device Coordinates) space (we&amp;rsquo;ll see what these are later). Points in NDC space fall within the range $[-1, 1]$.&lt;/p&gt;
&lt;p&gt;It&amp;rsquo;s crucial to remember that projection matrices are intended for transforming vertices or 3D points, not vectors. The workaround involves treating points as $1\times 4$ vectors, enabling their multiplication by a $4\times 4$ matrix. The result is another $1\times 4$ matrix, or 4D points with homogeneous coordinates. These coordinates are only directly applicable as 3D points if their fourth component is $1$, allowing the first three components to represent a standard 3D Cartesian point.&lt;/p&gt;
&lt;p&gt;This operation determines how much of the view space will be rendered and how it will be mapped onto the computer screen. This region is known as the &lt;strong&gt;frustum&lt;/strong&gt; and it is defined by six planes (near, far, top, bottom, right, and left planes), as shown in the following diagram:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../assets/projection_transform.png&#34; alt=&#34;Projection Transform&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;These six planes are encoded in the &lt;strong&gt;Projection matrix&lt;/strong&gt;. Any vertices lying outside the frustum after applying the transformation are clipped out and discarded from further processing. Therefore, the frustum defines clipping coordinates, and the Projection matrix that encodes the frustum produces clipping coordinates.&lt;/p&gt;
&lt;p&gt;If the far and near planes have the same dimensions, the frustum will then determine an &lt;strong&gt;orthographic projection&lt;/strong&gt;. Otherwise, it will be a &lt;strong&gt;perspective projection&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../assets/orthographic_perspective_projection.png&#34; alt=&#34;Orthographic vs Perspective projection&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;We went from &lt;strong&gt;Camera Space&lt;/strong&gt; (all vertices defined relatively to the camera) to &lt;strong&gt;Homogeneous Space&lt;/strong&gt; (all vertices defined in a small cube. Everything inside the cube is onscreen).&lt;/p&gt;
&lt;p&gt;Before projection, we’ve got our blue objects, in Camera Space, and the red shape represents the frustum of the camera: the part of the scene that the camera is actually able to see.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../assets/projection_coordinates_before.png&#34; alt=&#34;Projection Coordinates&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Multiplying everything by the Projection Matrix has the following effect:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../assets/projection_coordinates_after.png&#34; alt=&#34;Projection Coordinates&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;h3&gt;Perspective or Orthogonal Projection&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;perspective-or-orthogonal-projection&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#perspective-or-orthogonal-projection&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;A perspective projection assigns more space to details that are closer to the camera than details that are farther away. In other words, the geometry that is close to the camera will appear larger than the geometry that is farther from it.&lt;/p&gt;
&lt;p&gt;In contrast, an orthogonal projection uses parallel lines; this means that lines will appear to be the same size, regardless of their distance to the camera.&lt;/p&gt;
&lt;h4&gt;Perspective Matrix&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;perspective-matrix&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#perspective-matrix&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;The Projection matrix determines the &lt;strong&gt;field of view&lt;/strong&gt; (FOV) of the camera. Which is how much of the 3D space will be captured by the camera. It is a measure given in degrees, and the term is used interchangeably with the term &lt;strong&gt;angle of view&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../assets/fov.png&#34; alt=&#34;Field of View (FOV)&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;./02_01_perspective&#34; &gt;Perspective Matrix&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Orthographic Matrix&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;orthographic-matrix&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#orthographic-matrix&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;./02_02_orthographic&#34; &gt;Orthographic Matrix&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Clipping&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;clipping&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#clipping&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Up to this point, we are still working with Homogeneous coordinates. Projection matrices actually transform points from the camera space to the &lt;strong&gt;homogeneous clip space&lt;/strong&gt;, not to &lt;strong&gt;NDC&lt;/strong&gt; (Normalized Device Coordinate) space.&lt;/p&gt;
&lt;p&gt;Because WebGL doesn&amp;rsquo;t know anything about the coordinate space it requires that when all of the transformations are done, things should be in normalized device coordinates. Normalized device coordinates are obtained by dividing the clipping coordinates by the $w$ component. This is why this step is known as &lt;strong&gt;perspective division&lt;/strong&gt;. In the NDC space, the $x$ and $y$ coordinates represent the location of your vertices on a normalized 2D screen, while the z-coordinate encodes depth information, which is the relative location of the objects with respect to the near and far planes.&lt;/p&gt;
&lt;p&gt;Basically the homogeneous coordinates have four components: $x$, $y$, $z$, and $w$. The clipping is done by comparing the $x$, $y$, and $z$ components against the Homogeneous coordinate, $w$. If any of them is more than, $+w$, or less than, $-w$, then that vertex lies outside the frustum and is discarded.&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;clipping coordinates&lt;/strong&gt; now range from $-1$ to $+1$ on each axis, regardless of the shape or size of the actual screen. The bottom left corner will be at $(-1, -1)$, and the top right corner will be at (1, 1). WebGL will then map these coordinates onto the viewport that was configured with &lt;code&gt;glViewport&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../assets/normalized_device_coordinates.png&#34; alt=&#34;Normalized Device Coordinates&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../assets/view_transform_1.png&#34; alt=&#34;View Transform&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;h2&gt;Recap&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;recap&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#recap&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;The following diagram shows the theory we have learned so far, along with the relationships between the steps in the theory and the implementation in WebGL.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../../assets/transformations_recap.png&#34; alt=&#34;Translations Recap&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The five transformations that we apply to object coordinates to obtain viewport coordinates are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;strong&gt;Model-View matrix&lt;/strong&gt; that groups the model and view transform in one single matrix. When we multiply our vertices by this matrix, we end up in the &lt;strong&gt;camera space&lt;/strong&gt; with homogeneous coordinates.&lt;/li&gt;
&lt;li&gt;The &lt;strong&gt;Projection matrix&lt;/strong&gt; as a result, we end up in the &lt;strong&gt;homogeneous clip space&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Clipping&lt;/strong&gt;: transforms the homogeneous coordinates on cartesian coordinates by leaving out all vertices ouside of the range $[-w, w]$. This leaves us on the &lt;strong&gt;clip space&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Perspective Division&lt;/strong&gt;: after we apply perspective division, so now our coordinates are on the &lt;strong&gt;NDC space&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GL Viewport&lt;/strong&gt;: internal transform to move to the &lt;strong&gt;raster space&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;An extra transformation matrix is defined specially for the normals. This is the &lt;strong&gt;Normal matrix&lt;/strong&gt;, which is obtained by inverting and transposing the Model-View matrix. This matrix is applied to normal vectors to ensure that they continue to be perpendicular to the surface.&lt;/p&gt;
&lt;h2&gt;References&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;references&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#references&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://jsantell.com/model-view-projection/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Model View Projection&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/projection-matrix-GPU-rendering-pipeline-clipping.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Projection Matrices&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

      </description>
    </item>
    
    <item>
      <title>Normal Transform</title>
      <link>//localhost:1313/notes/cs/rtgw/04/03_normal_transform/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/notes/cs/rtgw/04/03_normal_transform/</guid>
      <description>
        
        
        &lt;h3&gt;Calculating the Normal Matrix&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;calculating-the-normal-matrix&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#calculating-the-normal-matrix&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;Two vectors are perpendicular if their dot product is $0$. In our example&lt;/p&gt;
$$
\begin{aligned}
&lt;N, S&gt; = 0
\end{aligned}
$$&lt;p&gt;Here, $S$ is the surface vector and can be calculated as the difference of two vertices. Let $M$ be the Model-View matrix. We can use $M$ to transform $S$ as follows:&lt;/p&gt;
$$
\begin{aligned}
S&#39; = MS
\end{aligned}
$$&lt;p&gt;We want to find a matrix, $K$, that allows us to transform normals in a similar way. For the $N$ normal, we want the following:&lt;/p&gt;
$$
\begin{aligned}
N&#39; = KN
\end{aligned}
$$&lt;p&gt;For the scene to be consistent after obtaining $N&amp;rsquo;$ and $S&amp;rsquo;$, these two need to keep the perpendicularity that the original vectors $N$ and $S$ had.&lt;/p&gt;
$$
\begin{aligned}
&lt;N&#39;, S&#39;&gt; = 0
\end{aligned}
$$&lt;p&gt;Substituting $N&amp;rsquo;$ and $S&amp;rsquo;$:&lt;/p&gt;
$$
\begin{aligned}
&lt;KN, MS&gt; = 0
\end{aligned}
$$$$
\begin{aligned}
(KN)^T(MS) = 0
\end{aligned}
$$$$
\begin{aligned}
N^TK^TMS = 0
\end{aligned}
$$$$
\begin{aligned}
N^T(K^TM)S = 0
\end{aligned}
$$&lt;p&gt;Now, remember that $&amp;lt;N, S&amp;gt; = 0$ so $N^TS = 0$. This means that in the previous equation, $(K^TM)$ needs to be the identity matrix, $I$, so the original condition of N and S being perpendicular holds:&lt;/p&gt;
$$
\begin{aligned}
K^TM = I
\end{aligned}
$$$$
\begin{aligned}
K^TMM^{-1} = IM^{-1} = M^{-1}
\end{aligned}
$$$$
\begin{aligned}
K^T = M^{-1}
\end{aligned}
$$$$
\begin{aligned}
(K^T)^T = (M^{-1})^T
\end{aligned}
$$$$
\begin{aligned}
K = (M^{-1})^T
\end{aligned}
$$&lt;p&gt;$K$ is obtained by transposing the inverse of the Model-View matrix ($M$, in this example). We need to use $K$ to multiply the normal vectors so that they keep being perpendicular to the surface when transformed.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Camera Matrix</title>
      <link>//localhost:1313/notes/cs/rtgw/04/04_camera/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>//localhost:1313/notes/cs/rtgw/04/04_camera/</guid>
      <description>
        
        
        &lt;h2&gt;Camera Translation&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;camera-translation&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#camera-translation&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Let&amp;rsquo;s move the camera to $[0, 0, 4]$ in world coordinates. This means four units from the origin on the positive z-axis. If we applied:&lt;/p&gt;
&lt;div class=&#34;hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code&#34;&gt;
  

&lt;div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;mat4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;translate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;modelViewMatrix&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;modelViewMatrix&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0&#34;&gt;
  &lt;button
    class=&#34;hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50&#34;
    title=&#34;Copy code&#34;
  &gt;
    &lt;div class=&#34;copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
    &lt;div class=&#34;success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
  &lt;/button&gt;
&lt;/div&gt;

  
&lt;/div&gt;
&lt;p&gt;In such a case, the world would be translated 4 units on the positive z-axis, and since the camera position has not been changed, it would be located at $[0, 0, -4]$, which is exactly the opposite of what we want. Now, say that we applied the translation in the opposite direction:&lt;/p&gt;
&lt;div class=&#34;hextra-code-block hx-relative hx-mt-6 first:hx-mt-0 hx-group/code&#34;&gt;
  

&lt;div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nx&#34;&gt;mat4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;translate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;modelViewMatrix&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;modelViewMatrix&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;hextra-code-copy-btn-container hx-opacity-0 hx-transition group-hover/code:hx-opacity-100 hx-flex hx-gap-1 hx-absolute hx-m-[11px] hx-right-0 hx-top-0&#34;&gt;
  &lt;button
    class=&#34;hextra-code-copy-btn hx-group/copybtn hx-transition-all active:hx-opacity-50 hx-bg-primary-700/5 hx-border hx-border-black/5 hx-text-gray-600 hover:hx-text-gray-900 hx-rounded-md hx-p-1.5 dark:hx-bg-primary-300/10 dark:hx-border-white/10 dark:hx-text-gray-400 dark:hover:hx-text-gray-50&#34;
    title=&#34;Copy code&#34;
  &gt;
    &lt;div class=&#34;copy-icon group-[.copied]/copybtn:hx-hidden hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
    &lt;div class=&#34;success-icon hx-hidden group-[.copied]/copybtn:hx-block hx-pointer-events-none hx-h-4 hx-w-4&#34;&gt;&lt;/div&gt;
  &lt;/button&gt;
&lt;/div&gt;

  
&lt;/div&gt;
&lt;p&gt;In such a case, the world would be moved 4 units on the negative z-axis and then the camera would be located at $[0, 0, 4]$ in the new world-coordinate system.&lt;/p&gt;
&lt;p&gt;The Camera matrix transformation is the inverse of the Model-View matrix transformation.&lt;/p&gt;
&lt;h2&gt;Interpreting Transformations Using the Model-View Matrix&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;interpreting-transformations-using-the-model-view-matrix&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#interpreting-transformations-using-the-model-view-matrix&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;../assets/rotations_with_model_view_matrix.png&#34; alt=&#34;Rotation on the Model-View Matrix&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;p&gt;As we&amp;rsquo;ve just seen, understanding the rotation matrix (the $3 \times 3$ upper-left corner of the Model-View matrix) is simple: the first $3$ columns always tell us where the axis is.&lt;/p&gt;
&lt;h2&gt;Basic Camera Types&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;basic-camera-types&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#basic-camera-types&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;So far, we&amp;rsquo;ve learned how to generate rotations and translations in either world or camera coordinates. In both cases, however, we are always generating the rotations around the center of the world. This may be ideal when we&amp;rsquo;re orbiting around a 3D object. We will refer to this type of camera as an &lt;strong&gt;orbiting camera&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;If we are able to look left and right (rotations) and then move in the direction in which our
camera is pointing (translation), then this camera type can be designated as a &lt;strong&gt;first-person camera&lt;/strong&gt; and it is generally known as a &lt;strong&gt;tracking camera&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;When applying transformation the order of the operations affects the result. It is not the same to rotate around the origin and then translate away from it (orbiting camera), as compared to translating the origin and then rotating around it (tracking camera).&lt;/p&gt;
&lt;p&gt;With an orbiting camera, the camera will always look toward the center of the world.
Therefore, we will always use the z-axis to move to and from the object we are examining.
However, with a tracking camera, since the rotation occurs at the camera location, we can
end up looking to any position in the world. Thus, we need to know the direction in which the camera is pointing in world coordinates (camera axis).&lt;/p&gt;
&lt;h2&gt;The Camera Model&lt;span class=&#34;hx-absolute -hx-mt-20&#34; id=&#34;the-camera-model&#34;&gt;&lt;/span&gt;
    &lt;a href=&#34;#the-camera-model&#34; class=&#34;subheading-anchor&#34; aria-label=&#34;Permalink for this section&#34;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;Just like the Model-View matrix, the Camera matrix encodes information about the camera orientation. As we can see in the following diagram, the upper-left $3 \times 3$ matrix corresponds to the camera axes:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;../assets/camera_model.png&#34; alt=&#34;Camera Model&#34; loading=&#34;lazy&#34; /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The first column corresponds to the x-axis of the camera. We will call it &lt;code&gt;RightVector&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The second column is the y-axis of the camera. This will be &lt;code&gt;UpVector&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The third column determines the vector in which the camera can move back and forth. This is the z-axis of the camera and we will call it &lt;code&gt;CameraAxis&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Because the Camera matrix is the inverse of the Model-View matrix, the upper-left $3 \times 3$ rotation matrix contained in the Camera matrix gives us the orientation of the camera axes in world space. This means that we can tell the orientation of our camera in world space just by looking at the columns of this $3 \times 3$ rotation matrix.&lt;/p&gt;

      </description>
    </item>
    
  </channel>
</rss>
