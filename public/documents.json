[
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Robotics/UKF/ukf.html",
    "title": "Unscented Kalman Filter",
    "body": " index search search back unscented kalman filter contents numerical solution selecting less points to sample mean approximation covariance approximation general unscented transformation sigma points generation weight definition mean and covariance approximation it approximates a non-linear transformation of a probability distribution, as a gaussian distribution. assume that we have a probability distribution for a random variable vector defined as: \\begin{align} x \\sim \\mathcal{n}(\\overline{x}, \\sigma_x) \\end{align} given a non-linear transofrm that we want to apply to the distribution: \\begin{align} y = f(x) \\end{align} we want to obtain a gaussian approximation of the resulting transformed distribution: \\begin{align} y \\sim \\mathcal{n}(\\overline{y}, \\sigma_y) \\end{align} numerical solution generate \\(n\\) samples from the original distribution \\begin{align} x_i \\sim \\mathcal{n}(\\overline{x}, \\sigma_x) \\end{align} \\begin{align} i=1, \\cdots, n \\end{align} for each sample \\(x_i\\) apply the non-linear transformation to find the corresponding \\(y_i\\) \\begin{align} y_i = f(x_i) \\end{align} fit a gaussian to the transformed points \\begin{align} \\overline{y} = \\frac{1}{n}\\sum^n y_i \\end{align} \\begin{align} \\sigma_y = \\frac{1}{n} \\sum^n (y_i - \\overline{y}) (y_i - \\overline{y})^t \\end{align} selecting less points to sample let \\(x\\) be a \\(n \\times 1\\) random vector with mean \\(\\overline{x}\\) and covariance \\(p\\), that is \\(x \\sim \\mathcal{n}(\\overline{x}, p)\\) we choose \\(2n\\) sigma points as follows: \\begin{align} x^{(i)} = \\overline{x} + \\delta x^{(i)} \\end{align} \\begin{align} i=1, \\cdots, 2n \\end{align} where: \\begin{align} \\delta x^{(i)} = (\\sqrt{np})_i \\end{align} \\begin{align} i=1, \\cdots, n \\end{align} which means \\(\\delta x^{(i)}\\) is the i-th column of the covariance matrix multiplied by \\(\\sqrt{n}\\). for a \\(2\\times 1\\) state vector, this gives us the two following points: we do the same, but inversing, for the remaining \\(n\\) points: \\begin{align} \\delta x^{(n+i)} = -(\\sqrt{np})_i \\end{align} \\begin{align} i=1, \\cdots, n \\end{align} such that we obtain: from the following image we can see the \\(4\\) points we obtained seem to be a good approximation of the shape of the ellipse: so we can use these points to obtain the new ellipse which resulted from applying the transformation. mean approximation we apply the non-linear transformation to the sigma points: \\begin{align} y^{(i)} = h(x^{(i)}), i = 1, \\cdots, 2n \\end{align} such that we have the following situation: we obtain the weighted mean of the transformed sigma points: \\begin{align} \\overline{y} = \\sum_{i=1}^{2n} w^{(i)} y^{(i)} \\end{align} where \\(w^{(i)} = \\frac{1}{2n}\\). such that: \\begin{align} \\overline{y} = \\frac{1}{2n} \\sum_{i=1}^{2n} y^{(i)} \\end{align} and so, we obtain the following estimated mean: covariance approximation we apply this same methodology for the covariance, given the transformed points \\(y^{(i)}\\) we obtain the weighted covariance: \\begin{align} p_y = \\sum_{i=1}^{2n} w^{(i)} (y^{(i)} - \\overline{y})(y^{(i)} - \\overline{y})^t \\end{align} \\begin{align} = \\frac{1}{2n} \\sum_{i=1}^{2n}(y^{(i)} - \\overline{y})(y^{(i)} - \\overline{y})^t \\end{align} which given us the following estimated covariance: general unscented transformation we now show a general definition which allows for more accuracy: sigma points generation we generate \\(2n+1\\) instead of \\(2n\\) and we define \\(x^{(0)}\\) such that it equals the mean: \\begin{align} x^{(i)} = \\overline{x} + \\delta x^{(i)}, i=0, \\cdots, 2n \\end{align} \\begin{align} \\delta x^{(0)} = 0 \\end{align} \\begin{align} \\delta x^{(i)} = \\left(\\sqrt{(n+k)p}\\right)_i, i=1, \\cdots, n \\end{align} \\begin{align} \\delta x^{(n+i)} = -\\left(\\sqrt{(n+k)p}\\right)_i, i=1, \\cdots, n \\end{align} weight definition the weights are now defined as follows: \\begin{align} w^{(0)} = \\frac{k}{n+k} \\end{align} \\begin{align} w^{(i)} = \\frac{1}{2(n+k)} \\end{align} where \\(k=3-n\\) has shown to help improve accuracy. note that \\((n+k)\\neq 0\\) mean and covariance approximation finally we approximate the mean and the covariance of the transformed distribution the same way we did before: for the mean: \\begin{align} \\overline{y} = \\sum_{i=1}^{2n} w^{(i)} y^{(i)} \\end{align} for the covariance: \\begin{align} p_y = \\sum_{i=1}^{2n} w^{(i)} (y^{(i)} - \\overline{y})(y^{(i)} - \\overline{y})^t \\end{align} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Robotics/AIRobotics/ParticleFilters/Particle Filters.html",
    "title": "Particle Filters",
    "body": " index search search back particle filters contents properties introduction initial probability resampling motion algorithm measurement updates motion updates resampling example properties state space belief efficiency accuracy continuous multimodal   approximate introduction so, in a first instance, given a floor plan the robot has to perform global localization. that is, it does not know where it is, and it has to find out based on sensor measurements: the robot has range sensors (blue lines), which use sonar sensors (basically sound) to obtain the distance between the robot and the obstacles around it. it uses this sensors to determine a posterior distribution that models its position at a given time. each particle (dot) is a discrete guess whether the robot might be, and it holds the following information: x coordinate, y coordinate, and heading direction. then, the comprise of multiple of these guesses make up the representation for the posterior of the robot's location. so, initially the robot is completely uncertain as to where it is, which derives into a uniform distribution as to where it may be, and thus the particles are scattered all over the floor plan. however as time passes, the particle filter makes them survive according to how consistent these particles are compared to the sensor measurements: in summary, the particles guess where the robot might be moving and then the filter makes them \"survive\" (it does not discard them) using survival of the fittest. this latter statement means that those particles that are more consistent with the measurements are more likely to survive. initial probability at the start the robot only has the map of the room and no other knowledge, therefore there is equal probability that the robot is at any position in the map. hence, we create a set of \\(n\\) particles modeled after a uniform distribution. which means each particle is as likely to be chosen as any other. resampling at first, we have \\(n\\) particles scattered all over the map and most of them are wrong. so now, we can start removing some of the wrong guesses using measurements of the environment. and we do this by resampling \\(n\\) particles. this translates into, we choose \\(n\\) particles that represent the place we believe the robot is in. so, now the filter can go through each of our particles and determine what the measurement would be if our robot was in the position indicated by the particle. in other words, each particle has assigned an importance weight \\(w\\) that determines how likely the measurement \\(z\\) is given a concrete particle \\(p_i\\), (\\(p(z|p_i)\\)). so, given a total of \\(n\\) particles: \\begin{align} n \\begin{cases} p_1 & \\rightarrow w_1\\\\ p_2 & \\rightarrow w_2\\\\ \\vdots\\\\ p_n & \\rightarrow w_n\\\\ \\end{cases} \\end{align} let \\(w = \\sum_i w_i\\) be the sum of all the weights. we introduce a new variable \\(\\alpha\\) which represents the normalized weights: \\begin{align} n \\begin{cases} p_1 & \\rightarrow w_1 & \\rightarrow \\alpha_1 = \\frac{w_1}{w}\\\\ p_2 & \\rightarrow w_2 & \\rightarrow \\alpha_2 = \\frac{w_2}{w}\\\\ \\vdots\\\\ p_n & \\rightarrow w_n & \\rightarrow \\alpha_n = \\frac{w_n}{w}\\\\ \\end{cases} \\end{align} hence, \\(\\sum_i \\alpha_i = 1.0\\). so we have now defined a new probability distribution that describes more clearly the position of our robot because it takes into account our measurement. so, it's time for the resampling. we have to choose \\(n\\) particles from the overall set, where each particle \\(p_i\\) is chosen with probability \\(\\alpha_i\\): note we allow replacement, so we can draw multiple copies of the same particle \\(p_i\\). so what will happen is, the higher \\(\\alpha_i\\) the more likely it is that particle \\(p_i\\) is chosen multiple times, meanwhile the lower \\(\\alpha_i\\) is the more likely it is that it will not be chosen, and therefore simply removed from the set of particles. as you can see in the previous image, we have drawn three times \\(p_2\\), probably because the associated \\(\\alpha_2\\) was larger than the rest of the \\(\\alpha\\). therefore, the particles with a low importance weight will survive with a much lower rate than the ones with a higher importance weight. motion we also have to take into account that our particles cannot be static, but have to move with our robot. so whichever motion is applied to the robot should be applied to every single particle. once the motion is applied we obtain a measurement and perform resampling to choose those particles that are more likely to describe the real position of the robot. note that the motion will most probably contain noise, so we do not want to propagate the motion equally to each particle. what we would want is to add some gaussian noise to the particles to represent somewhat this uncertainty about the motion. algorithm measurement updates we compute the posterior over state distribution: \\begin{align} p(x|z) \\propto p(z|x)p(x) \\end{align} here: \\(p(x)\\) is the distribution over the set of particles. \\(p(z|x)\\) is the distribution that models the importance weights. and by resampling we obtain \\(p(x|z)\\), because we draw with probability equal to the importance weight a given particle. motion updates we compute the posterior over distribution one step later (after movement): \\begin{align} p(x^t) = \\sum p(x^t|x)p(x) \\end{align} where: \\(p(x)\\) is the distribution over the set of particles. and then, we sample from the sum. that is we generate a random particle \\(x^t\\) by applying the motion model \\(p(x^t|x)\\) to the particles \\(p(x)\\). resampling example suppose we have the following data: \\begin{align} n \\begin{cases} p_1 & \\rightarrow w_1 = 0.6 & \\rightarrow \\alpha_1 = \\frac{w_1}{w} = \\frac{0.6}{6.0} = 0.1\\\\ p_2 & \\rightarrow w_2 = 1.2 & \\rightarrow \\alpha_2 = \\frac{w_2}{w} = \\frac{1.2}{6.0} = 0.2\\\\ p_3 & \\rightarrow w_3 = 2.4 & \\rightarrow \\alpha_3 = \\frac{w_3}{w} = \\frac{2.4}{6.0} = 0.4\\\\ p_4 & \\rightarrow w_4 = 0.6 & \\rightarrow \\alpha_4 = \\frac{w_4}{w} = \\frac{0.6}{6.0} = 0.1\\\\ p_5 & \\rightarrow w_2 = 1.2 & \\rightarrow \\alpha_5 = \\frac{w_5}{w} = \\frac{1.2}{6.0} = 0.2\\\\ \\end{cases} \\end{align} then, the probability of never sampling \\(p_3\\) is given by the multiplication rule of probability: on the first draw: \\begin{align} p(\\bar{p_3}) = p(p_1) + p(p_2) + p(p_4) + p(p_5) = 0.6 \\end{align} because we allow for resampling, on the second draw: \\begin{align} 0.6 \\cdot p(\\bar{p_3}) = 0.6 \\cdot (p(p_1) + p(p_2) + p(p_4) + p(p_5)) = 0.6^2 \\end{align} thus, on the fifth and final draw: \\begin{align} 0.6^4 \\cdot p(\\bar{p_3}) = 0.6^4 \\cdot (p(p_1) + p(p_2) + p(p_4) + p(p_5)) = 0.6^5 = 0.0777 \\end{align} however, the probabily of never drawing \\(p_1\\) equals: \\begin{align} p(\\bar{p_1}) = 0.9 ^ 5 = 0.59 \\end{align} therefore, the particles with a low importance weight will survive with a much lower rate than the ones with a higher importance weight. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Robotics/AIRobotics/PIDControl/PIDControl.html",
    "title": "PID Control",
    "body": " index search search back pid control contents smoothing algorithm pid control p controller pd control systematic bias pid control twiddle up until now we have created paths that connect dots with straight lines. however this tend to become unnefficient, as you can smooth them to reduce the distance and also to represent the motion of an object is a more realistic way. smoothing algorithm initilize \\(y_i\\) to the non-smooth locations \\(x_i\\): \\(y_i = x_i\\) optimize two criteria: first minimize the distance between the non-smooth point and the smooth point \\begin{align} \\min_i (x_i - y_i)^2 \\end{align} then minimize the distance between two consecutive smooth points \\begin{align} \\min_i (y_i - y_{i+1})^2 \\end{align} to optimize both, we include a parameter \\(\\alpha\\), to minimize the weigthed sum: \\begin{align} \\min (x_i - y_i)^2 + \\alpha (y_i - y_{i+1})^2 \\end{align} we optimize both, because they are in conflict with each other: if we only optimize the first one, we obtain the same path as the original non-smoothed path if we only optimize the second one, we obtain no path pid control if we have a car that has a steering angle \\(\\alpha\\), how would we go about defining this parameter? p controller we set this angle proportional by some factor of \\(\\tau\\) to the crosstrack error. where the crosstrack error refers to the lateral error between the vehicle and the reference trajectory. thus: \\begin{align} \\alpha = \\tau cte \\end{align} note that with this approach we will eventually overshoot when reaching for the reference trajectory. that is because the car it not oriented the same as the trajectory, therefore it needs to reposition once it reaches the trajectory: pd control here the steering angle does no only take into account the \\(cte\\), but it also uses the derivative of cte. the latter will compute how much we are reducing the error in each moment \\(t\\), and use this value to counter steer this angle (reduce the angle): \\begin{align} \\alpha = - \\tau_p cte - \\tau \\frac{\\delta}{\\delta t} cte \\end{align} where: \\begin{align} \\frac{\\delta}{\\delta t} cte = \\frac{cte_t - cte_{t-1}}{\\delta t} \\end{align} systematic bias in real life there is usually some noise when it comes to the angle of the wheels, and we refer to that as systematic bias. for example the wheels might be deviated a certain angle without us knowing. pid control because of this systematic bias, the error with respect to the reference trajectory is very large. therefore if we sum it over time we obtain larger and larger values. so, if we sum this cte error weighted by a factor \\(\\tau_i\\), we can correct this error by counter steering: \\begin{align} \\alpha = - \\tau_p cte - \\tau_d \\frac{\\delta}{\\delta t} cte - \\tau_i \\sum cte \\end{align} where \\(\\sum cte\\) equals the sum of the \\(cte\\) error overtime. note: \\(- \\tau_p cte\\): represents the proportional error \\(- \\tau_d \\frac{\\delta}{\\delta t}\\): represents the differential error \\(- \\tau_i \\sum cte\\): represents the integral error twiddle we use twiddle to optimize a set of parameters. in our case what we do is optimize, that is minimize, the average cte. so, given a parameters vector \\(p = [0, 0, 0]\\) and a vector of potential changes \\(dp = [1, 1, 1]\\) we: execute run() which computes the \"optimal\" steering angle and moves the robot accordingly. it also stores this motion as a trajectory. this function will return a \"goodness\" metric, that will signify the cte. so, after executing run() we get the best error so far. we modify p to make our error smaller, to make this modification we use twiddle. the algorithm is as follows: # compute initial error best_error = run(p) # while the sum of the potential changes is bigger than a tolerance parameter while sum(dp) < tolerance: # iterate over every parameter for i in range(len(p)): # update the parameter value by the value of the corresponding potential change p[i] += dp[i] # compute the new error for this change err = run(p) # does this better the previous error? err < best_error: # make the change bigger dp[i] *= 1.1 # if the error is worse else: # we try updating the parameter by subtracting (by two because we added before) p[i] -= 2*dp[i] err = run(p) # does this better the previous error? err < best_error: # make the change bigger dp[i] *= 1.1 # if substracting does not make the error better else: # we decrease the change dp[i] *= 0.9 basically twiddle decreases/increases the parameters first a little bit, and for each time we make the error better we augment the increase or decrease. and we stop when there are no major changes being made to the parameters, that is sum(dp) < tolerance. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Robotics/AIRobotics/index.html",
    "title": "Artificial Intelligence Robotics",
    "body": " index search search back artificial intelligence robotics histogram localization kalman filters particle filters search pid control slam $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Robotics/AIRobotics/Search/Search.html",
    "title": "Search",
    "body": " index search search back search contents a algorithm dynamic programming the process of finding a path from a starting point to the goal location is called robot motion planning or simply planning. then given: map starting location goal location cost function the goal is to find the minimum cost path between the start and the goal. a* consider a square grid having many obstacles and we are given a starting cell and a target cell. we want to reach the target cell (if possible) from the starting cell as quickly as possible. what a* search algorithm does is that at each step it picks the node according to a value \\(f = g + h(x,y)\\), where \\(g\\) is the current cost and \\(h(x,y)\\) is the value of the heuristic function in cell \\((x,y)\\). that is h is the estimated movement cost to move from that given square on the grid to the final destination. this is often referred to as the heuristic, which is nothing but a kind of smart guess. algorithm 1. let openlist equal empty list of nodes 2. let closedlist equal empty list of nodes 3. put startnode on the openlist (leave it's f at zero) 4. while openlist is not empty 5. let currentnode equal the node with the least f value 6. remove currentnode from the openlist 7. add currentnode to the closedlist 8. if currentnode is the goal 9. you've found the exit! 10. let children of the currentnode equal the adjacent nodes 11. for each child in the children 12. if child is in the closedlist 13. continue to beginning of for loop 14. child.g = currentnode.g + distance b/w child and current 15. child.h = distance from child to end 16. child.f = child.g + child.h 17. if child.position is in the openlist's nodes positions 18. if child.g is higher than the openlist node's g 19. continue to beginning of for loop 20. add the child to the openlist dynamic programming given a grid and a goal position, dynammic programming gives you the optimal action for each cell. where the optimal action is to move to the direction that offers the lower distance to the goal. to compute this distance we calculate: \\begin{align} f(x,y) = g = min_{x',y'} f(x', y') + 1 \\end{align} that is, we obtain recursively the distance of each neighbour to the goal and we add one. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Robotics/AIRobotics/Localization/Localization.html",
    "title": "Histogram Localization",
    "body": " index search search back histogram localization contents probability given by belief probability after sense normalize the distribution exact motion theorem of total probability inexact motion entropy bayes rule motion using total probability summary belief sense move localization algorithm probability given by belief probability after sense exact motion inexact motion bayes rule motion using total probability summary localization algorithm probability given by belief suppose every place in the world is modeled after an uniform probability distribution, then every cell the robot has the same probability. probability after sense now suppose the robot is able to sense a color, and each cell has a different color assigned. let's assume the robot senses the color red, then the cells with this color assigned should have a higher probability. therefore we define two values, a hit value and a miss value. if the cell is red, then we multiply its probability by the hit value. if the cell is not red, then we multiply its probability by the miss value. note that the hit value is a big value, and the miss value is lower. thus the probability for miss cells is lower than the probability for hit cells. also, observe that a measurement refers to what the robot senses, that is, a green cell or a red cell. normalize the distribution now that we have altered the values of the probability distribution, it is likely that they do not sum up to one, which is a requirement to every probability function. therefore we need to normalize it. so what we would do is: compute the probabilities after the robot \"senses\" a measurement normalize these probabilities by dividing each probability by the total sum of all probabilities exact motion suppose we have a world made up of a grid with 5 cells with the following probabilities: [\\(\\frac{1}{3}\\)][\\(\\frac{1}{3}\\)][\\(\\frac{1}{9}\\)][\\(\\frac{1}{9}\\)][\\(\\frac{1}{3}\\)] we also know that with 100% probability the world moves to the right. theorem of total probability to compute the probability of each cell after the movement, we use the law of total probability that states: given events a and \\(b = \\{b_1, \\cdots, b_n\\}\\) events in a sample space where \\(b\\) is pairwise disjoint, then: \\begin{align} p(a) = \\sum_n p(a \\cap b_n) \\end{align} then, by the conditional probability formula: \\begin{align} p(a) = \\sum_n p(a|b_n)p(b_n) \\end{align} so to apply this theorem what we do is sum the probabilities of ending up in cell \\(j\\) when we come from cell \\(i\\), which is expressed symbolically: \\begin{align} p(x_{j}) = \\sum_{i=1}^5 p(x_{j}|x_{i}) \\cdot p(x_{i}) = 1 \\cdot p({x_j}_{\\{j=(i+1)\\}}) \\end{align} because we know: \\begin{align} p(x_j|x_i) = \\begin{cases} 1, & j = i + 1 \\\\ 0, & \\text{ in any other case} \\end{cases} \\end{align} inexact motion however what if \\(p(x_j|x_i) < 1\\)? suppose: \\(p(x_{i+2}|x_i) = 0.8\\): the robot moved 2 positions/units with \\(0.8\\) probability \\(p(x_{i+1}|x_i) = 0.1\\): the robot moved 1 positions/units with \\(0.1\\) probability \\(p(x_{i+3}|x_i) = 0.1\\): the robot moved 3 positions/units with \\(0.1\\) probability then for each \\(i\\): \\begin{align} p(x_{j}) = \\sum_{i=1}^5 p(x_{j}|x_{i}) \\cdot p(x_{i}) \\end{align} where: \\begin{align} p(x_{j}|x_{i}) = \\begin{cases} 0.8, & j = i + 2 \\\\ 0.1, & j = i + 1 \\\\ 0.1, & j = i + 3 \\\\ 0, & \\text{ otherwhise } \\end{cases} \\end{align} entropy the entropy will decrease after the measurement update (sense) step, and the entropy will increase after the movement step (move). in general, entropy represents the amount of uncertainty in a system. since the measurement update step decreases uncertainty, entropy will decrease. the movement step increases uncertainty, so entropy will increase after this step. the entropy formula for our case is the following: \\begin{align} entropy = \\sum_{i=1}^5(-p(x_i) \\cdot \\log(p(x_i))) \\end{align} bayes rule suppose: \\(x\\) represents the grid cell \\(z\\) represents the measurements then the bayes rule states: \\begin{align} p(x_i|z) = \\frac{p(z|x_i)p(x_i)}{p(z)} \\end{align} where: \\(p(x_i|z)\\) is called the posterior \\(p(z|x_i)\\) is called the likelihood \\(p(z)\\) is known as the evidence or marginal likelihood (that is, it marginalizes \\(z\\)). to compute \\(p(z)\\) we use the theorem of total probability: \\begin{align} p(z) = \\sum_{i=1}^n p(z|x_i)p(x_i) \\end{align} so, to compute \\(p(x_i|z)\\) we follow the steps: for each \\(x_i\\) compute the non-normalized posterior: \\(\\hat{p}(x_i|z) = p(z|x_i)p(x_i)\\) sum all non-normalized posteriors to obtain the evidence: \\(p(z) = \\sum_{i=1}^n \\hat{p}(x_i|z)\\) for each \\(x_i\\) normalize the posterior with the evidence: \\(p(x_i|z) = \\frac{\\hat{p}(x_i|z)}{p(z)}\\) motion using total probability let's say we are at time \\(t\\), and \\(i\\) determines the cell, then the motion is expressed probabilistically as follows: \\begin{align} p(x_i^t) = \\sum_{j} p(x_i|x_j)p(x_j^{t-1}) \\end{align} if we break down this formula: \\(p(x_i|x_j)\\) is the probability that we end up in the cell \\(x_i\\) given we come from the cell \\(x_j\\) \\(p(x_j^{t-1})\\) is the probability of being in cell \\(x_j\\) at the previous time \\(p(x_i^t)\\) is the probability of being in cell \\(x_i\\) at time \\(t\\) summary belief represents where are possible places the robot might be, that is each cell has an associated probability value sense also known as the measurement update function. for each cell we compute the probability that the robot is in that cell, given a measurement sensed by the robot in the moment \\(t\\) (\\(p(x_k|z)\\), where \\(x_k\\) is the cell and \\(z\\) is the measurement). therefore, for each cell in the world we multiply the previous probability value (given by belief) and the probability that the robot moved to the given cell. for example, to satisfy the probability function properties, we need to normalize it, so it sums up to one. move it is a convolution, for each possible location, after the motion, we reverse engineered the situation and guessed where the world might have come from. so what we do is we compute the probability of each cell using the total probability theorem, so given a cell \\(x_k\\), we compute: \\begin{align} p(x_k) = \\sum_{l}p(x_k|x_l)p(x_l) \\end{align} where \\(p(x_k|x_l)\\) is the probabily that the robot moved to cell \\(x_k\\) from cell \\(x_l\\). usually what we do is stablish a motion using a vector (i.e. \\((0,1) \\in \\mathbb{r}^2\\) to indicate the robot moved one unit up in the two dimensional vector space). for example, this probability may refer to how likely it is that the robot moved to the exact cell, how likely it is that the robot moved to a cell \"beyond\" the goal or how likely it is that the robot moved to a cell that lies \"before\" the goal. so if we have these three probabilities, for each cell we sum the probabilities of the robot being in that cell taking into account the three scenarions: if the robot moved to cell \\(x_k\\) from cell \\(x_l\\), and that cell was the goal, then it moved to that cell with probability \\(p_{exact}\\) and maybe the robot moved to cell \\(x_k\\) from cell \\(x_i\\), however the goal was \\(x_{k+1}\\), then it moved to that cell with probability probability \\(p_{undershoot}\\) maybe the robot moved to cell \\(x_k\\) from cell \\(x_j\\), however the goal was \\(x_{k-1}\\), then it moved to that cell with probability probability \\(p_{overshoot}\\) suppose now that then only cells in the world are mentioned: \\(x_k, x_l, x_i, x_j\\). then for \\(x_k\\) we update the belief as follows: \\begin{align} p(x_k) = p(x_l) * p_{exact} + p(x_i) * p_{undershoot} + p(x_j) * p_{overshoot} \\end{align} localization algorithm next we lay out an example of the localization algorithm implemented in \\(\\mathbb{r}^2\\): # the function localize takes the following arguments: # # colors: # 2d list, each entry either 'r' (for red cell) or 'g' (for green cell) # # measurements: # list of measurements taken by the robot, each entry either 'r' or 'g' # # motions: # list of actions taken by the robot, each entry of the form [dy,dx], # where dx refers to the change in the x-direction (positive meaning # movement to the right) and dy refers to the change in the y-direction # (positive meaning movement downward) # note: the *first* coordinate is change in y; the *second* coordinate is # change in x # # sensor_right: # float between 0 and 1, giving the probability that any given # measurement is correct; the probability that the measurement is # incorrect is 1-sensor_right # # p_move: # float between 0 and 1, giving the probability that any given movement # command takes place; the probability that the movement command fails # (and the robot remains still) is 1-p_move; the robot will not overshoot # its destination in this exercise # # the function should return (not just show or print) a 2d list (of the same # dimensions as colors) that gives the probabilities that the robot occupies # each cell in the world. # # compute the probabilities by assuming the robot initially has a uniform # probability of being in any cell. # # also assume that at each step, the robot: # 1) first makes a movement, # 2) then takes a measurement. # # motion: # [0,0] - stay # [0,1] - right # [0,-1] - left # [1,0] - down # [-1,0] - up # compute the probability of \"hit\" cell and the probability of a \"miss\" cell # # :param float z value sensed by the robot (i.e. 'r' or 'g') # :param float cell_measurement value in the cell (i.e. 'r' or 'g') # :param float sensor_right probability that what the robot sensed is correct # # if the value sensed and the value in the cell are equal hit = 1 and miss = 0 # :return [sensor_right, 0] # otherwhise # :return [0, (1-sensor_right)] def probability_hit_miss(z, cell_measurement, sensor_right): hit = (z == cell_measurement) return [hit * sensor_right, (1-hit) * (1-sensor_right)] # compute the probability of a cell after the measurement of the robot # # :param cell_prior probability stored in the cell before measurement # :param float z value sensed by the robot (i.e. 'r' or 'g') # :param float cell_measurement value in the cell (i.e. 'r' or 'g') # :param float sensor_right probability that what the robot sensed is correct # # if the value sensed and the value in the cell are equal hit = sensor_right, else miss = (1-sensor_right) # :return the probability before measurement multiplied by the probability that the measurement is correct for the # given cell def probability_cell_given_measurement(cell_prior, z, cell_measurement, sensor_right): [hit, miss] = probability_hit_miss(z, cell_measurement, sensor_right) return cell_prior * (hit + miss) # for each cell x_k compute the probability that the robot is in the cell x_k given a measurement z # # :param list world measurements in the world # :param list p current world probabilities # :param list z current measurement of the robot # :param float sensor_right probability that the robot's measurement is correct # # for each cell x_k, where k is the cell [i][j]: # compute unnormalized p(x_k|z) = p(z|x_k) * p(x_k) # where p(x_k) = p[i][k] and # p(z|x_k) is computed in probability_cell_given_measurement and equals: # - sensor_right, if measurement in x_k = z # - (1-sensor_right), if measurement in x_k != z # compute the sum over all p(x_k|z), this sum equals p(z). # obtain normalized p(x_k|z) by dividing each p(x_k|z) by p(z) # :return list q of cell probabilies after measurement update def sense(world, p, z, sensor_right): q=[] # obtain probabilities q = [[ probability_cell_given_measurement(p[i][j], z, world[i][j], sensor_right) for j in range(len(p[0]))] for i in range(len(p))] # sum all probabilities s = sum([sum(row) for row in q]) ## normalize q = [[q[i][j]/s for j in range(len(p[0]))] for i in range(len(p))] return q # obtain probabilities of each cell in the grid after the robot moves # # :param list p current world probabilities # :param list u description of the motion (i.e. [0,1] to move to the right) # :param float p_move probability of moving from one cell to another # # for each cell x_k: # p(x_k) = sum over l=1...m of p(x_k|x_l) * p(x_l) # where # - p(x_k|x_l) = p_move and p(x_l) = p[(i-y) % len(p)][(j-x) % len(p[0])] if the robot moves from cell l = [(i-y)][(j-x)] to cell k = [i][j] # - p(x_k|x_l) = (1- p_move) and p(x_l) = p[i][j] if the robot does not move from cell k = [i][j] # :return list q of cell probabilies after the robot moves def move(p, u, p_move): q = [] [y, x] = u q = [[p_move * p[(i-y) % len(p)][(j-x) % len(p[0])] + (1-p_move) * p[i][j] for j in range(len(p[0]))] for i in range(len(p))] return q # for each pair of motion-measurement, update the grid probabilities of probabilities that represents where the robot is in any given moment # # :param matrix colors grid of measurements # :param list measurements measurements sensed by the robot # :param list motions directions in which the robot moved at each moment (i.e. for [0,1] it moves to the right) # :param float sensor_right probability that the robot's measurement is correct # :param float p_move probability of moving from one cell to another # # :return list q of cell probabilies after finishing updating for every measurement-motion def localize(colors,measurements,motions,sensor_right,p_move): # initializes p to a uniform distribution over a grid of the same dimensions as colors pinit = 1.0 / float(len(colors)) / float(len(colors[0])) p = [[pinit for row in range(len(colors[0]))] for col in range(len(colors))] # update probabilities iteratively for k in range((len(measurements))): p=move(p, motions[k], p_move) p=sense(colors, p, measurements[k], sensor_right) return p so for example, for the following data: colors = [['r','g','g','r','r'], ['r','r','g','r','r'], ['r','r','g','g','r'], ['r','r','r','r','r']] measurements = ['g','g','g','g','g'] motions = [[0,0],[0,1],[1,0],[1,0],[0,1]] where: the robot does not move (\\([0,0]\\)) and senses a green cell 'g'. the robot moves down (\\([0,1]\\)) and senses a green cell 'g'. the robot moves right (\\([1,0]\\)) and senses a green cell 'g'. the robot moves right (\\([1,0]\\)) and senses a green cell 'g'. the robot moves down (\\([0,1]\\)) and senses a green cell 'g'. and the colors is the representation of the world. then, we apply the localization algorithm to obtain the probability distribution that the robot is in each cell: p = localize(colors,measurements,motions,sensor_right = 0.7, p_move = 0.8) show(p) note that the probabily that the robot sensed the measurement correctly (\\(p(z|x_i)\\)) is \\(0.7\\) and the probability that the robot moved to the cell given by the motion vector (\\(p(x_i|x_j)\\)) is \\(0.8\\). this outputs: [[0.01106,0.02464,0.06800,0.04472,0.02465], [0.00715,0.01017,0.08697,0.07988,0.00935], [0.00740,0.00894,0.11273,0.35351,0.04066], [0.00911,0.00715,0.01435,0.04313,0.03643]] where each element in the matrix is the probabily of a cell. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Robotics/AIRobotics/KalmanFilters/Examples.html",
    "title": "Examples",
    "body": " index search search back examples contents design kalman filters for 2d 4d example motion measurement code example design kalman filters for 2d to design a kalman filter in two dimensions (position, velocity) you need two things: a state transition function, which is usually a matrix \\(f\\): \\begin{align} \\begin{bmatrix} x \\\\ \\hat{x} \\\\ \\end{bmatrix} \\leftarrow f \\begin{bmatrix} x \\\\ \\hat{x} \\\\ \\end{bmatrix} \\end{align} a measurement function, represented by the matrix \\(h\\): \\begin{align} z \\leftarrow h \\begin{bmatrix} x \\\\ \\hat{x} \\\\ \\end{bmatrix} \\end{align} for example, suppose we update the location and the velocity as follows: \\begin{align} x' = x + \\hat{x} \\end{align} \\begin{align} \\hat{x}' = \\hat{x} \\end{align} then the transition function is represented as the following matrix: \\begin{align} f = \\begin{bmatrix} 1 & 1 \\\\ 0 & 1 \\\\ \\end{bmatrix} \\end{align} and for the measurement function, we only observe the location not the velocity, therefore: \\begin{align} h = \\begin{bmatrix} 1 & 0 \\\\ \\end{bmatrix} \\end{align} 4d example motion given a state \\((x, y, \\hat{x}, \\hat{y})\\), where \\((x, y)\\) is the position and \\((\\hat{x}, \\hat{y})\\) is the velocity.if in each iteration the motion update for the state is: \\begin{align} \\begin{matrix} x + dt\\cdot \\hat{x} \\\\ y + dt\\cdot \\hat{y} \\\\ \\hat{x} \\\\ \\hat{y} \\\\ \\end{matrix} \\end{align} so the position moves with time and the velocity does not change with time. then the state transition function is represented by the following matrix: \\begin{align} f = \\begin{bmatrix} 1 & 0 & dt & 0\\\\ 0 & 1 & 0 & dt\\\\ 0 & 0 & 1 & 0\\\\ 0 & 0 & 0 & 1\\\\ \\end{bmatrix} \\end{align} measurement and, because we can only measure the position the measurement update is of the form: \\begin{align} z \\leftarrow \\begin{bmatrix} x \\\\ y \\\\ \\end{bmatrix} \\leftarrow h \\cdot \\begin{bmatrix} x \\\\ y \\\\ \\hat{x} \\\\ \\hat{y} \\\\ \\end{bmatrix} \\end{align} therefore the measurement function is represented as follows: \\begin{align} h = \\begin{bmatrix} 1 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 0 \\\\ \\end{bmatrix} \\end{align} code example so for the following data, which deals with 4d data, that is we store a 2d location and a 2d velocity vector in the state. we will have to take this into account in the different update matrices and uncertainty matrix: # location measurements measurements = [[5., 10.], [6., 8.], [7., 6.], [8., 4.], [9., 2.], [10., 0.]] # initial location initial_xy = [4., 12.] dt = 0.1 x = matrix([[initial_xy[0]], [initial_xy[1]], [0.], [0.]]) # initial state (location and velocity) u = matrix([[0.], [0.], [0.], [0.]]) # external motion # initial uncertainty: 0 for positions x and y, 1000 for the two velocities # p = 0 0 0 0 # 0 0 0 0 # 0 0 1000 0 # 0 0 0 1000 p = matrix([[0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 1000., 0.], [0., 0., 0., 1000.]]) # next state function: generalize the 2d version to 4d # f = 1 0 0.1 0 # 0 1 0 0.1 # 0 0 1 0 # 0 0 0 1 # so, velocity vector (x', y') does not change, and the position vector (x, y) is updated according to the velocity and dt # f · x = x + 0.1x' # y + 0.1y' # x' # y' f = matrix([[1., 0., dt, 0], [0, 1., 0, dt], [0, 0, 1., 0], [0, 0, 0, 1.]]) # measurement function: reflect the fact that we observe x and y but not the two velocities # h = 1 0 0 0 # 0 1 0 0 # so, for the measurement we only take into account the position vector (x,y) and not the velocity # z = h · x = x # y h = matrix([[1., 0., 0., 0.], [0., 1., 0., 0.]]) # measurement uncertainty: use 2x2 matrix with 0.1 as main diagonal # r = 0.1 0 # 0 0.1 r = matrix([[.1, 0.], [0., .1]]) # 4d identity matrix # i = 1 0 0 0 # 0 1 0 0 # 0 0 1 0 # 0 0 0 1 i = matrix([[1., 0., 0., 0.], [0., 1., 0., 0.], [0., 0., 1., 0.], [0., 0., 0., 1.]]) and we execute the filter: filter(x, p) to obtain the following state \\(x\\) and uncertainty matrix \\(p\\): x= [9.999340731787717] [0.001318536424568617] [9.998901219646193] [-19.997802439292386] p= [0.03955609273706198, 0.0, 0.06592682122843721, 0.0] [0.0, 0.03955609273706198, 0.0, 0.06592682122843721] [0.06592682122843718, 0.0, 0.10987803538073201, 0.0] [0.0, 0.06592682122843718, 0.0, 0.10987803538073201] $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Robotics/AIRobotics/KalmanFilters/Kalman Filters.html",
    "title": "Kalman Filters",
    "body": " index search search back kalman filters contents markov model gaussian distribution measurement and motion motion step motion noise measurement step updating the mean updating the variance measurement noise states predicting velocity high dimensional spaces put everything together motion measurement iterative process algorithm prediction measurement update code this is a tracking technique. it is similar to the histogram localization we talked about previously, however there are some key differences: kalman filter maintains a continuous state (therefore uses a uni-modal distribution: probability density function only has one peak) histogram localization uses discrete state to represent the world (uses a multi-modal distribution: probability density function has multiple peaks) markov model in histogram localization we assigned a probability to each cell in the world: [\\(0.2\\)][\\(0.1\\)][\\(0.5\\)][\\(0.1\\)][\\(0.2\\)] what we did is we divided the continuous space into a finite number of cells, that approximates the posterior distribution (which is continuous: red line) by a histogram (blue bars) over the original distribution. however in kalman filters this distribution is given by a gaussian distribution. gaussian distribution a gaussian distribution is a continuous function which is described in \\(\\mathbb{r}\\) by the mean \\(\\mu\\) and the variance \\(\\sigma^2\\). the formula is the following: \\begin{align} f(x) = \\frac{1}{\\sqrt{2\\pi\\sigma^2}} \\exp^{-\\frac{1}{2}\\frac{(x-\\mu)}{\\sigma^2}} \\end{align} where \\(\\frac{1}{\\sqrt{2\\pi\\sigma^2}}\\) is a constant that normalizes \\(\\exp^{-\\frac{1}{2}\\frac{(x-\\mu)}{\\sigma^2}}\\) remark the bigger the covariance \\(\\sigma^2\\) the wider the distribution, which means we are less certain of the state. if it is narrow, that means we are confident about our location. measurement and motion like with localization kalman filters operate within a cycle, that is, it iterates like so: motion (or prediction): where we predict the position of the car based on data we know. to perform this prediction we sum the location distribution and the distribution that describes the motion. measurement (or measurement update/correction): where we combine the prediction with the measurement made by the sensors. to perform this update we multiply the motion prediction with the distribution that describes the measurement. this is illustrated in the following image: here the predicted state estimate corresponds to the motion step, and the measurement distribution corresponds to the measurement. the result of the product between the two eausl the optimal state estimate. motion step suppose, at moment \\(t\\), your location is represented as follows: where: the blue gaussian distribution represents your best guess (prediction) at where your are at \\(t\\), and is characterized by \\((\\mu, \\sigma^2)\\) the green gaussian distribution represents the motion of \\(\\nu\\) units, which has its own uncertainty, and is characterized by \\((\\nu, r^2)\\) the red gaussian distribution represents you location at time \\(t+1\\) after the motion where this last distribution equals the sum of the other two distributions and is characterized by: \\begin{align} \\hat{\\mu} = \\mu + \\nu \\end{align} \\begin{align} \\hat{\\sigma}^2 = \\sigma^2 + r^2 \\end{align} so, basically the mean is shifted \\(\\nu\\) units and the covariance is made larger by summing \\(\\sigma^2\\) and \\(r^2\\), as a result of summing the distributions. motion noise note that the movement may not be certain, that is why we introduce some gaussian noise. this noise is drawn from a normal distribution where the variance is given by a co-variance matrix \\(q\\) (this matrix describes the uncertainty for the initial state). we define this noise as follows: \\begin{align} u \\sim \\mathcal{n}(0, q) \\end{align} measurement step as we have already said, the update is the result of multiplying the prediction distribution (after motion step), which was characterized in the previous section, by the measurement distribution. this would mean \"creating\" a new distribution that models the robot's current state. we now show how the multiplication of two distributions is performed: updating the mean we are going to show how to the mean is computed when multiplying two distributions. suppose the prior distribution is as follows: where the covariance is very large, so we are very uncertain about a location. and we recieve a measurement of the form: which is much more certain about the location. then the mean will shift accordingly (green line): updating the variance we are going to show how to the variance is computed when multiplying two distributions. so, after multiplying the prior and the measurement shown previously, the resulting gaussian y more certain than both of the prior and the measurement gaussians. that is the covariance of this new gaussian is smaller, so the more measurements we have the more certain the are. why does this happen? well, given these two distributions: where the first distribution is characterized by \\((\\mu, \\sigma^2)\\) and the second distribution is characterized by \\((\\nu, r^2)\\). the product of the two is a distribution characterized by \\((\\hat{\\mu}, \\hat{\\sigma}^2)\\), computed as follows: \\begin{align} \\hat{\\mu} = \\frac{r^2\\mu + \\sigma^2\\nu}{r^2 + \\sigma^2} \\end{align} observe, because \\(\\sigma^2 >> r^2\\) in our example, then \\(\\hat{\\mu}\\) will be closer to the second distribution's mean \\(\\nu\\). also: \\begin{align} \\hat{\\sigma}^2 = \\frac{1}{\\frac{1}{r^2} + \\frac{1}{\\sigma^2}} = \\frac{\\sigma^2 r^2}{\\sigma^2 + r^2} \\end{align} thus, the updated covariance is not affected by the means and will always be smaller than \\(\\sigma^2\\) and \\(r^2\\). we illustrate this is the following image, where the updated distribution is the one drawn in blue: note that the wider distribution represents the prior, the measurement represents the likelihood and the updated distribution represents the posterior. measurement noise however, note that the measurement might also be noisy. so we again introduce gaussian noise \\(v\\) that is modeled after a normal distribution with known variance. that is \\(v \\sim \\mathcal{n}(0, r)\\). this indicates how much we trust the measurements provided by the sensors. this variable is called measurement noise covariance matrix states kalman filters are made up from what it's called states, and we differentiate two different kinds of states: observables (in our case the location) hidden (in our case the velocity, which i can never observe) these two types of states interact with each other in the sense that a sequence of observable variables gives us information about the hidden variables. thus we can estimate what these hidden variables are. applied to our case scenario, multiple observations of where we are, that is, our location, we can estimate how fast we are moving, that is, our velocity. predicting velocity given the following graph: where \\(\\hat{x}\\) represents the velocity and \\(x\\) represents the location. in this first instance, we represent the measurement at with an elongated gaussian because the measurement does not tell us anything about the velocity. however, if we now draw our predicition, given by our motion model which is represented by the red gaussian distribution, we obtain: suppose we take a new measurement (a second observation) represeted by the green normal distribution (remember, it tells us nothing about the velocity), it only gives us information about the location as the first observation did. then: multiply the prior (the red gaussian) and the measurement (the green gaussian) to obtain a really good estimate of an object's velocity and location (black distribution): so we were able to infer the velocity by only observing the location. high dimensional spaces up until now we have generally been operating in a one dimensional space, however if we were to work withing higher dimensional spaces we would need to make use of multivariate gaussians. so a multivariate gaussian in a d-dimensional space is characterized as follows: \\begin{align} \\mu = \\begin{bmatrix} \\mu_0 \\\\ \\vdots \\\\ \\mu_d \\\\ \\end{bmatrix}, \\sigma = \\begin{bmatrix} \\sigma_{11} & \\cdots & \\sigma_{1d}\\\\ \\vdots \\\\ \\sigma_{d1} & \\cdots & \\sigma_{dd}\\\\ \\end{bmatrix} \\end{align} also de density function is now, for \\(x \\in \\mathbb{r}^d\\): \\begin{align} f(x) = (2\\pi)^{-\\frac{d}{2}}|\\sigma|^{-\\frac{1}{2}} \\exp^{-\\frac{1}{2}(x - \\mu)^t\\sigma^{-1}(x-\\mu)} \\end{align} here are some examples of how the kalman filter works for spaces with higher dimension: put everything together motion at a given time \\(k-1\\), we have the following prediction: we use a motion model (in our case a gaussian that represents the movement) to update our prediction as follows: the motion model is described as follows: \\begin{align} x_k = f_{k-1}x_{k-1} + u_{k-1} \\end{align} where: \\(f_{k-1}\\) represents the transition function at time \\(k-1\\) \\(u_{k-1}\\) represents the noise at time \\(k-1\\) measurement then, we use the following observation model: we correct our prediction with this observation model as follows: the measurement model is described as follows: \\begin{align} y_k = h_k x_k + v_k \\end{align} where: \\(h_k\\) is the measurement function at time \\(k\\). this function maps the state into the observable state, that does not have to be the same (refer to states) \\(v_k\\) is the noise at time \\(k\\) iterative process first we make a prediction as to where the robot is at time \\(k\\): \\begin{align} \\check{x}_k = f_{k-1}x_{k-1} \\end{align} \\begin{align} \\check{p}_k = f_{k-1}\\hat{p}_{k-1}f_{k-1}^t + q_{k-1} \\end{align} then we compute the optimal gain \\(k\\) as follows: \\begin{align} k_k = \\check{p}_kh_k^t(h_k\\check{p}_kh^t+r_k)^{-1} \\end{align} this gain basically represents how much we trust our motion estimation versus our measurement estimation. finally we obtain the correction using the measurement model: shift the mean: \\begin{align} \\hat{x}_k = \\check{x}_k + k_k(y_k - h_k\\check{x}_k) \\end{align} where \\(y_k - h_k\\check{x}_k\\) represents the difference between the measurement and the prediction we made. lastly, we update the covariance of our motion model: update the variance: \\begin{align} \\hat{p}_k = (1-k_kh_k)\\check{p}_k \\end{align} algorithm so in the kalman filter cycle what we do is: first we perform the prediction and the correction or measurement update. more concretely: prediction we apply the same formulas we defined in motion model and iterative process to make a prediction: \\begin{align} x = fx + u \\end{align} \\begin{align} p = f \\cdot p \\cdot f^t \\end{align} measurement update now, for the correction: first we compute the intermediate \\(s\\) matrix, which equals the second part of the formula for \\(k\\), \\(h_k\\check{p}_kh^t+r_k\\): \\begin{align} s = h \\cdot p \\cdot h^t + r \\end{align} then we compute the kalman gain (as we defined in iterative process): \\begin{align} k = ph^ts^{-1} \\end{align} obtain difference between measurement (\\(z = y_k\\)) and our prediction \\(h \\cdot x = h_k\\check{x}_k\\) (note where \\(\\check{x}_k\\) comes from, \\(h\\) is usually a matrix that selects a concrete part of the kalman state like the position. see examples): \\begin{align} y = z - h \\cdot x \\end{align} finally obtain the correction: \\begin{align} x' = x + (k \\cdot y) \\end{align} \\begin{align} p' = (i- k\\cdot h) \\cdot p \\end{align} code the filter algorithm follows the same steps laid out in the previous section: def filter(x, p): for n in range(len(measurements)): # prediction x = (f * x) + u p = f * p * f.transpose() # measurement update z = matrix([measurements[n]]) y = z.transpose() - (h * x) s = h * p * h.transpose() + r k = p * h.transpose() * s.inverse() x = x + (k * y) p = (i - (k * h)) * p return x, p $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Robotics/AIRobotics/SLAM/SLAM.html",
    "title": "SLAM",
    "body": " index search search back slam contents graph slam constraint matrix noise how to create maps and localize a robot at the same time? for this we use a technique known as slam: simultaneous localization and mapping graph slam suppose we have a robot whose initial position is \\(x_0 = 0\\) and \\(y_0 = 0\\) at time \\(0\\), then at time \\(1\\) (because of how we mode our motion) the robot is at \\(x_1 = x_0 + 10\\) and \\(y_1 = y_0\\). however we know that our location is uncertain therefore the position at time \\(1\\) is really described by a gaussian distribution centered around \\(10\\) and with a given variance that signifies how certain we are about our position. so to express this with a gaussian, that we do is define a distribution whose pdf peaks when \\(x_1 = x_0 + 10\\) and \\(y_1 = y_0\\), therefore we would like to maximize both the following equations: \\begin{align} \\frac{1}{\\sqrt{2\\pi\\sigma^2}}\\exp{-\\frac{1}{2}\\frac{(x_1-x_0-10)^2}{\\sigma^2}} \\end{align} \\begin{align} \\frac{1}{\\sqrt{2\\pi\\sigma^2}}\\exp{-\\frac{1}{2}\\frac{(y_1 - y_0)^2}{\\sigma^2}} \\end{align} here if \\(x_1 = x_0 + 10\\), then \\(x_1 - x_0 - 10 = 0\\) and if \\(y_1 = y_0\\) ,then \\(y_1 - y_0 = 0\\). these conditions we define are called constraints, so what graph slam does is creating our probabilities defining a sequence of these constraints. suppose we have a robot that has followed the following path: where each \\(x_i\\) is a vector (usually a three dimensional vector) then graph slam defines the following constraints: initial position constraint: \\(x_0\\) relative motion constraints: \\((x-1 - x_0)\\), \\((x-2 - x_1)\\), \\((x-3 - x_2)\\) (indicated by the red lines). ideally these are the same as the robot motion (direction vector), however in reality it tends to bend to accommodate the map. relative measurement constraints: these are the segment between each position vector (not necessarily every position vector) and each landmark defined in the map, and are also captured by gaussian distributions. in our case \\(z_0, z_1, z_2, z_3\\), the lines colored in green. after we have collected these constraints, what the algorithm does is it relaxes the position vectors \\(x_i\\) to find the most likely configuration of robot path for the given landmarks (that is measurements of distance to the landmark). constraint matrix to define our constraints, suppose we have 3 position vectors \\(x_0, x_1, x_2\\) and two landmarks \\(l_0, l_1\\), then we define the following matrix: \\begin{align} \\begin{array}{c} \\begin{array} - & x_0 & x_1 & x_2 & l_0 & l_1 \\end{array}\\\\[5pt] \\begin{matrix} x_0 \\\\ x_1 \\\\ x_2 \\\\ l_0 \\\\ l_1 \\end{matrix}\\quad \\begin{bmatrix} 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\\\ 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\\\ 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\\\ 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\\\ 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\end{bmatrix} \\begin{bmatrix} 0.0 \\\\ 0.0 \\\\ 0.0 \\\\ 0.0 \\\\ 0.0 \\end{bmatrix}\\quad \\end{array} \\end{align} we denote this structure as follows: \\begin{align} \\omega = \\begin{bmatrix} 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\\\ 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\\\ 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\\\ 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\\\ 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\end{bmatrix} \\end{align} and: \\begin{align} \\xi = \\begin{bmatrix} 0.0 \\\\ 0.0 \\\\ 0.0 \\\\ 0.0 \\\\ 0.0 \\end{bmatrix} \\end{align} suppose \\(x_0\\) moves to \\(x_1\\) by moving \\(5\\) units to the right, that is \\(x_1 = x_0 + 5\\), then we define this constrain in the matrix as follows: \\begin{align} \\begin{array}{c} \\begin{array} - & x_0 & x_1 & x_2 & l_0 & l_1 \\end{array}\\\\[5pt] \\begin{matrix} x_0 \\\\ x_1 \\\\ x_2 \\\\ l_0 \\\\ l_1 \\end{matrix}\\quad \\begin{bmatrix} 1.0 & -1.0 & 0.0 & 0.0 & 0.0 \\\\ -1.0 & 1.0 & 0.0 & 0.0 & 0.0 \\\\ 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\\\ 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\\\ 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\end{bmatrix} \\begin{bmatrix} -5.0 \\\\ 5.0 \\\\ 0.0 \\\\ 0.0 \\\\ 0.0 \\end{bmatrix}\\quad \\end{array} \\end{align} because given the initial constraint \\(x_1 = x_0 + 5\\), if we move around the \\(x_i\\) we get: \\begin{align} x_0 - x_1 = -5 \\end{align} \\begin{align} x_1 - x_0 = 5 \\end{align} now we add another constraint \\(x2 = x_1 - 4\\), therefore: \\begin{align} x_2 - x_1 = -4 \\end{align} \\begin{align} x_1 - x_2 = 4 \\end{align} so the constraint matrix is updated to: \\begin{align} \\begin{array}{c} \\begin{array} - & x_0 & x_1 & x_2 & l_0 & l_1 \\end{array}\\\\[5pt] \\begin{matrix} x_0 \\\\ x_1 \\\\ x_2 \\\\ l_0 \\\\ l_1 \\end{matrix}\\quad \\begin{bmatrix} 1.0 & -1.0 & 0.0 & 0.0 & 0.0 \\\\ -1.0 & 2.0 & -1.0 & 0.0 & 0.0 \\\\ 0.0 & -1.0 & 1.0 & 0.0 & 0.0 \\\\ 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\\\ 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\end{bmatrix} \\begin{bmatrix} -5.0 \\\\ 9.0 \\\\ -4.0 \\\\ 0.0 \\\\ 0.0 \\end{bmatrix}\\quad \\end{array} \\end{align} we add a relative measurement constraint like \\(l_0 - x_1 = 9\\), therefore: \\begin{align} l_0 - x_1 = 9 \\end{align} \\begin{align} x_1 - l_0 = -9 \\end{align} so the constraint matrix is updated to: \\begin{align} \\begin{array}{c} \\begin{array} - & x_0 & x_1 & x_2 & l_0 & l_1 \\end{array}\\\\[5pt] \\begin{matrix} x_0 \\\\ x_1 \\\\ x_2 \\\\ l_0 \\\\ l_1 \\end{matrix}\\quad \\begin{bmatrix} 1.0 & -1.0 & 0.0 & 0.0 & 0.0 \\\\ -1.0 & 3.0 & -1.0 & -1.0 & 0.0 \\\\ 0.0 & -1.0 & 1.0 & 0.0 & 0.0 \\\\ 0.0 & -1.0 & 0.0 & 1.0 & 0.0 \\\\ 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\end{bmatrix} \\begin{bmatrix} -5.0 \\\\ 0.0 \\\\ -4.0 \\\\ 9.0 \\\\ 0.0 \\end{bmatrix}\\quad \\end{array} \\end{align} note that whenever we add a constraint to two parameters, let's say \\(x_1\\) and \\(x_2\\), we sum one to the diagonal element of the matrix corresponding to \\(x_1\\) and \\(x_2\\). noise given the following motion: we know that the localization of our robot is not an exact value, but is is modeled after a gaussian distribution, so \\(x_1 \\sim \\mathcal{n}(\\mu_{x_1}, \\sigma_{x_1})\\) and \\(x_2 \\sim \\mathcal{n}(\\mu_{x_2}, \\sigma_{x_2})\\). suppose \\(\\sigma_{x_1} = \\sigma_{x_2}\\). then we want to maximize the expected value, which is given by the expressions: \\begin{align} \\frac{1}{\\sqrt{2\\pi\\sigma^2}}\\exp{-\\frac{1}{2}\\frac{(x_1-x_0-10)^2}{\\sigma^2}} \\end{align} \\begin{align} \\frac{1}{\\sqrt{2\\pi\\sigma^2}}\\exp{-\\frac{1}{2}\\frac{(x_2 - x_1 -5)^2}{\\sigma^2}} \\end{align} to maximize both expressions means to maximize their product: \\begin{align} \\max_{x_0, x_1, x_2} \\frac{1}{\\sqrt{2\\pi\\sigma^2}}\\exp{-\\frac{1}{2}\\frac{(x_1-x_0-10)^2}{\\sigma^2}} \\cdot \\frac{1}{\\sqrt{2\\pi\\sigma^2}}\\exp{-\\frac{1}{2}\\frac{(x_2 - x_1 -5)^2}{\\sigma^2}} \\end{align} we also know that constants are irrelevant during maximization: \\begin{align} \\max_{x_0, x_1, x_2} \\exp{-\\frac{1}{2}\\frac{(x_1-x_0-10)^2}{\\sigma^2}} \\cdot \\exp{-\\frac{1}{2}\\frac{(x_2 - x_1 -5)^2}{\\sigma^2}} \\end{align} this maximization is equivalent to the maximization of its logarithm: \\begin{align} \\max_{x_0, x_1, x_2} \\log \\left(\\exp{-\\frac{1}{2}\\frac{(x_1-x_0-10)^2}{\\sigma^2}} \\cdot \\exp{-\\frac{1}{2}\\frac{(x_2 - x_1 -5)^2}{\\sigma^2}}\\right) \\end{align} because the logarithm of a product equal the sum of logarithms: \\begin{align} \\max_{x_0, x_1, x_2} \\left(\\log \\exp{-\\frac{1}{2}\\frac{(x_1-x_0-10)^2}{\\sigma^2}}\\right) + \\left(\\log \\exp{-\\frac{1}{2}\\frac{(x_2 - x_1 -5)^2}{\\sigma^2}}\\right) \\end{align} given \\(\\log \\exp (x) = x\\): \\begin{align} \\max_{x_0, x_1, x_2} \\left(-\\frac{1}{2}\\frac{(x_1-x_0-10)^2}{\\sigma^2}\\right) + \\left(-\\frac{1}{2}\\frac{(x_2 - x_1 -50)^2}{\\sigma^2}\\right) \\end{align} again, constants are irrelevant: \\begin{align} \\max_{x_0, x_1, x_2} \\left(\\frac{(x_1-x_0-10)^2}{\\sigma^2}\\right) + \\left(\\frac{(x_2 - x_1 -5)^2}{\\sigma^2}\\right) \\end{align} so, we end up with equations of the form: \\begin{align} \\frac{1}{\\sigma} x_1 - \\frac{1}{\\sigma} x_0 = \\frac{10}{\\sigma} \\end{align} where now \\(\\sigma\\) symbolizes how confident you are in your location/measurement. usually we define a \\(\\sigma\\) for the location and another \\(\\sigma_{measurement}\\) for the measurement (distance to the landmark). $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Robotics/OnlineTrainingMobileRobotics/Models/Motion Model.html",
    "title": "Motion Model",
    "body": " index search search back motion model contents introduction recursive bayes filter typical motion models reasons for motion errors of wheeled robots odometry motion model introduction the motion of the system will always contain uncertainty, because it does not move perfectly with the command it is given. for example, suppose the robot follows the path illustrated in the next image: however the internal estimate of the system yields the following result: showing that it has a tendency to drift to the right. recursive bayes filter as you may recall from bayes filter our belief at time \\(t\\) was defined as follows: \\[ bel(x_t) = \\eta \\cdot p(z_t | x_t) \\cdot \\int p(x_t | x_{t-1}, u_{1:t}) \\cdot bel(x_{t-1}) dx_{t-1} \\] and we said we used our motion model to estimate the next state of the system \\(\\overline{x_t}\\): \\[ bel(\\overline{x}_t) = \\int p(x_t | x_{t-1}, u_{1:t}) \\cdot bel(x_{t-1}) dx_{t-1} \\] what we are doing here is marginilizing \\(x_t\\) so that we know the probability of being at state \\(x_t\\) given previous states \\(x_{t-1}\\) and control command \\(u_t\\). our motion model specifies a posterior probability, that asks what is the probability of the state being \\(x_t\\) given we were at state \\(x_{t-1}\\) and carried the command \\(u_t\\). typical motion models odometry-based models: we use the measurements (odometry) of the robot about how it moved as a command velocity-based models: we simply tell the system to move at a given velocity. reasons for motion errors of wheeled robots some errors that cause wrong movement estimations are the following: for the three different causes there are physical factors that make our robot move differently that what we expect it to for the given control command. odometry motion model suppose a motion takes place, where the initial point is described as \\((\\overline{x}, \\overline{y}, \\overline{\\theta})\\) and the final point is \\((\\overline{x}', \\overline{y}', \\overline{\\theta}')\\) our odometry information is given by \\(u = (\\delta_{rot1}, \\delta_{trans}, \\delta_{rot2})\\), where \\(\\delta_trans\\) is the distance between the two points, \\(\\delta_{rot1}\\) is the rotation on the first point and \\(\\delta_{rot2}\\) is the rotation on the second point. all of them are defined as follows: \\[ \\delta_{trans} = \\sqrt{(\\overline{x}' - \\overline{x})^2 + (\\overline{y}' - \\overline{y})^2} \\] \\[ \\delta_{rot1} = atan2(\\overline{y}' - \\overline{y}, \\overline{x}' - \\overline{x}) - \\overline{\\theta} \\] \\[ \\delta_{rot2} = \\overline{\\theta}' - \\overline{\\theta} - \\delta_{rot1} \\] each part is illustrated in the following image: $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Robotics/OnlineTrainingMobileRobotics/OccpancyGridMaps/Occpancy Grid Maps.html",
    "title": "Occupancy Grid Maps",
    "body": " index search search back occupancy grid maps contents inverse sensor model for laser range finders introduction features vs volumetric maps description of the mapping task grid maps assumptions occupancy probability notation joint distribution estimating a map from data static state binary bayes filter odds ratio log odds notation algorithm inverse sensor model for laser range finders example introduction description of the mapping task grid maps assumptions occupancy probability joint distribution estimating a map from data static state binary bayes filter odds ratio log odds ration algorithm inverse sensor model for laser range finders introduction occupancy grid maps store information about the environment regarding which parts of the map are occupied and which are free. features vs volumetric maps feature map representations store where on the environment certain points or landmarks lay that the systems uses in order to estimate where it is. volumetric maps are most typically used to store free space. description of the mapping task the goal to obtain a map of a given environment is to compute the most likely map given the sensor data: \\[ m^* = \\arg \\max_m p(m|u_1,z_1, \\cdots, u_t,z_t) \\] however, we will simplify this problem by assuming we already know the poses for certain, thus we swap the control commands \\(u_t\\) for poses \\(x_t\\): \\[ m^* = \\arg \\max_m p(m|x_1,z_1, \\cdots, x_t,z_t) \\] grid maps grid maps discretize the environment by dividing it into a finite number of cells, which encode information about its occupation. that is, a cell is either free or occupied. grids are rigid structures, where cells are distributed uniformly along the grid and represent a definite space. generally we describe cells as pixels. assumptions for each cell, the area corresponding to the cell are completely free or occupied. every cell can be described with a binary random variable that models the occupancy: the world is static. the cells are independent of each other. which means: if i know the occupancy state of a given cell, it does not help me estimate the occupancy state of another. occupancy probability as we have said, each cell is a binary random variable that models the occupancy, that is: if we are certain a cell \\(m_i\\) is occupied: \\(p(m_i) = 1\\) if we are certain a cell \\(m_i\\) is free: \\(p(m_i) = 0\\) if we have no knowledge about the cell \\(m_i\\): \\(p(m_i) = 0.5\\) notation the probability of a cell \\(m_i\\) being occupied is expressed as follows: \\[ p(m_i = occ) = p_{occ}(m_i) = p(m_i) \\] the probability of it being free is given by: \\[ p(m_i = free) = p_{free}(m_i) = 1- p_{occ}(m_i) = p(\\neg m_i) \\] also, the shading in the map tells us how certain we are about \\(p(m_i)\\), that is the more intense the shade the higher the probability. joint distribution the map is described by a probability distribution defined as the joint belief of each cell in the map: \\[ p(m) = p(m_1, m_2, \\cdots, m_n) \\] to simplify this distribution we exploit one of the assumptions made before, that said cells were independent of each other, thus: \\[ p(m) = \\prod_i p(m_i) \\] estimating a map from data our goal is to estimate the map given the sensor data \\(z_{1:t}\\) and the poses \\(x_{1:t}\\), that is: \\[ p(m | z_{1:t}, x_{1:t}) = \\prod_i p(m_i|z_{1:t}, x_{1:t}) \\] in order to do this we use a variant of the bayes filter called binary bayes filter that is optimized for binary random variables (\\(m_i\\)). static state binary bayes filter so, for each cell in the environment \\(m_i\\) we compute: \\[ p(m_i|z_{1:t}, x_{1:t}) \\] we apply the bayes rule to swap \\(m_i\\) for \\(z_t\\), therefore: \\[ p(m_i|z_{1:t}, x_{1:t}) = \\frac{p(z_t|m_i, z_{1:t-1}, x_{1:t})p(m_i, z_{1:t-1}, x_{1:t})}{p(z_t | z_{1:t-1}, x_{1:t})} \\] we apply markov's assumption and assume independence between \\(z_t\\) and the previous observations \\(z_{1:t-1}\\) and poses \\(x_{1:t-1}\\), therefore: \\[ p(m_i|z_{1:t}, x_{1:t}) = \\frac{p(z_t|m_i, x_t)p(m_i, z_{1:t-1}, x_{1:t})}{p(z_t | z_{1:t-1}, x_{1:t})} \\] we also make use of the markov's assumption to discard future poses when we the most up to date observation is of \\(t-1\\): \\[ p(m_i|z_{1:t}, x_{1:t}) = \\frac{p(z_t|m_i, x_t)p(m_i, z_{1:t-1}, x_{1:t-1})}{p(z_t | z_{1:t-1}, x_{1:t})} \\] we apply bayes rule again over \\(p(z_t|m_i, x_t)\\) to swap \\(z_t\\) and \\(m_i\\) again: \\[ p(z_t|m_i, x_t) = \\frac{p(m_i|z_t, x_t) p(z_t|x_t)}{p(m_i|x_t)} \\] we plug this into the previous expression: \\[ p(m_i|z_{1:t}, x_{1:t}) = \\frac{p(m_i|z_t, x_t) p(z_t|x_t) p(m_i, z_{1:t-1}, x_{1:t-1})}{p(m_i|x_t) p(z_t | z_{1:t-1}, x_{1:t})} \\] we assume that \\(p(mi|x_t) \\approx p(mi)\\), because knowing for certain the current pose tells us nothing about the state of the cell: \\[ p(m_i|z_{1:t}, x_{1:t}) = \\frac{p(m_i|z_t, x_t) p(z_t|x_t) p(m_i, z_{1:t-1}, x_{1:t-1})}{p(m_i) p(z_t | z_{1:t-1}, x_{1:t})} \\] we compute this same derivation for the complement of \\(m_i\\): \\[ p(\\neg m_i|z_{1:t}, x_{1:t}) = \\frac{p(\\neg m_i|z_t, x_t) p(z_t|x_t) p(\\neg m_i, z_{1:t-1}, x_{1:t-1})}{p(\\neg m_i) p(z_t | z_{1:t-1}, x_{1:t})} \\] what we are going to do is compute the ratio between these two expressions: \\[ \\frac{p(m_i|z_{1:t}, x_{1:t})}{p(\\neg m_i|z_{1:t}, x_{1:t})} = \\frac{\\frac{p(m_i|z_t, x_t) p(z_t|x_t) p(m_i, z_{1:t-1}, x_{1:t-1})}{p(m_i) p(z_t | z_{1:t-1}, x_{1:t})}}{\\frac{p(\\neg m_i|z_t, x_t) p(z_t|x_t) p(\\neg m_i, z_{1:t-1}, x_{1:t-1})}{p(\\neg m_i) p(z_t | z_{1:t-1}, x_{1:t})}} \\] now, all of the terms that do not depend on \\(m_i\\) can be discarded: \\(p(z_t|x_t)\\) and \\(p(z_t | z_{1:t-1}, x_{1:t})\\), then \\[ \\frac{p(m_i|z_{1:t}, x_{1:t})}{p(\\neg m_i|z_{1:t}, x_{1:t})} = \\frac{\\frac{p(m_i|z_t, x_t)p(m_i, z_{1:t-1}, x_{1:t-1})}{p(m_i)}}{\\frac{p(\\neg m_i|z_t, x_t) p(\\neg m_i, z_{1:t-1}, x_{1:t-1})}{p(\\neg m_i)}} \\] we reorganize the expression: \\[ \\frac{p(m_i|z_{1:t}, x_{1:t})}{p(\\neg m_i|z_{1:t}, x_{1:t})} = \\frac{p(m_i|z_t, x_t)p(m_i, z_{1:t-1}, x_{1:t-1})p(\\neg m_i)}{p(\\neg m_i|z_t, x_t) p(\\neg m_i, z_{1:t-1}, x_{1:t-1})p(m_i)} \\] \\[ \\frac{p(m_i|z_{1:t}, x_{1:t})}{p(\\neg m_i|z_{1:t}, x_{1:t})} = \\frac{p(m_i|z_t, x_t)}{p(\\neg m_i|z_t, x_t)} \\frac{p(m_i, z_{1:t-1}, x_{1:t-1})}{p(\\neg m_i, z_{1:t-1}, x_{1:t-1})} \\frac{p(\\neg m_i)}{ p(m_i)} \\] we express \\(\\neg m_i\\) in terms of \\(m_i\\): \\[ \\frac{p(m_i|z_{1:t}, x_{1:t})}{1-p(m_i|z_{1:t}, x_{1:t})} = \\frac{p(m_i|z_t, x_t)}{ 1- p(m_i|z_t, x_t)} \\frac{p(m_i, z_{1:t-1}, x_{1:t-1})}{1-p(m_i, z_{1:t-1}, x_{1:t-1})} \\frac{1-p(m_i)}{ p(m_i)} \\] note that now we have three expressions: the first one uses the observation \\(z_t\\) the second one is a recursive term the third one describes our prior knowledge about the state of the cell without any other information about the environment. odds ratio what we do now is turn this ratio called odds ratio into the probability as follows: \\[ odds(x) = \\frac{p(x)}{1-p(x)} \\] we multiply by \\(1-p(x)\\) in both sides. \\[ odds(x)(1-p(x)) = p(x) \\] we expand the left hand side expression: \\[ odds(x)-odds(x)p(x) = p(x) \\] we add \\(odds(x)p(x)\\) to both sides: \\[ odds(x) = p(x) + odds(x)p(x) \\] we extract \\(p(x)\\) as a common factor on the right hand side: \\[ odds(x) = p(x) (1 + odds(x)) \\] we divide by \\((1 + odds(x))\\) on both sides: \\[ \\frac{odds(x)}{(1 + odds(x))} = p(x) \\] and finally: \\[ p(x) = \\frac{1}{\\left(1 + \\frac{1}{odds(x)} \\right)} \\] so by using: \\[ p(x) = [1 + odds(x)^{-1}]^{-1} \\] in our update rule: \\[ p(m_i | z_{1:t}, x_{1:t}) = \\left[1 + (\\frac{p(m_i|z_{1:t}, x_{1:t})}{1-p(m_i|z_{1:t}, x_{1:t})})^{-1}\\right]^{-1} \\] \\[ p(m_i | z_{1:t}, x_{1:t}) = \\left[1 + \\frac{1-p(m_i|z_{1:t}, x_{1:t})}{p(m_i|z_{1:t}, x_{1:t})}\\right]^{-1} \\] because: \\[ \\frac{p(m_i|z_{1:t}, x_{1:t})}{1-p(m_i|z_{1:t}, x_{1:t})} = \\frac{p(m_i|z_t, x_t)}{ 1- p(m_i|z_t, x_t)} \\frac{p(m_i, z_{1:t-1}, x_{1:t-1})}{1-p(m_i, z_{1:t-1}, x_{1:t-1})} \\frac{1-p(m_i)}{ p(m_i)} \\] the inverse equals: \\[ \\frac{1-p(m_i|z_{1:t}, x_{1:t})}{p(m_i|z_{1:t}, x_{1:t})} = \\frac{ 1- p(m_i|z_t, x_t)}{p(m_i|z_t, x_t)} \\frac{1-p(m_i, z_{1:t-1}, x_{1:t-1})}{p(m_i, z_{1:t-1}, x_{1:t-1})} \\frac{ p(m_i)}{1-p(m_i)} \\] therefore: \\[ p(m_i | z_{1:t}, x_{1:t}) = \\left[1 + \\frac{ 1- p(m_i|z_t, x_t)}{p(m_i|z_t, x_t)} \\frac{1-p(m_i, z_{1:t-1}, x_{1:t-1})}{p(m_i, z_{1:t-1}, x_{1:t-1})} \\frac{ p(m_i)}{1-p(m_i)}\\right]^{-1} \\] which means, we can obtain information about the state of the \\(m_i\\) grid cell given the observation and the positions. log odds notation to make the computation more efficient we are going to take the log of this expression. the notation will be the following: \\[ l(m_i | z_{1:t}, x_{1:t}) = \\log \\left(\\frac{1-p(m_i|z_{1:t}, x_{1:t})}{p(m_i|z_{1:t}, x_{1:t})}\\right) \\] note that we can map from the log space to the probability space and vice versa as follows: \\[ l(x) = \\log \\frac{p(x)}{1-p(x)} \\] \\[ p(x) = 1- \\frac{1}{1 + \\exp(l(x))} \\] given this facts, we can turn the aforementioned product into a sum, because the log of the product of two terms equal the sum of the log of each term. \\[ l(m_i|z_{1:t}, x_{1:t}) = l(m_i|z_t,x_t) + l(m_i|z_{1:t-1}, x_{1:t-1}) - l(m_i) \\] where: \\(l(m_i|z_t,x_t)\\) is the inverse sensor model, which contains information about what we sensed. \\(l(m_i|z_{1:t-1}, x_{1:t-1})\\) is the recursive term, that is the state of cell on the previous iteration. \\(l(m_i)\\) is the prior. in short: \\[ l_{t,i} = inv\\_sensor\\_model(m_i, x_t, z_t) + l_{t-1, i} - l_0 \\] algorithm as we can see in the algorithm what we do is, given an observation \\(z_t\\) we go through each cell, and if the cell is close to the area where the observation took place then we update the state of the cell taking into account the sensor information. else we just propagate the previous state into the current state: inverse sensor model for laser range finders on the following graph we show the way we update the occupancy probability of the cells. here, the x axis represent several cells and the y axis represents the occupancy probability. at cell \\(n\\) our scanner detects an obstacle at time \\(t\\), this corresponds to the observation \\(z_{t,n}\\). therefore: the probability of cells prior to cell \\(n\\) of being occupied is low, because we were able to shot a laser through them without encountering no obstacle the probability of the n-th cell of being occupied is high, because it is the place where we found the obstacle. the probability of cells after \\(n\\) of bain occupied is unknown because we cannot see after the laser. a similar idea could be applied to sonar range sensor, which measure an area instead of a line: however the graph is a bit different, we now take into account that the sensor might not be completely reliable, therefore when the sonar detects an obstacle at a given distance we spread the probability of being occupied over adjacent cells/distances. example the idea is to add sensor information to a current \"map\" to increase the certainty of the state of each cell: $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Robotics/OnlineTrainingMobileRobotics/index.html",
    "title": "Online Training: Mobile Robotics",
    "body": " index search search back online training: mobile robotics source: online training: mobile robotics by cyrill stachniss bayes filter occpancy grid maps motion model observation model kalman filter extended kalman filter particle filter markov decision processes slam graph-based slam graph-based slam with landmarks $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Robotics/OnlineTrainingMobileRobotics/KalmanFilter/Extended Kalman Filter.html",
    "title": "Extended Kalman Filter",
    "body": " index search search back extended kalman filter contents introduction local linearization jacobian error under local linearization linearized motion model linearized observation model algorithm kalman gain localization example introduction what happens if we are dealing with non-linear dynamic systems, such that we do not use our linear models anymore: \\begin{align} x_t = a_tx_{t-1} + b_tu_t + \\epsilon_t \\end{align} \\begin{align} z_t = c_t x_t + \\delta_t \\end{align} but we introduce new functions that need not be linear: \\begin{align} x_t = g(u_t, x_{t-1}) + \\epsilon_t \\end{align} \\begin{align} z_t = h(x_t) + \\delta_t \\end{align} before, when we transformed our belief (a gaussian) with a linear transformation, something like the following happened: where the distribution of the upper left is the result of transforming the distribution of the bottom by applying the linear function on the upper right. however, if we try to do this same thing with a non-linear transformation, we could end up with something like this: so, the result of the transformation is clearly no a gaussian. which means, the kalman filter is not applicable anymore. to prevent this problem we are going to use local linearization. local linearization in order to perform local linearization what we do is approximate the non-linear functions \\(g\\) and \\(h\\) by the means of the taylor expansion. thus we re-define our non-linear functions as follows: the linearization for prediction step consists of linearizing around our previous state \\(x_{t-1} = (\\mu_{t-1}, \\sigma_{t-1})\\)and is described as follows: \\begin{align} g(u_t, x_{t-1}) \\approx g(u_t, \\mu_{t-1}) + \\frac{\\delta g(u_t, \\mu_{t-1})}{\\delta x_{t-1}}(x_{t-1} - \\mu_{t-1}) \\end{align} \\(g(u_t, \\mu_{t-1})\\) is the value of our non-linear model at the linearization point \\(\\mu_{t-1}\\), which corresponds to our previous belief. \\(g_t = \\frac{\\delta g(u_t, \\mu_{t-1})}{\\delta x_{t-1}}\\) is the slope of the local linearization at \\(x_{t-1}\\). this is a first partial derivative which constitutes a jacobian. \\((x_{t-1} - \\mu_{t-1})\\) tells us how far we are away from the linearization point \\(\\mu_{t-1}\\). for the correction step we linearize around our predicted state \\(\\overline{x}_t = (\\overline{\\mu}_t, \\overline{\\sigma}_t)\\): \\begin{align} h(x_t) \\approx h(\\overline{\\mu}_t) + \\frac{\\delta h(\\overline{\\mu}_t)}{\\delta x_t} (x_t - \\overline{\\mu}_t) \\end{align} \\(h(\\overline{\\mu}_t)\\) is the value of our non-linear observation model at the linearization point, which now is the predicted belief, that is the best estimate that i have. \\(h_t = \\frac{\\delta h(\\overline{\\mu}_t)}{\\delta x_t}\\) is the jacobian that equals the slope at the linearization point. \\((x_t - \\overline{\\mu}_t)\\) signifies how far away is the variable \\(x_t\\) to our linearization point \\(\\overline{\\mu}_t\\). jacobian given a function \\(f: \\mathbb{r}^n \\rightarrow \\mathbb{r}^m\\), such that given \\(x \\in \\mathbb{r}^n\\), \\(x \\mapsto f(x) \\in \\mathbb{r}^{m}\\). then the jacobian has the following shape: \\begin{align} j = \\begin{bmatrix} \\frac{\\delta f_1}{\\delta x_1} & \\frac{\\delta f_1}{\\delta x_2} & \\cdots & \\frac{\\delta f_1}{\\delta x_n} \\\\ \\vdots & \\cdots & \\cdots & \\vdots \\\\ \\frac{\\delta f_m}{\\delta x_1} & \\frac{\\delta f_m}{\\delta x_2} & \\cdots & \\frac{\\delta f_m}{\\delta x_n} \\end{bmatrix} \\in \\mathbb{r}^{m \\times n} \\end{align} and we can illustrate it graphically: as you can see, for points close to the linearization point, it constitutes a good approximation, but the further we move away the bigger the error is. so, let's revisit the transformation of our gaussian belief. remember we had, the following non-linear transformation: what we do now, is take the mean of our belief \\(\\mu_t\\) and approximate it locally with a linear function by using the taylor expansion as we have explained before. and then we transform our gaussian belief with this linear approximation (represented by the red line) which results in the following transformation: error under local linearization when we perform local linearization the error depends on to factors: the difference between the non-linear function and its linear approximation the uncertainty of our original gaussian distribution. because the larger the uncertainty, more probability mass will fall farther from our linearization point (the mean of that same gaussian distribution), and remember that the further we are from the linearization point the worse the approximation is, and thus the bigger the error is. linearized motion model we defined our linear motion model as follows: \\begin{align} p(x_t|x_{t-1}, u_t) = \\det(2\\pi r_t)^{-\\frac{1}{2}} \\exp(-\\frac{1}{2}(x_t - a_tx_{t-1} - b_tu_t)^tr^{-1}_t(x_t - a_tx_{t-1} - b_tu_t)) \\end{align} if our world is non-linear we substitute \\begin{align} x_t = a_tx_{t-1} + b_tu_t + \\epsilon_t \\end{align} for \\begin{align} x_t = g(u_t, x_{t-1}) + \\epsilon_t \\end{align} therefore the motion model is expressed as follows: \\begin{align} p(x_t|x_{t-1}, u_t) = \\det(2\\pi r_t)^{-\\frac{1}{2}} \\exp(-\\frac{1}{2}(x_t - g(u_t, x_{t-1}))^tr^{-1}_t(x_t - g(u_t, x_{t-1}))) \\end{align} finally we find a linear approximation, such that: \\begin{align} g(u_t, x_{t-1}) \\approx g(u_t, \\mu_{t-1}) + \\frac{\\delta g(u_t, \\mu_{t-1})}{\\delta x_{t-1}}(x_{t-1} - \\mu_{t-1}) = g(u_t, \\mu_{t-1}) + g_t(x_{t-1} - \\mu_{t-1}) \\end{align} and the linearized motion model becomes: \\begin{align} p(x_t|x_{t-1}, u_t) = \\det(2\\pi r_t) ^{-\\frac{1}{2}} \\cdot \\end{align} \\begin{align} \\cdot \\exp(-\\frac{1}{2}(x_t - g(u_t, \\mu_{t-1}) - g_t(x_{t-1} - \\mu_{t-1}))^tr^{-1}_t \\cdot \\end{align} \\begin{align} \\cdot (x_t - g(u_t, \\mu_{t-1}) - g_t(x_{t-1} - \\mu_{t-1}))) \\end{align} where \\(r^{-1}_t\\) describes the motion noise. linearized observation model we defined our linear observation model as follows: \\begin{align} p(z_t|x_t) = \\det(2\\pi q_t)^{-\\frac{1}{2}} \\exp(-\\frac{1}{2}(z_t - c_tx_t)^tq^{-1}_t(z_t - c_tx_t)) \\end{align} if our world is non-linear we substitute \\begin{align} z_t = c_t x_t + \\delta_t \\end{align} for \\begin{align} z_t = h(x_t) + \\delta_t = h(\\overline{\\mu}_t) + \\delta_t \\end{align} note that \\(x_t = \\overline{\\mu}_t\\) here refers to our best estimation up until now, that comes from the prediction step. therefore the observation model is expressed as follows: \\begin{align} p(z_t|x_t) = \\det(2\\pi q_t)^{-\\frac{1}{2}} \\exp(-\\frac{1}{2}(z_t - h(\\overline{\\mu}_{t}))^tq^{-1}_t(z_t - h(\\overline{\\mu}_{t}))) \\end{align} finally we find a linear approximation, such that: \\begin{align} h(x_t) \\approx h(\\overline{\\mu}_t) + \\frac{\\delta h(\\overline{\\mu}_t)}{\\delta x_t} (x_t - \\overline{\\mu}_t) = h(\\overline{\\mu}_t) + h_t (x_t - \\overline{\\mu}_t) \\end{align} and the linearized observation model becomes: \\begin{align} p(z_t|x_t) = \\det(2\\pi q_t)^{-\\frac{1}{2}} \\cdot \\end{align} \\begin{align} \\cdot \\exp(-\\frac{1}{2}(z_t - h(\\overline{\\mu}_t) - h_t (x_t - \\overline{\\mu}_t))^tq^{-1}_t \\cdot \\end{align} \\begin{align} \\cdot (z_t - h(\\overline{\\mu}_t) - h_t (x_t - \\overline{\\mu}_t))) \\end{align} where \\(q^{-1}_t\\) describes the measurement noise. algorithm to take into account the linearized models, we have to make a few changes to the kalman filter algorithm: the first thing that changes is that we use our linearized moition model \\(g(u_t, \\mu_{t-1})\\) to obtain our predicted estate \\(\\overline{x}_t = (\\overline{\\mu}_t, \\overline{\\sigma}_t)\\) we use the jacobian \\(g_t\\) to transform our previous uncertainty \\(\\sigma_{t-1}\\), given the jacobian is the linear transformation that approximates the non-linear transformation we defined originally for our motion model. same thing goes for the correction step. we use the jacobian \\(h_t\\) to apply a linear transformation that allows us to map \\(\\overline{\\sigma}_t\\) from the state space to the observation space, and thus calculate the kalman gain taking into account the measurement noise. then we compute the corrected mean of the estimated state \\(x_t\\) by obtaining the weighted sum of the mean of the predicted state \\(\\overline{\\mu}_t\\) and the correction factor. this correction factor equals the difference between the actual measurement \\(z_t\\) and the mapping of the predicted state to the observation space given by our linearized function \\(h(\\overline{\\mu}_t)\\). this mapping equals the expected measurement given our state is \\(\\overline{\\mu}_t\\). we do the same thing for the uncertainty \\(\\sigma_t\\). kalman gain suppose you have a perfect sensor, that is we trust completely the values given by this sensor and thus we set the measurement noise to be equal to zero (\\(q_t = 0\\)). then, the kalman gain becomes: \\begin{align} k_t = \\overline{\\sigma}_t h_t^t \\cdot (h_t \\overline{\\sigma}_t h_t^t + q_t)^{-1} \\end{align} \\begin{align} k_t = \\overline{\\sigma}_t h_t^t \\cdot (h_t \\overline{\\sigma}_t h_t^t + 0)^{-1} \\end{align} \\begin{align} k_t = \\overline{\\sigma}_t h_t^t \\cdot (h_t^t)^{-1} \\overline{\\sigma}_t^{-1} h_t^{-1} \\end{align} \\begin{align} k_t = \\overline{\\sigma}_t i \\overline{\\sigma}_t^{-1} h_t^{-1} \\end{align} \\begin{align} k_t = i h_t^{-1} = h_t^{-1} \\end{align} so, when we perform the correction over the mean of our belief: \\begin{align} \\mu_t = \\overline{\\mu}_t + k_t (z_t - h(\\overline{\\mu}_t)) \\end{align} \\begin{align} \\mu_t = \\overline{\\mu}_t + h_t^{-1} (z_t - h(\\overline{\\mu}_t)) \\end{align} \\begin{align} \\mu_t = \\overline{\\mu}_t + h_t^{-1} z_t - h_t^{-1}h(\\overline{\\mu}_t) \\end{align} with \\(h_t^{-1}h(\\overline{\\mu}_t)\\) what we are doing is, first computing \\(h(\\overline{\\mu}_t)\\) to map \\(\\overline{\\mu}_t\\) to the observation space, and the undoing this mapping with \\(h_t^{-1}\\), which means: \\begin{align} \\mu_t = \\overline{\\mu}_t + h_t^{-1} z_t - \\overline{\\mu}_t \\end{align} \\begin{align} \\mu_t = \\overline{\\mu}_t - \\overline{\\mu}_t + h_t^{-1} z_t \\end{align} \\begin{align} \\mu_t = h_t^{-1} z_t \\end{align} where \\(h_t^{-1}\\) maps \\(z_t\\) from the observation space to the state space, and this means in this update we trust our observation completely, and therefore our estate equals the observation. on the contrary, suppose the sensor is very unreliable, and so the noise is set to be infinity. then the correction step is executed as follows: \\begin{align} k_t = \\overline{\\sigma}_t h_t^t \\cdot (h_t \\overline{\\sigma}_t h_t^t + q_t)^{-1} \\end{align} \\begin{align} k_t = \\overline{\\sigma}_t h_t^t \\cdot (h_t \\overline{\\sigma}_t h_t^t + \\infty)^{-1} \\end{align} because we are dividing by infinity, \\(k_t = 0\\). so the mean of our belief is computed as follows: \\begin{align} \\mu_t = \\overline{\\mu}_t + k_t (z_t - h(\\overline{\\mu}_t)) \\end{align} \\begin{align} \\mu_t = \\overline{\\mu}_t + 0 (z_t - h(\\overline{\\mu}_t)) \\end{align} \\begin{align} \\mu_t = \\overline{\\mu}_t \\end{align} hence, if the measurement is too noisy, we only take into account our predicted state. localization example localization example using extended kalman filter (from 11') $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Robotics/OnlineTrainingMobileRobotics/KalmanFilter/Kalman Filter.html",
    "title": "Kalman Filter",
    "body": " index search search back kalman filter contents introduction properties of gaussian distributions linear model models linear motion model linear observation model gaussian world representing the belief algorithm assumptions the kalman filter requires the world to be gaussian, that is every probability distribution used must be gaussian. this filter also assumes linear models. introduction suppose your position on a 2d plane is given by the black dot: let's say you get your estimate as to where you are, inferred from a certain control command. for example if you are trying to move forward in the same direction you estimate your new position will be the cross: this is will be the prediction step. now suppose you get an observation about the distance to the nearest lighthouse: so now we can perform our new state estimate by combining by the means of a weighted sum our prediction along with the measurement: this weighted sum is performed trading off how certain you are about your prediction and how certain you are about your observation. properties of gaussian distributions in order to derive and prove some parts of the kalman filter we exploit the following properties: the product of two gaussian is a gaussian. a gaussian stays gaussian under linear transformations the marginal and conditional distribution of a gaussian is a gaussian linear model what does it mean when we say the kalman filter uses linear models? this means that both the motion model and the observation model can be expressed through a linear function, that is: \\begin{align} f(x) = ax + b \\end{align} one important property is that if a gaussian distribution is transformed through a linear function it stays gaussian. also, we introduce noise by using a zero mean gaussian distribution. models the motion model is defined as follows: \\begin{align} \\overline{x}_t = a_t x_{t-1} + b_tu_t + \\epsilon_t \\end{align} where \\(x_{t-1}\\) is the previous state estimate, \\(u_t\\) is the control command at time \\(t\\) and \\(\\epsilon_t\\) is gaussian noise. let's dive a little deeper: \\(a_t\\) is a matrix \\(n \\times n\\) (a mapping between the state space and the state space) which tells us how the state evolves from \\(t-1\\) to \\(t\\) without control commands or noise. we can use this matrix to encode information about velocity, acceleration, etc. \\(b_t\\) is a matrix \\(n \\times l\\) (a mapping between the control space and the state space) that describes how the control command \\(u_t\\) changes the state from \\(t_1\\) to \\(t\\). \\(\\epsilon_t\\) is a random variable that represents the motion noise with covariance \\(r_t\\). the observation model is defined as follows: \\begin{align} z_t = c_t \\overline{x}_t + \\delta_t \\end{align} where \\(\\overline{x}_t\\) is the estimated state and \\(\\delta_t\\) is gaussian noise. \\(c_t\\) is a matrix \\(k \\times n\\) which describes a mapping between the state \\(\\overline{x}_t\\) to an observation \\(z_t\\). \\(\\delta_t\\) is a random variable that represents the observation noise with covariance \\(q_t\\). linear motion model now that we have defined our linear models, we are going to show how to express the motion under a gaussian: \\begin{align} p(x_t|x_{t-1}, u_t) = \\det(2\\pi r_t)^{-\\frac{1}{2}} \\exp(-\\frac{1}{2}(x_t - a_tx_{t-1} - b_tu_t)^tr^{-1}_t(x_t - a_tx_{t-1} - b_tu_t)) \\end{align} which means we are obtaining the value of a probability distribution that incorporates our linear model for the prediction: \\begin{align} p(x_t|x_{t-1}, u_t) \\sim \\mathcal{n}(a_tx_{t-1} + b_tu_t, r_t) \\end{align} linear observation model we will apply the same reasoning to obtain the observation model under a gaussian: \\begin{align} p(z_t|x_t) = \\det(2\\pi q_t)^{-\\frac{1}{2}} \\exp(-\\frac{1}{2}(z_t - c_t\\overline{x}_t)^tq^{-1}_t(z_t - c_t\\overline{x}_t)) \\end{align} which means we are obtaining the difference between the observation \\(z_t\\) and what i expect to observe \\(\\overline{x}_{t}\\) (\\(z_t - c\\overline{x}_t\\)) while also taking the uncertainty into account \\(q_t^{-1}\\). we compute this incorporating our linear model for the correction step: \\begin{align} p(z_t|x_t) \\sim \\mathcal{n}(c_t\\overline{x}_t, q_t) \\end{align} gaussian world as we have said, we are assuming everything is gaussian. up until now we have described our models by using gaussian distributions, however we still have to make sure these are maintained when we are performing the prediction and the update. so, given the belief at time \\(t\\): if we suppose \\(\\overline{bel}(x_t)\\) is gaussian, then \\(bel(x_t)\\) is gaussian because the product of gaussian distribution is a gaussian distribution. therefore we need to show that \\(\\overline{bel}(x_t)\\) is also gaussian. that is: \\begin{align} \\overline{bel}(x_t) = \\int p(x_t|u_t,x_{t-1})bel(x_{t-1})dx_{t-1} \\end{align} we know, by its definition, that \\(p(x_t|u_t,x_{t-1})\\) is gaussian, and also we can prove by mathematical induction that \\(bel(xx_{t-1})\\) is gaussian. because if we start from a gaussian distributed belief and everything stays gaussian then the belief at time \\(t-1\\) will also be gaussian. noting that the convolution of two gaussian stays gaussian we conclude that \\(\\overline{bel}(x_t)\\) is gaussian and thus \\(bel(t)\\) is also gaussian. let's show however that the integral preserves the gaussian. note that we can express the predicted belief by using our linear models as follows: \\begin{align} \\overline{bel}(x_t) = \\int p(x_t|u_t,x_{t-1}) bel(x_{t-1})dx_{t-1} \\end{align} \\[ = \\int \\det(2\\pi r_t)^{-\\frac{1}{2}} \\exp(-\\frac{1}{2}(x_t - a_tx_{t-1} - b_tu_t)^tr^{-1}_t(x_t - a_tx_{t-1} - b_tu_t))bel(x_{t-1})dx_{t-1} \\] \\[ = \\eta \\int \\exp(-\\frac{1}{2}(x_t - a_tx_{t-1} - b_tu_t)^tr^{-1}_t(x_t - a_tx_{t-1} - b_tu_t))bel(x_{t-1})dx_{t-1} \\] \\[ = \\eta \\int \\exp(-\\frac{1}{2}(x_t - a_tx_{t-1} - b_tu_t)^tr^{-1}_t(x_t - a_tx_{t-1} - b_tu_t)) exp(-\\frac{1}{2}(x_{t-1} - \\mu_{t-1})^t\\sigma_{t-1}^{-1}(x_{t-1} - \\mu_{t-1})) \\] where \\(exp(-\\frac{1}{2}(x_{t-1} - \\mu_{t-1})^t\\sigma_{t-1}^{-1}(x_{t-1} - \\mu_{t-1}))\\) is the expected value of the gaussian that describes our previous belief \\(bel(x_{t-1})\\). now, we combine both exponentials, given \\(exp(x) \\cdot exp(y) = exp(x + y)\\): \\[ \\overline{bel}(x_t) = \\eta \\int \\exp(-l_t)dx_{t-1} \\] given: \\[ l_{t} = \\frac{1}{2}(x_t - a_tx_{t-1} - b_tu_t)^tr^{-1}_t(x_t - a_tx_{t-1} - b_tu_t) \\] \\[ + \\frac{1}{2}(x_{t-1} - \\mu_{t-1})^t\\sigma_{t-1}^{-1}(x_{t-1} - \\mu_{t-1}) \\] we can split \\(l_t\\) up in a part that only depends on \\(x_t\\) and another part that depends on \\(x_t, x_{t-1}\\). such that: \\[ l_t = l_t(x_{t-1}, x_t) + l_t(x_t) \\] thus: \\[ \\overline{bel}(x_t) = \\eta \\int \\exp(-l_t(x_{t-1}, x_t) -l_t(x_t))dx_{t-1} \\] \\[ \\overline{bel}(x_t) = \\eta \\exp(-l_t(x_t)) \\int \\exp(-l_t(x_{t-1}, x_t) )dx_{t-1} \\] this way we have: \\(\\exp(-l_t(x_t))\\): gaussian distribution \\(\\int \\exp(-l_t(x_{t-1}, x_t) )dx_{t-1}\\): this is the marginalization of a gaussian of the variable \\(x_{t-1}\\), which happens to also be a gaussian. therefore we have shown that everything stays gaussian: representing the belief we have said that everything is gaussian, which includes our belief. this belief will be represented, like any other gaussian is, by its mean \\(\\mu\\) and variance \\(\\sigma\\). so our belief at time \\(t\\) would be represented by \\((\\mu_t, \\sigma_t)\\). algorithm the kalman filter algorithm is defined as follows: inputs: \\(\\mu_{t-1}\\): previous mean that describes our belief at time \\(t-1\\) \\(\\sigma_{t-1}\\): previous covariance that describes our uncertainty at time \\(t-1\\) \\(z_t\\): the observation at time \\(t\\). \\(u_t\\): the control command at time \\(t\\). the algorithm is, as usual, divided into a prediction step and a correction step: in the prediction step we estimate our next belief, described by a gaussian \\(\\overline{bel}(x_t) \\sim \\mathcal{n}(\\overline{\\mu_t}, \\overline{\\sigma_t})\\). first we compute our new estimated mean \\(\\overline{\\mu}_t\\) by multiplying our transformation function \\(a_t\\) by the previous mean \\(\\mu_{t-1}\\) which tells us how the state evolves generally without any motion added to it (i.e. velocity, acceleration, etc). to add the motion we add \\(b_tu_{t}\\). then we update our uncertainty. the estimate of the new covariance is derived from how a gaussian changes through a linear transformation, thus we compute \\(a_t \\sigma_{t-1} a_t^t\\). we also add additional noise that the motion adds to the new belief by adding \\(r_t\\). the we apply the correction step: what we mainly do is computing the weighted sum between two distributions first we obtain the weighting factor \\(k_t\\), also known as the kalman gain. this equals a ratio between the prediction and the observation. here we use \\(c_t^t\\) to map our uncertainty from the state space to the observation space. on the denominator we map our uncertainty onto the observation space and we also add the measurement noise \\(q_t\\) then we divide the two terms to obtain a factor that tells us if we trust more the prediction or the correction. then we modify our estimated mean \\(\\overline{\\mu}_{t}\\) with a weighted correction: we compute the error between what we observed and what we predicted \\(z_t - c_t \\overline{\\mu}_t\\) (again \\(c\\) to map to the observation space). then we change the estimated state by this error pondered by \\(k\\). we also update our uncertainty assumptions we can apply the kalman filter as long as the two following assumptions hold: everything is gaussian the motion and observation model are linear however, what if this is not the case? extended kalman filter $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Robotics/OnlineTrainingMobileRobotics/BayesFilter/Bayes Filter.html",
    "title": "Bayes Filter",
    "body": " index search search back bayes filter contents state estimation recursive state estimation recursive bayes filter intuition derivation prediction and correction step implementation popular filters model examples motion model measurement model state estimation state estimation means we want to estimate the state of the system based on sensor measurements and control commands. thus, given observations \\(z\\) and control commands \\(u\\), estimate the current state \\(x\\) at time \\(t\\): \\begin{align} p(x_t|z_{1:t}, u_{1:t}) \\end{align} recursive state estimation recursive state estimation means we want to update our belief based on the observation that comes in reusing the previous distribution that we had. therefore, using the previous definition of the current state, we would introduce recursion by computing \\(x_t\\) based on the current measurement \\(z_t\\), the current control command \\(u_t\\) and the previous state \\(x_{t-1}\\). the latter is in itself also defined recursively. recursive bayes filter intuition we start with no knowledge of the environment, so our state is described by a uniform distribution, indicating we could be located at any point in space. after receiving a measurement \\(z\\), we update our belief. in this case we have sensed a door, and we know there are three doors in our map. therefore the probability of obtaining the measurement \\(z\\) given we are in front of that door is larger than in the other possible positions. so if we combine our previous belief with this measurement's probability distribution, our belief becomes: now we move forward, so we also have to shift our belief forward. note, however, that our movement is not exact, there is also a level of uncertainty, so we describe it by using a distribution. hence, when combining our previous belief with the probability distribution for the motion our certainty about our state decreases, and our belief becomes: we receive yet another measurement \\(z\\), again we have that \\(p(z|x)\\) is larger on the locations where there is a door, because this measurement has sensed a door. so if we combine this probability distribution for this measurement with our previous state we increase our certainty about our current state. therefor, our belief becomes: derivation the belief at time \\(t\\) is given by: \\begin{align} bel(x_t) = p(x_t | z_{1:t}, u_{1:t}) \\end{align} that is, where am i at moment \\(t\\), given all previous observations \\(z_{1:t}\\) and control commands \\(u_{1:t}\\). we now apply bayes rule, to swap \\(x_t\\) and \\(z_t\\) on the conditional probability: \\begin{align} = \\eta \\cdot p(z_t | x_t, z_{1:t-1}, u_{1:t}) \\cdot p(x_t|z_{1:t-1}, u_{1:t}) \\end{align} where \\(\\eta\\) is a normalization constant. now, let's pay attention to \\(p(z_t | x_t, z_{1:t-1}, u_{1:t})\\). by the markov assumption we are going to assume that the current state \\(x_t\\) and the previous observations and control commands are conditionally independent. that is, they do not give any information about the likelihood of the observation \\(z_t\\). thus, we drop them from the equation: \\begin{align} = \\eta \\cdot p(z_t | x_t) \\cdot p(x_t|z_{1:t-1}, u_{1:t}) \\end{align} for \\(p(x_t|z_{1:t-1}, u_{1:t})\\) we are going to use the law of total probability to add a new variable, so we integrate over this new variable. more concretely to add \\(x_{t-1}\\), which will allow us to introduce recursion to our expression: \\begin{align} = \\eta \\cdot p(z_t | x_t) \\cdot \\int p(x_t | x_{t-1}, z_{1:t-1}, u_{1:t}) \\cdot p(x_{t-1}|z_{1:t-1},u_{1:t}) dx_{t-1} \\end{align} we could interpret this rewritten expression as: for each previous state \\(x_{t-1}\\) we multiply \\(p(x_t | x_{t-1}, z_{1:t-1}, u_{1:t})\\), the probability of being in the new state \\(x_t\\) given the previous state \\(x_{t-1}\\), observations \\(z_{1:t-1}\\) and control commands \\(u_{1:t}\\) by \\(p(x_{t-1}|z_{1:t-1},u_{1:t})\\), the probability of being in the state \\(x_{t-1}\\) given the previous observations \\(z_{1:t-1}\\) and control commands \\(u_{1:t}\\) once again we apply the markov assumption over \\(p(x_t | x_{t-1}, z_{1:t-1}, u_{1:t})\\), because knowing where i am at moment \\(t-1\\), we assume the observations \\(z_{1:t-1}\\) do not add any information. however note the control command does indeed hold valuable information, as it tells us action last executed that moved us from \\(x_{t-1}\\) to \\(x_t\\). so we simplify the expression as follows: \\begin{align} = \\eta \\cdot p(z_t | x_t) \\cdot \\int p(x_t | x_{t-1}, u_{1:t}) \\cdot p(x_{t-1}|z_{1:t-1},u_{1:t}) dx_{t-1} \\end{align} we now suppose that knowing what action or command is executed in the future does not tell us anything about the present. hence we ignore the latest control command \\(u_t\\), so the expression becomes: \\begin{align} = \\eta \\cdot p(z_t | x_t) \\cdot \\int p(x_t | x_{t-1}, u_{1:t}) \\cdot p(x_{t-1}|z_{1:t-1},u_{1:t-1}) dx_{t-1} \\end{align} note that we have finally derived a recursive expression for our belief, given: \\begin{align} bel(x_{t-1}) = p(x_{t-1}|z_{1:t-1}, u_{1:t-1}) \\end{align} we substitute this expression in the belief at time \\(t\\): \\begin{align} = \\eta \\cdot p(z_t | x_t) \\cdot \\int p(x_t | x_{t-1}, u_{1:t}) \\cdot bel(x_{t-1}) dx_{t-1} \\end{align} prediction and correction step usually the bayes filter is broken up into: prediction step: estimates where the future state is based on the control command at time \\(t\\) and makes use of the motion model. motion model: \\(p(x_t | x_{t-1}, u_{1:t})\\) \\begin{align} \\hat{bel}(x_t) = \\int p(x_t | x_{t-1}, u_{1:t}) \\cdot bel(x_{t-1}) dx_{t-1} \\end{align} correction step: we get an observation that we use to correct potential mistakes we make in the prediction step. this correction is made using the observation or measurement model. observation model: \\(p(z_t | x_t)\\) \\begin{align} bel(x_t) = \\eta \\cdot p(z_t | x_t) \\cdot \\hat{bel}(x_t) \\end{align} implementation in order to implement a bayes filter we need to define certain things: specify the motion model specify the observation model specify the belief how do we move from one state to the next (i.e. linear model, non-linear model) popular filters kalman filters and efk use gaussians to represent the belief, motion model and observation model they use linear or linearized models particle filter the can use arbitrary models to represent state, motion model and observation model model examples motion model given a current state \\(x_t\\), the motion model could look like: in the first case, let's suppose a point represents the next state \\(x_{t+1}\\) after the control command is applied. if we execute our system \\(n\\) times, we get \\(n\\) estimations that are illustrated by the \\(n\\) points in the graph. they represent an approximation of the distribution that describes our predicted state (illustrated by the graph in the upper left corner). this distribution is our motion model at time \\(t+1\\). for the two middle graphs, we can deduce that our system is certain about the angle of motion, however it shows more uncertainty about the distance. finally in the last two graphs we see the opposite. the system knows how much we moved, that is the distance, but is uncertain about the angle of movement. measurement model suppose we have a sensor that tell us the distance between us and the closest obstacle in front of us. we know that this sensor is noisy, so to mimic that noise we can describe the measurement model as a normal distribution. in the previous image, the star represents the closest obstacle, and we use the gaussian distribution to describe how likely it is of obtaining a given measurement. observe that the further we move away from the actual obstacle the lower is the probability of that measurement taking place. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Robotics/OnlineTrainingMobileRobotics/ParticleFilter/Particle Filter.html",
    "title": "Particle Filter",
    "body": " index search search back particle filter contents intro particle set particle generation gaussian sampling importance sampling principle characteristics algorithm summary monte carlo localization structure particle filter algorithm for localization example resampling techniques roulette wheel low variance resampling algorithm intro with particle filters we are not restricting ourselves with parametric probability distributions like we do for example with kalman filters where we use gaussian distributions. as usual, we suppose we are given a map, and instead of using one parametric from we use non-parametric samples as a hypothesis of where the system might be. so, we are going to leave behind gaussian distributions to describe the estimate: and we are going to model our estimate using an arbitrary distribution: it turns out that we can describe this kind of distribution using samples: as you can see, the amount of samples in the areas where the density of the probability distribution is higher is also higher and vice versa. basically we have samples distributed over a state space, so imagine each sample signifies a little bit of probability mass, so we only need to count how many samples fall into a certain region to asses the probability that the system is in that region. also, we can weight our samples, so the larger the weight the larger the probability mass associated with that sample (taking into account that the sum of the weight have to amount to one). the weighting of the samples allows us to use less samples to represent the same probability distribution: note that by using samples we are computing an approximation of the probability function. and we use this weighted samples to estimate our belief. some examples are: we use the particles to approximate the probability function, where the more particles fall into a region, the higher the probability of the region. particle set we represent the sample set or particle set as follows: \\[ \\mathcal{x} = \\{\\langle x^{[j]}, w^{[j]}\\rangle\\}_{j=1\\cdots j} \\] where: there are \\(j\\) samples \\(x^{[j]}\\) represents the hypothesis (i.e. the state of the system) \\(w^{[j]}\\) represents the normalized weight assigned to jth particle the sum or integration over the particles represent the posterior (i.e. the probability function): \\[ p(x) = \\sum_{j=1}^j w^{[j]} \\delta_{x^{[j]}} (x) \\] where \\(\\delta\\) is the dirac function. note that \\(\\int \\delta(x) dx = 1\\) particle generation gaussian sampling note that closed form sampling is only possible for a few distributions, for example: for a gaussian distribution to obtain an approximation from sampling, we would sample by summing \\(12\\) times a random (uniformly drawn) number \\(x \\in [-\\sigma, \\sigma]\\), where \\(\\sigma\\) represents the standard deviation, and divide the sum by \\(\\frac{1}{2}\\). then you would draw samples that are approximately close to a gaussian distribution. importance sampling principle but, how can we approximate for another probability distribution functions? it turns out we can do this by sampling from a different probability function that the actual probability function and then compensating for the mistakes that we have done by drawing from this \"mistaken\" probability function. to do this we apply the importance sampling principle which tells us: we can use a different distribution (proposal distribution) \\(\\pi\\) to generate samples from the target (real) distribution \\(f\\). we need to account for the differences between \\(\\pi\\) and \\(f\\) using a weight, given by \\(\\omega = \\frac{f(x)}{\\pi{x}}\\) we need to assert the following pre-condition: \\(f(x) > 0 \\rightarrow \\pi(x) > 0\\) you can see that the weights are larger where the difference between the proposal and the target function is bigger. observe on the right side of the graph that we have drawn a low number of samples because our proposal probability function tells us the us the density on that region is low. however the target function shows a high probability in that same region, so by computing the difference between the proposal and the target function we assign bigger weights to those few particles. characteristics it is a recursive bayes filter uses a non-parametric approach models the distribution using samples and so the model need not be linear. the prediction step consists of drawing samples from the proposal function (takes the motion into account) the correction step consists of weighting the samples by the ration between the target function and the proposal function (takes the observation into account) the more particles we use to approximate the probability function the better the estimate is. algorithm the algorithm is composed of the following three steps: (prediction step) sample the particles using the proposal distribution (this signifies: where could my system be?). because we can choose the proposal function, what we do in this step is sampling from the motion model: \\[ x_t^{[j]} \\sim proposal(x_t|\\cdots) \\] (correction step) compute the importance weights to compensate from the mistakes made by sampling from the proposal distribution. if we derive the following expression, we obtain that the weights are given by the observation model: \\[ w_t^{[j]} = \\frac{target(x_t^{j})}{proposal(x_t^{j})} \\] resampling: draw with replacement \\(j\\) samples \\(i\\) with probability \\(w_t^{[i]}\\). so now we have a resampled set of samples where we update the weights by dividing the by \\(1/j\\) so they are normalized. what we do is generate a new set of samples where we replace the weight by the frequency. we do this because we work with a finite number of samples, so it could be the case that some particles have a very low probability and thus contribute very little to approximating the probability function. so it is better to eliminate those samples and replace them with a sample that is located in an area with high probability. we start with a empty sample set for the prediction step \\(\\hat{\\mathcal{x}}_t\\) and for the correction step \\(\\mathcal{x}_t\\). (prediction step) for \\(j=1\\cdots j\\): sample particle \\(x^{[j]}_t\\) from the proposal distribution \\(\\pi(x_t)\\), this distribution can be defined by the user, and corresponds to the belief at time \\(t-1\\) and constrained to the control command at time \\(t\\), \\(u_t\\). compute the weight by obtaining the difference between the proposal distribution and the target distribution. this results in using the observation model save the pair \\(x_t^{[j]}\\), \\(w_t^{[j]}\\) to the prediction sample set \\(\\hat{\\mathcal{x}}_t\\). (correction step) for \\(j=1\\cdots j\\): draw a particle \\(x_t^{[j]}\\) with replacement from the prediction sample set with probability proportional to the weight of the sample \\(w_t^{[j]}\\). add the particle to the correction sample set \\(\\mathcal{x}_t\\) return the resampled sample set \\(\\mathcal{x}_t\\) summary what the particle filter does is: it takes each particle as a pose hypothesis that says \"this is where the system is at time \\(t\\)\". then it adds weight to each particle signifying how much that pose hypothesis conforms to the given observation, and tells us how likely the hypothesis is. if we do this with \\(n\\) particles what we obtain is a belief, that is, a set of possibilities of where we are which describe my probability distribution. monte carlo localization monte carlo localization refers to the estimation the location and orientation of the system using a particle filter. for example: with a particle filter, our belief shows where the robot is located by having a bigger density of particles right under where the robot is. another example is the following, where we start with all the particles scattered over the map that means the particles are sampled from a uniform distribution so every point in space is equally likely to be the location of the robot. once the robot drives around and obtains new measurements the probability mass concentrates on places where the robot is more likely to be in given the motion commands and the observations. eventually the system converges and you end up with a unimodal distribution that is similar to a gaussian distribution. structure each particle represents a pose hypothesis we represent the proposal probability function by drawing from the motion model. because we are sampling from the motion distribution what we do is increasing the uncertainty about the motion at time \\(t\\) and thus account for the noise present in each motion. \\[ x_t^{[j]} \\sim p(x_t|x_{t-1}, u_t) \\] we apply the correction via the observation model. so the weight of each particle is proportional to the likelihood of an observation \\(z_t\\) given i know where i am \\(x_t\\) and the map of the environment \\(m\\). this result is dependent of the choice made previously of sampling from the motion model. \\[ w_t^{[j]} = \\frac{target}{proposal} \\propto p(z_t|x_t,m) \\] particle filter algorithm for localization we modify slightly our particle filter algorithm to use it for localization: we sample from the motion model \\(p(x_t|u_t, x^{[j]}_{t-1})\\) instead from the generic proposal function \\(\\pi(x_t)\\) we compute the weights with \\(w_t^{[j]} = \\frac{target}{proposal} \\propto p(z_t|x_t,m)\\). example first we start with a uniform distribution, and we sample from that distribution, obtaining \\(j\\) particles distributed over the space with the same probability. then we obtain an observation, and in the weighting step we increase the weight of the samples with are more likely given the observation. in this case the samples in front of doors, while the rest of the particles get a lower weight. then we apply resampling to replace weight by frequencies (the probability mass of a particle is bigger if this particle has been resampled several times, which means it weight was bigger than the rest of the samples). in the following picture the resampling step is executed along with the motion step (so the probability function is offsetted): because the prediction/motion was already performed before, now we obtain another observation: when we obtain the weights, two things happen. first, and as before, the particles (pose hypothesis) more likely to be correct given the observation obtain a larger weight. second, because the is a bigger number of particles in front of the second door the density in this area is bigger than in the areas in front of the other doors. another resampling and prediction step: resampling techniques roulette wheel first we create a roulette wheel where each field represents a particle, and the bigger the weight associated with that particle the bigger the field is: the idea is that, we normalize the weights, and each time we draw a number between zero and one, which will \"point\" to a weight. however this method can lead to suboptimal solutions. suppose that for some reason each time we end up with uniform weight, so that no particle is more likely than any other. then, with the wheel roulette we will duplicate some particles and remove some others. however this does not make sense, because every particle had the same weight. thus we introduce the lower variance resampling. low variance resampling here, the idea is using \\(j\\) arrows instead of only one, where the arrows are at the same angular distance from each other. so in order to sample what we do is, we simply turn the arrows, and where all the arrows end up, that is the samples we choose. this solution is faster, with time complexity equal to \\(o(j)\\) compared to the wheel roulette's \\(o(j \\log j)\\), and resolves the suboptimal solution problem presented earlier. algorithm first we draw a random number between \\(0\\) and \\(\\frac{1}{j}\\) then we pick \\(j-1\\) particles by advancing in the array in steps of \\(\\frac{1}{j}\\) to efficiently implement this what we do is, in each element of the array we store the cummulative weight up until that point: so, we draw a random number between \\(0\\) and \\(\\frac{1}{j}\\), if that number is bigger than the weight accumulated up until weight \\(i\\), then we move to the next one, else if it is less we sample the particle \\(i\\). and then we advance \\(\\frac{1}{j}\\). $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/SVM/Optimal Margin Classifier.html",
    "title": "Optimal Margin Classifier",
    "body": " index search search back optimal margin classifier contents train the classifier classify an example we use this classifier to categorize datasets that are perfectly separable, that is to say, we use it over data that is linearly separable. this classifier will help us find the green line we saw in the geometric margin. what the optimal margin classifier does is choose the parameters \\(w, b\\) that maximize \\(\\gamma\\) one way to solve this optimization problem is: \\begin{align} \\underset{\\gamma, w, b}{\\max} \\gamma \\end{align} subject to \\begin{align} \\frac{y^{(i)}(w^tx + b)}{||w||} \\geq \\gamma \\end{align} this will cause the maximization of the geometric margin with respect to the training set. the restriction means that we want to maximize \\(\\gamma\\) while having every example have a geometric margin of at least \\(\\gamma\\). because this is a non-convex problem, we will transform it. given \\(\\gamma = \\frac{\\hat{\\gamma}}{||w||}\\), then \\(\\gamma \\cdot ||w|| = \\hat{\\gamma}\\), and so if we multiply in the subject both sides by \\(||w||\\): \\begin{align} \\frac{y^{(i)}(w^tx + b)}{||w||} \\cdot ||w|| \\geq \\gamma \\cdot ||w|| \\leftrightarrow y^{(i)}(w^tx + b) \\geq \\hat{\\gamma} \\end{align} and the optimization problem can be re-written as: \\begin{align} \\underset{\\hat{\\gamma}, w, b}{\\max} \\frac{\\hat{\\gamma}}{||w||} \\end{align} subject to \\begin{align} y^{(i)}(w^tx + b) \\geq \\hat{\\gamma} \\end{align} however, we are still stuck with a non-convex objective \\(\\frac{\\hat{\\gamma}}{||w||}\\). because, as we've said previously scaling the functional margin (changing the magnitude of \\(w^tx + b\\)) does not change the decision boundary itself, we will add an scaling constraint that the functional margin of \\(w, b\\) with respect to the training set must be 1: \\(\\hat{\\gamma} = 1\\) observe, now, that maximizing \\(\\frac{\\hat{\\gamma}}{||w||} = \\frac{1}{||w||}\\) is like minimizing \\(||w||^2\\), we re-write the optimization problem as follows: \\begin{align} \\underset{w, b}{\\min} ||w||^2 \\end{align} subject to \\begin{align} y^{(i)}(w^tx + b) \\geq 1 \\end{align} we will revise once more the optimization problem for the optimal margin classifier. first, we have to suppose two facts: by the representer theorem we can assume that \\(w\\) can be expressed as a linear combination of \\(x\\), that is: \\begin{align} w = \\sum_{i=1}^m \\alpha_i x^{(i)} \\end{align} let's review this claim with logistic regression. we know that we apply stochastic gradient descent (we update \\(\\theta\\) for every example, instead of summing all the examples) on \\(\\theta\\) as follows: \\begin{align} \\theta = \\theta - \\alpha (h_\\theta(x^{(i)}) - y^{(i)})x^{(i)} \\end{align} which means that in every interation we are updating \\(\\theta\\) by adding or substracting a factor \\(\\alpha_i\\) multiplied by \\(x^{(i)}\\). therefore we can show by mathematical induction that if we start with \\(\\theta_0 = c\\), where \\(c\\) is a constant and go on adding and substracting \\(ax^{(i)}\\), where \\(a= \\alpha (h_\\theta(x^{(i)}) - y^{(i)})\\), then \\(w\\) can be expressed as a linear combination of \\(x\\). you can also derive the gradient descent expression in our optimization problem, and show that in this case \\(w\\) is also a linear combination of \\(x\\). we can rewrite \\(w\\) as follows: \\begin{align} w = \\sum_{i=1}^m \\alpha_i y^{(i)} x^{(i)} \\end{align} given any decision boundary, the vector \\(w\\) is always orthogonal to the decision boundary: now, the optimization problem becomes (note \\(w^2 = w^tw\\)): \\begin{align} \\underset{w, b}{min} \\frac{1}{2}||w||^2 = \\underset{w, b}{min} \\frac{1}{2} (\\sum_{i=1}^m \\alpha_i y^{(i)} x^{(i)})^t(\\sum_{j=1}^m \\alpha_j y^{(j)} x^{(j)}) = \\end{align} \\begin{align} \\underset{w, b}{min} \\frac{1}{2} \\sum_{i=1}^m\\sum_{j=1}^m \\alpha_i \\alpha_j y^{(i)}y^{(j)}(x^{(i)})^tx^{(j)} \\end{align} we now denote the inner product of \\((x^{(i)})^t x^{(j)}\\) as \\(\\langle x^{(i)}, x^{(j)} \\rangle\\), so: \\begin{align} \\underset{w, b}{min} \\frac{1}{2} \\sum_{i=1}^m\\sum_{j=1}^m \\alpha_i \\alpha_j y^{(i)}y^{(j)} \\langle x^{(i)}, x^{(j)} \\rangle \\end{align} and the restriction of the optimization becomes: \\begin{align} y^{(i)}(w^tx^{(i)} + b) \\geq 1 \\rightarrow y^{(i)}((\\sum_{j=1}^m \\alpha_j y^{(j)}x^{(j)})^tx^{(i)} + b) \\geq 1 \\rightarrow \\end{align} \\begin{align} y^{(i)}((\\sum_{j=1}^m \\alpha_j y^{(j)}(x^{(j)})^tx^{(i)}) + b) \\geq 1 \\rightarrow y^{(i)}((\\sum_{j=1}^m \\alpha_j y^{(j)} \\langle x^{(j)}, x^{(i)} \\rangle) + b) \\geq 1 \\end{align} applying convex optimization theory you can simplify this optimization problem further to: \\begin{align} \\underset{\\alpha}{max} \\sum_{i=1}^m \\alpha_i - \\frac{1}{2} \\sum_{i=1}^m\\sum_{j=1}^m y^{(i)}y^{(j)}\\alpha_i\\alpha_j\\langle x^{(i)}, x^{(j)}\\rangle \\end{align} subject to \\begin{align} \\alpha_i \\geq 0 \\end{align} \\begin{align} \\sum_{i=1} y^{(i)}\\alpha_i = 0, i=1, \\cdots,m \\end{align} train the classifier to train the svm we have to solve the optimization problem for \\(\\alpha\\) classify an example to predict an example \\(x\\): \\begin{align} h_{w,b} = g(w^tx + b) = g\\left(\\left(\\sum_{i=1}^m \\alpha_i y^{(i)}x^{(i)}\\right)^tx + b\\right) = g\\left(\\left(\\sum_{i=1}^m \\alpha_i y^{(i)} \\langle x^{(i)}, x^{(j)} \\rangle\\right) + b\\right) \\end{align} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/SVM/Functional Margin.html",
    "title": "Functional Margin",
    "body": " index search search back functional margin contents intuition formal definition evaluation normalizing the functional margin intuition the functional margin describes how accurately do we classify an example. for example, for binary classification, given an example x: \\begin{align} h_\\theta(x) = g(\\theta x) = \\begin{cases} \\text{ predict } 1 & \\text{ if } \\theta^t x \\geq 0, \\text{ that is } h_\\theta(x)=g(\\theta x) \\geq 0.5\\\\ \\text{ predict } 0 & \\text{ otherwise } \\\\ \\end{cases} \\end{align} let's distinguish between the two cases when classifying an example \\(x^{(i)}\\): (1) if \\(y^{(i)} = 1\\), then we want \\(h_\\theta(x) = g(\\theta x) \\approx 1\\), which means we want \\(\\theta \\cdot x >> 0\\). (2) if \\(y^{(i)} = 0\\), then we want \\(h_\\theta(x) = g(\\theta x) \\approx 0\\), which means we want \\(\\theta \\cdot x << 0\\). as we can see in the following graph, the bigger \\(z = \\theta x\\) the closer \\(g(z)\\) is to one and vice versa. formal definition the functional margin of the hyperplane defined by \\((w, b)\\) with respect to the example \\((x^{(i)}, y^{(i)})\\) is defined as: \\begin{align} \\hat{\\gamma}^{(i)} = y^{(i)}(w^tx^{(i)}+b) \\end{align} so, if we modify slightly the two statements above and use the new notation for svms: if \\(y^{(i)} = 1\\), then we want \\(w^t \\cdot x + b >> 0\\). if \\(y^{(i)} = 0\\), then we want \\(w^t \\cdot x + b << 0\\). the combination of these two declarations yields the definition of the functional margin. why?, well: when \\(y^{(i)}\\) is positive, we want to have \\(w^tx^{(i)} + b >> 0\\) by (1), so \\(\\hat{\\gamma}^{(i)}\\) will be large, because both values are positive when \\(y^{(i)}\\) is negative, we want to have \\(w^tx^{(i)} + b << 0\\) by (2), so \\(\\hat{\\gamma}^{(i)}\\) will be large, because both values are negative so, given an example \\(x^{(i)}\\), if \\(\\hat{\\gamma}^{(i)} > 0\\) that means either \\(y^{(i)} = 1\\) and \\(w^tx + b > 0\\) or \\(y^{(i)} = -1\\) and \\(w^tx + b < 0\\) which shows that the classification is correct. evaluation to evaluate the functional margin with respect to the training set we make use of the worst case notion: \\begin{align} \\hat{\\gamma} = \\underset{i}{\\min} \\hat{\\gamma}^{(i)} \\end{align} that is, we evaluate how well we are doing in the worst example. normalizing the functional margin note that the functional margin is very easy to cheat (to increase its value with any meaningful change to the decision boundary). given our definition for \\(g\\): \\begin{align} g = \\begin{cases} 1, & \\text{ if } z \\geq 0 \\\\ -1, & \\text{ otherwise } \\end{cases} \\end{align} it follows that \\(h_{w,b}(x^{(i)}) = g(2w^tx^{(i)} + 2b) = g(w^tx^{(i)} + b)\\), because what matters is the sign, not the magnitude. however, if you scale \\(w\\) and \\(b\\) by a factor of \\(n\\) where \\(n\\) is a positive number then \\(\\gamma \\) increases because: \\begin{align} \\hat{\\gamma}^{(i)} = (w^tx + b) \\end{align} so, \\begin{align} n \\cdot \\hat{\\gamma}^{(i)} = n \\cdot (w^tx + b) \\end{align} where, \\begin{align} \\hat{\\gamma}^{(i)} < n \\cdot \\hat{\\gamma}^{(i)} \\end{align} one way to avoid this is to normalize the length of the parameters, that is either: add a constraint where \\(||w|| = 1\\) or set \\((w, b)\\) to be \\((\\frac{w}{||w||}, \\frac{b}{||b||})\\) in both cases we are re-scaling the parameters. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/SVM/Geometric Margin.html",
    "title": "Geometric Margin",
    "body": " index search search back geometric margin contents intuition euclidean distance to the decision boundary formal definition evaluation intuition first of all, let's assume we have a dataset that is linearly separable like: here we have two examples of two decision boundaries that do classify correctly all of the samples. however the red one looks worse than the green one. that is because for the red one there are some examples that are very close to the boundary compared to the rest. whereas for the green one there is a bigger separation. so, first we define a line by the equation \\(w^tx + b = 0\\), therefore: every example \\(x\\) that lies to the left of the line satisfies \\(w^tx + b < 0\\) and every example \\(x\\) that lies to the right of the line satisfies \\(w^tx + b > 0\\) furthermore the geometric margin with respect to a single example \\((x^{(i)}, y^{(i)})\\) is the euclidean distance between the point \\((x^{(i)}, y^{(i)})\\) and the line we have defined as \\(w^tx + b = 0\\). euclidean distance to the decision boundary the decision boundary corresponding to (w, b) is shown, along with the vector w. note that w is orthogonal (at 90º) to the separating hyperplane. consider the point at \\(a\\), which represents the example \\(x^{(i)}\\) with \\(y^{(i)} = 1\\). its distance to the decision boundary, denoted by \\(\\gamma^{(i)}\\), is given by the line segment \\(ab\\). how do we find \\(\\gamma^{(i)}\\): we know \\(\\frac{w}{||w||}\\) is a unit length vector pointing to the same direction as \\(w\\). also \\(a = x^{(i)}\\) we also know that the vector between points \\(a\\) and \\(b\\) is defined like \\(a - b\\), in this scenario, \\(a - b = \\gamma^{(i)}\\frac{w}{||w||}\\), where \\(\\gamma^{(i)}\\) is the length of the vector and \\(\\frac{w}{||w||}\\) is the direction of the vector. thus if we solve for \\(b\\), \\(b = x^{(i)} - \\gamma^{(i)}\\frac{w}{||w||}\\) furthermore, \\(b\\) lies on the decision boundary, therefore: \\begin{align} w^t(b) + b = 0 \\rightarrow w^t\\left(x^{(i)} - \\gamma^{(i)}\\frac{w}{||w||}\\right) + b = 0 \\end{align} solving for \\(y^{(i)}\\) yields: \\begin{align} \\gamma^{(i)} = \\frac{w^tx^{(i)} + b}{||w||} = \\left(\\frac{w}{||w||}\\right)^tx(i) + \\frac{b}{||w||} \\end{align} formal definition the geometric margin of the hyperplane \\((w, b)\\) with respect to \\((x^{(i)}, y^{(i)})\\) is defined as: \\begin{align} \\gamma^{(i)} = \\frac{w^t x^{(i)} + b}{||w||} \\end{align} this is the definition for a positive example (\\(y^{(i)} = 1\\)), and measures the euclidean distance from the decision boundary to the example \\((x^{(i)}, y^{(i)})\\). if we generalize, as to compute the geometric margin for both positive and negative examples: \\begin{align} \\gamma^{(i)} = \\frac{y^{(i)} (w^t x^{(i)} + b)}{||w||} \\end{align} evaluation to evaluate the geometric margin with respect to the training set we make use of the worst case notion: \\begin{align} \\gamma = \\underset{i}{\\min} \\gamma^{(i)} \\end{align} that is, we evaluate how well we are doing in the worst example. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/SVM/SVM.html",
    "title": "SVM",
    "body": " index search search back svm contents notation functional margin geometric margin relationship between functional margin and geometric margin optimal margin classifier svm kernels kernel trick applying kernels validity of kernels generality of the kernel trick l1-norm soft margin svm graphical representation outliers optimization kernel examples the support vector machine allows you to find potential non-linear decision boundaries: svm provides an algorithm that: maps a vector of features to a vector of features of a much higher dimension (manually picking the new features is difficult, that is why we automate it with these types of algorithms) \\begin{align} \\begin{bmatrix} x_1 \\\\ x_2 \\\\ \\end{bmatrix} \\rightarrow \\begin{bmatrix} x_1 \\\\ x_2 \\\\ x_1^2 \\\\ x_2^2 \\\\ x_1\\cdot x_2 \\\\ \\vdots \\end{bmatrix} \\end{align} applies a linear classifier over the high dimensional features (note: if you apply logistic regression to high dimensional vectors then it can learn non-linear decision boundaries) notation labels: \\(y^{(i)} \\in \\{-1, +1\\}\\) now the hypothesis outputs a \\(1\\) or a \\(-1\\), which means: \\begin{align} g(z) = \\begin{cases} 1, & \\text{ if } z \\geq 0 \\\\ 0, & \\text{ otherwise } \\\\ \\end{cases} \\end{align} that is, now instead of a smooth transition of probabilities from zero to one, we have a hard transition between \\(1\\) and \\(-1\\). weights: now the weights \\(\\theta \\in \\mathbb{r}^{(n+1)}\\), where \\(\\theta_0 = 1\\) are divided into: \\(w \\in \\mathbb{r}^{(n)}\\) and \\(b \\in \\mathbb{r}\\). thus we drop the convention of assigning \\(x_0 = 1\\). also now the hypothesis function is defined as: \\(h_{w,b}(x) = g(w^tx + b) = g((\\sum_{i=1}^n w_i x) + b)\\) functional margin functional margin geometric margin geometric margin relationship between functional margin and geometric margin as you may have picked up we can stablish an equality between both margins: \\begin{align} \\gamma^{(i)} = \\frac{\\hat{\\gamma}^{(i)}}{||w||} \\end{align} optimal margin classifier optimal margin classifier svm kernels kernel trick to apply kernels first we will lay out the kernel trick: write the algorithm in terms of the inner products of the training examples \\(\\langle x^{(i)}, x^{(j)} \\rangle=(\\langle x, z \\rangle)\\) let there be a mapping \\(x \\rightarrow \\phi(x)\\), where \\(\\phi(x)\\) is a high dimensional feature vector. find a way to compute \\(k(x, z) = \\phi(x)^t\\phi(z)\\), even if \\(x, z\\) are very high dimensional features vectors (which would be very computationally expensive). where \\(k(x, z)\\) is denoted as the kernel function replace \\(\\langle x, z \\rangle\\) with \\(k(x, z)\\) applying kernels given \\(x, z \\in \\mathbb{r}^n\\), where: \\begin{align} x = \\begin{bmatrix} x_1 \\\\ \\vdots \\\\ x_n \\\\ \\end{bmatrix} \\end{align} we define the mapping \\(\\phi(x) \\in \\mathbb{r}^{n^2}\\) as follows: \\begin{align} \\phi(x) = \\begin{bmatrix} x_ix_i \\\\ \\end{bmatrix} \\end{align} \\(\\forall i, j\\) with \\(1 \\leq i,j \\leq n\\) so we have \\begin{align} k(x, z) = \\phi(x)^t \\phi(z) = \\sum_{i=1}^{n^2} \\phi(x)_i \\phi(z)_i = \\sum_{i=1}^n \\sum_{j=1}^n (x_ix_j) (z_iz_j) \\end{align} which would take \\(o(n^2)\\) time to compute. but, observe that: \\begin{align} (x^tz)^2 = (x^tz)^t(x^tz) = \\sum_{i=1}^n\\sum_{j=1}^n (x_iz_i)(x_jz_j) = \\sum_{i=1}^n\\sum_{j=1}^n (x_ix_j)(z_iz_j) \\end{align} whick takes \\(o(n)\\) time to compute. so we conclude that the kernel can be defined as \\(k(x, z) = (x^tz)^n\\) given \\(x, z \\in \\mathbb{r}^n\\) \\(k(x, z) = (x^tz + c)^2\\) where the mapping function \\(\\phi\\) is defined as: given \\begin{align} x = \\begin{bmatrix} x_1 \\\\ x_2 \\\\ \\end{bmatrix} \\end{align} then: \\begin{align} \\phi(x) = \\begin{bmatrix} x_1x_1 \\\\ x_1x_2 \\\\ x_2x_1 \\\\ x_2x_2 \\\\ \\sqrt{2c}x_1 \\\\ \\sqrt{2c}x_2 \\\\ \\end{bmatrix} \\end{align} given \\(x, z \\in \\mathbb{r}^n\\) \\(k(x, z) = (x^tz+ c)^d\\) where \\(\\phi(x)\\) contains the \\(\\binom{n+d}{d}\\) combinations of monomials of degree d. (note: a monomial of degree 3 could be \\(x_1x_2x_3\\) or \\(x_1x_2^2\\), etc) validity of kernels to test is a kernel is valid we use mercer's theorem that says: k is a valid kernel function (i.e. \\(\\exists \\phi\\) such that \\(k(x, z) = \\phi(x)^t\\phi(z)\\)) if and only if for any \\(d\\) points \\(\\{x^{(1)}, \\cdots , x^{(d)}\\}\\) the corresponding kernel matrix \\(k\\) is positive semi-definite, that is \\(k \\geq 0\\) we are going to prove the first part of this theorem: given examples \\(\\{x^{(1)}, \\cdots , x^{(d)}\\}\\), let \\(k \\in \\mathbb{r}^{d\\times d}\\), be the kernel matrix, such that \\begin{align} k_{ij} = k(x^{(i)}, x^{(j)}) \\end{align} then, if \\(k\\) is a valid kernel: \\begin{align} z^tkz = \\sum_{i=1}^d \\sum_{j=1}^d z_i^t k_{ij} z_j = \\sum_{i=1}^d \\sum_{j=1}^d z_i^t \\phi(x^{(i)})^t \\phi(x^{(j)}) z_j = \\end{align} we expand \\(\\phi(x^{(i)})^t \\phi(x^{(j)})\\) as follows: \\begin{align} = \\sum_{i=1}^d \\sum_{j=1}^d z_i^t \\left[\\sum_{k=1}^d (\\phi(x^{(i)}))_k (\\phi(x^{(j)}))_k\\right] z_j = \\end{align} now, if we rearrange the sums: \\begin{align} = \\sum_{k=1}^d \\left[\\sum_{i=1}^d z_i (\\phi(x^{(i)}))_k\\right]^2 \\end{align} so, because the power of two of any real number is a positive number, and the sum of positive numbers is positive we derive: \\begin{align} \\sum_{k=1}^d \\left[\\sum_{i=1}^d z_i (\\phi(x^{(i)}))_k\\right]^2 \\geq 0 \\end{align} which means that \\(k \\geq 0\\), hence \\(k\\) is a positive, semi-definite matrix generality of the kernel trick the kernel trick can be applied to more algorithms, not only in svm. because, if you have any algorithm written in terms of \\(\\langle x^{(i)}, x^{(j)} \\rangle\\), you can apply the kernel trick to it. some of the algorithms that can be re-written like this are: lineal regression logistic regression gdm pca etc. l1-norm soft margin svm it may be the case where you map your data to a very high dimensional space, but it is still not linearly separable, or the decision boundary becomes too complex: in order to avoid this we will use a modification of the basic algorithm called l1-norm soft margin svm. with this new algorithm the optimization problem becomes \\begin{align} \\underset{w,b,\\xi_i}{min} \\frac{1}{2}||w||^2 + c \\sum_{i=1}^m \\xi_i \\end{align} subject to \\begin{align} y^{(i)}(w^tx^{(i)} + b) \\geq 1 - \\xi_i \\end{align} \\begin{align} \\xi_i \\geq 0, i = 1, \\cdots, m \\end{align} note that if \\(x^{(i)}\\) is classified correctly then \\(y^{(i)}(w^tx^{(i)} + b) \\geq 0\\) and therefore satisfies \\(y^{(i)}(w^tx^{(i)} + b) \\geq 1 - \\xi_i\\), because \\(\\xi_i \\geq 0\\) before the modification, the restriction forced the functional margin to be at least 1, however after the modification, because \\(\\xi_i\\) is positive we relax the restriction. also, we do not want \\(\\xi_i\\) to be too big, that is why it is added to the optimization objective as a cost. graphical representation with the addition of \\(\\xi_i\\) we are allowing some examples to have a functional margin less than 1, by setting \\(\\xi_i \\geq 0\\). for example look at the example \\(x^{(i)}\\) which has \\(\\xi_i = 0.5\\) outliers this relaxation on the restriction upong the geometric margin also avoids the following problem. if you have a lot of data that is linearly separable, but you have one outlier the optimal margin classifier allows for the decision boundary to be drastically changed because its optimization is based on the word performing example (which would be the outlier in this case). thus: however, the l1-norm soft margin svm allows for this example to be classified incorrectly of be close to the decision boundary without changing the boundary which makes it more robuts to outliers. optimization picking up the optimal margin classifier optimization problem, after applying the insight derived from the representer theorem, we have that the only addition needed to implement this algorithm is: \\begin{align} \\underset{\\alpha}{max} \\sum_{i=1}^m \\alpha_i - \\frac{1}{2} \\sum_{i=1}^m\\sum_{j=1}^m y^{(i)}y^{(j)}\\alpha_i\\alpha_j\\langle x^{(i)}, x^{(j)}\\rangle \\end{align} subject to \\begin{align} \\sum_{i=1} y^{(i)}\\alpha_i = 0 \\end{align} \\begin{align} 0 \\leq \\alpha_i \\leq c, i = 1, \\cdots , m \\end{align} the parameter \\(c\\) is a parameter your choose and it determines the level of strictness you want your model to have about some examples being misclassified. kernel examples the gaussian kernel: \\(k(x, z) = \\exp\\left(\\frac{||x-z||^2}{2\\sigma}\\right)\\) linear kernel: \\(k(x, z) = \\phi(x)^t\\phi(z)\\), where \\(\\phi(x) = x\\) polynomial kernel: \\(k(x, z) = (x^tz)^d\\) $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/Grandes Datasets.html",
    "title": "Grandes Datasets",
    "body": " index search search back grandes datasets contents stochastic gradient descent mini batch gradient descent cuando los conjuntos de datos son muy grandes los algoritmos son computacionalmente más caros: varianza elevada: se obtiene mejor rendimiento con más ejemplos. sesgo/bias elevado: se obtiene mejor rendimiento con más características. stochastic gradient descent el algoritmo de stochastic gradient descent es el siguiente: reordenar aleatoriamente el conjunto de datos para cada ejemplo \\(i\\) y cada característica \\(j\\): \\(\\theta_j = \\theta_j - \\alpha (h_\\theta(x^{(i)}) - y^{(i)})x^{(i)}_j\\) es decir, se ajusta \\(\\theta\\) para cada ejemplo, en lugar de hacer el cálculo sobre todo el conjunto de datos cada iteración es más rápida no converge como batch gradient descent, llega a una aproximación. mini batch gradient descent esta técnica lo que hace el utilizar \\(b\\) ejemplos para calcular el gradiente: para cada \\(b\\) ejemplos y cada característica \\(j\\): \\(\\theta_j = \\theta_j - \\alpha \\frac{1}{b}(h_\\theta(x^{(i)}) - y^{(i)})x^{(i)}_j\\) permite vectorización $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/Gradient Checking.html",
    "title": "Gradient Checking",
    "body": " index search search back gradient checking consiste en la estimación numérica de los gradientes, tal que: \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta} \\approx \\frac{j(\\theta - \\epsilon) - j(\\theta + \\epsilon)}{2 \\cdot \\epsilon} \\end{align} \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_j} \\approx \\frac{j(\\theta_0, ..., \\theta_j - \\epsilon, ..., \\theta_n) - j(\\theta_0, ..., \\theta_j + \\epsilon, ..., \\theta_n)}{2 \\cdot \\epsilon} \\end{align} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/Ceiling Analysis.html",
    "title": "Ceiling Analysis",
    "body": " index search search back ceiling analysis supongamos que tenemos un pipeline que conforma todo nuestro sistema de aprendizaje automático y está formado por: obtención de la imagen detección de texto segmentación de caracteres reconocimiento de caracteres lo que hacemos es determinar una o varias métricas de evaluación, por ejemplo nosotros utilizaremos la precisión. entonces, ahora creamos una tabla indicando el valor de métrica para cada parte del sistema así como para el sitema completo: componente precisión detección del texto 82% segmentación de caracteres 90% reconocimiento de caracteres 100% total 72% a partir de esta tabla podemos comprobar que mejorar la detección en el texto y la segmentación de caracteres mejora el rendimiento del modelo. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/NeuralNetworks/Anexo/Partes del algoritmo en python.html",
    "title": "Algoritmo",
    "body": " index search search back algoritmo dado un conjunto de entrenamiento \\(x\\), donde \\(x\\) es una matriz \\((n + 1) \\times m\\) con \\(m\\) ejemplos: propagación hacia adelante def feed_forward(self, theta=none, capa=none, test=false): if theta is none: # si no se introduce theta como argumento theta = self.theta # inicializar theta con el almacenado en el objeto if test: # si se indica utilizar x_test a = self.x_test n, m = self.x_test.shape # guardar dimensiones de test else: a = self.x # la primera entrada es x n, m = self.x.shape # guardar dimensiones de train if capa is not none: # si se ha indicado una capa if capa <= len(theta) and capa >= 0: # chequeamos que la capa esta dentro de los limites for i in range(capa): # recorremos las capas a = self.sigmoid(theta[i], a) # calculamos la salida de la capa a = np.concatenate((np.matrix(np.ones(m)), a)) # añadimos una fila de unos return a else: print(\"el número de capa no es válido\") # mensaje de error else: for elemento in theta: a = self.sigmoid(elemento, a) # calculamos la salida de la capa actual a = np.concatenate((np.matrix(np.ones(m)), a)) # añadimos una fila de unos h = a[1:, :] # eliminamos los 1 en la última capa return h calculo del coste en la última capa def calculo_coste(self, theta=none, unrolled=false): if theta is none: # si no se introduce theta como argumento theta = self.theta # inicializar theta con el almacenado en el objeto if unrolled: # si theta se ha flatten en un vector de una dimension theta = self._roll_theta(theta) # crear lista con matriz theta de capa capa h = self.feed_forward(theta) # obtener la salida para todos los ejemplo coste = -np.sum(np.diagonal(self.y_hot_enc.t.dot(np.log(h)) + (1 - self.y_hot_enc.t).dot(np.log(1 - h))))/self.m # calcular el error con la matriz codificada de y if self.reg: # si se ha indicado que se aplica regularizacion reg_parcial = 0 # inicializamos la variable temporal for elemento in theta: # para capa reg_parcial += np.sum(np.power(elemento[:, 1:], 2)) # no sumar el término independiente en cada nodo: primera fila reg_result = self.reg_par/(2*self.m)*(reg_parcial) # calcular la regularizacion coste = coste + reg_result return coste actualizar los pesos con propagación hacia atrás: def back_propagation(self, theta=none, unrolled=false, unroll=false): if theta is none: # si no se ha indicado ningun theta como argumento theta = self.theta # inicializar theta con el almacenado en el objeto if unrolled: theta = self._roll_theta(theta) # creamos una lista del array delta = [] # inicializamos las lista temporal que contendra el delta de cada nodo delta_sum = [] # inicializamos la lista temporal que contendra el sumatorio delta gradientes = [] # inicializamos la lista que contendrá los gradientes de cada capa h = self.feed_forward(theta=theta) # calculamos el valor del la salida para empezar a propagar hacia atras delta_next = h - self.y_hot_enc # calculamos el primer delta: el de la ultima capa delta.append(delta_next) # lo añadimos a la lista temporal indice = self.numero_capas - 1 # el indice indica hasta que capa calcular la salida for elemento in reversed(theta[1:]): # recorremos las capas de atras hacia adelante h = self.feed_forward(theta=theta, capa=indice) # calculamos la salida de la capa actual delta_aux = np.multiply(elemento.t.dot(delta_next), self.sigmoid_gradient(elemento, h)) # aplicamos la formula del gradiente delta_next = delta_aux[1:, :] # no cogemos el elemento independiente delta.append(delta_next) # lo añadimos a la lista de delta indice -= 1 # actualizamos el indice delta.reverse() # damos la vuelta a la lista for indice in range(len(delta)): h = self.feed_forward(theta=theta, capa=indice) # obtenemos la salida de cada capa delta_sum.append(delta[indice].dot(h.t)) # añadimos (delta * a) a la lista de delta_mayuscula -> sumatorio for indice in range(len(delta_sum)): gradiente = (1/self.m) * delta_sum[indice] # calculamos el grandiente: delta_mayuscula / m if self.reg: gradiente[1:, :] += (self.reg_par/self.m) * theta[indice][1:, :] # si se indica regularizacion aplicarla: no regularizan primer elemento gradientes.append(gradiente) # lo añadimos a la lista coste = self.calculo_coste(theta=theta) if unroll: # si se ha indicado que se quiere hacer flatten a un vector de una dimension return coste, self._unroll_theta(gradientes) else: return coste, gradientes $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/NeuralNetworks/Anexo/Ejemplo Cálculo Función de Coste.html",
    "title": "Ejemplo Cálculo Función de Coste",
    "body": " index search search back ejemplo cálculo función de coste utilizamos como ejemplo la figura de multiclasificación donde tenemos que \\(c=3\\), y la hipótesis tiene los valores: \\begin{align} h_\\theta(x_1) = \\begin{bmatrix} 0.02 \\\\ 0.1 \\\\ 0.88 \\\\ \\end{bmatrix} \\end{align} y la salida real para el ejemplo \\(x_1\\) tiene los valores: \\begin{align} y_1 = \\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\\\ \\end{bmatrix} \\end{align} entonces la función de coste se calcularía como (observa que esto es sólo para un ejemplo, por lo que obviamos el primer sumatorio): \\begin{align} j(\\theta) = - \\sum_{i=1}^c [y_{ij}\\cdot \\log(h_\\theta(x_j)_i)] + [(1-y_{ij})\\cdot \\log(1-(h_\\theta(x_j)_i))] \\end{align} \\begin{align} j(\\theta) = - \\{[(y_{11}\\cdot\\log(h_\\theta(x_1)_{1})) + (1-y_{11})\\cdot\\log(1-h_\\theta(x_1)_{1})] + \\end{align} \\begin{align} + [(y_{21}\\cdot\\log(h_\\theta(x_1)_{2})) + (1-y_{21})\\cdot\\log(1-h_\\theta(x_1)_{2})] + \\end{align} \\begin{align} + [(y_{31}\\cdot\\log(h_\\theta(x_1)_{3})) + (1-y_{31})\\cdot\\log(1-h_\\theta(x_1)_{3})]\\} \\end{align} sustituimos los valores de cada vector: \\begin{align} j(\\theta) = - \\{ [(0\\cdot\\log(0.02)) + (1-0)\\cdot\\log(1-0.02)] + \\end{align} \\begin{align} + [(0\\cdot\\log(0.1)) + (1-0)\\cdot\\log(1-0.1)] + \\end{align} \\begin{align} + [(1\\cdot\\log(0.88)) + (1-1)\\cdot\\log(1-0.88)] \\} = \\end{align} calculamos los valores: \\begin{align} j(\\theta) = - (\\log(0.98) + \\log(0.9) + \\log(0.88)) \\end{align} \\begin{align} j(\\theta) = - (-0.009 - 0.046 -0.056) = - (-0.111) = 0.111 \\end{align} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/NeuralNetworks/Anexo/Derivadas capas intermedias.html",
    "title": "Derivada capas intermedias",
    "body": " index search search back derivada capas intermedias donde \\(q\\) denota la capa, con \\(1 \\leq q \\leq (k-1)\\). pues lo que tenemos que hacer es, de nuevo, aplicar la regla de la cadena, entre el peso \\(\\theta_{it}^{(q)}\\) (peso \\(t\\) del nodo \\(i\\) de la capa \\(q\\)) y todo nodo \\(a_{lj}^{(q+1)}\\)(es decir para el nodo \\(l\\) en la capa \\(q+1\\) para el ejemplo \\(j\\)). \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_{it}^{(q)}} = \\frac{j(\\theta)}{\\delta a^{(q+1)}_{1j}}\\frac{\\delta a_{1j}^{(q+1)}}{\\delta \\theta_{it}^{(q)}} + \\cdots + \\frac{j(\\theta)}{\\delta a^{(q+1)}_{(s_(q+1))j}}\\frac{\\delta a_{(s_(q+1))j}^{(q+1)}}{\\delta \\theta_{it}^{(q)}} \\end{align} donde \\(s_{(q+1)}\\) es el número de nodos en la capa \\(q+1\\). para cada término \\(l\\) de la suma, debemos volver a aplicar la regla de la cadena, tal que: \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_{it}^{(q)}} = \\frac{j(\\theta)}{\\delta a^{(q+1)}_{lj}}\\frac{\\delta a_{lj}^{(q+1)}}{\\delta a_{lj}^{(q)}}\\frac{\\delta a_{lj}^{(q)}}{\\delta \\theta_{it}^{(q)}} \\end{align} es decir: \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_{it}^{(q)}} = \\sum_{l=1}^{s_{(q+1)}} \\frac{j(\\theta)}{\\delta a^{(q+1)}_{lj}}\\frac{\\delta a_{lj}^{(q+1)}}{\\delta a_{lj}^{(q)}}\\frac{\\delta a_{lj}^{(q)}}{\\delta \\theta_{it}^{(q)}} \\end{align} cabe destacar que \\(\\frac{\\delta a_{lj}^{(q)}}{\\delta \\theta_{it}^{(q)}} = \\frac{\\delta g(z_{lj}^{(q)})}{\\delta z_{lj}^{(q)}} \\frac{\\delta z_{lj}^{(q)}}{\\delta \\theta_{it}^{(q)}}\\) (explicado en derivada de la función del coste). entonces, si generalizamos para todos los ejemplos, \\(m\\): \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_{it}^{(q)}} = \\sum_{j=1}^m\\sum_{l=1}^{s_{(q+1)}} \\frac{j(\\theta)}{\\delta a^{(q+1)}_{lj}}\\frac{\\delta a_{lj}^{(q+1)}}{\\delta a_{lj}^{(q)}}\\frac{\\delta a_{lj}^{(q)}}{\\delta \\theta_{it}^{(q)}} \\end{align} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/NeuralNetworks/Anexo/index.html",
    "title": "Anexo",
    "body": " index search search back anexo clasificación múltiple para crear una red neuronal que permita trabajar con \\(c\\) clases lo que hacemos es hacer que la red neuronal tenga \\(c\\) nodos en su capa de salida. esto se ilustra en la siguiente imagen: de tal manera que ahora, cada salida \\(y_j\\) será un vector columna \\(c\\times1\\), donde existe un valor por cada categoría, al igual que la hipótesis para el ejemplo \\(j\\), \\(h_\\theta(x_j)\\), es un vector columna \\(c\\times1\\). como podemos ver, los valores de \\(y_j\\) indican claramente a qué clase pertenece el ejemplo \\(j\\) (clase 3), mientras que la hipótesis \\(h_\\theta(x_j)\\) ofrece, para cada clase (columna) la probabilidad de que el ejemplo \\(j\\) pertenezca a esa clase. función de coste notación como ya hemos visto en función del número de clases la salida tendrá distinta forma: clasificación binaria: para cada ejemplo \\(j\\), \\(y_j \\in \\{0, 1\\}\\), \\(h_\\theta(x_j) \\in \\mathbb{r}\\) clasificación múltiple: para cada ejemplo \\(j\\), \\(y \\in \\mathbb{r}^c\\), \\(h_\\theta(x_j) \\in \\mathbb{r}^c\\), donde \\(c\\) es el número de clases sea \\(k\\) el número de capas y \\(s_i\\) el número de nodos en la capa \\(i\\). sea \\(y=(y_{ij})\\) una matriz \\(c\\times m\\), donde \\(m\\) es el número de ejemplos y cada \\(y_{j}\\) es el vector columna \\(c\\times1\\) de salida para el ejemplo \\(j\\). definimos la función de coste como sigue: \\begin{align} j(\\theta) = - \\frac{1}{m} \\left\\{ \\sum_{j=1}^m \\sum_{i=1}^c [y_{ij}\\cdot \\log(h_\\theta(x_j)_i)] + [(1-y_{ij})\\cdot \\log(1-(h_\\theta(x_j)_i))]\\right\\} \\end{align} el primer sumatorio que va de 1 a \\(m\\) se encarga de calcular el coste para cada ejemplo \\(j\\). mientras que el segundo sumatorio, que va de 1 a \\(c\\), se encarga de calcular el coste para cada nodo de salida. esta función se aplica sobre los \\(k\\) nodos en la capa de salida. ejemplo cálculo función de coste regularización definimos la función de coste introduciendo regularización como sigue: \\begin{align} j(\\theta) = - \\frac{1}{m} \\left\\{ \\sum_{j=1}^m \\sum_{i=1}^c [y_{ij}\\cdot \\log(h_\\theta(x_j)_i)] + [(1-y_{ij})\\cdot \\log(1-(h_\\theta(x_j)_i))]\\right\\} + \\frac{\\lambda}{2m} \\sum_{q=1}^k \\sum_{i=1}^{s_q}\\sum_{j=1}^{s_{q+1}} (\\theta_{ji}^{(q)})^2 \\end{align} antes de nada, recordar que \\(s_q\\) denota el número de nodos en la capa \\(q\\). entonces, el primer término de la función es igual que cuando no se aplicaba regularización. expliquemos el segundo término. la regularización, en este caso, consiste en sumar todos los pesos de la red neuronal, por lo tanto: por cada capa \\(q\\), con \\(1 \\leq q \\leq k\\), sumamos todos los elementos de la matriz de pesos \\(\\theta^{q}\\), que como sabemos tiene dimensiones \\(s_{q} \\times s_{q-1}\\) dada la matriz \\(\\theta^{(q)}\\) recorremos cada columna \\(i\\), con \\(1 \\leq i \\leq s_{q-1}\\) recorremos cada elemento \\(j\\) de la columna \\(i\\), con \\(1 \\leq j \\leq s_{q}\\) sumamos al total cada elemento de la matriz \\(\\theta^{(q)}_{ji}\\) una vez se han sumado todas las matrices de pesos obtenemos un escalar, que multiplicamos por \\(\\frac{\\lambda}{2m}\\) múltiple ejemplos la salida de cada capa \\(q\\) es una matriz \\(s_q \\times m\\), donde \\(s_q\\) denota el número de nodos en la capa \\(q\\) y \\(m\\) denota el número de ejemplos. como vimos en nuestras figuras, donde se presentaban los cálculos sólo para un ejemplo, en cada capa \\(q\\) podemos mapear la salida de los \\(s_q\\) nodos a un vector columna \\(s_q \\times 1\\). si generalizamos esto a \\(m\\) ejemplos tenemos que la salida de cada capa es una matriz \\(s_q \\times m\\). esto se ilustra en la siguiente imagen: retropropagación vamos, ahora a explicar cómo se aplica la retropropagación. lo primero que debemos tener en cuenta es que este proceso se basa en la misma idea de optimización que la regresión lineal y la regresión logística, es decir, lo que queremos hacer es minimizar el coste, \\(j(\\theta)\\) sea \\(c\\) el número de nodos en la última capa, \\(\\theta_{it}\\) el peso \\(t\\) del nodo \\(i\\) de la última capa \\(k\\), \\(a_{ij}^{(k)}\\) la salida del nodo \\(i\\) para el ejemplo \\(j\\) en la capa \\(k\\): calculamos el gradiente de la última capa \\(k\\) como: \\(\\frac{\\delta j(\\theta)}{\\delta \\theta_{it}^{(k)}} = \\frac{\\delta j(\\theta)}{\\delta a_{1j}^{(k)}}\\frac{\\delta a_{1j}^{(k)}}{\\delta \\theta_{it}^{(k)}}\\) calculamos el gradiente en capas intermedias utilizando la regla de la cadena como: \\(\\frac{\\delta j(\\theta)}{\\delta \\theta_{it}^{(q)}} = \\sum_{i=1}^{s_{(q+1)}} \\frac{\\delta j(\\theta)}{\\delta a_{ij}^{(q+1)}}\\frac{\\delta a_{ij}^{(q+1)}}{\\delta a_{ij}^{(q)}}\\frac{\\delta a_{ij}^{(q)}}{\\delta \\theta_{it}^{(q)}}\\) normalmente en las capas intermedias, \\(q\\), nos referimos al término \\(\\frac{\\delta j(\\theta)}{\\delta a_{ij}^{(q+1)}}\\) como \\(\\delta^{(q+1)}_{ij}\\). explicación de la retropropagación derivada de la función de coste a continuación explicamos cómo derivar la función de coste (paso 1). derivada de la función de coste capas intermedias veamos, ahora, cómo llevar a cabo el paso 2: ¿cómo calculamos el gradiente (o lo que contribuye el peso \\(it\\) en el error) para los pesos de las capas intermedias?, es decir, cómo calculamos: \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_{it}^{(q)}} \\end{align} derivadas capas intermedias ejemplo de retropropagación ejemplo de retropropagación algoritmo partes del algoritmo en python notación época: iteración en el entrenamiento pesos (\\(w_j^k, b_j^k\\)): se inicializan de forma aletoria (evitar simetría) y con valores bajos. criterios de finalización \\(j\\) o gradiente de \\(j\\) inferior a un umbral número máximo de épocas velocidad de apredizaje \\(\\mu\\) intermedia: evita lentitud en las oscilaciones caída en mínimos locales que pueden tener \\(j\\) elevado. es por ello que se ejecuta varias veces el entrenamiento y se selecciona aquel que obtenga mejor resultado. actualización de pesos patrón a patrón en lugar de tras computar el error sobre todo el dataset. puede evitar mínimos locales y converge antes. función de activación sigmoide para clasificación o linear para regresión pseudocódigo $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/NeuralNetworks/Anexo/Explicación de la retropropagación.html",
    "title": "Explicación de la retropropagación",
    "body": " index search search back explicación de la retropropagación contents descenso gradiente derivada del error gradiente capa de salida retropropagaci n del gradiente gradiente acumulado derivadas de las funciones de activaci n componentes: \\(w_j^k\\): peso de la neurona \\(j=1...i_k\\) en la capa \\(k=1...h\\) \\(a_{ij}^k=(w_j^k)^th_i^{k-1}+b_j^k\\): \\(i=1...n\\) (patrón), \\(k=1...h\\)(capa), \\(j=1...i_k\\) (neurona de la capa \\(k\\)). \\(h_i^{k-1}\\): salida de la capa \\(k-1\\) con \\(i_{k-1}\\) valores (uno por cada neurona \\(j=1...i_{k-1}\\) para cada patrón \\(x_i\\). \\(h_i^k\\): salida de la capa \\(k\\) para cada patrón \\(x_i\\): \\(h_{ij}=f(a_{ij}^k)\\) con \\(j=1...i_k\\) \\(y_{ij}\\): salida verdadera de la neurona de salida \\(j\\) y el patrón \\(x_i\\). descenso gradiente \\begin{align} \\delta w_j^k=-\\mu \\frac{\\delta j}{\\delta w_j^k} \\end{align} \\begin{align} \\delta b_j^k=-\\mu \\frac{\\delta j}{\\delta b_j^k} \\end{align} para \\(k=1...h\\). de tal forma que se actualizan los pesos \\(w_j^k\\) y el offset \\(b_j^k\\) de la capa \\(k\\) y de la neurona \\(j\\). tenemos que la capa de salida está compuesta de \\(i_h\\) neuronas que se recorren con el índice \\(j\\). accedemos a la salida verdadera del ejemplo \\(i\\) para la neurona \\(j\\) (\\(y_{ij}\\)) y restamos la salida predicha \\(h_{ij}^h\\) que hace referencia a la salida de la función de activación de la capa \\(h\\) para la neurona \\(j\\) y el ejemplo \\(i\\). la diferencia se eleva al cuadrado para obtener mse. también se puede vectorizar restando los vectores \\(y_i\\) y \\(h_i^h \\in \\mathbb{r}^j\\). de esta manera obtenemos el error para el patrón \\(x_i\\): \\(j_i\\). derivada del error aplicamos la regla de la cadena sobre \\(j_i\\), ya que este depende de \\(a_{ij}^k\\): \\begin{align} \\frac{\\delta j_i}{\\delta w_j^k}=\\frac{\\delta j_i}{\\delta a_{ij}^k}\\frac{\\delta a_{ij}^k}{\\delta w_j^k} \\end{align} \\begin{align} \\frac{\\delta j_i}{\\delta b_j^k}=\\frac{\\delta j_i}{\\delta a_{ij}^k}\\frac{\\delta a_{ij}^k}{\\delta b_j^k} \\end{align} definimos: \\begin{align} \\delta_{ij}^k \\equiv \\frac{\\delta j_i}{\\delta a_{ij}^k} \\end{align} este indica el gradiente de la capa siguiente, para evitar tener que calcularlo. \\begin{align} \\frac{\\delta a_{ij}^k}{\\delta w_j^k} = h_i^{k-1} \\end{align} \\begin{align} \\frac{\\delta a_{ij}^k}{\\delta b_j^k} = 1 \\end{align} debido a que el valor de \\(a_{ij}^k\\) es la combinación lineal de la entradas y los pesos, donde las entradas son las salidas de la capa anterior (\\(k-1\\)), es decir \\(h_i^{k-1}\\), de tal manera que: \\begin{align} a_{ij}^k = (w_j^k)^th_i^{k-1}+b_j^k \\end{align} por lo que la derivada en función de \\(w_j^k\\) se corresponde con \\(h_i^{k-1}\\) y la derivada en función de \\(b_j^k\\) es 1. gradiente si sustituimos \\(\\delta_{ij}^k \\equiv \\frac{\\delta j_i}{\\delta a_{ij}^k}\\) y \\(\\frac{\\delta a_{ij}^k}{\\delta w_j^k} = h_i^{k-1}\\) en \\(\\frac{\\delta j_i}{\\delta w_j^k}=\\frac{\\delta j_i}{\\delta a_{ij}^k}\\frac{\\delta a_{ij}^k}{\\delta w_j^k}\\) obtenemos: \\begin{align} \\delta w_j^k=-\\mu \\frac{\\delta j}{\\delta w_j^k} \\end{align} \\begin{align} \\delta w_j^k=-\\mu \\sum_{i=1}^n \\frac{\\delta j_i}{\\delta a_{ij}^k}\\frac{\\delta a_{ij}^k}{\\delta w_j^k} = -\\mu \\sum_{i=1}^n\\delta_{ij}^kh_i^{k-1} \\end{align} hacemos los mismo para el offset sustituyendo \\(\\delta_{ij}^k \\equiv \\frac{\\delta j_i}{\\delta a_{ij}^k}\\) y \\(\\frac{\\delta a_{ij}^k}{\\delta b_j^k} = 1\\) en \\(\\frac{\\delta j_i}{\\delta b_j^k}=\\frac{\\delta j_i}{\\delta a_{ij}^k}\\frac{\\delta a_{ij}^k}{\\delta b_j^k}\\) obtenemos: \\begin{align} \\delta b_j^k=-\\mu \\frac{\\delta j}{\\delta b_j^k} \\end{align} \\begin{align} \\delta b_j^k= -\\mu \\sum_{i=1}^n\\frac{\\delta j_i}{\\delta a_{ij}^k}\\frac{\\delta a_{ij}^k}{\\delta b_j^k}=-\\mu \\sum_{i=1}^n\\delta_{ij}^k \\end{align} capa de salida calculamos \\(\\delta_{ij}^k\\) en la capa de salida (\\(k=h\\)), cuyo valor se va a propagar hacia las capas anteriores. lo que vamos a calcular es \\(\\delta_{ij}^k \\equiv \\frac{\\delta j_i}{\\delta a_{ij}^k}\\). tenemos que la función de coste para el patrón \\(i\\), \\(j_i\\) viene definida por: \\begin{align} j_i=\\frac{1}{2}\\sum_{j=1}^{i_h}(y_{ij}-h_{ij}^h)^2=\\frac{|y_i-h_i^h|^2}{2} \\end{align} además el valor de \\(a_{ij}^k\\), que es la combinación lineal de las entradas (salidas de las neuronas capa anterior, \\(k-1\\)) y los pesos junto con el offset: \\begin{align} a_{ij}^k=(w_j^k)^th_i^{k-1}+b_j^k \\end{align} por lo tanto en la capa final: \\begin{align} \\frac{\\delta j_i}{\\delta a_{ij}^h}=\\frac{1}{2}\\frac{\\delta (y_{ij}-h_{ij}^h)^2}{\\delta (y_{ij}-h_{ij}^h)}\\frac{\\delta (y_{ij}-h_{ij}^h)}{\\delta a_{ij}^h} \\end{align} donde: \\begin{align} \\frac{\\delta (y_{ij}-h_{ij}^h)^2}{\\delta (y_{ij}-h_{ij}^h)}=2(y_{ij}-h_{ij}^h) \\end{align} \\begin{align} \\frac{\\delta (y_{ij}-h_{ij}^h)}{\\delta a_{ij}^h}=\\frac{\\delta y_{ij}}{\\delta a_{ij}^h}-\\frac{\\delta h_{ij}^h}{\\delta a_{ij}^h}=0-f'(a_{ij}^h) \\end{align} ya que sabemos que \\(h_{ij}^h=f(a_{ij}^h)\\), por lo que: \\begin{align} \\frac{\\delta h_{ij}^h}{\\delta a_{ij}^h}=\\frac{\\delta f(a_{ij}^h)}{\\delta a_{ij}^h}=f'(a_{ij}^h) \\end{align} una vez desarrollado todo esto sustiuimos los resultados en \\(\\frac{\\delta j_i}{\\delta a_{ij}^h}\\): \\begin{align} \\frac{\\delta j_i}{\\delta a_{ij}^h}=\\frac{1}{2}2(y_{ij}-h_{ij}^h)(-f'(a_{ij}^h))=(y_{ij}-h_{ij}^h)f'(a_{ij}^h) \\end{align} de tal forma que: \\begin{align} \\delta_{ij}^h=\\frac{\\delta j_i}{\\delta a_{ij}^h}=(y_{ij}-h_{ij}^h)f'(a_{ij}^h)=\\epsilon_{ij}^hf'(a_{ij}^h) \\end{align} donde se define \\(\\epsilon_{ij}^h\\) como: \\begin{align} \\epsilon_{ij}^h=y_{ij}-h_{ij}^h \\end{align} finalmente obtenemos que el antigradiente en la última capa \\(h\\) viene dado por: \\begin{align} \\delta w_j^h=-\\mu \\sum_{i=1}^n\\delta_{ij}^hh_i^{h-1}=-\\mu\\sum_{i=1}^n\\epsilon_{ij}^hf'(a_{ij}^h)h_i^{h-1} \\end{align} \\begin{align} \\delta b_j^h=-\\mu \\sum_{i=1}^n\\delta_{ij}^h=-\\mu\\sum_{i=1}^n\\epsilon_{ij}^hf'(a_{ij}^h) \\end{align} retropropagación del gradiente para las capas anteriores a la capa de salida (\\(k<h\\)): \\begin{align} \\delta_{ij}^k=\\frac{\\delta j_i}{\\delta a_{ij}^k}=\\sum_{l=1}^{i_{k+1}}\\frac{\\delta j_i}{\\delta a_{il}^{k+1}}\\frac{\\delta a_{il}^{k+1}}{\\delta a_{ij}^k}=\\sum_{l=1}^{i_{k+1}}\\delta_{il}^{k+1}\\frac{\\delta a_{il}^{k+1}}{\\delta a_{ij}^k} \\end{align} en este caso se utiliza la regla de la cadena para obtener \\(\\delta_{ij}^k\\) de modo que se tienen en cuenta todas las combinaciones del gradiente acumulado \\(\\delta a_{il}^{k+1}\\) con la neurona actual (\\(\\delta a_{ij}^k\\)) donde \\(l=1...i_{k+1}\\), es decir se tienen encuenta todas las neuronas de la capa siguiente. con grafos, la regla de la cadena se puede interpretar como todos los caminos posibles desde la capa de salida hasta la neurona \\(j\\) en la capa \\(k\\). cada camino une cada neurona \\(l\\) de la capa siguiente: \\(\\delta_{il}^{k+1}\\) (el cual ya tiene el gradiente acumulado de las capas siguientes) con una neurona \\(j\\) de la capa actual: \\(\\delta a_{ij}^k\\) de la siguiente forma: \\(\\delta_{il}^{k+1}\\frac{\\delta a_{il}^{k+1}}{\\delta a_{ij}^k}\\). además se suman todas las combinación posibles: \\(\\sum_{l=1}^{i_{k+1}}\\). esto nos permite utilizar el gradiente acumulado calculado en la capa siguiente que se propaga hacia atrás en la red neuronal, lo que evita tener que calcular \\(\\frac{\\delta j_i}{\\delta a_{ij}^k}\\). por otro lado tenemos: \\begin{align} a_{il}^{k+1}=(w_l^{k+1})^th_i^{k}+b_l^{k+1} \\end{align} que es el cálculo de la neurona \\(l\\) de la capa siguiente, por lo que utiliza como entradas las salidas de la neurona de esta capa \\(h_i^{k}\\). esta es la versión vectorizada del cálculo, si lo expresamos como sumatorio: \\begin{align} a_{il}^{k+1}=\\sum_{m=1}^{i_k}w_{lm}^{k+1}h_{im}^{k}+b_{lm}^{k+1}=\\sum_{m=1}^{i_k}w_{lm}^{k+1}f(a_{im}^{k})+b_{lm}^{k+1} \\end{align} de tal forma que se multiplican los \\(i_k\\) pesos de la capa siguiente (\\(w_{lm}^{k+1}\\)) con las \\(i_k\\) salidas de la capa actual (\\(h_{im}^{k}\\)) y sumamos los offset (\\(b_{lm}^{k+1}\\)). además sabemos que \\(h_{im}^{k}=f(a_{im}^{k})\\). por lo tanto: \\begin{align} \\frac{\\delta a_{il}^{k+1}}{\\delta a_{ij}^k}=\\sum_{m=1}^{i_k}(\\frac{\\delta(w_{lm}^{k+1}f(a_{im}^{k}))}{\\delta a_{ij}^k}+\\frac{\\delta b_{lm}^{k+1}}{\\delta a_{ij}^k}) \\end{align} la primera derivada tiene la siguiente forma: \\begin{align} \\frac{\\delta(w_{lm}^{k+1}f(a_{im}^{k}))}{\\delta a_{ij}^k}=w_{lm}^{k+1}\\frac{\\delta f(a_{im}^{k})}{\\delta a_{ij}^k} \\end{align} \\begin{align} \\frac{\\delta f(a_{im}^{k})}{\\delta a_{ij}^k} =\\begin{cases} f'(a^k_{im})=f'(a^k_{ij}) & m=j\\\\ 0 & m \\ne j \\end{cases} \\end{align} por lo que podemos eliminar el sumatorio sobre \\(m\\) y la derivada sobre el offset ya que su valor es nulo: \\begin{align} \\frac{\\delta a_{il}^{k+1}}{\\delta a_{ij}^k}=w_{lj}^{k+1}f'(a^k_{ij}) + 0 \\end{align} gradiente acumulado si volvemos a \\(\\delta_{ij}^k=\\frac{\\delta j_i}{\\delta a_{ij}^k}=\\sum_{l=1}^{i_{k+1}}\\delta_{il}^{k+1}\\frac{\\delta a_{il}^{k+1}}{\\delta a_{ij}^k}\\). sustituimos \\(\\frac{\\delta a_{il}^{k+1}}{\\delta a_{ij}^k}\\) obteniendo: \\begin{align} \\delta_{ij}^k=\\frac{\\delta j_i}{\\delta a_{ij}^k}=\\sum_{l=1}^{i_{k+1}}\\delta_{il}^{k+1}w_{lj}^{k+1}f'(a^k_{ij}) \\end{align} podemos extraer \\(f'(a^k_{ij})\\) ya que esta no depende de \\(l\\): \\begin{align} \\delta_{ij}^k=f'(a^k_{ij})\\sum_{l=1}^{i_{k+1}}\\delta_{il}^{k+1}w_{lj}^{k+1} \\end{align} si definimos: \\begin{align} \\epsilon_{ij}^k=\\sum_{l=1}^{i_{k+1}}\\delta_{il}^{k+1}w_{lj}^{k+1} \\end{align} tenemos que: \\begin{align} \\delta_{ij}^k=f'(a^k_{ij})\\epsilon_{ij}^k \\end{align} derivadas de las funciones de activación la derivada de la función sigmoide: \\begin{align} f'(t)=af(t)(1-f(t)) \\end{align} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/NeuralNetworks/Anexo/Ejemplo de retropropagación.html",
    "title": "Ejemplo de retropropagación",
    "body": " index search search back ejemplo de retropropagación contents capa 3 capa 2 capa 1 por ejemplo, supongamos que tenemos una red con tres capas, entonces \\(k=3\\), dado un ejemplo \\(x_j\\). en este caso tenemos que capa 3 la derivada en la última capa, para el único vector de pesos \\(\\theta^{(3)}_1\\) que tiene \\(n\\) elementos (features o características), es: \\(\\frac{\\delta j(\\theta)}{\\delta \\theta_{1t}^{(3)}}\\), para cada \\(t\\), \\(0 \\leq t \\leq n\\) como: \\begin{align} j(\\theta) = e^{(3)}(a_1^{(3)}) = e^{(3)}(g(z_1^{(3)})) = e^{(3)}(g(\\theta^{(3)}\\cdot a^{(2)})) \\end{align} donde denotamos la función que calcula el error entre lo predicho y la salida real como \\(e\\), y \\(g\\) es la función de activación. entonces, aplicamos la regla de la cadena para cada elemento \\(t\\) en el vector de pesos: \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_{1t}^{(3)}} = \\frac{\\delta j(\\theta)}{\\delta a_1^{(3)}}\\frac{\\delta a_1^{(3)}}{\\delta z_1^{(3)}}\\frac{\\delta z_1^{(3)}}{\\delta \\theta_{1t}^{(3)}} \\end{align} si vectorizamos: \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_{1}^{(3)}} = \\frac{\\delta j(\\theta)}{\\delta a_1^{(3)}}\\frac{\\delta a_1^{(3)}}{\\delta z_1^{(3)}}\\frac{\\delta z_1^{(3)}}{\\delta \\theta_{1}^{(3)}} \\end{align} capa 2 si ahora queremos obtener la derivada para uno de los vectores de pesos en la capa \\(2\\), volvemos a aplicar la regla de la cadena. tenemos ahora que desestructurar la función de coste todavía más, hasta obtener la expresión que incluye las salidas de la capa \\(1\\), \\(a^{(1)}\\). \\begin{align} j(\\theta) = e^{(3)}(g(\\theta^{(3)}\\cdot a^{(2)})) = e^{(3)}(g(\\theta^{(3)}\\cdot g(z^{(2)}))) = e^{(3)}(g(\\theta^{(3)}\\cdot g(\\theta^{(2)} \\cdot a^{(1)}))) \\end{align} sea \\(\\delta^{(3)}_{1j}\\): \\begin{align} \\delta^{(3)}_{1j} = \\frac{\\delta j(\\theta)}{\\delta a_{1j}^{(3)}}\\frac{\\delta a_{1j}^{(3)}}{\\delta z_{1j}^{(3)}} \\end{align} entonces, aplicamos la regla de la cadena para cada nodo \\(i\\) de la capa \\(2\\) y para cada elemento \\(t\\): \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_{it}^{(2)}} = \\sum_{l=1}^{s_{(3)}} \\delta_{lj}^{(3)}\\frac{\\delta z_{lj}^{(3)}}{\\delta a_{lj}^{(2)}}\\frac{\\delta a_{lj}^{(2)}}{\\delta z_{lj}^{(2)}}\\frac{\\delta z_{lj}^{(2)}}{\\delta \\theta_{it}^{(2)}} = \\delta_{1j}^{(3)}\\frac{\\delta z_{1j}^{(3)}}{\\delta a_{1j}^{(2)}}\\frac{\\delta a_{1j}^{(2)}}{\\delta z_{1j}^{(2)}}\\frac{\\delta z_{1j}^{(2)}}{\\delta \\theta_{it}^{(2)}} \\end{align} si vectorizamos: \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_{i}^{(2)}} = \\delta_{j}^{(3)}\\frac{\\delta z^{(3)}}{\\delta a_{j}^{(2)}}\\frac{\\delta a_{j}^{(2)}}{\\delta z_{j}^{(2)}}\\frac{\\delta z_{j}^{(2)}}{\\delta \\theta_{i}^{(2)}} \\end{align} capa 1 para la capa \\(1\\), volvemos a expandir la función de coste para ver cómo aplicar la regla de la cadena: \\begin{align} j(\\theta) = e^{(3)}(g(\\theta^{(3)}\\cdot g(\\theta^{(2)} \\cdot a^{(1)}))) = e^{(3)}(g(\\theta^{(3)}\\cdot g(\\theta^{(2)} \\cdot g(z^{(1)})))) = \\end{align} \\begin{align} = e^{(3)}(g(\\theta^{(3)}\\cdot g(\\theta^{(2)} \\cdot g(\\theta^{(1)} x_j)))) \\end{align} para simplificar la notación: sea, para cada nodo \\(l\\) de la capa \\(2\\) \\begin{align} \\delta^{(2)}_{lj} = \\delta_{1j}^{(3)}\\frac{\\delta z_1^{(3)}}{\\delta a_{lj}^{(2)}}\\frac{\\delta a_{lj}^{(2)}}{\\delta z_{lj}^{(2)}} \\end{align} aplicamos la regla de la cadena, tal que para cada nodo \\(l\\) de la capa \\(2\\): \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_{it}^{(1)}} = \\sum_{l=1}^{s_{(2)}} \\delta_{lj}^{(2)}\\frac{\\delta z_{lj}^{(2)}}{\\delta a_{lj}^{(1)}}\\frac{\\delta a_{lj}^{(1)}}{\\delta z_{lj}^{(1)}}\\frac{\\delta z_{lj}^{(1)}}{\\delta \\theta_{it}^{(1)}} \\end{align} si vectorizamos: \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_{i}^{(1)}} = \\delta_{j}^{(2)}\\frac{\\delta z_{j}^{(2)}}{\\delta a_{j}^{(1)}}\\frac{\\delta a_{j}^{(1)}}{\\delta z_{j}^{(1)}}\\frac{\\delta z_{j}^{(1)}}{\\delta \\theta_{i}^{(1)}} \\end{align} el procedimiento se ilustra en la siguiente figura: $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/NeuralNetworks/Anexo/Derivada de la función de coste.html",
    "title": "Derivada de la Función de Coste",
    "body": " index search search back derivada de la función de coste contents capa de salida sabemos que la función de coste: \\begin{align} j(\\theta) = - \\frac{1}{m} \\left\\{ \\sum_{j=1}^m\\sum_{i=1}^c (y_{ij}\\cdot \\log(h_\\theta(x_j)_i)) + [(1-y_{ij})\\log(1-h_\\theta(x_j)_i)]\\right\\} \\end{align} donde \\(\\theta_{it}^{(k)}\\) es el peso que conecta el nodo \\(i\\) de la capa \\(k\\) con el nodo \\(t\\) de la capa \\((k-1)\\), es decir, es el elemento en la fila \\(i\\) columna \\(t\\) de la matriz de pesos de la capa \\(k\\), \\(\\theta^{(k)}\\). por la regla de la cadena, separamos la derivada de la función del coste en función de los pesos en dos términos: \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_{it}^{(k)}} = \\sum_{j=1}^m \\sum_{i=1}^c \\frac{\\delta e^{(k)}}{\\delta a_{ij}^{(k)}} \\frac{\\delta a_{ij}^{(k)}}{\\delta \\theta_{it}^{(k)}} \\end{align} capa de salida procedemos a calcular la derivada: \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_{it}^{(k)}} = \\frac{\\delta}{\\delta \\theta_{it}^{(k)}} \\left(- \\frac{1}{m}\\right) \\left\\{ \\sum_{j=1}^m\\sum_{i=1}^c (y_{ij}\\cdot \\log(h_\\theta(x_j)_i)) + [(1-y_{ij})\\log(1-h_\\theta(x_j)_i)]\\right\\} \\end{align} sacamos el término constante de la derivada y aplicamos la propiedad: \"la derivada de una suma equivale a la suma de las derivadas\" \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_{it}^{(k)}} = \\left(- \\frac{1}{m}\\right) \\sum_{j=1}^m\\sum_{i=1}^c \\frac{\\delta}{\\delta \\theta_{it}^{(k)}} \\left\\{(y_{ij}\\cdot \\log(h_\\theta(x_j)_i)) + [(1-y_{ij})\\log(1-h_\\theta(x_j)_i)]\\right\\} \\end{align} sea \\(h_\\theta(x_j) = a^{(k)}_j\\), es decir la salida de la última capa para el ejemplo \\(j\\). \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_{it}^{(k)}} = \\left(- \\frac{1}{m}\\right) \\sum_{j=1}^m\\sum_{i=1}^c \\frac{\\delta}{\\delta \\theta_{it}^{(k)}} \\left\\{(y_{ij}\\cdot \\log(a^{(k)}_{ij})) + [(1-y_{ij})\\log(1-a^{(k)}_{ij})]\\right\\} \\end{align} sacaremos el término \\(y_{ij}\\) de la derivada y juntemos todas las expresiones: \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_{it}^{(k)}} = \\left(- \\frac{1}{m}\\right) \\sum_{j=1}^m\\sum_{i=1}^c \\left\\{y_{ij} \\left(\\frac{\\delta}{\\delta \\theta_{it}^{(k)}} \\log(a^{(k)}_{ij}) \\right) + (1-y_{ij}) \\left(\\frac{\\delta}{\\delta \\theta_{it}^{(k)}} \\log(1-a^{(k)}_{ij})\\right)\\right\\} \\end{align} aplicamos la regla de la cadena sobre el logaritmo: \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_{it}^{(k)}} = \\left(- \\frac{1}{m}\\right) \\sum_{j=1}^m\\sum_{i=1}^c \\left\\{y_{ij} \\left(\\frac{\\delta \\log(a_{ij}^{(k)})}{\\delta a_{ij}^{(k)}} \\frac{\\delta a_{ij}^{(k)}}{\\delta \\theta_{it}^{(k)}} \\right) + (1-y_{ij}) \\left(\\frac{\\delta \\log(1-a^{(k)}_{ij})}{\\delta (1-a^{(k)}_{ij})} \\frac{\\delta (1-a^{(k)}_{ij})}{\\delta \\theta_{it}^{(k)}} \\right)\\right\\} \\end{align} como sabemos: \\(\\frac{\\delta (1)}{\\delta \\theta_{it}^{(k)}} = 0\\), entonces \\(\\frac{\\delta(1-a_{ij}^{(k)})}{\\delta \\theta_{it}^{(k)}} = \\frac{\\delta (1)}{\\delta \\theta_{it}^{(k)}} - \\frac{\\delta a_{ij}^{(k)}}{\\delta \\theta_{it}^{(k)}} = 0 + (-1) \\frac{\\delta a_{ij}^{(k)}}{\\delta \\theta_{it}^{(k)}}\\) entonces \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_{it}^{(k)}} = \\left(- \\frac{1}{m}\\right) \\sum_{j=1}^m\\sum_{i=1}^c \\left\\{y_{ij} \\left(\\frac{\\delta \\log(a_{ij}^{(k)})}{\\delta a_{ij}^{(k)}} \\frac{\\delta a_{ij}^{(k)}}{\\delta \\theta_{it}^{(k)}} \\right) + (1-y_{ij}) \\left((-1)\\frac{\\delta \\log(1-a^{(k)}_{ij})}{\\delta (1-a^{(k)}_{ij})} \\frac{\\delta a^{(k)}_{ij}}{\\delta \\theta_{it}^{(k)}} \\right)\\right\\} \\end{align} sacamos \\(\\frac{\\delta a_{ij}^{(k)}}{\\delta \\theta_{it}^{(k)}}\\) como factor común y aplicamos el \\((-1)\\): \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_{it}^{(k)}} = \\left(- \\frac{1}{m}\\right) \\sum_{j=1}^m\\sum_{i=1}^c \\frac{\\delta a_{ij}^{(k)}}{\\delta \\theta_{it}^{(k)}}\\left\\{y_{ij} \\frac{\\delta \\log(a_{ij}^{(k)})}{\\delta a_{ij}^{(k)}} - \\left((1-y_{ij})\\frac{\\delta \\log(1-a^{(k)}_{ij})}{\\delta (1-a^{(k)}_{ij})} \\right)\\right\\} \\end{align} sustituimos \\(\\frac{\\delta e^{(k)}}{\\delta a_{ij}^{(k)}} = \\left\\{y_{ij} \\frac{\\delta \\log(a_{ij}^{(k)})}{\\delta a_{ij}^{(k)}} - \\left((1-y_{ij})\\frac{\\delta \\log(1-a^{(k)}_{ij})}{\\delta (1-a^{(k)}_{ij})} \\right)\\right\\}\\) \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_{it}^{(k)}} = \\left(- \\frac{1}{m}\\right) \\sum_{j=1}^m\\sum_{i=1}^c \\frac{\\delta e^{(k)}}{\\delta a_{ij}^{(k)}} \\frac{\\delta a_{ij}^{(k)}}{\\delta \\theta_{it}^{(k)}} \\end{align} si resolvemos las derivadas de los logaritmos obtenemos: \\begin{align} \\frac{\\delta e^{(k)}}{\\delta a_{ij}^{(k)}} = y_{ij} \\frac{\\delta \\log(a_{ij}^{(k)})}{\\delta a_{ij}^{(k)}} - (1-y_{ij})\\frac{\\delta \\log(1-a_{ij}^{(k)})}{\\delta (1-a_{ij}^{(k)})} \\end{align} nos centraremos ahora en la derivada que nos falta \\(\\frac{\\delta a_{ij}^{(k)}}{\\delta \\theta_{it}^{(k)}}\\): sabemos que, vectorizando la operación, \\(a^{(k)}_j = g(z^{(k)}_j)\\), donde \\(g\\) es la función de activación (en este caso sigmoide). además: \\begin{align} z^{(k)}_j = \\theta^{k} \\cdot a^{(k-1)}_j \\end{align} por lo tanto, para cada nodo \\(i\\) en la última capa \\(k\\): \\begin{align} z^{(k)}_{ij} = \\sum_{l=1}^{s_{(k-1)}} \\theta^{(k)}_{il} \\cdot a^{(k-1)}_{lj} \\end{align} donde \\(s_{(k-1)}\\) es el número de nodos en la capa \\(k-1\\). entonces, aplicamos de nuevo la regla de la cadena: \\begin{align} \\frac{\\delta a_{ij}^{(k)}}{\\delta \\theta_{it}^{(k)}} = \\frac{\\delta g(z_{ij}^{(k)})}{\\delta z_{ij}^{(k)}} \\frac{\\delta z_{ij}^{(k)}}{\\delta \\theta_{it}^{(k)}} \\end{align} resolvemos la derivada para el segundo término: \\begin{align} \\frac{\\delta z_{ij}^{(k)}}{\\delta \\theta_{it}^{(k)}} = \\sum_{l=1}^{s_{(k-1)}} \\frac{\\delta}{\\delta \\theta_{it}^{(k)}} \\theta^{(k)}_{il} \\cdot a^{(k-1)}_{lj} \\end{align} tal que: \\begin{align} \\frac{\\delta}{\\delta \\theta_{it}^{(k)}} \\theta^{(k)}_{il} \\cdot a^{(k-1)}_{lj} = \\begin{cases} a_{lj}^{(k-1)}, & t = l \\\\ 0, & t \\neq l \\\\ \\end{cases} \\end{align} por lo tanto, como sólo hay un \\(l\\) con \\(l = t\\) donde \\(1 \\leq l \\leq s_{(k-1)}\\), entonces: \\begin{align} \\frac{\\delta z_{ij}^{(k)}}{\\delta \\theta_{it}^{(k)}} = a_{lj}^{(k-1)} = a_{tj}^{(k-1)} \\end{align} juntamos ambos términos de la derivada inicial, con \\(\\frac{\\delta g(z_{ij}^{(k)})}{\\delta z_{ij}^{k}} = \\sigma'(z_{ij}^{(k)})\\) \\begin{align} \\frac{\\delta a_{ij}^{(k)}}{\\delta \\theta_{it}^{(k)}} = \\frac{\\delta g(z_{ij}^{(k)})}{\\delta z_{ij}^{(k)}} \\frac{\\delta z_{ij}^{(k)}}{\\delta \\theta_{it}^{(k)}} = \\sigma'(z_{ij}^{(k)}) a_{tj}^{(k-1)} \\end{align} vamos a resumir lo que tenemos hasta ahora. por la regla de la cadena, separamos la derivada de la función del coste en función de los pesos en dos términos: \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_{it}^{(k)}} = \\sum_{j=1}^m \\sum_{i=1}^c \\frac{\\delta e^{(k)}}{\\delta a_{ij}^{(k)}} \\frac{\\delta a_{ij}^{(k)}}{\\delta \\theta_{it}^{(k)}} \\end{align} si sustituimos ambos términos, para la capa de salida \\(k\\): \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_{it}^{(k)}} = \\left(- \\frac{1}{m}\\right) \\sum_{j=1}^m\\sum_{i=1}^c \\sigma'(z_{ij}^{(k)}) a_{tj}^{(k-1)}\\left\\{ \\frac{y_{ij}}{a_{ij}^{(k)}} - \\left(\\frac{(1-y_{ij})}{(1-a^{(k)}_{ij})} \\right)\\right\\} \\end{align} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/NeuralNetworks/Neural Networks.html",
    "title": "Neural Networks",
    "body": " index search search back neural networks contents architecture algorithm output layer sigmoid softmax relu loss function forward propagation parameters outputs graphical representation optimization problem loss function optimization back-propagation output layer hidden layers vectorization output layer hidden layer graphical representation improving a neural network activation functions initialization techniques vanishing exploding gradients intuition initialization techniques optimization mini batch gradient descent momentum algorithm anexo architecture algorithm output layer forward propagation parameters outputs graphical representation optimization problem loss function optimization back-propagation vectorization improving a neural network activation functions initialization techniques anexo architecture input: given any input \\(x\\) the first thing we do is flatten it. for example if \\(x\\) is a rgb image of \\(64 \\times 64\\), then \\(x \\in \\mathbb{r}^{64 \\times 64 \\times 3}\\) (for each of the \\(64 \\times 64\\) pixels we have three color channels: red, green, blue), is flattened into a vector in \\(\\mathbb{r}^{(64*64*3) \\times 1}\\) neuron: is an operation that has two parts: linear part: we denote the linear part like \\(z^{[i]}\\), where \\(i\\) is the current layer. activation part layer: a layer is a compound of neurons that are not connected with each other. algorithm the principal steps of the algorithm are: initialize the weights \\(w\\) and biases \\(b\\) randomly find the optimal \\(w, b\\) use the optimized \\(w, b\\) to predict the output by using the formula \\(\\hat{y} = \\sigma(wx +b)\\) output layer sigmoid the output layer will be different depending on the problem we are tackling. for example if we want to discriminate between 3 classes then the output layer could be as follows: so now the output is a vector \\(\\hat{y} \\in \\mathbb{r}^{c \\times 1}\\) where \\(c\\) is the number of classes. softmax the previous classifier allows for outputting multiples classes in the result, that is we can obtain a predicted output of the form \\(\\hat{y} = \\begin{bmatrix} 1 \\\\1 \\\\ 0 \\end{bmatrix}\\). what if we want to add a constraint such that only one class can be predicted. then we use the softmax function as the activation function on the output layer: thus, instead of a probability for each class what we obtain is a probability distribution for all the classes. relu on linear regression we do not want the activation function to be linear, because then the whole network becomes a very large linear regression. instead we use as an activation function the relu function (rectified linear unit), whose output is zero if the input value is negative and linear otherwise. loss function the loss function when using the sigmoid function on the output layer is as follows: \\begin{align} \\mathcal{l} = - \\frac{1}{q} \\sum_{k=1}^q [y^{(k)} \\log(\\hat{y}^{(k)}) + (1- y^{(k)})\\log(1-\\hat{y}^{(k)})] \\end{align} where \\(\\hat{y}^{(k)}\\) are the predicted values and \\(q\\) is the total number of neurons on the output layer. however, if we use the softmax function as the activation function on the last layer we have to use a different derivative because this function does depend on the outputs of the other neurons. thus, we make use of a function called cross entropy loss: \\begin{align} \\mathcal{l}_{ce} = - \\sum_{k=1}^q y^{(k)} \\log(\\hat{y}^{(k)}) \\end{align} for linear regression we use as the loss function the l1-norm or the l2-norm. the latter is defined as follows: \\begin{align} \\mathcal{l} = || \\hat{y} - y ||_2^2 \\end{align} forward propagation the forward propagation equations are the following: \\begin{align} z^{[i]} = w^{[i]} a^{[i-1]} + b^{[i]} \\tag{1} \\end{align} where \\(i\\) is the layer with \\(i \\geq 1\\), and the first layer equals the input matrix, that is \\(a^{[0]} = x\\). by applying the activation function over \\((1)\\): \\begin{align} a^{[i]} = g(z^{[i]}) \\end{align} where \\(g\\) is the activation function (e.g \\(\\sigma(z^{[i]})\\)). now, what are the shapes of these matrices? \\(z^{[i]} \\in \\mathbb{r}^{s_i \\times m}\\) \\(a^{[i]} \\in \\mathbb{r}^{s_i \\times m}\\) where \\(s_i\\) is the number of neurons on the ith layer and \\(m\\) is the number of examples. note that the shape of the final layer changes depending on the task. so if \\(k\\) is the number of layers: in linear regression: \\(\\hat{y} = a^{[k]} \\in \\mathbb{r}^{1 \\times m}\\) in multi-class classification: \\(\\hat{y} = a^{[k]} \\in \\mathbb{r}^{c \\times m}\\), where \\(c\\) is the number of classes. also the shape of the weights are \\(w[i] \\in \\mathbb{r}^{s_i \\times s_{i-1}}\\), that is, this matrix is compatible with the outputs of the previous layer (\\(a^{[i-1]} \\in \\mathbb{r}^{s_{i-1} \\times m}\\)) and the linear part of the next layer (\\(z^{[i]} \\in \\mathbb{r}^{s^i \\times m}\\)). however, the bias are \\(b^{[i]} \\in \\mathbb{r}^{s^i \\times 1}\\), therefore we cannot perform an element wise summation because the shape of \\((w^{[i]} a^{[i-1]}) \\in \\mathbb{r}^{s_i \\times m}\\) and \\(b^{[i]}\\) are not compatible. to avoid this problem we apply a technique called broadcasting to \\(b\\), such that we replicate \\(b^{[i]}\\) \\(m\\) times: \\begin{align} \\hat{b}^{[i]} = \\begin{bmatrix} | & | & \\cdots & | \\\\ b^{[i]} & b^{[i]} & \\cdots & b^{[i]} \\\\ | & | & \\cdots & | \\\\ \\end{bmatrix} \\in \\mathbb{r}^{s_i \\times m} \\end{align} to sum up, the shapes of the data and the parameters on each layer \\(i\\) are: parameters \\begin{align} \\hat{b}^{[i]} = \\begin{bmatrix} | & | & \\cdots & | \\\\ b^{[i]} & b^{[i]} & \\cdots & b^{[i]} \\\\ | & | & \\cdots & | \\\\ \\end{bmatrix} \\in \\mathbb{r}^{s_i \\times m} \\end{align} \\begin{align} w^{[i]} = \\begin{bmatrix} | & | & \\cdots & | \\\\ w^{[i](1)} & w^{[i](2)} & \\cdots & w^{[i](s_{i-1})} \\\\ | & | & \\cdots & | \\\\ \\end{bmatrix} \\in \\mathbb{r}^{s_i \\times s_{i-1}} \\end{align} outputs note that for each example \\(j\\) on layer \\(i\\) \\(z^{[i](j)} = (w^{[i]} a^{[i-1](j)} + \\hat{b}^{[i]})\\), then: \\begin{align} z^{[i]} = \\begin{bmatrix} | & | & \\cdots & | \\\\ z^{[i](1)} & z^{[i](2)} & \\cdots & z^{[i](m)} \\\\ | & | & \\cdots & | \\\\ \\end{bmatrix} \\in \\mathbb{r}^{s_i \\times m} \\end{align} \\begin{align} a^{[i]} = \\begin{bmatrix} | & | & \\cdots & | \\\\ g(z^{[i](1)}) & g(z^{[i](2)}) & \\cdots & g(z^{[i](m)}) \\\\ | & | & \\cdots & | \\\\ \\end{bmatrix} \\in \\mathbb{r}^{s_i \\times m} \\end{align} graphical representation now we present a small example of how forward propagation works on neural networks: optimization problem what we want to do is find the parameters \\(w^{[i]}, b^{[i]}\\) for each layer \\(i\\) that minimize the cost. loss function so first of all we define a cost function for the objective \\(\\mathcal{l}(\\hat{y}, y)\\), where \\(\\hat{y}\\) is the predicted output and \\(y\\) is the real output. the cost function will depend on the type of problem (classification, regression). optimization the we optimize the loss function we defined by using backward propagation. for each layer \\(l=1, \\cdots, k\\), where \\(k\\) is the number of layers, we apply batch gradient descent (not mandatory, but here it is convenient as we can vectorize the derivatives) as follows: \\begin{align} w^{[l]} = w^{[l]} - \\alpha \\frac{\\delta \\mathcal{l}(\\hat{y}, y)}{\\delta w^{[l]}} \\end{align} \\begin{align} b^{[l]} = b^{[l]} - \\alpha \\frac{\\delta \\mathcal{l}(\\hat{y}, y)}{\\delta b^{[l]}} \\end{align} back-propagation to compute the derivatives of the cost function with respect to \\(w^{[l]}\\) and \\(b^{[l]}\\) we use the chain rule. output layer suppose we have \\(k\\) layers, then we start by calculating \\(\\frac{\\delta \\mathcal{l}(\\hat{y}, y)}{\\delta w^{[k]}}\\) and \\(\\frac{\\delta \\mathcal{l}(\\hat{y}, y)}{\\delta b^{[k]}}\\), that is, the derivatives on the last layer. thus, to update \\(w^{[k]}\\) (we apply the same logic for \\(b^{[k]}\\)): \\begin{align} \\frac{\\delta \\mathcal{l}(\\hat{y}, y)}{\\delta w^{[k]}} = \\sum_{i=1}^m \\frac{\\delta \\mathcal{l}(\\hat{y^{(i)}}, y^{(i)})}{\\delta w^{[k]}} = \\end{align} because \\(\\hat{y^{(i)}} = (a^{[k]})^{(i)}\\): \\begin{align} = \\sum_{i=1}^m \\frac{\\delta \\mathcal{l}((a^{[k]})^{(i)}, y^{(i)})}{\\delta w^{[k]}} \\end{align} we apply the chain rule on the derivative, therefore: \\begin{align} = \\sum_{i=1}^m \\frac{\\delta \\mathcal{l}((a^{[k]})^{(i)}, y^{(i)})}{\\delta (a^{[k]})^{(i)}} \\frac{\\delta (a^{[k]})^{(i)}}{\\delta w^{[k]}} \\end{align} because \\((a^{[k]})^{(i)} = g((z^{[k]})^{(i)})\\), where \\(g\\) is the activation function: \\begin{align} = \\sum_{i=1}^m \\frac{\\delta \\mathcal{l}((a^{[k]})^{(i)}, y^{(i)})}{\\delta (a^{[k]})^{(i)}} \\frac{\\delta g((z^{[k]})^{(i)})}{\\delta w^{[k]}} \\end{align} we apply the chain rule on the last derivative, therefore: \\begin{align} = \\sum_{i=1}^m \\frac{\\delta \\mathcal{l}((a^{[k]})^{(i)}, y^{(i)})}{\\delta (a^{[k]})^{(i)}} \\frac{\\delta g((z^{[k]})^{(i)})}{\\delta (z^{[k]})^{(i)}} \\frac{\\delta (z^{[k]})^{(i)}}{\\delta w^{[k]}} \\end{align} hidden layers what about the previous layer \\(k-1\\)? \\begin{align} \\frac{\\delta \\mathcal{l}(\\hat{y}, y)}{\\delta w^{[k-1]}} = \\sum_{i=1}^m \\frac{\\delta \\mathcal{l}(\\hat{y^{(i)}}, y^{(i)})}{\\delta w^{[k-1]}} = \\end{align} because \\(\\hat{y^{(i)}} = (a^{[k]})^{(i)}\\): \\begin{align} = \\sum_{i=1}^m \\frac{\\delta \\mathcal{l}((a^{[k]})^{(i)}, y^{(i)})}{\\delta w^{[k-1]}} \\end{align} we apply the chain rule on the derivative, therefore: \\begin{align} = \\sum_{i=1}^m \\frac{\\delta \\mathcal{l}((a^{[k]})^{(i)}, y^{(i)})}{\\delta (a^{[k]})^{(i)}} \\frac{\\delta (a^{[k]})^{(i)}}{\\delta w^{[k-1]}} \\end{align} because \\((a^{[k]})^{(i)} = g((z^{[k]})^{(i)})\\), where \\(g\\) is the activation function: \\begin{align} = \\sum_{i=1}^m \\frac{\\delta \\mathcal{l}((a^{[k]})^{(i)}, y^{(i)})}{\\delta (a^{[k]})^{(i)}} \\frac{\\delta g((z^{[k]})^{(i)})}{\\delta w^{[k-1]}} \\end{align} we apply the chain rule on the last derivative, therefore: \\begin{align} = \\sum_{i=1}^m \\frac{\\delta \\mathcal{l}((a^{[k]})^{(i)}, y^{(i)})}{\\delta (a^{[k]})^{(i)}} \\frac{\\delta g((z^{[k]})^{(i)})}{\\delta (z^{[k]})^{(i)}} \\frac{\\delta (z^{[k]})^{(i)}}{\\delta w^{[k-1]}} \\end{align} \\begin{align} = \\sum_{i=1}^m \\frac{\\delta \\mathcal{l}((a^{[k]})^{(i)}, y^{(i)})}{\\delta (a^{[k]})^{(i)}} \\frac{\\delta (a^{[k]})^{(i)}}{\\delta (z^{[k]})^{(i)}} \\frac{\\delta (z^{[k]})^{(i)}}{\\delta w^{[k-1]}} \\end{align} as you can see the first two derivatives are the same as the derivatives on the layer \\(k\\), let's denote \\((\\delta^{[k]})^{(i)} = \\frac{\\delta \\mathcal{l}((a^{[k]})^{(i)}, y^{(i)})}{\\delta (a^{[k]})^{(i)}} \\frac{\\delta (a^{[k]})^{(i)}}{\\delta (z^{[k]})^{(i)}}\\) the accumulated gradient on layer \\(k\\) for example \\(i\\), then: \\begin{align} = \\sum_{i=1}^m (\\delta^{[k]})^{(i)} \\frac{\\delta (z^{[k]})^{(i)}}{\\delta w^{[k-1]}} \\end{align} because \\((z^{[k]})^{(i)} = w^{[k]} (a^{[k-1]})^{(i)} + b^{[k]}\\): \\begin{align} = \\sum_{i=1}^m (\\delta^{[k]})^{(i)} \\frac{\\delta (w^{[k]} (a^{[k-1]})^{(i)} + b^{[k]})}{\\delta w^{[k-1]}} \\end{align} \\begin{align} = \\sum_{i=1}^m (\\delta^{[k]})^{(i)} \\frac{\\delta (z^{[k-1]})^{(i)}}{\\delta (a^{[k-1]})^{(i)}} \\frac{\\delta (a^{[k-1]})^{(i)}}{\\delta w^{[k-1]}} \\end{align} because \\((a^{[k-1]})^{(i)} = g((z^{[k-1]})^{(i)})\\) \\begin{align} = \\sum_{i=1}^m (\\delta^{[k]})^{(i)} \\frac{\\delta (z^{[k-1]})^{(i)}}{\\delta (a^{[k-1]})^{(i)}} \\frac{\\delta g((z^{[k-1]})^{(i)})}{\\delta (z^{[k-1]})^{(i)}} \\frac{\\delta (z^{[k-1]})^{(i)}}{\\delta w^{[k-1]}} \\end{align} we apply the chain rule on the last derivative, hence: \\begin{align} = \\sum_{i=1}^m (\\delta^{[k]})^{(i)} \\frac{\\delta (z^{[k-1]})^{(i)}}{\\delta (a^{[k-1]})^{(i)}} \\frac{\\delta g((z^{[k-1]})^{(i)})}{\\delta (z^{[k-1]})^{(i)}} \\frac{\\delta (z^{[k-1]})^{(i)}}{\\delta w^{[k-1]}} \\end{align} \\begin{align} = \\sum_{i=1}^m (\\delta^{[k]})^{(i)} \\frac{\\delta (z^{[k-1]})^{(i)}}{\\delta (a^{[k-1]})^{(i)}} \\frac{\\delta (a^{[k-1]})^{(i)}}{\\delta (z^{[k-1]})^{(i)}} \\frac{\\delta (z^{[k-1]})^{(i)}}{\\delta w^{[k-1]}} \\end{align} vectorization output layer accumulated gradient for layer \\(k\\): \\(\\delta_w^{[k]} = \\frac{\\delta \\mathcal{l}(\\hat{y}, y)}{\\delta a^{[k]}} \\frac{\\delta a^{[k]}}{\\delta z^{[k]}}\\) gradient for layer \\(k\\): \\(\\frac{\\delta \\mathcal{l}(\\hat{y}, y)}{\\delta w^{[k]}} = \\delta_w^{[k]} \\frac{\\delta z^{[k]}}{\\delta w^{[k]}}\\) hidden layer accumulated gradient for layer \\(k-1\\): \\(\\delta_w^{[k-1]} = \\delta_w^{[k]} \\frac{\\delta z^{[k]}}{\\delta a^{[k-1]}} \\frac{\\delta a^{[k-1]}}{\\delta z^{[k-1]}}\\) gradient for layer \\(k-1\\): \\(\\frac{\\delta \\mathcal{l}(\\hat{y}, y)}{\\delta w^{[k-1]}} = \\delta_w^{[k-1]} \\frac{\\delta z^{[k-1]}}{\\delta w^{[k-1]}}\\) graphical representation on the following image we show how to obtain the gradient of the first element of the first layer's first neuron's weights \\(w^{[1]}_{11}\\) on the first layer: improving a neural network activation functions why do we need activation functions? well, suppose you have the following network where the activation function is the identity function. that is \\(a^{[i]} = g(z^{[i]}) = z^{[i]}\\): then: \\begin{align} \\hat{y} = a^{[3]} = z^{[3]} = w^{[3]} a^{[2]} + b^{[3]} = w^{[3]} z^{[2]} + b^{[3]} = w^{[3]} (w^{[2]} a^{[1]} + b^{[2]}) + b^{[3]} \\end{align} \\begin{align} = w^{[3]} (w^{[2]} z^{[1]} + b^{[2]}) + b^{[3]} = w^{[3]} (w^{[2]} (w^{[1]} x + b^{[1]}) + b^{[2]}) + b^{[3]} \\end{align} \\begin{align} = w^{[3]} (w^{[2]} w^{[1]} x + w^{[2]} b^{[1]} + b^{[2]}) + b^{[3]} \\end{align} \\begin{align} = w^{[3]} w^{[2]} w^{[1]} x + w^{[3]} w^{[2]} b^{[1]} + w^{[3]} b^{[2]} + b^{[3]} \\end{align} if \\begin{align} w = w^{[3]} w^{[2]} w^{[1]} \\end{align} \\begin{align} b = w^{[3]} w^{[2]} b^{[1]} + w^{[3]} b^{[2]} + b^{[3]} \\end{align} then: \\begin{align} \\hat{y} = wx + b \\end{align} as you can see if we do not use activation functions, it does not mater how deep your network is, it is going to be equivalent to a linear regression. depending on the task at hand we use different activation functions: sigmoid: \\(\\sigma(z) = \\frac{1}{1 + e^{-z}}\\), it maps \\(z \\in (-\\infty, \\infty)\\) to \\((0, 1)\\) it is good for classification works well when the values are in the linear region of the function however when the values are on the extremes the gradient (slope) is very small, therefore it ends up vanishing in the network. relu: \\(relu(z) = \\begin{cases}0 & z \\leq 0 \\\\ 1 & z > 0\\end{cases}\\) tanh: \\(tanh(z) = \\frac{e^z - e^{-z}}{(e^z + e^{-z})}\\) initialization techniques usually we normalize the input to avoid having saturated activation functions. to normalize: \\begin{align} x^{(i)}_j = \\frac{x^{(i)}_j - \\mu_j}{\\sigma_j} \\end{align} for every example \\(i\\) and feature \\(j\\). where: \\(\\mu_j\\) is the mean of the \\(j\\) feature, thus: \\(\\mu_j = \\frac{1}{m} \\sum_{i=1}^m x^{(i)}_j\\) \\(\\sigma_j^2\\) is the variance of the \\(j\\) feature, thus: \\(\\sigma_j^2 = \\frac{1}{m} \\sum_{i=1}^m (x^{(i)}_j - \\mu_j)^2\\) vanishing/exploding gradients suppose you have the following network, where the activation function is the identity function and \\(b=0\\). then \\(\\hat{y} = w^{[l]} a^{[l-1]} = w^{[l]} w^{[l-1]} a^{[l-2]} = \\cdots = w^{[l]} w^{[l-1]} \\cdots w^{[1]} x\\) therefore, if: \\begin{align} w^{[l]} = \\begin{bmatrix} 1.5 & 0 \\\\ 0 & 1.5 \\\\ \\end{bmatrix} \\end{align} then: \\begin{align} \\hat{y} = \\begin{bmatrix} 1.5^l & 0 \\\\ 0 & 1.5^l \\\\ \\end{bmatrix} \\end{align} which means we end up with an exploding gradient. the inverse happens when: \\begin{align} w^{[l]} = \\begin{bmatrix} 0.5 & 0 \\\\ 0 & 0.5 \\\\ \\end{bmatrix} \\end{align} then: \\begin{align} \\hat{y} = \\begin{bmatrix} 0.5^l & 0 \\\\ 0 & 0.5^l \\\\ \\end{bmatrix} \\end{align} which results in a vanishing gradient. to avoid this somewhat, we need to initialize the weights properly. what we want is for the weights to be very close to one to avoid the exploding/diminishing problem. intuition given a single neuron: then \\(a = g(z)\\) and \\(z = w_1 x_1 + \\cdots + w_n x_n\\). we can see that \\(z\\) will increase if \\(n\\) increases, therefore we would want \\(w_i\\) to be as small as \\(n\\) is large, that is: \\begin{align} w_i = \\frac{1}{n} \\end{align} initialization techniques if we want the value of \\(w^{[l]}\\) to be proportional to the number of inputs coming from the layer \\(l\\) (\\(n^{[l-1]}\\)). it works very well for sigmoid activation: w[k] = np.random.randn(shape)*np.sqrt(1/n[l-1]) for relu: w[k] = np.random.randn(shape)*np.sqrt(2/n[l-1]) xavier initialization (used with tanh): \\(w^{[l]} \\sim \\sqrt{\\frac{1}{n^{[l-1]}}}\\) her initialization: \\(w^{[l]} \\sim \\sqrt{\\frac{2}{n^{[l]} + n^{[l-1]}}}\\) also you need to initialize the weights randomly, else you will run into the symmetry problem, where all neurons learn the same thing (that is they update very similarly). optimization mini batch gradient descent mini batch gradient descent is a trade off between batch gradient descent and stochastic gradient descent. also, because mini batch gradient descent is an approximation it introduces some noise on the loss function: however mini batch gradient descent is more used because batch gradient descent can be very computationally expensive. momentum algorithm this algorithm combines gradient descent and momentum. suppose you have the following contour plot, where the horizontal axis is much more extended that the vertical axis. by default on gradient descent the gradient of the loss will be orthogonal to the contour at the given point, as we can see: however, what we would like, so it would converge faster, is to make it move more horizontally than vertically. in order to do that we use a technique called momentum. it takes intro account past updates to find the right way to go. if you take an average of past updates, then: vertical axis: it practically cancels itself because it oscillates a lot horizontal axis: its value it's maintained because the past and present gradients go in the same direction to update the weights we apply the following equation: \\begin{align} \\upsilon = \\beta \\upsilon + (1 - \\beta) \\frac{\\delta \\mathcal{l}(\\hat{y}, y)}{\\delta w} \\end{align} where: \\(\\upsilon\\): stores past updates \\(\\frac{\\delta \\mathcal{l}(\\hat{y}, y)}{\\delta w}\\): stores the current update we average with \\(\\beta\\) and \\((1 - \\beta)\\) finally we update the weights: \\begin{align} w = w - \\alpha \\upsilon \\end{align} anexo for more info about cost function and how to derive them: anexo $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/Ecuación Normal.html",
    "title": "Ecuación Normal",
    "body": " index search search back ecuación normal contents descripci n de los datos hip tesis funcion de coste regularizaci n minimizaci n del coste regularizaci n anotaciones descripción de los datos \\(x = (x_{ij})\\) una matriz \\(m \\times (n + 1)\\) donde cada \\(x_{i}\\) es un vector fila \\(1 \\times (n+1)\\), que incluye los valores de todas las características para el ejemplo \\(i\\). \\begin{align} x = \\begin{bmatrix} x_1 \\\\ \\vdots \\\\ x_i \\\\ \\vdots \\\\ x_m \\\\ \\end{bmatrix} \\end{align} cabe destacar que \\(x_{i0} = 1\\), es el término independiente. \\(\\theta = (\\theta_i)\\) es un vector columna \\((n+1)\\times 1\\) donde cada \\(\\theta_i\\) es el peso de la característica \\(i\\), tal que: \\begin{align} \\theta = \\begin{bmatrix} \\theta_0 \\\\ \\vdots \\\\ \\theta_n\\end{bmatrix} \\end{align} \\(y = (y_j)\\) es un vector columna \\(m\\times 1\\) donde cada \\(y_j\\) es la salida real para el ejemplo \\(j\\), tal que: \\begin{align} y = \\begin{bmatrix} y_1 \\\\ \\cdots \\\\ y_m\\end{bmatrix} \\end{align} hipótesis dado un conjunto de \\(m\\) datos, es decir matriz \\(x\\), de dimensiones \\(m \\times (n+1)\\), la hipótesis se define como: \\begin{align} h_\\theta(x) = x \\cdot \\theta = \\begin{bmatrix} x_1 \\cdot \\theta = \\sum_{i=0}^{n+1} \\theta_i x_{1i} \\\\ \\vdots \\\\ x_j \\cdot \\theta = \\sum_{i=0}^{n+1} \\theta_i x_{ji} \\\\ \\vdots \\\\ x_m \\cdot \\theta = \\sum_{i=0}^{n+1} \\theta_i x_{mi} \\\\ \\end{bmatrix} \\end{align} observa que ahora \\(x\\) y \\(\\theta\\) están colocados de forma inversa a como lo hacíamos en la regresión lineal y la regresión logística. esto es debido a que hemos transpuesto las matrices \\(x\\) y \\(\\theta\\), con respecto a como las habíamos definido en las secciones anteriores. el cálculo es el mismo. funcion de coste se define la función de coste, \\(j(\\theta)\\) como: \\begin{align} j(\\theta) = \\frac{1}{2m} (x\\theta - y)^t(x\\theta - y) \\end{align} la expresión \\((x\\theta - y)^t(x\\theta - y)\\) es equivalente a \\((h_\\theta(x) - y)^2\\), que se utilizaba en la función de coste de la regresión lineal. regularización con regularización, se define la función de coste, \\(j(\\theta)\\) como: \\begin{align} j(\\theta) = \\frac{1}{2m} (x\\theta - y)^t(x\\theta - y) + \\frac{1}{2m} \\lambda \\theta^t\\theta \\end{align} minimización del coste con la ecuación normal, en lugar de actualizar el vector de pesos \\(\\theta\\) de forma iterativa, lo que hacemos es igualar la derivada del coste en base a los pesos a cero utilizando derivación matricial: \\begin{align} \\delta_\\theta j(\\theta) = \\begin{bmatrix} \\frac{\\delta j(\\theta)}{\\delta \\theta_0} \\\\ \\vdots \\\\ \\frac{\\delta j(\\theta)}{\\delta \\theta_i} \\\\ \\vdots \\\\ \\frac{\\delta j(\\theta)}{\\delta \\theta_n} \\\\ \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ \\vdots \\\\ 0 \\\\ \\vdots \\\\ 0 \\\\ \\end{bmatrix} = \\overrightarrow{0} \\end{align} a continuación exponemos cómo se calcula la derivada: sustituímos la función de coste: \\begin{align} \\delta_\\theta j(\\theta) = \\delta_\\theta \\frac{1}{2m}(x \\theta - y)^t (x \\theta - y) \\end{align} aplicamos la propiedad \\((a + b)^t = a^t + b^t\\) \\begin{align} \\delta_\\theta j(\\theta) = \\delta_\\theta \\frac{1}{2m}((x\\theta)^t - y^t) (x \\theta - y) \\end{align} sacamos el factor constante de la derivada y realizamos la multiplicación: \\begin{align} \\delta_\\theta j(\\theta) = \\frac{1}{2m} \\delta_\\theta (x\\theta)^t(x\\theta) - (x\\theta)^ty -y^tx\\theta + y^ty \\end{align} aplicamos la propiedad \\(ab = b^ta^t\\), tal que \\(y^t(x\\theta) = (x\\theta)^t((y)^t)^t = (x\\theta)^ty\\) \\begin{align} \\delta_\\theta j(\\theta) = \\frac{1}{2m} \\delta_\\theta (x\\theta)^t(x\\theta) - (x\\theta)^ty - (x\\theta)^ty + y^ty \\end{align} agrupamos términos compatibles: \\begin{align} \\delta_\\theta j(\\theta) = \\frac{1}{2m} \\delta_\\theta (x\\theta)^t(x\\theta) - 2(x\\theta)^ty + y^ty \\end{align} como \\(\\delta_\\theta y^ty=0\\): \\begin{align} \\delta_\\theta j(\\theta) = \\frac{1}{2m} \\delta_\\theta (x\\theta)^t(x\\theta) - 2(x\\theta)^ty \\end{align} finalmente calculamos la derivada matricial: \\begin{align} \\delta_\\theta j(\\theta) = \\frac{1}{2m} 2x^t(x\\theta) - 2x^ty = \\frac{1}{m} x^t(x\\theta) - x^ty \\end{align} ahora igualamos la expresión obtenida a cero: \\begin{align} \\delta_\\theta j(\\theta) = \\frac{1}{m} [x^tx\\theta - x^ty] = 0 \\end{align} multiplicamos por \\(m\\) en ambos lados de la ecuación: \\begin{align} x^tx\\theta - x^ty = 0 \\end{align} sumamos \\(x^ty\\) en ambos lados de la ecuación: \\begin{align} x^tx\\theta - x^ty + x^ty= x^ty \\end{align} \\begin{align} x^tx\\theta = x^ty \\end{align} multiplicamos por \\((x^tx)^{-1}\\) por la izquierda en ambos lados de la ecuación: \\begin{align} (x^tx)^{-1}x^tx\\theta = (x^tx)^{-1}x^ty \\end{align} \\begin{align} i\\theta = (x^tx)^{-1}x^ty \\end{align} \\begin{align} \\theta = (x^tx)^{-1}x^ty \\end{align} de tal manera que ahora hemos calculado el vector de pesos óptimo que minimiza el coste. regularización con regularización debemos derivar la función que coste que incluye el parámetro de regularización: \\begin{align} j(\\theta) = \\frac{1}{2m} (x\\theta - y)^t(x\\theta - y) + \\frac{1}{2m} \\lambda \\theta^t\\theta \\end{align} el primer término ya lo hemos derivado, por lo tanto procedemos a derivar el segundo término: \\begin{align} \\delta_\\theta \\frac{1}{2m} \\lambda \\theta^t\\theta \\end{align} sacamos el factor constante \\(\\frac{\\lambda}{2m}\\) fuera de la derivada \\begin{align} \\frac{\\lambda}{2m} \\delta_\\theta [\\theta^t\\theta] \\end{align} llevamos a cabo la derivada matricial: \\begin{align} \\frac{\\lambda}{2m} 2 \\theta = \\frac{\\lambda}{m} \\theta \\end{align} juntamos las derivadas de ambos términos: \\begin{align} \\delta_\\theta j(\\theta) = \\frac{1}{m} [x^tx\\theta - x^ty] + \\frac{\\lambda}{m} \\theta \\end{align} sacamos \\(\\frac{1}{m}\\) como factor común e igualamos a cero \\begin{align} \\delta_\\theta j(\\theta) = \\frac{1}{m} (x^tx\\theta - x^ty + \\lambda\\theta) = 0 \\end{align} multiplicamos por \\(m\\) en ambos lados de la ecuación: \\begin{align} x^tx\\theta - x^ty + \\lambda\\theta = 0 \\end{align} sumamos \\(x^ty\\) en ambos lados de la ecuación: \\begin{align} x^tx\\theta - x^ty + x^ty + \\lambda\\theta = x^ty \\end{align} \\begin{align} x^tx\\theta + \\lambda\\theta = x^ty \\end{align} sacamos \\(\\theta\\) como factor común \\begin{align} (x^tx + \\lambda i)\\theta = x^ty \\end{align} donde \\(i\\) es la matriz identidad e dimensiones \\((n+1) \\times (n+1)\\). multiplicamos \\((x^tx + \\lambda i)^{-1}\\) por la izquierda en ambos lados de la ecuación: \\begin{align} (x^tx + \\lambda i)^{-1}(x^tx + \\lambda i)\\theta = (x^tx + \\lambda i)^{-1}x^ty \\end{align} \\begin{align} i\\theta = (x^tx + \\lambda i)^{-1}x^ty \\end{align} \\begin{align} \\theta = (x^tx + \\lambda i)^{-1}x^ty \\end{align} de tal forma que hemos calculado el \\(\\theta\\) óptimo que minimiza el coste, utilizando regularización. anotaciones no se debe utilizar la ecuación normal cuando el número de ejemplos \\(m\\) es muy grande, ya que es rendimiento del algoritmo es malo hay que tener cuidado con si las matrices son inversibles si \\(m \\leq n\\), entonces las matrices no son invertibles. si \\(\\lambda > 0\\), entonces aseguramos la inversibilidad de las matrices. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/index.html",
    "title": "Machine Learning Stanford Coursera",
    "body": " index search search back machine learning stanford coursera apredizaje supervisado regresión lineal regresión logística ecuación normal neural networks gradient checking inicialización aleatoria evaluación de modelos svm aprendizaje no supervisado en el aprendizaje no supervisado, los ejemplos de entrenamiento no tienen etiquetas (\\(y\\)). se utilizan para buscar correlación y patrones en los ejemplos de entrenamiento. clustering dimensionality reduction expectation-maximization algorithms sistemas de recomendación grandes datasets aprendizaje online map reduce datos artificiales ceiling analysis $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/Aprendizaje Online.html",
    "title": "Aprendizaje Online",
    "body": " index search search back aprendizaje online contents ejemplo en estos tipos de problemas se generan datos de forma continua, tal que para cada nuevo dato: obtenemos \\((x, y)\\) actualizamos \\(\\theta\\) utilizando el nuevo ejemplo: \\(\\theta_j = \\theta_j - \\alpha (h_\\theta(x) - y)x_j\\) ejemplo aprender a buscar. supongamos que lo queremos aprender es aquellos resultados que le interesen más al usuario. si tenemos los siguientes datos: \\(x\\): características del producto \\(y\\): si el usuario hace click entonces, lo que queremos aprender es \\(p(y= 1|x;\\theta)\\), tal que por ejemplo enseñemos los 10 productos cuya probabilidad es mayor. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/Datos Artificiales.html",
    "title": "Datos Artificiales",
    "body": " index search search back datos artificiales cómo podemos generar datos? manualmente modificando los datos de entrada (añadir ruido en sonido, distorsionar imagen, etc) no obstante, debemos evitar añadir ruido aleatorio, ya que esto no ayuda a extraer características significativas del conjunto de datos. estos métodos se suelen utilizar si el modelos tiene un sesgo bajo y se produce underfitting, (por lo que hace falta añadir características). $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/Inicialización aleatoria.html",
    "title": "Inicialización aleatoria",
    "body": " index search search back inicialización aleatoria cuando creamos una red neuronal, si inicializamos todos los pesos \\(\\theta\\) a cero, entonces todos los nodos serán iguales. por ello se inicializa \\(\\theta\\) con valores aleatorios dentro de un rango \\([- \\epsilon, \\epsilon]\\) $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/DimensionalityReduction/Dimensionality Reduction.html",
    "title": "Dimensionality Reduction",
    "body": " index search search back dimensionality reduction contents standardize data pca find underlying space represent the subspace algorithm layout performing eigen-decomposition large datasets rephrasing pca ica intuition solution intuition given examples \\(\\{x^{(i)}\\}_{i=1}^n\\) where \\(x^{(i)} \\in \\mathbb{r}^d\\), we want to find out if our data lives is a low dimensional space. look at the next example: we can see that the two features are correlated, and we can project the points onto a line, reducing the space from two dimensions to one. so it might be the case that some features are highly correlated, and so de d-dimensional space can be as a k-dimensional space where \\(0 < k < d\\): \\begin{align} \\begin{bmatrix} x_{11} & \\cdots & x_{1d} \\\\ \\vdots & \\ddots & \\vdots \\\\ x_{n1} & \\cdots & x_{nd} \\\\ \\end{bmatrix} \\rightarrow \\begin{bmatrix} x_{11} & \\cdots & x_{1k} \\\\ \\vdots & \\ddots & \\vdots \\\\ x_{n1} & \\cdots & x_{nk} \\\\ \\end{bmatrix} \\end{align} standardize data a lot of the times the units of each feature in the data make the values in one column (feature) be much bigger than the values in another column. thus, the first step is to standardize your data: center data have it have variance equal to one so we transform our data as follows: \\begin{align} x_j^{(i)} = \\frac{x_j^{(i)} - \\mu_j}{\\sigma_j} \\end{align} where: \\(u_j\\) is the mean of the feature \\(j\\) over the \\(n\\) examples, such that \\(u_j = \\frac{1}{n}\\sum_{i=1}^nx^{(i)}_j\\) \\(\\sigma_j\\) is the standard deviation of the feature \\(j\\) over the \\(n\\) examples, where \\(\\sigma_j^2 = \\frac{1}{n}\\sum_{i=1}^n(x^{(i)}_j - \\mu_j)^2\\) pca find underlying space to reduce the dimensionality of our data we first define a subspace and then we project each point onto the subspace. this projection is the closes point in the subspace to the point we are trying to project, this has as a consequence that the \"line\" connecting the point to its projection is always perpendicular to the subspace: the goal is to choose the subspace that maximizes the variance of the projected points, to retain the maximum possible variance of the data. as you can see if we choose the blue line as the subspace the variance is much bigger that if we choose the red line: represent the subspace let us suppose the subspace is defined by a basis vector \\(u \\in \\mathbb{r}^d\\) where \\(u\\) is a unit vector, then projection of \\(\\overrightarrow{x^{(i)}}\\) on to the space spanned by \\(u\\) will be: \\begin{align} proj(u)\\overrightarrow{x^{(i)}} \\end{align} where \\(proj(u)\\) is the projection matrix and \\(x^{(i)} \\in \\mathbb{r}^d\\). so, because \\(proj(u) = \\frac{uu^t}{u^tu}\\), then the projected point is defined as: \\begin{align} proj(u)\\overrightarrow{x^{(i)}} = \\frac{uu^t}{u^tu} \\overrightarrow{x^{(i)}} = ((x^{(i)})^tu)u \\end{align} where \\(((x^{(i)})^tu)\\) is an scalar. so, now our goal is to find a \\(u\\) that maximizes the variance across the \\(n\\) examples. that is, we want to maximize the sum of the square of the norms of the projected points: more formally: \\begin{align} u = \\underset{u}{\\arg \\max} \\frac{1}{n}\\sum_{i=1}^n ||proj(u)x^{(i)}||^2 = \\frac{1}{n}\\sum_{i=1}^n ||((x^{(i)})^tu)u||^2 \\end{align} because the norm of a unit vector multiplied by a scalar is just the square of the scalar (for \\(3 \\cdot \\begin{pmatrix} 1 & 0 & 0 \\end{pmatrix}\\): \\(||\\begin{pmatrix} 3 & 0 & 0 \\end{pmatrix}|| = (\\sqrt{3^2 + 0^2 + 0^2})^2 = 3^2\\)): \\begin{align} u = \\underset{u}{\\arg \\max} \\frac{1}{n}\\sum_{i=1}^n ((x^{(i)})^tu)^2 = \\frac{1}{n}\\sum_{i=1}^n ((x^{(i)})^tu)^t((x^{(i)})^tu) = \\frac{1}{n}\\sum_{i=1}^n u^t x^{(i)} (x^{(i)})^t u \\end{align} because \\(u, u^t\\) are a common factor in the sum: \\begin{align} u = \\underset{u}{\\arg \\max} \\left[u^t \\left(\\frac{1}{n}\\sum_{i=1}^n x^{(i)} (x^{(i)})^t \\right) u\\right] \\end{align} now, we know that given the optimization problem of the form \\(\\underset{u}{\\arg \\max} \\left[u^t a u\\right]\\), the solution \\(u\\) is the eigenvector corresponding to the largest eigenvalue of \\(a\\). in this scenario, \\(a = \\left(\\frac{1}{n}\\sum_{i=1}^n x^{(i)} (x^{(i)})^t \\right)\\), which equals the sample covariance matrix, which is defined as: \\begin{align} \\frac{1}{n} \\sum_{i=1}^n (x^{(i)} - \\mu)^t (x^{(i)} - \\mu) = \\frac{1}{n} \\sum_{i=1}^n (x^{(i)} - 0)^t (x^{(i)} - 0) = \\frac{1}{n} \\sum_{i=1}^n (x^{(i)})^t x^{(i)} \\end{align} note that, because our data is now centered after standardizing it, the mean \\(\\mu\\) equals zero. hence, we want to calculate the eigenvectors of the sample covariance matrix of x. mind you, we have derived this solution for a space defined by only one vector \\(u\\). however given basis vectors \\((u_1, \\cdots, u_k)\\) the optimization problem holds and the solution are the \\(k\\) eigenvectors corresponding to the \\(k\\) largest eigenvalues of \\(a\\). algorithm layout the steps of pca are the following: calculate the sample covariance matrix as \\(x^tx\\) calculate the eigenvector and eigenvalues of \\(x^tx\\), such that: \\begin{align} \\begin{matrix} (\\lambda_1, u_1) \\\\ (\\lambda_2, u_2) \\\\ \\vdots \\\\ (\\lambda_d, u_d) \\\\ \\end{matrix} \\end{align} are the \\(d\\) eigenvectors (\\(u_i\\)) and eigenvalues (\\(\\lambda_i\\)). we assume the tuples are ordered in decreasing order with respect to the eigenvalues, such that if \\(i > j\\) then \\(\\lambda_i > \\lambda_j\\). find \\(k\\) such that we satisfy a confidence level with respect to the variance, i.e. suppose you want to preserve 95% of the variance of the original data then: \\begin{align} \\frac{\\sum_{i=1}^k \\lambda_i}{\\sum_{j=1}^d \\lambda_j} = 95\\% \\end{align} choose the \\(k\\) eigenvectors with the largest corresponding eigenvalues. performing eigen-decomposition first of all, let us present two properties regarding eigen-decompositions of a matrix \\(x\\): if \\(x\\) is a square matrix and symmetric then \\(x\\) has orthogonal eigenvectors and real eigenvalues. if \\(x\\) is also positive semi-definite then the eigenvalues are positive. in our case, the eigen-decomposition is done over \\(x^tx\\), therefore this matrix is guaranteed to be a square matrix, symmetric and positive semi-definite. then, performing the eigen decomposition of \\(x^tx\\) is equivalent to performing singular value decomposition (svd) over \\(x\\), such that the single values equal the square root of the eigenvalues. large datasets to perform pca on large datasets we use a technique called power iteration, which consists on: for \\(i=0\\), initialize \\(u^{(i)}\\) to random values other than zero set \\(i = i+1\\), and \\(u^{(i)} = (x^tx)u^{(i-1)}\\) re-scale \\(u^{(i)}\\) to have unit length such that: \\(u^{(i)}=\\frac{(x^tx)u^{(i-1)}}{||(x^tx)u^{(i-1)}||}\\) go to step 2. eventually it will converge to the largest eigenvector. rephrasing pca another way to describe the problem solved by pca, equivalent to the maximization variance perspective, is: find a subspace such that the projection of the points are as close to the original data as possible, that is minimize the sum of the distances between the projected points and the original points. ica this algorithm pretends to solve what is commonly known as the source separation problem, where we are given a dataset \\(x\\) that is a mixture of some source data \\(s\\). we then use these mixed sources \\(x\\) to construct a unmixing matrix \\(w\\) to recover the source \\(s\\). intuition imagine there are \\(d\\) speakers and \\(d\\) microphones randomly distributed in a room, such that: \\(s \\in \\mathbb{r}^d\\) is the representation of what a speaker says. so \\(s_j^{(i)}\\) is what the \\(j\\) speaker said in moment \\(i\\). \\(x \\in \\mathbb{r}^d\\) is the representation of what a microphone records. so \\(x_j^{(i)}\\) is what the \\(j\\) microphone recorded in moment \\(i\\). for example, given two speaker, what they say is represented as follows: meanwhile the recordings of the microphones are the following: we are only given \\(x\\), and the goal is to recover the original speech signal spoken by each speaker. we assume that \\(x\\) is a linear combination of what each speaker says, thus \\(x = as\\), where \\(a\\) is a quare matrix \\(d \\times d\\) and is called the mixing matrix. what we want to do is to compute the inverse of \\(a\\), \\(w\\) such that \\(w = a^{-1}\\), where \\(w\\) is called the unmixing matrix. then: \\begin{align} a^{-1}x = a^{-1}as \\rightarrow a^{-1}x = s \\rightarrow wx = s \\rightarrow s = wx \\end{align} solution to solve this problem we make the following assumptions: the number of sources \\(s\\) are equal to the number of \"examples\" in the mixed dataset \\(x\\) \\(x\\) is a linear combination of \\(s\\), such that \\(s = wx\\) \\(s_j\\) is independent of \\(s_k\\), whenever \\(j \\neq k\\). that is to say, each belongs to a different probability distribution, and are two independent random variables. each \\(s_j\\) is not gaussian. intuition suppose we are given a random variable \\(x\\) such that \\(x ~ unif [0,1]\\), then the probability density function is: let us define a new distribution as follows \\(y=2x\\), then the probability density function is: note, that the function is \"stretched\" as to always satisfy the condition that the integral of \\(pdf\\) must equal 1, which is the same as saying the area under the function is 1. so now, \\(p_y (y) = p_x(x) \\cdot \\frac{1}{2} = p_x(\\frac{y}{2})\\cdot\\frac{1}{2}\\), because \\(x = \\frac{y}{2}\\). but what happens in a higher dimension? that is, what happens when we multiply \\(x \\in \\mathbb{r}^d\\) by a mixing matrix \\(w \\in \\mathbb{r}^{d \\times d}\\). well, given \\(y \\in \\mathbb{r}^{d \\times d}\\), such that \\(y=wx\\), then to perform a change of random variable we use the jacobian: \\begin{align} p_y(y) = p_x(x)\\frac{1}{|w|} = p_x(w^{-1}y)\\frac{1}{|w|} \\end{align} where \\(|w|\\) is the determinant of \\(w\\). first of all we define the distribution of the mixed dataset as follows: \\begin{align} p_x(x) = \\prod_{j=1}^d p_s (s_j) |w| = \\prod_{j=1}^d p_s (w_j^tx) |w| \\end{align} note that \\(s_j=(w_j)^tx\\). we also assume that \\(p_s\\) is distributed according to a logistic distribution, thus: cumulative distribution function (cdf): \\(\\frac{1}{1+e^{-x}} = \\sigma(x)\\) probability density function (pdf): \\(\\sigma(x)\\sigma(1-x)\\) so, we obtain the likelihood of \\(w\\) as follows: \\begin{align} l(w) = \\sum_{i=1}^n \\left[\\left(\\sum_{j=1}^d \\log[\\sigma(x^{(i)})(1-\\sigma(x^{(i)}))]\\right) + \\log{|w|}\\right] \\end{align} where \\(w\\) is the parameter we are trying to obtain. so, to solve the optimization problem: we define the maximization of the likelihood as the objective we compute the derivative of \\(l(w)\\) and perform gradient descent, such that the update step is as follows: \\begin{align} w = w - \\alpha \\left\\{\\begin{bmatrix} (1- 2\\sigma(w_1^tx^{(i)})) \\\\ (1- 2\\sigma(w_2^tx^{(i)})) \\\\ \\vdots \\\\ (1- 2\\sigma(w_d^tx^{(i)})) \\\\ \\end{bmatrix} (x^{(i)})^t + (w^t)^{-1} \\right\\} \\end{align} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/Sistemas de Recomendación.html",
    "title": "Sistemas de Recomendación",
    "body": " index search search back sistemas de recomendación contents content based recommendations funci n de coste descenso gradiente collaborative filtering problema de optimizaci n algoritmo buscar tems relacionados dados los parámetros: \\(n_\\mu\\): número de usuarios \\(n_m\\): número de ítems valorables \\(r(i,j)\\): marcador de si el ítem ha sido valorado, tal que: \\begin{align} r(i, j) = \\begin{cases} 1, & \\text{ si el usuario j ha valorado el ítem i} \\\\ 0, & \\text{ en cualquier otro caso} \\end{cases} \\end{align} \\(y^{(i, j)}\\): valoración del usuario \\(j\\) al ítem \\(i\\). el objetivo de un sistema de recomendación es predecir los valores de las valoraciones donde \\(r(i, j) \\neq 1\\) (es decir predecir las valoraciones de usuarios hacia ítems que no han valorado con anteioridad) content based recommendations cada ítem está definido por \\(n\\) características. para cada usuario \\(j\\), debemos obtener \\(\\theta^{(j)} \\in \\mathbb{r}^{n+1}\\), de tal manera que para predecir la valoración de \\(x^{(i)} \\rightarrow h_\\theta(x^{(i)}) = (\\theta^{(j)})^t x^{(i)}\\) función de coste sea \\(m^{(j)}\\) el número de ítems valorados por el usuario \\(j\\), entonces la función de coste se define como: \\begin{align} j(\\theta) = \\frac{1}{2m^{(j)}}\\sum_{j=1}^{n_\\mu} \\sum_{i; r(i, j) = 1} ((\\theta^{(j)})^t x^{(i)} - y^{(i, j)})^2 + \\frac{\\lambda}{2m^{(j)}} \\sum_{k=1}^{n_\\mu} \\theta^{(j)}_k \\end{align} donde \\(\\theta = \\{\\theta_1, \\cdots, \\theta_{n_\\mu}\\}\\) es decir queremos minimizar la \"distancia\" entre lo predicho \\((\\theta^{(j)})^t x^{(i)}\\) para el ítem (que ha sido valorado, por lo tanto \\(r(i, j) = 1\\)) y el usuario \\(i\\) y la valoración real \\(y^{(i, j)}\\). descenso gradiente lo que queremos es minimizar el coste, por lo tanto, calculamos \\(\\frac{\\delta j(\\theta)}{\\delta \\theta_j}\\) para obtener el vector en dirección al mayor incremento en la función, seguidamente, utilizar su opuesto, obtenemos el vector que apunta a la dirección de menor incremento. es decir, aplicamos descenso gradiente como sigue: para \\(k = 0\\): \\begin{align} \\theta_k^{(j)} = \\theta_k^{(j)} - \\alpha \\left(\\sum_{i; r(i,j)=1} (\\theta^{(j)})^tx^{(i)} - y^{(i,j)}x^{(i)}_k \\right) \\end{align} para \\(k \\neq 0\\): \\begin{align} \\theta_k^{(j)} = \\theta_k^{(j)} - \\alpha \\left(\\sum_{i; r(i,j)=1} (\\theta^{(j)})^tx^{(i)} - y^{(i,j)}x^{(i)}_k + \\lambda \\theta_k^{(j)} \\right) \\end{align} collaborative filtering collaborative filtering consiste en calcular las características de cada usuario (ejemplo \\(x^{(i)}\\)) en función de los pesos \\(\\theta^{(j)}\\). una vez hecho esto se calculan los pesos óptimos que que minimizan la función de coste y volvemos a obtener las características de cada usuario en función de estes nuevos pesos. este proceso se describe más formalmente a continuación: problema de optimización el problema de optimización se describe como sigue: dados \\(\\theta^{(1)}, \\cdots, \\theta^{n_\\mu}\\): para un ejemplo \\(x^{(i)}\\) \\begin{align} \\underset{x^{(i)}}{\\min{}} \\frac{1}{2} \\sum_{j:r(i,j)=1} ((\\theta^{(j)})^tx^{(i)} - y^{(i,j)})^2 + \\frac{\\lambda}{2} \\sum_{k=1}^n (x_k^{(i)})^2 \\end{align} para todos los ejemplos del conjunto \\(x^{0}, \\cdots, x^{(n_m)}\\): \\begin{align} \\underset{x^{(1)}, \\cdots, x^{(n_m)}}{\\min{}} \\frac{1}{2} \\sum_{i=1}^{n_m} \\sum_{j:r(i,j)=1} ((\\theta^{(j)})^tx^{(i)} - y^{(i,j)})^2 + \\frac{\\lambda}{2} \\sum_{i=1}^{n_m}\\sum_{k=1}^n (x_k^{(i)})^2 \\end{align} es decir queremos minimizar la \"distancia\" entre lo predicho \\((\\theta^{(j)})^t x^{(i)}\\) para el ítem (que ha sido valorado, por lo tanto \\(r(i, j) = 1\\)) y el usuario \\(i\\) y la valoración real \\(y^{(i, j)}\\). además como queremos obtener los valores de \\(x\\) que minimizan el coste, los añadimos como coste a problema de optimización para evitar overfitting. algoritmo el algoritmo consta de los siguientes pasos: inicializar \\(x^{(1)}, \\cdots, x^{(m)}\\) y \\(\\theta^{(1)}, \\cdots, \\theta^{(n_\\mu)}\\) de forma aleatoria. calcular \\(x\\) a partir de \\(\\theta\\) calcular \\(\\theta\\) a partir de \\(x\\) volvemos al paso 2. es decir, queremos obtener \\(x\\) y \\(\\theta\\) que optimice el siguiente problema: \\begin{align} \\underset{x^{(1)}, \\cdots, x^{(n_m)}, \\theta^{(1)}, \\cdots, \\theta^{(n_\\mu)}}{\\min{}} \\frac{1}{2} \\sum_{i=1}^{n_m} \\sum_{j:r(i,j)=1} ((\\theta^{(j)})^tx^{(i)} - y^{(i,j)})^2 + \\frac{\\lambda}{2} \\sum_{i=1}^{n_m}\\sum_{k=1}^n (x_k^{(i)})^2 + \\frac{\\lambda}{2} \\sum_{i=1}^{n_\\mu}\\sum_{k=1}^n (\\theta_k^{(i)})^2 \\end{align} observa que, como estamos optimizando tanto \\(\\theta\\) como \\(x\\), entonces los añadimos como coste a la función de optimización para evitar overfitting: \\(\\frac{\\lambda}{2} \\sum_{i=1}^{n_m}\\sum_{k=1}^n (x_k^{(i)})^2\\) \\(\\frac{\\lambda}{2} \\sum_{i=1}^{n_\\mu}\\sum_{k=1}^n (\\theta_k^{(i)})^2\\) para aplicar la optimización utilizamos descenso gradiente: primero en función de \\(x\\) y después en función de \\(\\theta\\): \\begin{align} x^{(i)}_k = x^{(i)}_k - \\alpha \\left( \\sum_{j:r(i, j)=1} ((\\theta^{(j)})^t x^{(i)} - y^{(i, j)}) \\theta_k^{(j)} + \\lambda x^{(i)}_k\\right) \\end{align} \\begin{align} \\theta^{(j)}_k = \\theta^{(j)}_k - \\alpha \\left( \\sum_{i:r(i, j)=1} ((\\theta^{(j)})^t x^{(i)} - y^{(i, j)}) x_k^{(i)} + \\lambda \\theta^{(j)}_k\\right) \\end{align} buscar ítems relacionados si \\(||x^{(i)} - x^{(j)}\\)|| es un valor pequeño entonces los ítems \\(i\\) y \\(j\\) son similares. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/Clustering.html",
    "title": "Clustering",
    "body": " index search search back clustering contents k-means algoritmo cl sters no claramente separables inicializaci n aleatoria parametrizaci n de cl stering k-means escogemos e inicializamos \\(k\\) centroides que servirán para hacer de clústers. para cada ejemplo \\(j\\): asignamos el centroide más cercano una vez asignados todos los ejemplos, resituamos cada centroide en función de los ejemplos asignados al mismo. volvemos al paso 2. algoritmo entrada: número de clústers \\(k\\) conjunto de entrenamiento: \\(\\{x^{(0)}, \\cdots, x^{(m)}\\}\\), con \\(x^{(i)} \\in \\mathbb{r}^n\\) inicializamos los \\(k\\) centroides \\((\\mu_1, \\cdots, \\mu_k) \\in \\mathbb{r}^n\\) de forma aleatoria. repetimos: para cada ejemplo \\(x^{(j)}\\), \\(c^{(j)}\\) es el índice del centroide más cercano a \\(x^{(j)}\\): \\(\\underset{i}{min}||x^{(j)} - \\mu_i||\\) para cada clúster: \\(\\mu_i\\) es la media de los puntos \\(x^{(j)}\\) asignados al centroide \\(i\\): \\(\\mu_i = \\frac{1}{t} \\left[\\sum_{j=1}^t x^{(j)} \\text{ donde } c^{(j)} = i\\right]\\), donde \\(t\\) es el número de ejemplos asignados al centroide \\(i\\). si el centroide no tiene puntos, se elimina o se vuelve a inicializar de forma aleatoria. clústers no claramente separables cuando los datos contienen mucho ruido lo que se hace es resolver el siguiente problema de optimización: \\begin{align} \\underset{c^{(1)}, \\cdots, c^{(m)}, \\mu_1, \\cdots, \\mu_k}{min} j(c^{(1)}, \\cdots, c^{(m)}, \\mu_1, \\cdots, \\mu_k) \\end{align} donde la función de coste \\(j\\) se define como: \\begin{align} j(c^{(i)}, \\mu_i) = \\frac{1}{m} \\sum_{i=1}^m ||x^{(i)} - \\mu_{c^{(i)}}||^2 \\end{align} es decir, el coste es equivalente a la suma de la distancia entre el ejemplo \\(x^{(i)}\\) y su clúster asignado \\(\\mu_{c^{(i)}}\\), para cada ejemplo. el algoritmo de optimización lo que hace es: minimiza el coste con respecto a \\(c\\) minimiza el coste con respecto a \\(\\mu\\) inicialización aleatoria debemos escoger un número de centroides \\(k\\) menor que el número de ejemplos \\(m\\). inicializamos cada centroide equivalente a un ejemplo aleatorio del conjunto de entrenamiento: \\(\\mu_i = x^{(j)}\\) hay que tener en cuenta que, en función de la inicialización de los centroides, se pueden obtener distintos resultados en el problema de optimización, por ello lo que se hace es: aplicar el algoritmo muchas veces escoger el modelo que obtuvo menor coste este proceso es viable si el número de clústers es pequeño. parametrización de clústering una forma de escoger el número de clústers \\(k\\) es utilizando el método del codo: se aplica el modelo con un número distinto de clústers se evalúa con alguna métrica el rendimiento (coste) del modelo y se elige el ofrece una mayor mejora con respecto a un número de clústers menor $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/Regresión Logística.html",
    "title": "Regresión Logística",
    "body": " index search search back regresión logística contents descripci n de los datos hip tesis funcion de coste regularizaci n descenso gradiente regularizaci n descripción de los datos \\(x = (x_{ij})\\) una matriz \\(n \\times m\\) donde cada \\(x_{ij}\\) es la característica \\(i\\) del ejemplo \\(j\\), tal que \\begin{align} x = \\begin{bmatrix} x_{11} & \\cdots & x_{1m} \\\\ \\cdots & \\ddots & \\cdots \\\\ x_{n1} & \\cdots & x_{nm} \\\\ \\end{bmatrix} \\end{align} cada columna es un ejemplo en cada fila están los valores de una característica \\(\\theta = (\\theta_i)\\) es un vector fila \\(1\\times n\\) donde cada \\(\\theta_i\\) es el peso de la característica \\(i\\), tal que: \\begin{align} \\theta = \\begin{bmatrix} \\theta_1 & \\cdots & \\theta_n\\end{bmatrix} \\end{align} \\(y = (y_j)\\) es un vector fila \\(1\\times m\\) donde cada \\(y_j\\) es la salida real para el ejemplo \\(j\\), tal que: \\begin{align} y = \\begin{bmatrix} y_1 & \\cdots & y_m\\end{bmatrix} \\end{align} donde cada salida \\(y_j\\), para un clasificador de dos clases sólo puede tener los valores \\(0\\) o \\(1\\). hipótesis para un valor \\(z\\), la función sigmoide \\(g\\) se define como: \\begin{align} g(z) = \\frac{e^z}{(1+e^z)} = \\frac{1}{(1 + e^{-z})} \\end{align} sea \\(g\\) la función sigmoide. dado un ejemplo, es decir un vector columna \\(x\\), de dimensiones \\(n \\times 1\\), la hipótesis se define como: \\begin{align} h_\\theta(x) = g\\left(\\sum_{i=1}^n \\theta_i \\cdot x_i\\right) = \\begin{cases} 0, & h_\\theta(x) < 0.5 \\\\ 1, & h_\\theta(x) \\geq 0.5 \\\\ \\end{cases} \\end{align} dado un conjunto de \\(m\\) datos, es decir matrix \\(x\\), de dimensiones \\(n \\times m\\), la hipótesis se define como: \\begin{align} h_\\theta(x) = \\theta\\cdot x = \\begin{bmatrix}g(\\sum_{i=1}^n \\theta_i \\cdot x_{i1}) & \\cdots & g(\\sum_{i=1}^n \\theta_i \\cdot x_{im})\\end{bmatrix} \\end{align} el resultado es un vector fila \\(1 \\times m\\), es decir como el vector de salidas \\(y\\) funcion de coste se define la función de coste, \\(j(\\theta)\\) como: \\begin{align} j(\\theta) = \\frac{1}{m}\\sum_{j=1}^m \\text{coste}(h_\\theta(x_j)) \\end{align} donde \\(\\text{coste}\\) es una función definida como sigue: \\begin{align} \\text{coste}(h_\\theta(x_j)) = [-y_j \\log(h_\\theta(x_j))] - [(1-y_j)\\log(1-h_\\theta(x_j))] \\end{align} regularización con regularización, se define la función de coste, \\(j(\\theta)\\) como: \\begin{align} j(\\theta) = -\\frac{1}{m}\\sum_{j=1}^m [y_j \\log(h_\\theta(x_j))] + [(1-y_j)\\log(1-h_\\theta(x_j))] + \\frac{1}{2m} \\lambda \\sum_{i=1}^n \\theta_i^2 \\end{align} descenso gradiente para actualizar el vector de pesos \\(\\theta\\) aplicamos el descenso gradiente. para cada peso \\(\\theta_i\\): \\begin{align} \\theta_i = \\theta_i - \\alpha \\left( \\frac{\\delta j(\\theta)}{\\delta \\theta_i}\\right) \\end{align} la derivada del coste en función del peso \\(\\theta_i\\) se calcula como sigue: sustituimos la función de coste \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_i} = \\frac{\\delta}{\\delta \\theta_i} \\left(-\\frac{1}{m}\\sum_{j=1}^m [y_j \\log(h_\\theta(x_j))] + [(1-y_j)\\log(1-h_\\theta(x_j))]\\right) = \\end{align} sacamos el factor constante \\(\\frac{1}{m}\\) y aplicamos la propiedad \"la derivada de una suma equivale a la suma de las derivadas\", tal que: \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_i} = -\\frac{1}{m}\\sum_{j=1}^m \\frac{\\delta}{\\delta \\theta_i} \\left([y_j \\log(h_\\theta(x_j))] + [(1-y_j)\\log(1-h_\\theta(x_j))]\\right) = \\end{align} \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_i} = -\\frac{1}{m}\\sum_{j=1}^m \\left(\\frac{\\delta}{\\delta \\theta_i} [y_j \\log(h_\\theta(x_j))]\\right) + \\left(\\frac{\\delta}{\\delta \\theta_i}[(1-y_j)\\log(1-h_\\theta(x_j))]\\right) = \\end{align} sacamos los factores constantes \\(y_j\\) y \\(1-y_j\\) y aplicamos la regla de la cadena: \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_i} = -\\frac{1}{m}\\sum_{j=1}^m \\left(y_j\\frac{\\delta\\log(h_\\theta(x_j))}{\\delta h_\\theta(x_j)} \\frac{\\delta h_\\theta(x_j)}{\\delta \\theta_i}\\right) + \\left((1-y_j)\\frac{\\delta\\log(1-h_\\theta(x_j))}{\\delta (1- h_\\theta(x_j))}\\frac{\\delta (1- h_\\theta(x_j))}{\\delta \\theta_i}\\right) = \\end{align} tenemos que, para el último término: \\begin{align} \\frac{\\delta (1- h_\\theta(x_j))}{\\delta \\theta_i} = \\frac{\\delta(1)}{\\delta \\theta_i} - \\frac{\\delta h_\\theta(x_j)}{\\delta \\theta_i} = - \\frac{\\delta h_\\theta(x_j)}{\\delta \\theta_i} \\end{align} por lo tanto, si sustituimos: \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_i} = -\\frac{1}{m}\\sum_{j=1}^m \\left(y_j\\frac{\\delta\\log(h_\\theta(x_j))}{\\delta h_\\theta(x_j)} \\frac{\\delta h_\\theta(x_j)}{\\delta \\theta_i}\\right) + \\left((1-y_j)\\frac{\\delta\\log(1-h_\\theta(x_j))}{\\delta (1- h_\\theta(x_j))}(-1)\\frac{\\delta h_\\theta(x_j)}{\\delta \\theta_i}\\right) = \\end{align} aplicamos la regla \\(\\frac{\\delta \\log(x)}{\\delta x} = \\frac{1}{x}\\), sacamos la expresión \\(\\frac{\\delta h_\\theta(x_j)}{\\delta \\theta_i}\\) como factor común y hacemos negativo el segundo término: \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_i} = -\\frac{1}{m}\\sum_{j=1}^m \\left(\\frac{y_j}{h_\\theta(x_j)} \\right) - \\left(\\frac{(1 - y_j)}{1-h_\\theta(x_j)}\\right) \\frac{\\delta h_\\theta(x_j)}{\\delta \\theta_i} = \\end{align} aplicamos operationes aritméticas: \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_i} = -\\frac{1}{m}\\sum_{j=1}^m \\left(\\frac{(y_j)(1-h_\\theta(x_j)) - (1-y_j)(h_\\theta(x_j))}{h_\\theta(x_j)(1-h_\\theta(x_j))} \\right)\\frac{\\delta h_\\theta(x_j)}{\\delta \\theta_i} = \\end{align} centrémonos ahora en \\(\\frac{\\delta h_\\theta(x_j)}{\\delta \\theta_i}\\). para calcular esta derivada, primero expresamos la hipótesis utilizando la función sigmoide: \\begin{align} \\frac{\\delta h_\\theta(x_j)}{\\delta \\theta_i} = \\frac{\\delta}{\\delta \\theta_i} g(\\theta x_j) \\end{align} aplicamos la regla de la cadena \\begin{align} \\frac{\\delta h_\\theta(x_j)}{\\delta \\theta_i} = \\frac{\\delta g(\\theta x_j)}{\\delta \\theta x_j} \\frac{\\delta \\theta x_j}{\\delta \\theta_i} \\end{align} sabemos que la derivada del segundo término \\(\\frac{\\delta \\theta x_j}{\\delta \\theta_i}\\) equivale a \\(x_{ij}\\), por lo tanto, calcularemos sólo \\(\\frac{\\delta g(\\theta x_j)}{\\delta \\theta x_j}\\) sea: \\begin{align} g(\\theta x_j) = \\frac{1}{1 + e^{-\\theta x_j}} = (1 + e^{-\\theta x_j})^{-1} \\end{align} aplicamos la regla de la cadena \\begin{align} \\frac{\\delta g(\\theta x_j)}{\\delta \\theta x_j} = \\frac{\\delta(1 + e^{-\\theta x_j})^{-1}}{\\delta(1+e^{-\\theta x_j})}\\frac{\\delta(1+e^{-\\theta x_j})}{\\delta \\theta x_j} \\end{align} resolvemos la primera derivada aplicando las propiedades de las derivadas sobre los polinomios y volvemos a aplicar la propiedad de que la derivada de una suma equivale a la suma de las derivadas en el segundo término: \\begin{align} \\frac{\\delta g(\\theta x_j)}{\\delta \\theta x_j} = (-1)(1 + e^{-\\theta x_j})^{-2}\\left[\\frac{\\delta (1)}{\\delta \\theta x_j} + \\frac{\\delta e^{-\\theta x_j}}{\\delta \\theta x_j} \\right] \\end{align} como \\(\\frac{\\delta (1)}{\\delta \\theta x_j}\\) equivale a cero: \\begin{align} \\frac{\\delta g(\\theta x_j)}{\\delta \\theta x_j} = (-1)(1 + e^{-\\theta x_j})^{-2} \\frac{\\delta e^{-\\theta x_j}}{\\delta \\theta x_j} \\end{align} resolvemos la última derivada, sabiendo que \\(\\frac{\\delta e^x}{\\delta x} = e^x\\) \\begin{align} \\frac{\\delta g(\\theta x_j)}{\\delta \\theta x_j} = (-1)(1 + e^{-\\theta x_j})^{-2} (-1) e^{-\\theta x_j} = (1 + e^{-\\theta x_j})^{-2} e^{-\\theta x_j} = \\frac{e^{-\\theta x_j}}{(1 + e^{-\\theta x_j})^2} \\end{align} como \\(\\frac{e^{-\\theta x_j}}{(1 + e^{-\\theta x_j})^2} = \\left(\\frac{1}{1+e^{-\\theta x_j}}\\right)\\left(1 - \\frac{1}{1 + e^{-\\theta x_j}}\\right)\\), entonces: \\begin{align} \\frac{\\delta g(\\theta x_j)}{\\delta \\theta x_j} = \\frac{e^{-\\theta x_j}}{(1 + e^{-\\theta x_j})^2} = \\left(\\frac{1}{1+e^{-\\theta x_j}}\\right)\\left(1 - \\frac{1}{1 + e^{-\\theta x_j}}\\right) = h_\\theta(x_j) (1- h_\\theta(x_j)) \\end{align} ya que según la definición de la hipótesis \\(h_\\theta(x_j) = \\frac{1}{1 + e^{-\\theta x_j}}\\) por lo tanto, juntado los resultados, tenemos que: \\begin{align} \\frac{\\delta h_\\theta(x_j)}{\\delta \\theta_i} = \\frac{\\delta g(\\theta x_j)}{\\delta \\theta x_j} \\frac{\\delta \\theta x_j}{\\delta \\theta_i} = h_\\theta(x_j) (1- h_\\theta(x_j)) x_{ij} \\end{align} volvemos, entonces, a la derivada de la función de coste y sustituimos \\(\\frac{\\delta h_\\theta(x_j)}{\\delta \\theta_i}\\) \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_i} = -\\frac{1}{m}\\sum_{j=1}^m \\left(\\frac{(y_j)(1-h_\\theta(x_j)) - (1-y_j)(h_\\theta(x_j))}{h_\\theta(x_j)(1-h_\\theta(x_j))} \\right) h_\\theta(x_j) (1- h_\\theta(x_j)) x_{ij} = \\end{align} los términos \\(h_\\theta(x_j) (1- h_\\theta(x_j))\\) se cancelan tal que: \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_i} = -\\frac{1}{m}\\sum_{j=1}^m \\left((y_j)(1-h_\\theta(x_j)) - (1-y_j)(h_\\theta(x_j)) \\right) x_{ij} = \\end{align} aplicamos operaciones aritméticas: \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_i} = -\\frac{1}{m}\\sum_{j=1}^m (y_j - y_jh_\\theta(x_j) - h_\\theta(x_j) + y_jh_\\theta(x_j)) x_{ij} \\end{align} el término \\(y_jh_\\theta(x_j)\\) se cancela, tal que: \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_i} = -\\frac{1}{m}\\sum_{j=1}^m (y_j - h_\\theta(x_j)) x_{ij} \\end{align} finalmente movemos el \\((-1)\\) dentro del sumatorio: \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_i} = \\frac{1}{m}\\sum_{j=1}^m (h_\\theta(x_j)-y_j) x_{ij} \\end{align} por lo tanto la función del descenso gradiente equivale a: \\begin{align} \\theta_i = \\theta_i - \\alpha \\left( \\frac{\\delta j(\\theta)}{\\delta \\theta_i}\\right) = \\theta_i - \\alpha \\left[\\frac{1}{m} \\left(\\sum_{j=1}^m (h_\\theta(x_j) - y_j) \\cdot x_{ij}\\right) \\right] \\end{align} observa que tiene la misma forma que para la regresión lineal, pero la hipótesis para la regresión logística está definida en términos de la función sigmoide regularización con regularización debemos derivar la función de coste que incluye el parámetro de regularización: \\begin{align} \\theta_i = \\theta_i - \\alpha \\left( \\frac{\\delta j(\\theta)}{\\delta \\theta_i}\\right) + \\frac{\\lambda}{2m} \\sum_{k=1}^n \\theta_k^2 \\end{align} el primer término ya lo hemos derivado, por lo tanto procedemos a derivar el segundo término: \\begin{align} \\frac{\\delta}{\\delta \\theta_i} \\left(\\frac{\\lambda}{2m} \\sum_{k=1}^n \\theta_k^2\\right) = \\frac{\\lambda}{2m} \\left(\\sum_{k=1}^n \\frac{\\delta}{\\delta \\theta_i} \\theta_k^2\\right) \\end{align} donde \\begin{align} \\frac{\\delta}{\\delta \\theta_i} \\theta_k^2 = \\begin{cases} 2 \\theta_k, & k = i \\\\ 0, & k \\neq i \\end{cases} \\end{align} como para todo \\(k\\), con \\(1 \\leq k \\leq n\\) sólo hay un \\(k\\), tal que \\(k = i\\), entonces: \\begin{align} \\frac{\\delta}{\\delta \\theta_i} \\left(\\frac{\\lambda}{2m} \\sum_{k=1}^n \\theta_k^2\\right) = \\frac{\\lambda}{2m} 2\\theta_i = \\frac{\\lambda}{m} \\theta_i \\end{align} por lo tanto la función del descenso gradiente equivale a: \\begin{align} \\theta_i = \\theta_i - \\alpha \\left( \\frac{\\delta j(\\theta)}{\\delta \\theta_i}\\right) = \\theta_i - \\alpha \\left[\\frac{1}{m} \\left(\\sum_{j=1}^m (h_\\theta(x_j) - y_j) \\cdot x_{ij}\\right) + \\frac{\\lambda}{m}\\theta_i\\right] \\end{align} al igual que antes, observa que tiene la misma forma que para la regresión lineal, pero la hipótesis para la regresión logística está definida en términos de la función sigmoide $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/ExpectationMaximization/Expectation-Maximization Algorithms.html",
    "title": "Expectation Maximization",
    "body": " index search search back expectation maximization contents introduction gaussian mixture models em algorithm with gmm s e-step m-step optimal parameters of a gmm iterative process recap anomaly detection generalized em algorithm jensen s inequality convex function concave function some intuition motivation e-step m-step make log likelihood and lower bound equal on theta putting everything together derive em for gmm from the generalized algorithm e-step m-step introduction this technique is employed in density estimation problems and anomaly detection. such problems aim to represent data in a compact form using a statistical distribution, e.g., gaussian, beta, or gamma. you can think of those problems as a clustering task but from a probabilistic point of view. this is what makes the em algorithm a probabilistic generative model. thus, if we are given \\(n\\) samples, we model them with \\(p(x)\\), such that if \\(p(x) < \\epsilon\\), where \\(\\epsilon\\) is some threshold, then we detect an anomaly. however, you may expect that a single gaussian with its mean and variance cannot map thousands of instances in a dataset into a set of \\(k\\) clusters accurately, so we may assume that there are \\(k\\) distributions that describe the data, hence we use mixture models. for example, imagine you have the following dataset: it looks like the data comes from two different gaussian distributions: so to model this data we use a mixture of gaussian models. note that if we knew by which distribution each sample was generated, we would simply use mle, however we do not know this information, therefore we use the expectation maximization algorithm and we introduce the latent variable \\(z\\) in place of the predicted output \\(y\\) we had in supervised learning algorithms. to model the data, first of all, we suppose that there is a latent (hidden/unobserved) random variable \\(z\\), and \\(x^{(i)}, z^{(i)}\\) are distributed (by a joint distribution) like so \\begin{align} p(x^{(i)},z^{(i)}) = p(x^{(i)}|z^{(i)}) p(z^{(i)}) \\end{align} where \\(z^{(i)} \\sim multinomial(\\phi)\\), that is \\(z^{(i)}\\) is distributed according to a multinomial distribution. this distribution models for each \\(z^{(i)}\\) the probability of it being equal to \\(1, 2, ..., k\\), where \\(k\\) is the number of clusters. this will denote the probability of a point \\(x^{(i)}\\) being drawn from each of the distributions. and \\(p(x^{(i)}|z^{(i)}=j)\\) is the probability of \\(x^{(i)}\\) being generated by the cluster \\(j\\). where \\(x^{(i)}|z^{(i)} = j\\) is drawn from a normal distribution \\(\\mathcal{n}(\\mu_j, \\sigma_j)\\). gaussian mixture models to build a density estimator model, we cannot rely on a simple distribution. mixture models try to tackle this limitation by combining a set of distributions to create a convex space where we can search for the optimal parameters for such distributions using maximum likelihood estimation (mle). a mixture model is expressed by the following equations: \\begin{align} p(x^{(i)}) = \\sum_{j=1}^k \\phi^{(i)}_j p_j(x^{(i)}) \\tag{1} \\end{align} \\begin{align} 0 \\leq \\phi^{(i)}_j \\leq 1, \\sum_{j=1}^k \\phi^{(i)}_j = 1 \\end{align} where \\(k\\) is the number of mixture components (clusters), \\(\\phi^{(i)}_j\\)'s are the mixture weights, and \\(p_j(x^{(i)})\\)'s are members of a family of distributions (gaussian, poisson, bernoulli, etc). so for each example \\(x^{(i)}\\) and for each distribution \\(j\\), each weight \\(\\phi^{(i)}_j\\) is between 0 and 1, and the sum over \\(k\\) of the weights \\(\\phi_j^{(i)}\\) for every example \\(x^{(i)}\\) equals one. consequently, a gmm is a mixture model where the \\(p_j(x^{(i)})\\) is a finite combination of gaussian distributions. therefore, a gmm can be precisely defined by the following set of equations: \\begin{align} p(x^{(i)};\\theta) = \\sum_{j=1}^k \\phi^{(i)}_j \\mathcal{n}(x^{(i)};\\mu_j,\\,\\sigma_j) \\end{align} \\begin{align} 0 \\leq \\phi^{(i)}_j \\leq 1, \\sum_{j=1}^k \\phi^{(i)}_j = 1 \\end{align} where \\(\\theta\\) is the collection of all the parameters of the model (mixture weights, means, and covariance matrices): \\begin{align} \\theta = \\{\\phi_1, \\cdots, \\phi_k, \\mu_1, \\cdots, \\mu_k, \\sigma_1, \\cdots, \\sigma_k\\} \\end{align} for example, the following plot shows what a gmm derived from 3 mixture components looks like: as a consequence, for each data point, \\(x^{(i)}\\) (in red), we can compute the probability that it belongs to each component (\\(p(x^{(i)}|z^{(i)} = j)\\), where \\(j = 1, 2, 3\\))(make a “soft” assignment). this quantity is called “responsibility”. em algorithm with gmm's the expectation maximization algorithm is comprised of two steps: guess the value of the responsibilities \\(w^{(i)}_j\\), that represent the \"amount\" of each \\(x^{(i)}\\) that was generated from the distribution \\(j\\) (or the probability that the \\(j\\)th distribution generated the point \\(x^{(i)}\\)). compute the values of the parameters of the distributions: \\(\\theta = \\{\\phi, \\mu, \\sigma\\}\\) according to the \\(mle\\) (maximum likelihood estimation) with respect to the parameters. thus, we want to maximize \\(\\mathcal{l}(\\phi, \\mu, \\sigma)\\). e-step in this step, as we have said, we will compute the value of the responsibilities with the given parameters \\(\\phi, \\mu, \\sigma\\). so for each example \\(i\\) and each component (distribution) \\(j\\), the amount of \\(x^{(i)}\\) that is generated by the component \\(j\\) is given by: \\begin{align} w^{(i)}_j = p(z^{(i)} = j | x^{(i)}; \\phi_j, \\mu_j, \\sigma_j) \\end{align} by bayes' rule, we can rewrite the equation as follows: \\begin{align} w^{(i)}_j = \\frac{p(x^{(i)}|z^{(i)} = j)p(z^{(i)} = j)}{\\sum_{l=1}^k \\left[p(x^{(i)}|z^{(i)} = l)p(z^{(i)} = l)\\right]} \\end{align} note that the likelihood \\(p(x^{(i)}|z^{(i)} = j)\\) and each likelihood \\(p(x^{(i)}|z^{(i)} = l)\\) come from a gaussian distribution, therefore: \\begin{align} p(x^{(i)}|z^{(i)} = j) = \\frac{1}{(2\\pi)^{\\frac{n}{2}}|\\sigma_j|^{\\frac{1}{2}}} \\exp\\left(-\\frac{1}{2}(x^{(i)} - \\mu_j)^t \\sigma_j^{-1} (x^{(i)} - \\mu_j)\\right) \\tag{2} \\end{align} to simplify notation we will denote \\(p(x^{(i)}|z^{(i)} = j)\\) as \\(\\mathcal{n}(\\mu_j, \\sigma_j)\\). on the other hand, the prior \\(p(z^{(i)} = j)\\) comes from a multinomial distribution, hence: \\begin{align} p(z^{(i)} = j) = \\phi_j \\tag{3} \\end{align} combining all the expressions: \\begin{align} w^{(i)}_j = \\frac{\\phi_j\\mathcal{n}(\\mu_j, \\sigma_j)}{\\sum_{l=1}^k \\left[\\phi_l\\mathcal{n}(\\mu_l, \\sigma_l)\\right]} \\tag{4} \\end{align} all that is left to do is plug all of the values into each equation \\((2)\\) and \\((3)\\) (this values are known, given the equations are written in terms of the distributions' parameters) and compute each \\(w^{(i)}_j\\) given \\((4)\\). m-step in this step what we do is maximize the log likelihood of the distributions' parameters \\(\\theta\\), that is we maximize \\(\\mathcal{l}(\\phi, \\mu, \\sigma)\\). but first, let us see how do we maximize the parameters in gmm. optimal parameters of a gmm we are going to show how to maximize the log likelihood of the parameters of a gaussian mixture model. the goal of the gmm is to represent the distribution of the data as accurately as possible using a linear combination of gaussian distributions. given a dataset \\(x\\) of \\(m\\) data points, we assume they are i.i.d (independent and identically distributed), therefore the maximum likelihood estimator over \\(x\\) can be expressed as the product of the individual likelihoods. to simplify the equations, we are going to directly apply the logarithm to the mle function: \\begin{align} \\log \\mathcal{l}(x|\\theta) = \\log p(x|\\theta) = \\log \\prod_{i=1}^m p(x^{(i)}|\\theta) = \\sum_{i=1}^m \\log p(x^{(i)}|\\theta) \\end{align} by \\((1)\\) we know that \\(p(x^{(i)}|\\theta)\\) is a linear combination of gaussian distributions, therefore: \\begin{align} \\log \\mathcal{l}(x|\\theta) = \\sum_{i=1}^n \\log \\sum_{j=1}^k \\phi_j^{(i)}\\mathcal{n}(x^{(i)}|\\mu_j, \\sigma_j) \\end{align} this equation is not tractable, so we won't get an analytical solution by just taking the its derivative with respect to \\(\\theta\\) and setting it to 0. the following set of equations outline how we would evaluate it: \\begin{align} \\frac{\\delta \\mathcal{l}}{\\delta \\mu_j} \\sum_{i=1}^m \\frac{\\delta \\log p(x^{(i)}|\\theta)}{\\delta \\mu_j} = 0^t \\end{align} \\begin{align} \\frac{\\delta \\mathcal{l}}{\\delta \\sigma_j} \\sum_{i=1}^m \\frac{\\delta \\log p(x^{(i)}|\\theta)}{\\delta \\sigma_j} = 0 \\end{align} \\begin{align} \\frac{\\delta \\mathcal{l}}{\\delta \\phi_j} \\sum_{i=1}^m \\frac{\\delta \\log p(x^{(i)}|\\theta)}{\\delta \\phi_j} = 0 \\end{align} observe that the computation of each parameter from \\(\\theta (\\mu, \\sigma, \\phi)\\) depends on the other parameters in a complex way. to solve those equations, we can use the strategy of optimizing some parameters while keeping the others fixed. going back to the expectation maximization algorithm, there is a way of updating the individual parameters of a gmm given prior (initialized at random) parameters \\(\\mu, \\sigma, \\phi\\). this approach works by updating some parameters while keeping the others fixed. so, by solving the derivatives presented above we derive the three following updating rules: \\begin{align} \\hat{\\mu}_j = \\frac{\\sum_{i=1}^m w^{(i)}_jx^{(i)}}{\\sum_{l=1}^m w^{(l)}_j} \\end{align} \\begin{align} \\hat{\\sigma}_j = \\frac{\\sum_{i=1}^m w^{(i)}_j (x^{(i)} - \\hat{\\mu}_j)(x^{(i)} - \\hat{\\mu}_j)^t}{\\sum_{l=1}^m w^{(l)}_j} \\end{align} \\begin{align} \\hat{\\phi}_j = \\frac{1}{m} \\sum_{i=1}^m w^{(i)}_j \\end{align} to simplify a bit the notation, if \\(n_j = \\sum_{l=1}^m w^{(i)}_l\\): \\begin{align} \\hat{\\mu}_j = \\frac{1}{n_j} \\sum_{i=1}^m w^{(i)}_jx^{(i)} \\end{align} \\begin{align} \\hat{\\sigma}_j = \\frac{1}{n_j}\\sum_{i=1}^m w^{(i)}_j (x^{(i)} - \\hat{\\mu}_j)(x^{(i)} - \\hat{\\mu}_j)^t \\end{align} \\begin{align} \\hat{\\phi}_j = \\frac{n_j}{m} \\end{align} note that the update of \\(\\mu, \\sigma, \\phi\\), all depend on the responsibilities (\\(w^{(i)}_j\\)), which by its turn, depends on \\(\\mu, \\sigma, \\phi\\). that’s why there's not a closed-form solution to equations. furthermore these equations do not aim to precisely maximize over \\(\\theta\\) the actual log likelihood. instead they maximize a proxy function of the log-likelihood over \\(\\theta\\), namely, the expected log-likelihood, which can be derived from the log-likelihood using jensen's inequality as follows: \\begin{align} \\hat{\\mathcal{l}}(x|\\theta) = \\sum_{i=1}^m\\sum_{j=1}^k w^{(i)}_j \\log \\left( \\frac{\\phi_j \\mathcal{n}(x^{(i)} | \\mu_j, \\sigma_j)}{w^{(i)}_j} \\right) \\tag{5} \\end{align} iterative process the process consists of an iterative process that alternates between two steps. the first step is to compute the responsibilities (e step) of each mixture component for each data point using the current parameters (\\(\\mu, \\sigma, \\phi\\)). the second step consists of updating the parameters (m step) in order to maximize the expected log-likelihood given by \\((5)\\) the e and m steps are repeated until there is no significant progress in the proxy function of the log-likelihood computed after the m step. recap: anomaly detection thus, when the parameters \\(\\theta\\) are optimized, we can compute \\(p(x) = \\sum_{j=1}^k p(x|z = j)\\) and if \\(p(x) < \\epsilon\\) you can flag \\(x\\) as an anomaly. generalized em algorithm jensen's inequality convex function we are going to show what jensen's inequality is about. so: let \\(f\\) be a convex function (e.g. \\(f''(x) > 0\\)) and let \\(x\\) be a random variable, then \\begin{align} f(e[x]) \\leq e[f(x)] \\end{align} where \\(e\\) is the expected value. further, if \\(f''(x) > 0\\) (we say f is strictly convex, that is f is not a straight line), then: \\begin{align} e[f(x)] = f(e[x]) \\leftrightarrow \\text{ x is a constant, more formally } x = e[x] \\text{ with probability 1} \\end{align} concave function we are going to apply the same arguments with a concave function. note that a concave function equals the negative of a convex function, thus: let \\(f\\) be a concave function (e.g. \\(f''(x) < 0\\)) and let \\(x\\) be a random variable, then \\begin{align} f(e[x]) \\geq e[f(x)] \\end{align} where \\(e\\) is the expected value. further, if \\(f''(x) < 0\\) (we say f is strictly concave), then: \\begin{align} e[f(x)] = f(e[x]) \\leftrightarrow \\text{ x is a constant, more formally } x = e[x] \\text{ with probability 1} \\end{align} some intuition given any convex function (the inverse also applies to concave functions), if we draw a chord between any two points, its middle point (that is the expected value of the function or \\(e[f(x)]\\)) is always above that the value of the expected value under the function (that is \\(f(e[x])\\)). graphically: motivation given a model for \\(p(x, z , \\theta)\\) where \\(\\theta\\) are the parameters of the model. we only observe \\(x = \\{x^{(1)}, \\cdots, x^{(m)}\\}\\). the goal is to obtain by the maximum likelihood estimation the value of \\(\\theta\\) that maximizes the log likelihood, defined as: \\begin{align} \\theta = \\underset{\\theta}{\\arg \\max{l(\\theta)} } = \\sum_{i=1}^m \\log (p(x^{(i)}; \\theta)) \\end{align} if we marginalize \\(z^{(i)}\\): \\begin{align} \\theta = \\underset{\\theta}{\\arg \\max{l(\\theta)} } = \\sum_{i=1}^m \\log \\sum_{z^{(i)}} (p(x^{(i)}, z^{(i)}; \\theta)) \\end{align} e-step in the e-step we construct a lower bound from a given theta: so, let's say \\(l(\\theta)\\) is the log likelihood. on the first iteration, the graph would be as follows: and on the second iteration: we iterate until there are no significant changes in the lower bound, that is the algorithm converges to a local optimum (it should be noted the optimum is local not absolute, and it depends on the initialization of the distributions' parameters). m-step now, in the m-step we maximize the log likelihood as follows: \\begin{align} \\underset{\\theta}{\\max{ }} \\sum_{i=1}^m \\log p(x^{(i)}; \\theta) \\end{align} by marginalizing \\(z^{(i)}\\): \\begin{align} \\underset{\\theta}{\\max{ }} \\sum_{i=1}^m \\log \\sum_{z^{(i)}} p(x^{(i)}, z^{(i)}; \\theta) \\end{align} we now introduce a probability distribution over \\(z^{(i)}\\) (thus \\(\\sum_{z^{(i)}}q(z^{(i)}) = 1\\)), and we multiply by \\(\\frac{q(z^{(i)})}{q(z^{(i)})}\\): \\begin{align} \\underset{\\theta}{\\max{ }} \\sum_{i=1}^m \\log \\sum_{z^{(i)}} q(z^{(i)}) \\frac{p(x^{(i)}, z^{(i)}; \\theta)}{q(z^{(i)})} \\end{align} now, by the definition of expected value (given a sequence of real values \\(a_1, \\cdots, a_n\\) with probabilities \\(p_1, \\cdots, p_n\\), the expected value is defined as: \\(e = \\sum_{i=1}^n p_i a_i\\)), if \\(p_i = q(z^{(i)})\\) and \\(a_i = \\frac{p(x^{(i)}, z^{(i)}; \\theta)}{q(z^{(i)})}\\) \\begin{align} \\underset{\\theta}{\\max{ }} \\sum_{i=1}^m \\log e_{z^{(i)}\\sim q} \\left[\\frac{p(x^{(i)}, z^{(i)}; \\theta)}{q(z^{(i)})}\\right] \\end{align} if we apply the concave version of jensen's inequality we obtain a lower bound of the form: \\begin{align} \\sum_{i=1}^m \\log e_{z^{(i)}\\sim q} \\left[\\frac{p(x^{(i)}, z^{(i)}; \\theta)}{q(z^{(i)})}\\right] \\geq \\sum_{i=1}^m e_{z^{(i)} \\sim q} \\left[\\log \\frac{p(x^{(i)}, z^{(i)}; \\theta)}{q(z^{(i)})} \\right] \\end{align} if \\(\\log (x) = f(x)\\), then this equation can be mapped to the inequality: \\begin{align} f(e[x]) \\geq e[f(x)] \\end{align} note that \\(log\\) is a concave function. if we \"unpack\" the expected value: \\begin{align} \\sum_{i=1}^m e_{z^{(i)} \\sim q} \\left[\\log \\frac{p(x^{(i)}, z^{(i)}; \\theta)}{q(z^{(i)})} \\right] = \\sum_{i=1}^m \\sum_{z^{(i)}} \\log q(z^{(i)}) \\left[\\frac{p(x^{(i)}, z^{(i)}; \\theta)}{q(z^{(i)})}\\right] \\end{align} make log likelihood and lower bound equal on theta for each \\(\\theta\\) on the e-step you wan the value of \\(\\theta\\) under the lower bound function to be equal to \\(l(\\theta)\\), which is what guarantees that when you optimize the lower bound you optimize \\(l(\\theta)\\). so, for a given iteration the current value of \\(\\theta\\), denoted by \\(\\hat{\\theta}\\), we want: \\begin{align} \\sum_{i=1}^m \\log e_{z^{(i)}\\sim q} \\left[\\frac{p(x^{(i)}, z^{(i)}; \\hat{\\theta})}{q(z^{(i)})}\\right] = \\sum_{i=1}^m e_{z^{(i)} \\sim q} \\left[\\log \\frac{p(x^{(i)}, z^{(i)}; \\hat{\\theta})}{q(z^{(i)})} \\right] \\end{align} remember, by the extension on jensen's inequality we know that \\(e[f(x)] = f(e[x])\\) if and only if \\(x\\) is a constant. in this case \\begin{align} x = \\frac{p(x^{(i)}, z^{(i)}; \\hat{\\theta})}{q(z^{(i)})} = constant \\end{align} for this to hold, we need \\(q(z^{(i)})\\) to be directly proportional to \\(p(x^{(i)}, z^{(i)}; \\hat{\\theta})\\) (so when one is bigger the other is bigger and vice versa, so the ratio between the two remains constant). so: \\begin{align} q(z^{(i)}) \\propto p(x^{(i)}, z^{(i)}; \\hat{\\theta}) \\end{align} because \\(\\sum_{z^{(i)}}q(z^{(i)}) = 1\\), a way to ensure this is to set each \\(q^{(i)} = p(x^{(i)}, z^{(i)}; \\hat{\\theta})\\) and then normalize it to make sure the sum of \\(q\\) over \\(z^{(i)}\\) equals one. hence: \\begin{align} q(z^{(i)}) = \\frac{p(x^{(i)}, z^{(i)}; \\hat{\\theta})}{\\sum_{z^{(i)}} p(x^{(i)}, z^{(i)}; \\hat{\\theta})} \\end{align} it turns out you can further derive this equation to be: \\begin{align} q(z^{(i)}) = p(z^{(i)}|x^{(i)}; \\hat{\\theta}) \\end{align} putting everything together so, after everything we have seen, we can summarize the em generalized algorithm as follows: if \\(\\theta\\) is the value of the parameters in the current iteration: e-step: set \\begin{align} q_i(z^{(i)}) = p(z^{(i)}|x^{(i)}; \\theta) \\end{align} m-step: set \\begin{align} \\theta := \\underset{\\theta}{\\arg \\max} \\sum_{i=1}^m \\sum_{z^{(i)}} q_i(z^{(i)}) \\log \\left[\\frac{p(x^{(i)}, z^{(i)};\\theta)}{q_i(z^{(i)})}\\right] \\end{align} derive em for gmm from the generalized algorithm given a model described by: \\(p(x^{(i)}, z^{(i)}) = p(x^{(i)}|z^{(i)}) p(z^{(i)})\\) where \\(z^{(i)} \\sim multinomial(\\phi)\\) (which means \\(p(z^{(i)} = j) = \\phi_j\\)) and \\(x^{(i)} | z^{(i)} \\sim \\mathcal{n}(\\mu_j, \\sigma_j)\\) e-step on the e-step we compute: \\(q_i(z^{(i)}) p(z^{(i)} = j | x^{(i)}; \\phi, \\mu, \\sigma)\\) if we look at e-step from gmm's we can see that the expression above equals \\(w^{(i)}_j\\). m-step now on the m-step what we do is maximize the lower bound we have constructed in the e-step. for that we need to compute the value of the parameters \\(\\phi, \\mu, \\sigma\\) that maximize this function, that is: \\begin{align} \\underset{\\phi, \\mu, \\sigma}{\\max} \\sum_{i=1}^m \\sum_{z^{(i)}} q_i(z^{(i)}) \\log \\left( \\frac{p(x^{(i)}, z^{(i)}; \\phi, \\mu, \\sigma)}{q_i(z^{(i)})} \\right) = \\end{align} as we know \\(q_i(z^{(i)}) = w^{(i)}_j\\) and \\(p(x^{(i)}, z^{(i)}) = p(x^{(i)}|z^{(i)}) p(z^{(i)})\\), thus: \\begin{align} = \\sum_{i=1}^m \\sum_{j}^k w^{(i)}_j \\log \\left( \\frac{p(x^{(i)}|z^{(i)} = j, \\mu_j, \\sigma_j) p(z^{(i)} = j)}{w^{(i)}_j} \\right) \\end{align} we also know that \\(p(z^{(i)} = j) = \\phi_j\\) and \\(x^{(i)} | z^{(i)} \\sim \\mathcal{n}(\\mu_j, \\sigma_j)\\), therefore: \\begin{align} = \\sum_{i=1}^m \\sum_{j}^k w^{(i)}_j \\log \\left( \\frac{\\mathcal{n}(x^{(i)}; \\mu_j, \\sigma_j) \\phi_j}{w^{(i)}_j} \\right) \\end{align} where: \\begin{align} \\mathcal{n}(x^{(i)}; \\mu_j, \\sigma_j) = \\frac{1}{(2\\pi)^{1/2}|\\sigma_j|^{1/2}} \\exp \\left( -\\frac{1}{2}(x^{(i)} - \\mu_j)^t \\sigma_j^{-1}(x^{(i)} - \\mu_j)\\right) \\end{align} from now on we denote \\(\\sum_{i=1}^m \\sum_{j}^k w^{(i)}_j \\log \\left( \\frac{\\mathcal{n}(x^{(i)}; \\mu_j, \\sigma_j) \\phi_j}{w^{(i)}_j} \\right)\\) as \\(\\mathcal{l}(\\phi, \\mu, \\sigma)\\): to maximize this formula over \\(\\phi, \\mu\\) and \\(\\sigma\\) you have to compute the derivatie of the function with respect to each parameter, such that: \\(\\delta_{\\mu_j} (\\mathcal{l}(\\phi, \\mu, \\sigma)) = 0\\), then: \\(\\mu_j = \\sum_{i}^m \\frac{w^{(i)}_j x^{(i)}_j}{w^{(i)}_j}\\) (same as in m-step in gmm's) \\(\\delta_{\\sigma_j} (\\mathcal{l}(\\phi, \\mu, \\sigma)) = 0\\) and \\(\\delta_{\\phi_j} (\\mathcal{l}(\\phi, \\mu, \\sigma)) = 0\\) $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/Regresión Lineal.html",
    "title": "Regresión Lineal",
    "body": " index search search back regresión lineal contents descripci n de los datos hip tesis funcion de coste regularizaci n descenso gradiente regularizaci n descripción de los datos \\(x = (x_{ij})\\) una matriz \\(n \\times m\\) donde cada \\(x_{ij}\\) es la característica \\(i\\) del ejemplo \\(j\\), tal que \\begin{align} x = \\begin{bmatrix} x_{11} & \\cdots & x_{1m} \\\\ \\cdots & \\ddots & \\cdots \\\\ x_{n1} & \\cdots & x_{nm} \\\\ \\end{bmatrix} \\end{align} cada columna es un ejemplo en cada fila están los valores de una característica \\(\\theta = (\\theta_i)\\) es un vector fila \\(1\\times n\\) donde cada \\(\\theta_i\\) es el peso de la característica \\(i\\), tal que: \\begin{align} \\theta = \\begin{bmatrix} \\theta_1 & \\cdots & \\theta_n\\end{bmatrix} \\end{align} \\(y = (y_j)\\) es un vector fila \\(1\\times m\\) donde cada \\(y_j\\) es la salida real para el ejemplo \\(j\\), tal que: \\begin{align} y = \\begin{bmatrix} y_1 & \\cdots & y_m\\end{bmatrix} \\end{align} hipótesis dado un ejemplo, es decir un vector columna \\(x\\), de dimensiones \\(n \\times 1\\), la hipótesis se define como: \\begin{align} h_\\theta(x) = \\sum_{i=1}^n \\theta_i \\cdot x_i \\end{align} dado un conjunto de \\(m\\) datos, es decir matriz \\(x\\), de dimensiones \\(n \\times m\\), la hipótesis se define como: \\begin{align} h_\\theta(x) = \\theta\\cdot x = \\begin{bmatrix}\\sum_{i=1}^n \\theta_i \\cdot x_{i1} & \\cdots & \\sum_{i=1}^n \\theta_i \\cdot x_{im}\\end{bmatrix} \\end{align} el resultado es un vector fila \\(1 \\times m\\), es decir como el vector de salidas \\(y\\) funcion de coste se define la función de coste, \\(j(\\theta)\\) como: \\begin{align} j(\\theta) = \\frac{1}{2m}\\sum_{j=1}^m (h_\\theta(x_j) - y_j)^2 \\end{align} esta función de coste se denomina mínimos cuadrados. regularización con regularización, se define la función de coste, \\(j(\\theta)\\) como: \\begin{align} j(\\theta) = \\frac{1}{2m}\\sum_{j=1}^m (h_\\theta(x_j) - y_j)^2 + \\frac{1}{2m} \\lambda \\sum_{i=1}^n \\theta_i^2 \\end{align} descenso gradiente para actualizar el vector de pesos \\(\\theta\\) aplicamos el descenso gradiente. para cada peso \\(\\theta_i\\): \\begin{align} \\theta_i = \\theta_i - \\alpha \\left( \\frac{\\delta j(\\theta)}{\\delta \\theta_i}\\right) \\end{align} la derivada del coste en función del peso \\(\\theta_i\\) se calcula como sigue: sustituimos la función de coste \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_i} = \\frac{\\delta}{\\delta \\theta_i} \\left(\\frac{1}{2m}\\sum_{j=1}^m (h_\\theta(x_j) - y_j)^2\\right) = \\end{align} sacamos el factor constante de la derivada \\begin{align} = \\frac{1}{2m} \\frac{\\delta}{\\delta \\theta_i} \\left(\\sum_{j=1}^m (h_\\theta(x_j) - y_j)^2\\right) \\end{align} aplicamos la propiedad que dice que la derivada de una suma equivale a la suma de las derivadas \\begin{align} = \\frac{1}{2m} \\left(\\sum_{j=1}^m \\frac{\\delta}{\\delta \\theta_i}(h_\\theta(x_j) - y_j)^2\\right) \\end{align} aplicamos la regla de la cadena \\begin{align} = \\frac{1}{2m} \\left(\\sum_{j=1}^m \\frac{\\delta(h_\\theta(x_j) - y_j)^2}{\\delta (h_\\theta(x_j) - y_j)} \\frac{\\delta (h_\\theta(x_j) - y_j)}{\\delta \\theta_i}\\right) \\end{align} aplicamos aritmética \\begin{align} = \\frac{1}{2m} \\left(\\sum_{j=1}^m 2(h_\\theta(x_j) - y_j) \\left[\\frac{\\delta (h_\\theta(x_j))}{\\delta \\theta_i} - \\frac{\\delta (y_j)}{\\delta \\theta_i}\\right]\\right) \\end{align} como la derivada de \\(y_i\\) es función de \\(\\theta_i\\) es cero, procedemos a calcular la derivada de \\(h_\\theta(x_j)\\): \\begin{align} \\frac{\\delta h_\\theta(x_j)}{\\delta \\theta_i} = \\frac{\\delta}{\\delta \\theta_i} \\sum_{k=1}^n \\theta_k x_{kj} = \\sum_{k=1}^n \\frac{\\delta}{\\delta \\theta_i} \\theta_k x_{kj} \\end{align} donde \\begin{align} \\frac{\\delta}{\\delta \\theta_i} \\theta_k x_{kj} = \\begin{cases} x_{kj}, & k = i \\\\ 0, & k \\neq i \\\\ \\end{cases} \\end{align} como para todo \\(k\\), con \\(1 \\leq k \\leq n\\) sólo hay un \\(k\\), tal que \\(k = i\\), entonces: \\begin{align} \\frac{\\delta h_\\theta(x_j)}{\\delta \\theta_i} = x_{kj} \\end{align} volemos a la derivada del peso, con \\(\\frac{\\delta h_\\theta(x_j)}{\\delta \\theta_i} = x_{kj}\\) y \\(\\frac{\\delta y_j}{\\delta \\theta_i} = 0\\): \\begin{align} = \\frac{1}{2m} \\left(\\sum_{j=1}^m 2(h_\\theta(x_j) - y_j) \\left[x_{ij} - 0\\right]\\right) \\end{align} \\begin{align} = \\frac{1}{2m} \\left(\\sum_{j=1}^m 2(h_\\theta(x_j) - y_j) \\cdot x_{ij}\\right) \\end{align} sacamos el factor constante 2 como factor común que se elimina con 1/2 \\begin{align} = \\frac{1}{m} \\left(\\sum_{j=1}^m (h_\\theta(x_j) - y_j) \\cdot x_{ij}\\right) \\end{align} finalmente, sustituimos todo en la función del gradiente: \\begin{align} \\theta_i = \\theta_i - \\alpha \\left( \\frac{\\delta j(\\theta)}{\\delta \\theta_i}\\right) = \\theta_i - \\alpha \\left[\\frac{1}{m} \\left(\\sum_{j=1}^m (h_\\theta(x_j) - y_j) \\cdot x_{ij}\\right)\\right] \\end{align} regularización con regularización debemos derivar la función que coste que incluye el parámetro de regularización: \\begin{align} \\theta_i = \\theta_i - \\alpha \\left( \\frac{\\delta j(\\theta)}{\\delta \\theta_i}\\right) + \\frac{\\lambda}{2m} \\sum_{k=1}^n \\theta_k^2 \\end{align} el primer término ya lo hemos derivado, por lo tanto procedemos a derivar el segundo término: \\begin{align} \\frac{\\delta}{\\delta \\theta_i} \\left(\\frac{\\lambda}{2m} \\sum_{k=1}^n \\theta_k^2\\right) = \\frac{\\lambda}{2m} \\left(\\sum_{k=1}^n \\frac{\\delta}{\\delta \\theta_i} \\theta_k^2\\right) \\end{align} donde \\begin{align} \\frac{\\delta}{\\delta \\theta_i} \\theta_k^2 = \\begin{cases} 2 \\theta_k, & k = i \\\\ 0, & k \\neq i \\end{cases} \\end{align} como para todo \\(k\\), con \\(1 \\leq k \\leq n\\) sólo hay un \\(k\\), tal que \\(k = i\\), entonces: \\begin{align} \\frac{\\delta}{\\delta \\theta_i} \\left(\\frac{\\lambda}{2m} \\sum_{k=1}^n \\theta_k^2\\right) = \\frac{\\lambda}{2m} 2\\theta_i = \\frac{\\lambda}{m} \\theta_i \\end{align} por lo tanto la función del descenso gradiente equivale a: \\begin{align} \\theta_i = \\theta_i - \\alpha \\left( \\frac{\\delta j(\\theta)}{\\delta \\theta_i}\\right) = \\theta_i - \\alpha \\left[\\frac{1}{m} \\left(\\sum_{j=1}^m (h_\\theta(x_j) - y_j) \\cdot x_{ij}\\right) + \\frac{\\lambda}{m}\\theta_i\\right] \\end{align} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/Evaluación de modelos.html",
    "title": "Evaluación de modelos",
    "body": " index search search back evaluación de modelos contents separaci n de datos entrenamiento en regresi n lineal entrenamiento en regresi n log stica selecci n de modelos cross validation proceso de selecci n diagn stico sesgo vs varianza regresi n lineal con regularizaci n escoger el par metro de regularizaci n curva de aprendizaje debugging un algoritmo de aprendizaje medidas de evaluaci n balance entre precisi n y recall separación de datos a la hora de entrenar un modelo, separamos los datos en dos conjuntos: conjunto de entrenamiento: \\(70\\%\\) - \\(80\\%\\) conjunto de test: \\(30\\%\\) - \\(20\\%\\) entrenamiento en regresión lineal el proceso de entrenamiento en la regresión lineal consiste en: entrenar el modelo sobre el conjunto de entrenamiento y obtener la matriz de pesos \\(\\theta\\) minimizando el coste \\(j(\\theta)\\) calcular el coste sobre el conjunto de test \\(j_{test}(\\theta)\\) \\[%align j_{test}(\\theta) = \\frac{1}{2m} \\sum_{i=1}^{m_{test}} (h_\\theta(x^{(i)}_{test}) - y^{(i)}_{test})^2 \\] entrenamiento en regresión logística el proceso de entrenamiento en la regresión logística consiste en: entrenar el modelo sobre el conjunto de entrenamiento y obtener la matriz de pesos \\(\\theta\\) minimizando el coste \\(j(\\theta)\\) calcular el coste sobre el conjunto de test \\(j_{test}(\\theta)\\) \\[%align j_{test}(\\theta) = - \\frac{1}{m} \\sum_{i=1}^{m_{test}} \\left[y^{(i)}_{test} \\log(h_\\theta(x^{(i)}_{test})) + (1-y^{(i)}_{test})\\log(1-h_\\theta(x^{(i)}_{test})) \\right] \\] el error de clasificación en la regresión logística se define como sigue: \\begin{align} error(h_\\theta(x), y) = \\begin{cases} 1, & \\text{ si } h_\\theta(x) \\geq 0.5 \\rightarrow \\log(h_\\theta(x)) = 1 \\text{ e } y = 0 \\\\ 1, & \\text{ si } h_\\theta(x) < 0.5 \\rightarrow \\log(h_\\theta(x)) = 0 \\text{ e } y = 1 \\\\ 0, \\text{ en cualquier otro caso } \\\\ \\end{cases} \\end{align} selección de modelos supongamos que tenemos \\(n\\) modelos, tal que cada modelo es equivalente al anterior pero con una característica más en sus datos: modelo 1: \\(h_\\theta(x) = \\theta_0 + \\theta_1 \\cdot x_1\\) modelo 2: \\(h_\\theta(x) = \\theta_0 + \\theta_1 \\cdot x_1 + \\theta_2 \\cdot x_2\\) modelo n: \\(h_\\theta(x) = \\theta_0 + \\theta_1 \\cdot x_1 + \\theta_2 \\cdot x_2 + \\cdots + \\theta_n \\cdot x_n\\) para evaluar los modelos lo que hacemos es escoger el que menor coste obtenga sobre el conjunto de test, tras ser entrenado sobre el conjunto de entrenamiento. \\begin{align} \\begin{bmatrix} \\theta^{(1)} \\\\ \\theta^{(2)} \\\\ \\vdots \\\\ \\theta^{(n)} \\\\ \\end{bmatrix} \\rightarrow \\begin{bmatrix} j_{test}(\\theta^{(1)}) \\\\ j_{test}(\\theta^{(2)}) \\\\ \\vdots \\\\ j_{test}(\\theta^{(n)}) \\\\ \\end{bmatrix} \\end{align} sin embargo, se puede dar el problema de que el mejor simplemente produzca overfitting sobre el conjunto de test (lo cual es probable cuando el vector de pesos tiene dimensiones grandes). para solventar este problema: cross validation separaremos el conjunto de datos en tres conjuntos: conjunto de entrenamiento: \\(60\\%\\) conjunto de validación cruzada (cross validation): \\(20\\%\\) conunto de test: \\(20\\%\\) por lo tanto ahora la función de coste para cada conjunto tiene la forma: función de coste para el conjunto de entrenamiento: \\begin{align} j_{train}(\\theta) = \\frac{1}{2m_{train}} \\sum_{i=1}^{m_{train}} error(h_\\theta(x^{(i)}), y^{(i)}) \\end{align} función de coste para el conjunto de test: \\begin{align} j_{test}(\\theta) = \\frac{1}{2m_{test}} \\sum_{i=1}^{m_{test}} error(h_\\theta(x^{(i)}), y^{(i)}) \\end{align} función de coste para el conjunto de validación cruzada: \\begin{align} j_{cv}(\\theta) = \\frac{1}{2m_{cv}} \\sum_{i=1}^{m_{cv}} error(h_\\theta(x^{(i)}), y^{(i)}) \\end{align} proceso de selección entonces ahora para seleccionar un modelo lo que hacemos que para cada modelo \\(q\\): minimizamos \\(j_{train}(\\theta^{(q)})\\) para obtener los pesos \\(\\theta^{(q)}\\) óptimos. calculamos el coste sobre el conjunto de validación cruzada \\(j_{cv}(\\theta^{(q)})\\) una vez hecho esto para todos, escogemos el modelo que ofrezca el mejor coste sobre el conjunto de validación cruzada y calculamos \\(j_{test}(\\theta^{(q)})\\) para evaluar la capacidad de generalización del modelo. diagnóstico: sesgo vs varianza underfitting: cuando se produce underfitting el coste de entrenamiento y el coste de validación tienen valores similares y ambos tiene valores bastante altos overfitting: cuando se produce overfitting el coste de entrenamiento es mucho menor que el coste de validación cruzada. regresión lineal con regularización también es importante observar cómo afecta el parámetro de regularización a nuestros modelos. por ejemplo, en la regresión linear, la función de coste tiene la forma: \\begin{align} j(\\theta) = \\frac{1}{2m}\\sum_{j=1}^m (h_\\theta(x_j) - y_j)^2 + \\frac{1}{2m} \\lambda \\sum_{i=1}^n \\theta_i^2 \\end{align} por lo tanto, el aumentar o reducir \\(\\lambda\\) es directamente proporcional al coste. si el parámetro de regularización \\(\\lambda\\) es muy grande entonces los pesos van a tender a ser muy pequeños (ya que el coste aumenta al aumentar el valor de \\(\\lambda\\)) si el parámetro de regularización \\(\\lambda\\) es muy pequeño entonces los pesos van a poder ser grandes (ya que el coste se reduce al reducir el valor de \\(\\lambda\\)) escoger el parámetro de regularización para escoger el parámetro de regularización seguimos el mismo proceso que para escoger el mejor modelo, para cada modelo \\(q\\): minimizamos \\(j_{train}(\\theta^{(q)})\\) para obtener los pesos \\(\\theta^{(q)}\\) óptimos. calculamos el coste sobre el conjunto de validación cruzada \\(j_{cv}(\\theta^{(q)})\\) una vez hecho esto para todos, escogemos el modelo que ofrezca el mejor coste sobre el conjunto de validación cruzada y calculamos \\(j_{test}(\\theta^{(q)})\\) para evaluar la capacidad de generalización del modelo. curva de aprendizaje a continuación vamos a estudiar cómo afecta el tamaño del conjunto de datos \\(m\\), el sesgo y la varianza a nuestro modelo: cuanto mayor es el tamaño, más difícil es encontrar una hipótesis que se adapte (\\(j_{train}(\\theta)\\) es mayor), pero el modelo generaliza mejor (\\(j_{cv}(\\theta)\\) es menor) cuando el sesgo (bias) es grande, entonces se produce underfitting y las predicciones de nuestro modelo son malas: el error del modelo es elevado, tanto sobre el conjunto de entrenamiento como sobre el conjunto de validación cruzada tener más ejemplos ayuda al modelo cuando la varianza (variance) es grande, entonces se produce overfitting, tal que el error en el conjunto de validación cruzada es muy alto: el modelo se adapta al conjunto de datos, por lo que el error de entrenamiento es menor tener más muestras ayuda al modelo debugging un algoritmo de aprendizaje para arreglar el overfitting que se produce cuando la varianza es elevada: obtener más datos de entrenamiento utilizar menos características (reducir el grado del vector de pesos), pero tras un proceso de selección de aquellas más relevantes intentar aumentar el parámetro de regularización para arregar el underfitting que se produce cuando el sesgo es elevado: añadir más características añadir características polinómicas intentar reducir el parámetro de regularización en las redes neuronales: las redes pequeñas tienden a producir underfitting pero son menos costosas computacionalmente las redes grandes tienen más características, por lo tanto hay una mayor probabilidad de overfitting gestionar datos sesgados: hay que ser consciente que a veces, por ejemplo en problemas de clasificación, hay categorías que con más comunes que el resto medidas de evaluación la precisión y el recall son medidas de evaluación que se complementan:     resultado resultado     1 0 predicción 1 verdadero positivo (tp) falso positivo (fp) predicción 0 falso negativo (fn) verdadero negativo (tn) precisión = \\(\\frac{tp}{\\text{ # positivos predichos }} = \\frac{tp}{tp + fp}\\) recall = \\(\\frac{tp}{\\text{ # positivos reales }} = \\frac{tp}{tp + fn}\\) balance entre precisión y recall cuánto mayor es la precisión menor es el recall y viceversa. entonces si queremos un modelo más preciso: \\begin{align} \\begin{cases} \\text{predecir } 1, \\text{ si } h_\\theta(x) \\geq 0.7 \\\\ \\text{predecir } 0, \\text{ si } h_\\theta(x) < 0.7 \\\\ \\end{cases} \\end{align} entonces, la precisión es mayor ya que el número de \\(fp\\) es menor, pero el recall es menor, ya que el número de \\(fn\\) es mayor. lo mismo pasa si queremos evitar falsos negativos, entonces hacemos: \\begin{align} \\begin{cases} \\text{predecir } 1, \\text{ si } h_\\theta(x) \\geq 0.5 \\\\ \\text{predecir } 0, \\text{ si } h_\\theta(x) < 0.5 \\\\ \\end{cases} \\end{align} tal que se reduce el número de \\(fn\\), y se aumenta el recall, pero el número de \\(fp\\) es mayor, por lo que se reduce la precisión. entonces, para encontrar un punto de balance entre las dos medidas tenemos que seleccionar un valor límite, tal que hacemos la predicción en base a \\(h_\\theta(x) \\geq \\text{ limite }\\). para calibrar ese límite podemos utilizar dos métricas de evaluación: la media de ambas métricas: \\(\\frac{p + r}{2}\\), funciona mal cuando \\(p >> r\\) o \\(r >> p\\), ya que el valor va a ser alto, pero no se ha encontrado un equilibrio. la puntuación \\(f_1 = 2 \\cdot \\frac{p\\cdot r}{(p + r)}\\), tal que cuanto mayor sea esta puntuación mejor ahora \\begin{align} \\begin{cases} f_1 \\approx 0, && p >> r \\\\ f_1 \\approx 0, && r >> p \\\\ \\end{cases} \\end{align} para escoger el límite lo que se hace es calcular la puntuación \\(f_1\\) sobre el conjunto de validación cruzada, y se escoge aquel límite que ofrezca la mayor puntuación. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/Map Reduce.html",
    "title": "Map Reduce",
    "body": " index search search back map reduce map reduce nos permite paralelizar los algoritmos. por ejemplo, supongamos que: tenemos \\(m = 400\\) datos utilizamos batch gradient descent para resolver el problema de optimización tenemos un número de pc equivalente a 4 sea \\(i\\) el índice de un pc este entrena sobre \\(x^{(i)}, \\cdots, x^{(i+100)}\\) calculamos el coste parcial para este conjunto de datos como: \\(temp_j^{(k)} = \\sum_{i}^{i+100} (h_\\theta(x^{(i)}) - y^{(i)})x^{(i)}_j\\) ahora, combinamos todos los pesos y aplicamos descenso gradiente: \\(\\theta_j = \\theta_j - \\alpha \\frac{1}{400} \\left( \\sum_{i}^k temp_j^{(i)}\\right)\\) este tipo de técnicas se utilizan si los algoritmos de entrenamiento pueden ser utilizamos como la suma de funciones, tanto el coste como el gradiente. también es aplicable a pcs con múltiples cores. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/MBJ/T3/02_information_criteria_and_crossvalidation.html",
    "title": "Information criteria and cross-validation",
    "body": " index search search back information criteria and cross-validation contents estimating out-of-sample predictive accuracy using available data akaike information criterion aic deviance information criterion dic and effective number of parameters watanabe-akaike or widely applicable information criterion waic effective number of parameters as a random variable bayesian information criterion bic leave-one-out cross-validation summary for historical reasons, measures of predictive accuracy are referred to as information criteria. these criteria are usually based on something called deviance that it's calculated by taking the negative two times the logarithm of the likelihood of the data given a point estimate of the model, \\(-2 \\log p(y|\\hat{\\theta}))\\). when we make predictions about new data that the model hasn't seen before, these predictions are usually less accurate than what we'd expect based on how well the model fits the data it was trained on. even if the family of models being fit happens to include the true data-generating process, and even if the parameters in the model happen to be sampled exactly from the specified prior distribution. we are interested in prediction accuracy for two reasons: to measure the performance of a model. to compare models. when comparing models with the same number of parameters, we can directly compare their best-fit log predictive densities. but when comparing models of different sizes or complexities we need to adjust for the fact that larger models can sometimes fit data better just by chance. estimating out-of-sample predictive accuracy using available data several methods are available to estimate the expected predictive accuracy without waiting for out-of-sample data. within-sample predictive accuracy: a naive estimate of the expected log predictive density for new data is the log predictive density for existing data using the computed lppd. this summary is in general an overestimate of elppd because it is evaluated on the data from which the model was fit. adjusted within-sample predictive accuracy: given that lppd is a biased estimate of elppd, the next logical step is to correct that bias. formulas such as aic, dic, and waic (all discussed below) give approximately unbiased estimates of elppd. cross-validation: one can attempt to capture out-of-sample prediction error by fitting the model to training data and then evaluating this predictive accuracy on a holdout set. cross-validation can be computationally expensive. akaike information criterion (aic) in much of the statistical literature on predictive accuracy, inference for \\(\\theta\\) is summarized not by a posterior distribution \\(p_{\\text{post}}\\) but by a point estimate \\(\\hat{\\theta}\\), typically the maximum likelihood estimate. out-of-sample predictive accuracy is then defined not by the expected log posterior predictive density (elppd) but by \\(\\text{elpd}_{\\hat{\\theta}} = \\mathbb{e}_f[\\log p(\\tilde{y}|\\tilde{\\theta}(y))]\\). let \\(k\\) be the number of parameters estimated in the model. aic is defined as follows: \\begin{align} \\hat{\\text{elpd}}_{\\text{aic}} = -2 \\log p(y|\\hat{\\theta}_{\\text{mle}}) + 2k \\end{align} subtracting \\(k\\) from the log predictive density given the maximum likelihood estimate \\(\\theta_{\\text{mle}}\\) is a correction to account for how much the fitting of \\(k\\) parameters will increase predictive accuracy, purely by chance. when we move beyond linear models with simple priors, just adding the number of fitted parameters \\(k\\) to adjust the deviance isn't accurate. informative priors and hierarchical structures typically decrease overfitting compared to simple estimation methods like least squares or maximum likelihood. in models with informative priors or hierarchical setups, the actual number of parameters depends heavily on the variance of the group-level parameter. deviance information criterion (dic) and effective number of parameters dic is a somewhat bayesian version of aic making two changes, replacing the maximum likelihood estimate with the posterior mean \\(\\hat{\\theta}_{\\text{bayes}} = \\mathbb{e}[\\theta|y]\\) and replacing \\(k\\) with a data-based bias correction. the new measure of predictive accuracy is: \\begin{align} \\hat{\\text{elpd}}_{dic} = \\log p(y|\\hat{\\theta}_{\\text{bayes}}) - p_{\\text{dic}} \\end{align} where \\(p_{\\text{dic}}\\) is the effective number of parameters, defined as: \\begin{align} p_{\\text{dic}} = 2 \\left(\\log p(y|\\hat{\\theta}_{\\text{bayes}}) - \\mathbb{e}_{post}[\\log p(y|\\theta)]\\right) \\end{align} where \\(\\mathbb{e}_{post}[\\log p(y|\\theta)]\\) is an average of \\(\\theta\\) over its posterior distribution. this is computed using simulation \\(\\theta^s, s= 1, \\cdots, s\\) as: \\begin{align} \\text{computed } p_{\\text{dic}} = 2 \\left(\\log p(y|\\hat{\\theta}_{\\text{bayes}}) - \\frac{1}{s} \\sum_{s=1}^s \\log p(y|\\theta^s)\\right) \\end{align} when the average value of \\(\\theta\\) in the posterior distribution matches the highest point (mode), it leads to the maximum log predictive density. however, if the average value is significantly different from the mode, it can result in a negative value for \\(p_{\\text{dic}}\\). an alternative version of dic uses a slightly different effective number of parameters: \\begin{align} p_{\\text{dic}_{\\text{alt}}} = 2 \\mathbb{v}_{\\text{post}}[\\log p(y|\\theta)] \\end{align} of these two measures, \\(p_{\\text{dic}}\\) is more numerically stable but \\(p_{\\text{dic}_{\\text{alt}}}\\) has the advantage of always being positive. the actual quantity called dic is defined in terms of the deviance rather than the log predictive density; thus: \\begin{align} \\text{dic} = -2 \\log p(y|\\hat{\\theta}_{\\text{bayes}}) + 2p_{dic} \\end{align} watanabe-akaike or widely applicable information criterion (waic) waic is a more fully bayesian approach for estimating the out-of-sample expectation. starting with the computed lppd and then adding a correction for effective number of parameters to adjust for overfitting. two adjustments have been proposed: \\begin{align} p_{\\text{waic}1} = 2 \\sum_{n=1}^n \\left(\\log(\\mathbb{e}_{\\text{post}}[p(y_i|\\theta)]) - \\mathbb{e}_{\\text{post}}[\\log p(y_i|\\theta)] \\right) \\end{align} computed by replacing the expectations by averages over the \\(s\\) posterior draws \\(\\theta^s\\): \\begin{align} \\text{computed } p_{\\text{waic}1} = 2 \\sum_{n=1}^n \\left(\\log\\left(\\frac{1}{s}\\sum_{s=1}^s p(y_i|\\theta^s)\\right) - \\frac{1}{s}\\sum_{s=1}^s \\log p(y_i|\\theta^s) \\right) \\end{align} the other measure uses the variance of individual terms: \\begin{align} p_{\\text{waic}2} = \\sum_{i=1}^n \\mathbb{v}_{\\text{post}}[\\log p(y_i|\\theta)] \\end{align} to compute it we compute the posterior sample variance (\\(\\mathbb{v}_{s=1}^s\\)) of the log predictive density for each data point \\(y_i\\) and we sum over all the data points: \\begin{align} \\text{computed } p_{\\text{waic}2} = \\sum_{i=1}^n \\mathbb{v}_{s=1}^s[\\log p(y_i|\\theta^s)] \\end{align} we can then use either \\(p_{\\text{waic}1}\\) or \\(p_{\\text{waic}2}\\) as a bias correction: \\begin{align} \\hat{\\text{elppd}}_{\\text{waic}} = \\text{lppd} - p_{\\text{waic}} \\end{align} as with \\(\\text{aic}\\) and \\(\\text{dic}\\), we define \\(\\text{waic}\\) so as to be on the deviance scale: \\begin{align} \\text{waic} = -2\\text{lppd} + 2p_{\\text{waic}2} \\end{align} for a normal linear model with a large sample size, known variance, and a uniform prior distribution on the coefficients, \\(p_{\\text{waic}1}\\) and \\(p_{\\text{waic}2}\\) are roughly equal to the number of parameters in the model. in general, this adjustment approximates the number of \"unconstrained\" parameters in the model. a parameter is counted as \\(1\\) if it's estimated without constraints or prior information, \\(0\\) if it's fully constrained, or if all the information comes from the prior distribution, or a value in between if both the data and prior distributions provide information. waic stands out because it averages over the whole posterior distribution rather than relying on a single point estimate, which is what aic and dic do. this makes waic more relevant when it comes to predicting new data in a bayesian framework. however, using waic requires dividing the data into \\(n\\) parts, which can be challenging in certain data setups like time series or spatial data. aic and dic don't require this explicit partition, but they assume that residuals are independent given a point estimate \\(\\hat{\\theta}\\), which may not fully capture posterior uncertainty. effective number of parameters as a random variable the number of parameters estimated in a model, as measured by \\(p_{\\text{dic}}\\) and \\(p_{\\text{waic}}\\), can vary depending on the observed data. let's take a simple example: imagine a model where the data \\(y_1, \\cdots, y_n\\) follow a normal distribution with a mean parameter \\(\\theta\\) and a known standard deviation of \\(1\\). the parameter \\(\\theta\\) is drawn from a uniform distribution between \\(0\\) and infinity, meaning it's positive but otherwise not informative. now, consider two scenarios: imagine you have a bunch of data points, but they are all very close to zero. in this case, the model has to consider that the parameter \\(\\theta\\) could be anywhere from very small positive values up to infinity. however, since the data are all close to zero, they don't provide much information about where \\(\\theta\\) might lie. the only constraint is that \\(\\theta\\) has to be positive. because the data don't give a strong indication of where \\(\\theta\\) might be, we say the effective number of parameters is roughly half. this is because half of the information about \\(\\theta\\) comes from the data, and the other half comes from the prior constraint that \\(\\theta\\) must be positive. now, imagine your data points are all large and positive. in this case, the constraint that \\(\\theta\\) must be positive doesn't really affect things much because the data already tell us that \\(\\theta\\) needs to be positive to explain those large positive values. since the data provide most of the information about where \\(\\theta\\) might lie, we say the effective number of parameters is approximately \\(1\\). this means that the data have a stronger influence on determining \\(\\theta\\) in this scenario. this example shows that even with the same model and true parameters, the effective number of parameters can change depending on the observed data. bayesian information criterion (bic) bic is a way to decide between different models by considering both how well the model fits the data and how complex the model is. the formula for bic is: \\begin{align} -2 \\log (p(y|\\hat{\\theta})) + k \\log(n) \\end{align} where \\(p(y|\\hat{\\theta})\\) is the likelihood of the data given the estimated parameters, \\(k\\) is the number of parameters in the model and \\(n\\) is the sample size. bic aims to approximate the marginal probability density of the data under the model, which can be used for comparing models and estimating relative posterior probabilities. bic tends to favor simpler models for large datasets because it penalizes complexity more, so a complicated model may perform well in predicting data but still have a high bic due to the penalty for complexity. unlike aic, which doesn't take the sample size into account, bic penalizes complex models more as the sample size increases. unlike aic, dic, and waic, bic doesn't focus on predicting future data but rather on estimating the probability of the observed data under the model. leave-one-out cross-validation in bayesian cross-validation, we split the data into two parts: a training set (\\(y_{\\text{ytrain}}\\)) and a holdout set (\\(y_{\\text{holdout}}\\)). we repeat this process multiple times, such that for each split: we train the model using the training set (\\(\\text{ytrain}\\)). this gives us a distribution of possible parameter values called \\(p_{\\text{train}}(\\theta) = p(\\theta|y_{\\text{train}})\\). then, we use this trained model to make predictions on the holdout set (\\(y_\\text{holdout}\\)). we evaluate the performance of our predictions using the log predictive density: \\begin{align} \\log p_{\\text{train}}(y_{\\text{holdout}}) = \\log \\mathbb{e}_{\\text{post}}[p_{\\text{train}}(y_{\\text{holdout}})] = \\log \\int p_{\\text{pred}}(y_{\\text{holdout}}|\\theta)p_{\\text{train}}(\\theta)d\\theta \\end{align} assuming the posterior distribution \\(p(\\theta|y_{\\text{train}})\\) is summarized by \\(s\\) simulation draws \\(\\theta^s\\), we calculate the log predictive density as: \\begin{align} \\log \\left(\\frac{1}{s} \\sum_{s=1}^s p(y_{\\text{holdout}}|\\theta^s)\\right) \\end{align} in loocv, we split the data into \\(n\\) partitions, where each partition represents a single data point. performing the analysis for each of the \\(n\\) data points yields n different inferences \\(p_{\\text{post}(-i)}\\), each summarized by \\(s\\) posterior simulations, \\(\\theta^{is}\\). the bayesian loo-cv estimate of out-of-sample predictive fit is: \\begin{align} \\text{lppd}_{\\text{loo-cv}} = \\sum_{i=1}^n \\log (p_{\\text{post}(-i)}(y_i)) \\end{align} computed as: \\begin{align} \\sum_{i=1}^n \\log \\left(\\frac{1}{s} \\sum_{s=1}^s p(y_i|\\theta^{is})\\right) \\end{align} where \\(\\theta^s\\) represents the \\(s\\) simulations under the posterior distribution \\(p(\\theta|y_{-1})\\). each prediction is conditioned on \\(n − 1\\) data points, which causes underestimation of the predictive fit. for large \\(n\\) the difference is negligible, but for small \\(n\\) (or when using \\(k\\)-fold cross-validation) we can use a first order bias correction b by estimating how much better predictions would be obtained if conditioning on \\(n\\) data points: \\begin{align} b = \\text{lppd} - \\overline{\\text{lppd}}_{-i} \\end{align} where: \\begin{align} \\overline{\\text{lppd}}_{-i} = \\frac{1}{n} \\sum_{i=1}^n \\sum_{j=1}^n \\log p_{\\text{post}(-i)}(y_j) \\end{align} computed as: \\begin{align} \\frac{1}{n} \\sum_{i=1}^n \\sum_{j=1}^n \\log \\left(\\frac{1}{s} \\sum_{s=1}^s p(y_j|\\theta^{is})\\right) \\end{align} the bias-corrected bayesian loo-cv is then: \\begin{align} \\text{lppd}_{\\text{cloo-cv}} = \\text{lppd}_{\\text{loo-cv}} + b \\end{align} the bias correction \\(b\\) is rarely used as it is usually small, but we include it for completeness. we compute an estimate of the effective number of parameters as: \\begin{align} p_{\\text{loo-cv}} = \\text{lppd} - \\text{lppd}_{\\text{loo-cv}} \\end{align} or, using bias-corrected loo-cv: \\begin{align} p_{\\text{cloo-cv}} = \\text{lppd} - \\text{lppd}_{\\text{cloo-cv}} \\end{align} \\begin{align} = \\overline{\\text{lppd}}_{-i} - \\text{lppd}_{\\text{loo-cv}} \\end{align} cv, like waic, requires the data to be split into distinct and ideally independent pieces. this can be challenging for structured models where the data isn't easily divided. additionally, cv can be computationally expensive, especially if the model needs to be re-fit for each fold. however, there are some shortcuts available, such as leave-one-out cross-validation (loo-cv), which can efficiently approximate predictions using the full posterior distribution. under certain conditions, different information criteria (like aic, dic, and waic) have been shown to be equivalent to loo-cv as the size of the dataset becomes very large. aic is equivalent to loo-cv when using maximum likelihood estimates. dic is a variation of regularized information criteria that approximates loo-cv using plug-in predictive densities. waic has been shown to be equivalent to bayesian loo-cv. loo-cv predicts the outcome for one data point using all other data points except that one. waic predicts the outcome for a data point using all observed data points. this difference becomes noticeable when dealing with small datasets or complex models, like hierarchical models. in regression or hierarchical models, loo-cv focuses on predicting specific data points, while waic predicts outcomes based on all observed data. this distinction can be important in models where predictions at one point are only weakly influenced by other data points. summary all the different measures discussed above are based on adjusting the log predictive density of the observed data by subtracting an approximate bias correction. the measures differ both in their baseline measures of fit and in their adjustments. aic starts with the log predictive density of the data conditional on the maximum likelihood estimate \\(\\hat{\\theta}\\), dic conditions on the posterior mean \\(\\mathbb{e}[\\theta|y]\\), and waic starts with the log predictive density, averaging over \\(p_{\\text{post}}(\\theta) = p(\\theta|y)\\). of these three approaches, only waic is fully bayesian and so it is our preference when using a bias correction formula. cross-validation can be applied to any measure of fit; we use the log pointwise posterior predictive density as with waic. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/MBJ/T3/03_model_comparison_based_on_predictive_performance.html",
    "title": "Model Comparison Based on Predictive Performance",
    "body": " index search search back model comparison based on predictive performance contents example aic dic waic cross validation comparing the three models evaluating predictive error comparisons bias induced by model selection challenges there are two common scenarios where we compare models. first, when we expand a model, we naturally want to compare the simpler version to the more complex one. we want to see if adding complexity improves the model's performance. conversely, if we simplify a model, we want to understand what information we might be losing. in essence, we're trying to figure out how much complexity is necessary to accurately represent the data. when comparing nested models, the bigger model usually fits the data better but can be more complex and harder to understand. so, we need to ask two main questions: does the better fit of the larger model justify its added complexity? and are the extra parameters in the larger model reasonable based on our prior knowledge? in the second scenario, we're comparing models that aren't nested. for example, we might compare two regression models that use different predictors to explain the same data. in these cases, we're not necessarily trying to pick one model over the other. instead, we might want to build a larger model that includes both sets of predictors, along with any interactions between them. this way, we get a more comprehensive picture. however, it's still useful to compare the performance of each model on its own to see how well they do individually. example on the eight schools example we defined three separate models: no pooling: separate estimates for each of the eight schools, reflecting that the experiments were performed independently. this model has eight parameters: an estimate for each school. complete pooling: a combined estimate averaging the data from all schools into a single number, reflecting that the eight schools come from the same population. this model has only one, shared, parameter. hierarchical model: a bayesian meta-analysis, partially pooling the eight estimates toward a common mean. this model has eight parameters but they are constrained through their hierarchical distribution and are not estimated independently; thus the effective number of parameters should be some number less than 8. in the following table we show the performance metrics for each of the models using predivtive log densities and information criteria. aic the log predictive density is higher—that is, a better fit—for the no pooling model. this makes sense: with no pooling, the maximum likelihood estimate is right at the data, whereas with complete pooling there is only one number to fit all \\(8\\) schools. however, the ranking of the models changes after adjusting for the fitted parameters (\\(8\\) for no pooling, \\(1\\) for complete pooling), and the expected log predictive density is estimated to be the best (that is, aic is lowest) for complete pooling. the last column of the table is blank for aic, as this procedure is defined based on maximum likelihood estimation which is meaningless for the hierarchical model. dic for both the no-pooling and complete-pooling models with their flat priors, dic provides results similar to aic. however, for the hierarchical model, dic falls in between the two extremes: it fits the data better than complete pooling but not as well as no pooling, and it suggests an effective number of parameters closer to \\(1\\) than to \\(8\\). this indicates that the estimated school effects are mostly pooled back to their common mean. when considering the correction for fitting, complete pooling emerges as the winner, which aligns with the idea that the data support very little variation between groups. waic this bayesian measure, similar to dic, indicates slightly worse fit to observed data for each model. this is because the posterior predictive density has a wider distribution, resulting in lower density values at the mode compared to the predictive density conditional on the point estimate. however, the correction for the effective number of parameters is lower with waic compared to dic. for models with no pooling and hierarchical models, the effective number of parameters (\\(p_{\\text{waic}}\\)) is about half of what's estimated by dic, suggesting that waic behaves as expected when there's only one data point per parameter. conversely, for complete pooling, \\(p_{\\text{waic}}\\) is only slightly less than \\(1\\), which aligns with expectations given the sample size of \\(8\\). overall, \\(p_{\\text{waic}}\\) is much less than pdic for all three models, mainly because the waic already considers much of the uncertainty stemming from parameter estimation. cross validation for this example, it's impossible to cross-validate the no-pooling model because it would mean predicting the performance of one school using data from the other seven, which isn't feasible. this highlights a key difference from information criteria, which assume predictions for the same schools and can work even in the absence of pooling. however, for the complete pooling and hierarchical models, we can directly perform leave-one-out cross-validation. in this setup, cross-validation predicts based only on information from other schools, while waic considers both the local observation and information from other schools. although both methods predict unknown future data, they differ in the amount of information used. as the hierarchical prior becomes less informative (or more vague), the predictive performance estimates diverge further, with the difference approaching infinity when the hierarchical prior becomes uninformative, effectively yielding the no-pooling model. comparing the three models in this dataset, the complete pooling model performs best in predicting new data. surprisingly, setting the hierarchical variance \\(\\tau\\) to zero results in a better fit to the data compared to both no pooling and complete pooling models. however, despite this result, we still prefer the hierarchical model because we don't believe \\(\\tau\\) is truly zero. for instance, the estimated effects in schools a and c show some differences, although they are not statistically significant. the data suggest that there might be no variation in effects between schools, but we are not entirely confident in this conclusion. therefore, while the model with \\(\\tau = 0\\) performs well, we might consider using a more informative prior distribution for \\(\\tau\\) to better capture the uncertainty and avoid implausible scenarios. in general, predictive accuracy measures are useful in parallel with posterior predictive checks to see if there are important patterns in the data that are not captured by each model. evaluating predictive error comparisons when comparing models for their predictive accuracy, we face two main challenges: statistical significance and practical significance. statistical significance arises from the uncertainty in estimating how well a model predicts new data. this uncertainty is due to variation in individual prediction errors, which can affect the averages we calculate from any finite dataset. a practical estimate of related sampling uncertainty can be obtained by analyzing the variation in the expected log predictive densities \\(\\hat{\\text{elppd}}\\) using parametric or nonparametric approaches. in some cases, we can use scoring functions that are familiar to experts in a particular field to understand the significance of differences in predictive accuracy. however, in situations where there are no established measures like auc, it can be challenging to interpret the significance of differences in log predictive probability between two models. one way to gauge the importance of such differences is by comparing them to simpler models. consider a scenario where we have two models for a survey of voters in an election: one model predicts a \\(50\\)/\\(50\\) chance for each voter to support either party, while the other model correctly assigns probabilities of \\(0.4\\) and \\(0.6\\) to the voters. in this case, the improvement in log predictive probability from using the better model can be calculated. for instance, if we have \\(1000\\) voters, the improvement would be \\(20\\), but for only \\(10\\) voters, the improvement would be just \\(2\\). this aligns with our intuition: a clear improvement in prediction is more noticeable in a larger dataset than in a smaller one where noise might overshadow the improvement. bias induced by model selection cross-validation and information criteria are methods that adjust for using the data twice—once for building the model and again for evaluating its performance. they aim to provide unbiased estimates of how well a model predicts new data. however, when these methods are used to select a model from multiple options, the estimate of predictive performance for the chosen model can be biased because of the selection process. when there are only a few models to compare, any bias introduced by the selection process is usually small. however, if there are many models to choose from, especially as the number of observations or predictors increases, the selection process can lead to significant overfitting. while it's possible to estimate and correct for this bias using additional cross-validation, it doesn't guarantee that the selected model will have the best predictive performance. therefore, cross-validation and information criteria are better suited for understanding models rather than selecting the best one among many options. challenges the methods we have for measuring how well predictive models fit still have their flaws. aic, dic, and waic don't always work perfectly: aic struggles with strong prior information, dic gives odd results when the average of the posterior distribution isn't reliable, and waic can be tricky to use with structured data like spatial or network data. cross-validation seems like a good alternative, but it can be slow to compute and doesn't always work well with dependent data. bayesian statisticians often don't rely solely on predictive error comparisons in their work because of various limitations. however, there are situations where comparing very different models is necessary, and in those cases, predictive comparisons can be valuable. additionally, measures of effective numbers of parameters are useful for understanding statistical methods. currently, we prefer cross-validation because it's similar to waic in large samples. however, in finite cases with weak priors or strong outliers, pareto-smoothed importance sampling loo-cv is both computationally efficient and robust. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/MBJ/T3/04_model_comparison_using_bayes_factors.html",
    "title": "Model Comparison Using Bayes Factors",
    "body": " index search search back model comparison using bayes factors contents example a discrete example in which bayes factors are helpful example a continuous example where bayes factors are a distraction in this chapter, we've been talking about how to evaluate and compare models by looking at how well they predict outcomes. another way to compare models is using bayesian analysis, where we use something called the bayes factor. so, if we have two models, let's call them \\(h_1\\) and \\(h_2\\), the bayes factor is just the ratio of how probable they are after we've looked at the data: \\begin{align} \\frac{p(h_2|y)}{p(h_1|y)} = \\frac{p(h_2)}{p(h_1)} \\times \\text{ bayes factor }(h_2;h_1) \\end{align} where \\begin{align} \\text{ bayes factor }(h_1; h_2) = \\frac{p(y|h_2)}{p(y|h_2)} = \\frac{\\int p(\\theta_2|h_2) p(y|\\theta_2, h_2) d\\theta_2}{\\int p(\\theta_1|h_1) p(y|\\theta_1, h_1) d\\theta_1} \\end{align} the bayes factor is only defined when the marginal density of \\(y\\) under each model is proper. this bayesian approach might sound good, but we usually don't recommend it. that's because the likelihood of the data given the model can be strongly influenced by parts of the model that are chosen somewhat arbitrarily and can't be tested with data. bayes factors can work well when the underlying model is truly discrete and for which it makes sense to consider one or the other model as being a good description of the data. we illustrate with an example from genetics. example: a discrete example in which bayes factors are helpful in the genetics example we talked about earlier, we can use bayes factors to help us make sense of things. imagine we have two possible scenarios: \\(h_1\\), where the woman is affected, and \\(h_2\\), where she's not affected. we can represent these scenarios using some numbers. for example, let's say \\(\\theta = 1\\) means she's affected, and \\(\\theta = 0\\) means she's not. now, let's say before we look at any data, we're equally likely to believe either scenario. so, the odds of h2 compared to h1 are 1 to 1, that is \\(\\frac{p(h_2)}{p(h_1)} = 1\\). then, when we look at the data and find out the woman has two unaffected sons, the data is \\(4\\) times more likely under \\(h_2\\) than under \\(h_1\\). that is \\(\\frac{p(y|h_2)}{p(y|h_1)} = \\frac{1.0}{0.25}\\). the posterior odds are thus \\(\\frac{p(h_2|y)}{p(h_1|y)} = 4\\) this example is helpful for bayes factors because the scenarios we're comparing make sense scientifically, and there are no other possible scenarios in between. also, the way the data fits with each scenario makes sense and gives us clear results. bayes factors don't work as well for models that are continuous. for instance, if we're looking at something like the effectiveness of a treatment, which can vary along a scale, it doesn't make sense to assign a probability to it being exactly zero. similarly, if we're comparing different models in regression, like deciding which variables to include, it's better to have all the possible variables in our consideration. we can then use a prior distribution to decide how much to trust each variable, even if we think some might not have much impact. to show why bayes factors struggle with continuous models, let's consider the example of the 8 schools problem, comparing the no-pooling and complete-pooling models. example. a continuous example where bayes factors are a distraction suppose we had analyzed the data from the 8 schools using bayes factors for the discrete collection of previously proposed standard models, no pooling (\\(h_1\\)) and complete pooling (\\(h_2\\)): \\begin{align} h_1: p(y|\\theta_1, \\cdots, \\theta_j) = \\prod_{j=1}^j text{n}(y_j|\\theta_j, \\sigma_j^2), p(\\theta_1, \\cdots, \\theta_j) \\propto 1 \\end{align} \\begin{align} h_2: p(y|\\theta_1, \\cdots, \\theta_j) = \\prod_{j=1}^j text{n}(y_j|\\theta_j, \\sigma_j^2), \\theta_1 = \\cdots = \\theta_j = \\theta \\propto 1 \\end{align} if we try to use bayes factors to pick or combine these models, we run into a problem. the bayes factor, which is the ratio of how likely the data is under one model compared to another, isn't defined here. that's because the prior distributions we're using are improper, which means they don't behave properly in the calculations. specifically, when we try to divide one function by another, we end up with \\(\\frac{0}{0}\\), which doesn't give us a clear answer. so, if we want to stick with the idea of assigning probabilities to these two specific models, we have two options: either use proper prior distributions or carefully construct improper ones in a way that makes sense. however, no matter which route we take, the results won't be very satisfying. more explicitly, suppose we replace the flat prior distributions in \\(h_1\\) and \\(h_2\\) by independent normal prior distributions, \\(\\text{n}(0, a^2)\\), for some large \\(a\\). the resulting posterior distribution for the effect in school \\(j\\) is: \\begin{align} p(\\theta_j|y) = (1 - \\lambda)p(\\theta_j|y, h_1) + \\lambda p(\\theta_j|y, h_2) \\end{align} the bayes factor, which compares how likely the data is under different models, is very sensitive to the prior variance, which is represented by \\(a^2\\). as we increase \\(a\\) (while keeping the data and prior odds fixed), the results tend to favor one model over the other more strongly. this means that bayes factors can't be reliably used with non-informative prior densities, even if we carefully define them in certain ways. another problem with bayes factors in this example is that they behave differently as we change the number of schools in the model. the results can vary significantly depending on how many schools are included, which doesn't make much sense from a scientific perspective. so, if we were to use bayes factors here, we'd likely run into issues during the model-checking stage, where we compare the model's predictions to what we know from real-world knowledge. instead, it might be better to use a smoother, continuous family of models that bridges the gap between the extreme models. this continuous model doesn't assign discrete probabilities to extreme values that don't make scientific sense. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/MBJ/T3/01_measure_precditive_accuracy.html",
    "title": "Measures of Predictive Accuracy",
    "body": " index search search back measures of predictive accuracy contents point prediction probabilistic prediction predictive accuracy for a single data point averaging over the distribution of future data evaluating predictive accuracy for a fitted model we begin by considering different ways of defining the accuracy or error of a model’s predictions then discuss methods for estimating predictive accuracy or error from data. preferably, the measure of predictive accuracy is specifically tailored for the application at hand, and it measures as correctly as possible the benefit (or cost) of predicting future data with the model. point prediction in point prediction (predictive point estimation or point forecasting) a single value is reported as a prediction of the unknown future observation. measures of predictive accuracy for point prediction are called scoring functions. for example, the mean squared error: \\begin{align} \\frac{1}{n} \\sum_{i=1}^n (y_i - \\mathbb{e}[y_i|\\theta])^2 \\end{align} or its weighted version: \\begin{align} \\frac{1}{n} \\sum_{i=1}^n \\frac{(y_i - \\mathbb{e}[y_i|\\theta])^2}{\\mathbb{v}[y_i|\\theta]} \\end{align} these are easy to compute but they are less appropiated for models that are far from the normal distribution. probabilistic prediction in probabilistic prediction (probabilistic forecasting) the aim is to report inferences about \\(\\hat{y}\\) in such a way that the full uncertainty over \\(\\hat{y}\\) is taken into account. these are called scoring rules. examples include the quadratic, logarithmic, and zero-one scores good scoring rules for prediction are: proper: the scoring rule encourages the decision maker to be honest when reporting their beliefs. local: the scoring rule takes into account the fact that some predictions may be worse than others, and it adjusts accordingly. for example the log predictive density or log-likelihood, \\(p(y|\\theta)\\), which is proportional to the mean squared error if the model is normal with constant variance. why not use the log posterior? the answer is that we are interested here in summarizing the fit of model to data, and for this purpose the prior is relevant in estimating the parameters but not inassessing a model's accuracy. we are not saying that the prior cannot be used in assessing a model's fit to data; rather we say that the prior density is not relevant in computing predictive accuracy. predictive accuracy for a single data point the best way to measure how well a model fits is by seeing how accurately it predicts outcomes in new data that it hasn't seen before (out-of-sample predictive performance), but that comes from the same process as the original data. we label \\(f\\) as the true model, \\(y\\) as the observed data and \\(\\tilde{y}\\) as future data. the out-of-sample predictive fit for a new data point \\(\\tilde{y}_i\\) using logarithmic score is: \\begin{align} \\log p_{\\text{post}}(\\tilde{y}_i) = \\log \\mathbb{e}_{\\text{post}}[p(\\tilde{y}_i|\\theta)] = \\end{align} by the definition of the expected value for a random variable: \\begin{align} = \\log \\int p(\\tilde{y}_i|\\theta) p_{\\text{post}}(\\theta)d\\theta \\end{align} where \\(p_{\\text{post}}(\\tilde{y}_i)\\) is the predictive density for \\(\\tilde{y}_i\\) induced by the posterior distribution \\(p_{\\text{post}}(\\theta)\\). note that we use \\(p_{\\text{post}}\\) and \\(\\mathbb{e}_{\\text{post}}\\) to denote any probability or expectation that averages over the posterior distribution of \\(\\theta\\). averaging over the distribution of future data the future data \\(\\tilde{y}_i\\) are themselves unknown and thus we define the expected out-of-sample log predictive density. by the definition of expected value of the function \\(\\log (x)\\) over \\(\\tilde{y}\\) with respect to a function \\(f\\) that describes the distribution of the data, we compute the expected log predictive density or elpd for a new data point as follows: \\begin{align} \\mathbb{e}_f[\\log p_{\\text{post}}(\\tilde{y}_i)] = \\int \\log (p_{\\text{post}}(\\tilde{y}_i)) f(\\tilde{y}_i) d\\tilde{y} \\end{align} in general we do not know the data distribution \\(f\\). a natural way to estimate the expected out-of-sample log predictive density would be to plug in an estimate for \\(f\\), but this will tend to imply too good a fit. for now we consider the estimation of predictive accuracy in a bayesian context. one can define a measure of predictive accuracy for the \\(n\\) data points taken one at a time: \\begin{align} \\sum_{i=1}^n \\mathbb{e}_f[\\log(p_{\\text{post}}(\\tilde{y}_i))] \\end{align} this gives us the expected log pointwise predictive density for a new dataset. using a single-point measure instead of dealing with the entire set of predictions (the joint distribution \\(p_{\\text{post}}(\\tilde{y})\\)) allows us to connect it to cross-validation, which helps us approximate how well our model performs on new data based on the data we already have. it is sometimes useful to consider predictive accuracy given a point estimate \\(\\theta(\\tilde{y})\\) (sampled data point given the parameter \\(\\theta\\)?). this gives us the expected log predictive density given \\(\\hat{\\theta}\\): \\begin{align} \\mathbb{e}_f[\\log(p(\\tilde{y}|\\theta))] \\end{align} evaluating predictive accuracy for a fitted model in practice the parameter \\(\\theta\\) is not known, so we cannot know the log predictive density \\(\\log p(y|\\theta)\\), which tells us how well our model predicts new data based on \\(\\theta\\). so, instead of using \\(\\theta\\) directly, we use something called the posterior distribution, denoted as \\(p_{\\text{post}}(\\theta) = p(\\theta|y)\\). this distribution gives us a range of possible values for \\(\\theta\\) based on the data we have. from this distribution, we can summarize how accurately our model predicts new data. so we define the log pointwise predictive density or lppd as: \\begin{align} \\log \\prod_{i=1}^n p_{\\text{post}}(y_i) = \\sum_{i=1}^n \\log \\int p(y_i|\\theta)p_{\\text{post}}(\\theta)d\\theta \\end{align} to calculate this predictive density, we can use samples drawn from the posterior distribution \\(p_{\\text{post}}(\\theta)\\) using simulation. these samples are labeled as \\(\\theta_s\\), where \\(s\\) ranges from \\(1\\) to \\(s\\). so we define the computed log pointwise predictive density or computed lppd as: \\begin{align} \\sum_{i=1}^n \\log \\left(\\frac{1}{s}\\sum_{s=1}^s p(y_i|\\theta^s)\\right) \\end{align} we basically compute the sample mean of the likelihood \\(p(y_i|\\theta)\\) for over all the \\(\\{\\theta^s\\}_{s=1}^s\\) we typically assume that the number of simulation draws \\(s\\) is large enough to fully capture the posterior distribution. the lppd of observed data y is an overestimate of the elppd for future data. hence the plan is to start with lppd and then apply some sort of bias correction to get a reasonable estimate of elppd. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/MBJ/01_intro.html",
    "title": "T1. Introduccion a la Inferencia Bayesiana",
    "body": " index search search back t1. introduccion a la inferencia bayesiana contents the three steps of bayesian data analysis notation exchangeability explanatory variables hierarchical modeling bayesian inference prediction likelikhood likelihood and odds ratios probability theory means and variances of conditional distributions transformation of variables the three steps of bayesian data analysis the process of bayesian data analysis can be idealized by dividing it into the following three steps: setting up a full probability model: a joint probability distribution for all observable and unobservable quantities in a problem. conditioning on observed data: calculating and interpreting the appropriate posterior distribution. evaluating the fit of the model and the implications of the resulting posterior distribution we distinguish between two kinds of estimands quantities that are not directly observable: for example, parameters that govern the hypothetical process leading to the observed data, for which statistical inferences are made. potentially observable quantities (such as future observations of a process, or the outcome under the treatment not received) notation \\(\\theta\\): unobservable vector quantities or population parameters. \\(y\\): observed data \\(\\tilde{y}\\): unknown, but potentially observable, quantities. exchangeability we assume assume that the \\(n\\) values \\(y_i\\) may be regarded as exchangeable. we express uncertainty as a joint probability density \\(p(y_1, \\cdots, y_n)\\) that is invariant to permutations of the indexes. we commonly model data from an exchangeable distribution as independently and identically distributed (iid). explanatory variables observations on each unit that we do not model as random. hierarchical modeling hierarchical models (also called multilevel models), which are used when information is available on several different levels of observational units. bayesian inference we define a prior distribution \\(p(\\theta)\\), and a sampling distribution (or data distribution) is given by \\(p(y|\\theta)\\), such that the joint probability distribution for \\(\\theta\\) and \\(y\\) is obtained as follows: \\begin{align} p(\\theta,y) = p(\\theta|y)p(y) \\end{align} by baye's rule: \\begin{align} p(\\theta|y) = \\frac{p(\\theta, y)}{p(y)} = \\frac{p(y|\\theta)p(\\theta)}{p(y)} \\end{align} where \\(p(y) = \\sum_y p(y, \\theta) = \\sum_y p(y|\\theta) p(y) = \\int_y p(y|\\theta) p(y) dy\\) an equivalent form is omitting the factor \\(p(y)\\), yielding the unnormalized posterior density: \\begin{align} p(\\theta|y) \\propto p(y|\\theta)p(\\theta) \\end{align} prediction the marginal distribution of \\(y\\) or prior predictive distribution is given by: \\begin{align} p(y) = \\int p(y, \\theta) dy = \\int p(y|\\theta) p(\\theta) d\\theta \\end{align} the distribution of \\(\\tilde{y}\\) is called the posterior predictive distribution, posterior because it is conditional on the observed \\(y\\) and predictive because it is a prediction for an observable \\(\\tilde{y}\\). it is defined as the marginalization of \\(\\tilde{y}\\) over \\(y\\). \\begin{align} p(\\tilde{y}|y) = \\int p(\\tilde{y}, \\theta|y)d\\theta \\end{align} we note that the statistical process is also conditioned on the unobservable data \\(\\theta\\). por la propiedad \\(p(x, y|z) = p(x|y, z)p(z)\\): \\begin{align} = \\int p(\\tilde{y}|y, \\theta)p(\\theta|y) d\\theta \\end{align} asumimos independencia condicional entre \\(y\\) y \\(\\tilde{y}\\): \\begin{align} = \\int p(\\tilde{y}|\\theta)p(\\theta|y) d\\theta \\end{align} likelikhood when regarded as a function of \\(\\theta\\), for fixed y \\(p(y|\\theta)\\) is the likelihood function. likelihood and odds ratios odds a posteriori: \\begin{align} \\frac{p(\\theta_1|y)}{p(\\theta_2|y)} = \\frac{\\frac{p(y|\\theta_1)p(\\theta_1)}{p(y)}}{\\frac{p(y|\\theta_2)p(\\theta_2)}{p(y)}} = \\frac{p(y|\\theta_1)p(\\theta_1)}{p(y|\\theta_2)p(\\theta_2)} \\end{align} odds a priori: \\begin{align} \\frac{p(\\theta_1)}{p(\\theta_2)} \\end{align} likelihood ratio: \\begin{align} \\frac{p(\\theta_1|y)}{p(\\theta_2|y)} \\end{align} probability theory the expected value of a continuous random variable \\(u\\) is given by: \\begin{align} \\mathbb{e}[u] = \\int u p(u)du \\end{align} the variance for a continuous random variable \\(u\\) is given by: \\begin{align} \\mathbb{e}[u] = \\int (u - \\mathbb{e}[u])^2 p(u)du \\end{align} the expected value of a discrete random variable \\(u\\) is given by: \\begin{align} \\mathbb{e}[u] = \\sum u p(u) \\end{align} the variance for a discrete random variable \\(u\\) is given by: \\begin{align} \\mathbb{e}[u] = \\sum (u - \\mathbb{e}[u])^2 p(u) \\end{align} means and variances of conditional distributions given two continuous random variables \\(u\\) and \\(y\\), the mean of \\(u\\) can be obtained by averaging the conditional mean over the marginal distribution of \\(v\\): \\begin{align} \\mathbb{e}(u) = \\int u p(u) du = \\int u \\left(\\int p(u, v)\\right) dv du \\end{align} \\begin{align} = \\int \\left(\\int u p(u|v) du \\right) p(v) dv = \\int \\mathbb{e}_u[u|v] p(v) dv = \\mathbb{e}_v[\\mathbb{e}_u[u|v]] \\end{align} the corresponding result for the variance: \\begin{align} \\mathbb{v}[u] = \\mathbb{e}[\\mathbb{v}[u|v]] - \\mathbb{v}[\\mathbb{e}[u|v]] \\end{align} transformation of variables suppose \\(p_u(u)\\) is the density of the vector \\(u\\), and we transform to \\(v = f(u)\\), where \\(v\\) has the same number of components as \\(u\\). if \\(p_u\\) is a discrete distribution, and \\(f\\) is a one-to-one function, then the density of \\(v\\) is given by: \\begin{align} p_v(v) = p_u(f^{-1}(v)) \\end{align} if \\(p_u\\) is a continuous distribution, and \\(v = f(u)\\) is a one-to-one transformation, then the joint density of the transformed vector is: \\begin{align} p_v(v) = |j| p_u(f^{-1}(v)) \\end{align} where \\(|j|\\) is the absolute value of the determinant of the jacobian of the transformation \\(u = f^{−1}(v)\\) as a function of \\(v\\). $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/MBJ/T4/01_gibbs_sampler.html",
    "title": "Gibbs Sampler",
    "body": " index search search back gibbs sampler contents introduction gibbs sampler example bivariate normal distribution introduction many smart techniques have been developed to create and sample from different types of posterior distributions. one common method is called markov chain simulation, also known as markov chain monte carlo (mcmc). it works by first drawing values of a parameter (usually denoted as \\(\\theta\\)) from rough estimates of the distribution, and then adjusting those draws to better match the actual distribution we're interested in, called the posterior distribution, denoted as \\(p(\\theta|y)\\). the drawing process is done step by step, with each draw depending on the previous one, forming what's called a markov chain. figure 11.1 shows a simple example of markov chain simulation, using what's called a metropolis algorithm. imagine we have a parameter called \\(\\theta\\) that is a vector with two components, such that \\(\\theta \\sim \\text{n}(0, i)\\). now, let's look at figure 11.1a, which shows the early steps of this simulation. the picture represents all the possible values that \\(\\theta\\) can take, and each of the five squiggly lines shows the path taken by a random walk. these random walks start either near the center or at the edges of the distribution and move around based on a series of random steps. in figure 11.1b, we see the later stages of the same simulation. each of the random walks has now traced a path throughout the entire space of possible \\(\\theta\\) values. they've settled into a common pattern, which matches the target distribution we're interested in. finally, in figure 11.1c, we can use the information gathered from the second halves of these simulated random walks to make inferences about \\(\\theta\\). in our use of markov chain simulation, we create multiple separate sequences. each sequence starts from a particular point, like \\(\\theta_0\\), and then we move step by step, drawing a new value \\(\\theta_t\\) from a transition distribution \\(t_t(\\theta_t|\\theta_{t−1})\\), which depends on the previous draw. markov chain simulation is used when it is not possible to sample \\(\\theta\\) directly from \\(p(\\theta|y)\\) instead we sample iteratively in such a way that at each step of the process we expect to draw from a distribution that becomes closer to \\(p(\\theta|y)\\). once the simulation algorithm has been implemented and the simulations drawn, it is absolutely necessary to check the convergence of the simulated sequences; for example, the simulations of figure 11.1a are far from convergence and are not close to the target distribution. gibbs sampler imagine you have a \\(d\\)-dimensional parameter vector \\(\\theta\\) that's been split into smaller parts, such that \\(\\theta = (\\theta_1, \\cdots, \\theta_d)\\). each time the gibbs sampler runs, it goes through each of the dimensions, one at a time, while keeping the rest fixed. so, if there are \\(d\\) dimensions, there are \\(d\\) steps in each iteration \\(t\\). at each iteration, we pick an order for the \\(d\\) parts of \\(\\theta\\). then, we go through each part one by one and we sample a new value for each part based on the current values of all the other parts. this continues for each part until we've updated all of them once, and then we start the process over again for the next iteration. \\begin{align} p(\\theta_j|\\theta_{-j}^{t-1}, y) \\end{align} where \\(\\theta_{-j}^{t-1}\\) represents all the components of \\(\\theta\\) except for \\(\\theta_j\\) at their current values: \\begin{align} \\theta_{-j}^{t - 1} = (\\theta_1^t, \\cdots, \\theta^t_{j - 1}, \\theta_{j + 1}^{t - 1}, \\theta_{d}^{t - 1}) \\end{align} thus, each subvector \\(\\theta_j\\) is updated conditional on the latest values of the other components of \\(\\theta\\), which are the iteration \\(t\\) values for the components already updated and the iteration \\(t − 1\\) values for the others. here, we illustrate the workings of the gibbs sampler with a simple example. example: bivariate normal distribution consider a single observation \\((y_1, y_2)\\) from a bivariate normally distributed population with unknown mean \\(\\theta = (\\theta_1, \\theta_2)\\) and known covariance matrix \\(\\begin{bmatrix}1 & \\rho \\\\ \\rho & 1\\end{bmatrix}\\). with a uniform prior distribution on \\(\\theta\\), the posterior distribution is: \\begin{align} \\begin{bmatrix} \\theta_1 \\\\ \\theta_2 \\\\ \\end{bmatrix} | y \\sim \\text{n}(\\begin{bmatrix} y_1 \\\\ y_2 \\\\ \\end{bmatrix}, \\begin{bmatrix} 1 & \\rho \\\\ \\rho & 1 \\\\ \\end{bmatrix}) \\end{align} we need the conditional posterior distributions, which, from the properties of the multivariate normal distribution, are: \\begin{align} \\theta_1 |\\theta_2, y \\sim \\text{n}(y_1 + \\rho(\\theta_2 - y_2), 1 - \\rho^2) \\end{align} \\begin{align} \\theta_2 |\\theta_1, y \\sim \\text{n}(y_2 + \\rho(\\theta_1 - y_1), 1 - \\rho^2) \\end{align} the gibbs sampler proceeds by alternately sampling from these two normal distributions. figure 11.2 illustrates for the case \\(\\rho = 0.8\\), data \\((y_1, y_2) = (0, 0)\\), and four independent sequences started at \\((\\pm 2.5, \\pm 2.5)\\). $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/MBJ/T4/05_effective_number_of_simulations.html",
    "title": "Effective Number of Simulation Draws",
    "body": " index search search back effective number of simulation draws contents bounded or long-tailed distributions stopping the simulations one way to define effective sample size for correlated simulation draws is to consider the statistical efficiency of the average of the simulations \\(\\overline{\\psi}_{..}\\), as an estimate of the posterior mean, \\(\\mathbb{e}[\\psi|y]\\). this might be inappropriate, for example, if there is particular interest in accurate representation of low-probability events in the tails of the distribution. continuing with this definition, it is usual to compute effective sample size using the following asymptotic formula for the variance of the average of a correlated sequence: \\begin{align} \\lim_{n \\rightarrow \\infty} mn \\mathbb{v}[\\overline{\\psi}_{..}] = \\left(1 + 2 \\sum_{t = 1}^{\\infty} \\rho_t\\right) \\mathbb{v}[\\psi|y] \\end{align} where \\(\\rho_t\\) is the autocorrelation of the sequence \\(\\psi\\) at \\(t\\). in the presence of correlation we then define the effective sample size as: \\begin{align} n_{eff} = \\frac{mn}{1 + 2 \\sum_{t = 1}^{\\infty} \\rho_t} \\end{align} the asymptotic nature of the previous equations might seem disturbing given that in reality we will only have a finite simulation, but this should not be a problem given that we already want to run the simulations long enough for approximate convergence to the (asymptotic) target distribution. we then estimate the correlations as: \\begin{align} \\hat{\\rho}_t = 1 - \\frac{v_t}{2 \\overline{\\mathbb{v}}^+} \\end{align} where: \\begin{align} v_t = \\frac{1}{m(n - t)} \\sum_{j=1}^m \\sum_{i = t+1}^n (\\psi_{i,j} - \\psi_{i - t, j})^2 \\end{align} unfortunately we cannot simply sum all of these to estimate \\(n_{eff}\\) given that for large values of \\(t\\) the sample correlation \\(\\psi_t\\) is too noisy. instead we compute a partial sum, starting from \\(t = 0\\) and continuing until the sum of autocorrelation estimates for two successive iterationsis negative: \\begin{align} \\hat{n}_{eff} = \\frac{mn}{1 + 2 \\sum_{t = 1}^t \\hat{\\rho}_t} \\end{align} all these calculations should be performed using only the saved iterations, after discarding the warm-up period. bounded or long-tailed distributions the above convergence diagnostics are based on means and variances, and they will not work so well for parameters or scalar summaries for which the posterior distribution, \\(p(\\phi|y)\\), is far from gaussian. for summaries \\(\\phi\\) whose distributions are constrained or otherwise far from normal, we can preprocess simulations using transformations before computing the potential scale reduction factor \\(\\hat{r}\\) and the effective sample size \\(\\hat{n}_{eff}\\). stopping the simulations we monitor convergence for the entire multivariate distribution, \\(p(\\theta|y)\\), by computing the potential scale reduction factor \\(\\hat{r}\\) and the effective sample size \\(\\hat{n}_{eff}\\) for each scalar summary of interest. we recommend computing the potential scale reduction for all scalar estimands of interest; if \\(\\hat{r}\\) is not near \\(1\\) for all of them, continue the simulation runs. we can use effective sample size \\(\\hat{n}_{eff}\\) to give us a sense of the precision obtained from our simulations. as a default rule, we suggest running the simulation until \\(\\hat{n}_{eff}\\) is at least \\(5m\\), that is, until there are the equivalent of at least \\(10\\) independent draws per sequence. for some purposes, more precision will be desired, and then a higher effective sample size threshold can be used. once \\(\\hat{r}\\) is near \\(1\\) and \\(\\hat{n}_{eff}\\) is more than \\(10\\) per chain for all scalar estimands of interest, just collect the \\(mn\\) simulations (with warm-up iterations already excluded) and treat them as a sample from the target distribution. even if an iterative simulation appears to converge and has passed all tests of convergence, it still may actually be far from convergence if important areas of the target distribution were not captured by the starting distribution and are not easily reachable by the simulation algorithm. when we declare approximate convergence, we are actually concluding that each individual sequence appears stationary and that the observed sequences have mixed well with each other. these checks are not hypothesis tests. there is no p-value and no statistical significance. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/MBJ/T4/03_using_gibbs_and_metropolis.html",
    "title": "Using Gibbs and Metropolis as Building Blocks",
    "body": " index search search back using gibbs and metropolis as building blocks contents interpretation of the gibbs sampler as a special case of the metropolis-hastings algorithm gibbs sampler with approximations the gibbs sampler is the simplest of the markov chain simulation algorithms, and it is our first choice for conditionally conjugate models. the metropolis algorithm can be used for models that are not conditionally conjugate. a general problem with conditional sampling algorithms is that they can be slow when parameters are highly correlated in the target distribution. interpretation of the gibbs sampler as a special case of the metropolis-hastings algorithm we first define iteration \\(t\\) to consist of a series of \\(d\\) steps, with step \\(j\\) of iteration \\(t\\) corresponding to an update of the subvector \\(\\theta_j\\) conditional on all the other elements of \\(\\theta\\). then the jumping distribution, \\(j_{j,t}(\\cdot|\\cdot)\\) is defined as follows: \\begin{align} j_{j, t}^{\\text{gibbs}}(\\theta^*|\\theta^{t-1}) = \\begin{cases} p(\\theta_j^*|\\theta_{-j}^{t-1}, y) & \\text{ if } \\theta_{-j}^* = \\theta_{-j}^{t-1} \\\\ 0 & \\text{ otherwise} \\end{cases} \\end{align} such that at step \\(j\\) of iteration \\(t\\) it only jumps along the \\(j\\)th subvector, and does so with the conditional posterior density of \\(\\theta_j\\) given \\(\\theta_{-j}^{t - 1}\\). the only possible jumps are to parameter vectors \\(\\theta^*\\) that match \\(\\theta^{t-1}\\) on all components other than the \\(j\\)th. under this jumping distribution, the ratio at the \\(j\\)th step of iteration t is: \\begin{align} r = \\frac{\\frac{p(\\theta^*|y)}{j_{j, t}^{\\text{gibbs}}(\\theta^*|\\theta^{t-1})}}{\\frac{p(\\theta^{t-1}|y)}{j_{j,t}^{\\text{gibbs}}(\\theta^{t-1}|\\theta^*)}} \\end{align} \\begin{align} = \\frac{\\frac{p(\\theta^*|y)}{p(\\theta_j^*|\\theta^{t-1}_{-j}, y)}}{\\frac{p(\\theta^{t-1}|y)}{p(\\theta^{t-1}_j|\\theta^{t-1}_{-j}, y)}} \\end{align} \\begin{align} = \\frac{p(\\theta^{t-1}_{-j}, y)}{p(\\theta^{t-1}_{-j}, y)} \\end{align} \\begin{align} = 1 \\end{align} and thus every jump is accepted. the second line above follows from the first because, under this jumping rule, \\(\\theta^*\\) differs from \\(\\theta^{t−1}\\) only in the \\(j\\)th component. the third line follows from the second by applying the rules of conditional probability to \\(\\theta = (\\theta_j, \\theta_{−j})\\) and noting that \\(\\theta^*_{-j} = \\theta^{t-1}_{-j}\\). it is possible to define gibbs sampling without the restriction that each component be updated in each iteration, as long as each component is updated periodically. gibbs sampler with approximations for some problems, sampling from some, or all, of the conditional distributions \\(p(\\theta_j|\\theta_{−j}, y)\\) is impossible, but one can construct approximations, which we label \\(g(\\theta_j|\\theta_{−j})\\), from which sampling is possible. the jumping function at the jth metropolis step at iteration \\(t\\) is then: \\begin{align} j_{j, t}(\\theta^*|\\theta^{t-1}) = \\begin{cases} g(\\theta^*_j|\\theta_{-j}^{t-1}) & \\text{ if } \\theta^*_{-j} = \\theta^{t-1}_{-j} \\\\ 0 & \\text{ otherwise } \\end{cases} \\end{align} and the ratio \\(r\\) must be computed and the acceptance or rejection of \\(\\theta^*\\) decided. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/MBJ/T4/04_inference_and_assesing_convergence.html",
    "title": "Inference and Assessing Convergence",
    "body": " index search search back inference and assessing convergence contents difficulties of inference from iterative simulation discarding early iterations of the simulation runs dependence of the iterations in each sequence multiple sequences with overdispersed starting points monitoring scalar estimands challenges of monitoring convergence mixing and stationarity splitting each saved sequence into two parts assessing mixing using between- and within-sequence variances example bivariate unit normal density with bivariate normal jumping kernel continued the basic method of inference from iterative simulation is the same as for bayesian simulation in general: use the collection of all the simulated draws from \\(p(\\theta|y)\\) to summarize the posterior density and to compute quantiles, moments, and other summaries of interest as needed. difficulties of inference from iterative simulation iterative simulation adds two challenges to simulation inference: if the iterations have not proceeded long enough the simulations may be unrepresentative of the target distribution (figure 11.1a) the iterative simulation draws present within-sequence correlation. serial correlation in the simulations is not necessarily a problem because, at convergence, the draws are identically distributed as \\(p(\\theta|y)\\). but such correlation can cause inefficiencies in simulations. we handle these problems as follows: we design the simulation runs to allow effective monitoring of convergence by simulating multiple sequences with starting points dispersed throughout parameter space. we monitor the convergence of all quantities of interest by comparing variation between and within simulated sequences until \"within\" variation roughly equals \"between\" variation. only when the distribution of each simulated sequence is close to the distribution of all the sequences mixed together can they all be approximating the target distribution. if the simulation efficiency is low, the algorithm may be altered. discarding early iterations of the simulation runs to diminish the influence of the starting values, we discard the first half of each sequence and focus attention on the second half. so our inferences will be based on the assumption that the distributions of the simulated values \\(\\theta_t\\), for large enough \\(t\\), are close to the target distribution, \\(p(\\theta|y)\\). we refer to the practice of discarding early iterations in markov chain simulation as warm-up. depending on the context, different warm-up fractions (number of elements on the sequence to discard) can be appropriate. dependence of the iterations in each sequence once approximate convergence has been reached, is whether to thin the sequences by keeping every \\(k\\)th simulation draw from each sequence and discarding the rest. whether or not the sequences are thinned, if the sequences have reached approximate convergence, they can be directly used for inferences about the parameters \\(\\theta\\) and any other quantities of interest. multiple sequences with overdispersed starting points our recommended approach to assessing convergence of iterative simulation is based on comparing different simulated sequences, as illustrated in figure 11.1. in figure 11.1a, the multiple sequences clearly have not converged; the variance within each sequence is much less than the variance between sequences. later, in figure 11.1b, the sequences have mixed, and the two variance components are essentially equal. monitoring scalar estimands we monitor each scalar estimand or other scalar quantities of interest separately. estimands include all the parameters of interest in the model and any other quantities of interest (for example, the ratio of two parameters or the value of a predicted future observation). it is often useful also to monitor the value of the logarithm of the posterior density, which has probably already been computed if we are using a version of the metropolis algorithm. challenges of monitoring convergence: mixing and stationarity figure 11.3a illustrates that, to achieve convergence, the sequences must together have mixed. the second graph in figure 11.3 shows two chains that have mixed, in the sense that they have traced out a common distribution, but they do not appear to have converged. figure 11.3b illustrates that, to achieve convergence, each individual sequence must reach stationarity. so to check convergence we have to simultaneously tests mixing (if all the chains have mixed well, the separate parts of the different chains should also mix) and stationarity (at stationarity, the first and second half of each sequence should be traversing the same distribution). splitting each saved sequence into two parts we diagnose convergence (as noted above, separately for each scalar quantity of interest) by checking mixing and stationarity. our approach consists on splitting each chain in half and check that all the resulting halfsequences have mixed. we start with some number of simulated sequences in which the warm-up period has already been discarded. we then take each of these chains and split into the first and second half. let \\(m\\) be the number of chains (after splitting) and \\(n\\) be the length of each chain. for example, suppose we simulate \\(5\\) chains, each of length \\(1000\\), and then discard the first half of each as warm-up. we are then left with \\(5\\) chains, each of length \\(500\\), and we split each into two parts: iterations \\(1–250\\) (originally iterations \\(501–750\\)) and iterations \\(251–500\\) (originally iterations \\(751–1000\\)). we now have \\(m = 10\\) chains, each of length \\(n = 250\\). assessing mixing using between- and within-sequence variances for each scalar estimand \\(\\psi\\), we label the simulations as \\(\\psi_{ij}, (i = 1, \\cdots, n; j = 1, \\cdots, m)\\), and we compute \\(b\\) and \\(w\\), the between- and within-sequence variances: \\begin{align} b = \\frac{n}{m - 1} \\sum_{j=1}^m (\\overline{\\psi}_{.j} - \\overline{\\psi}_{..})^2 \\end{align} where: \\begin{align} \\overline{\\psi}_{.j} = \\frac{1}{n} \\sum_{i=1}^n \\psi_{ij} \\end{align} \\begin{align} \\overline{\\psi}_{..} = \\frac{1}{m} \\sum_{j=1}^m \\overline{\\psi}_{.j} \\end{align} and \\begin{align} w = \\frac{1}{m} \\sum_{j=1}^m s_{j}^2 \\end{align} where \\begin{align} s^2_j = \\frac{1}{n - 1} \\sum_{i = 1}^n (\\psi_{ij} - \\overline{\\psi}_{.j})^2 \\end{align} we can estimate \\(\\mathbb{v}[\\psi|y]\\), the marginal posterior variance of the estimand, by a weighted average of \\(w\\) and \\(b\\), namely: \\begin{align} \\hat{\\mathbb{v}}^+[\\psi|y] = \\frac{n - 1}{n}w + \\frac{1}{n} b \\end{align} this quantity overestimates the marginal posterior variance assuming the starting distribution is appropriately overdispersed, but is unbiased under stationarity. meanwhile, for any finite \\(n\\), the \"within\" variance \\(w\\) should be an underestimate of \\(\\mathbb{v}[\\psi|y]\\) because the individual sequences have not had time to range over all of the target distribution and, as a result, will have less variability; in the limit as \\(n \\rightarrow \\infty\\), the expectation of \\(w\\) approaches \\(\\mathbb{v}[\\psi|y]\\). we monitor convergence of the iterative simulation by estimating the factor by which the scale of the current distribution for \\(\\psi\\) might be reduced if the simulations were continued in the limit \\(n \\rightarrow \\infty\\). this potential scale reduction is estimated by: \\begin{align} \\hat{r} = \\sqrt{\\frac{\\hat{\\mathbb{v}}[\\psi|y]}{w}} \\end{align} which declines to \\(1\\) as \\(n \\rightarrow 1\\). if the potential scale reduction is high, then we have reason to believe that proceeding with further simulations may improve our inference about the target distribution of the associated scalar estimand. example. bivariate unit normal density with bivariate normal jumping kernel (continued) table 11.1 displays posterior inference for the two parameters of the distribution as well as the log posterior density. after \\(50\\) iterations, the variance between the five sequences is much greater than the variance within, for all three univariate summaries considered. however, the five simulated sequences have converged adequately after \\(2000\\) or certainly \\(5000\\) iterations for the quantities of interest. the comparison with the true target distribution shows how some variability remains in the posterior inferences even after the markov chains have converged. the method of monitoring convergence presented here has the key advantage of not requiring the user to examine time series graphs of simulated sequences. inspection of such plots is a notoriously unreliable method. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/MBJ/T4/02_metropolist_algorithm.html",
    "title": "Metropolis and Metropolis-Hastings Algorithms",
    "body": " index search search back metropolis and metropolis-hastings algorithms contents the metropolis algorithm example bivariate unit normal density with normal jumping kernel why does the metropolis algorithm work the metropolis-hastings algorithm relation between the jumping rule and efficiency of simulations the metropolis-hastings algorithm is a general term for a family of markov chain simulation methods that are useful for sampling from bayesian posterior distributions. we have already seen the gibbs sampler in the previous section; it can be viewed as a special case of metropolis-hastings. the metropolis algorithm the metropolis algorithm is an adaptation of a random walk with an acceptance/rejection rule to converge to the specified target distribution. the algorithm proceeds as follows. draw a starting point \\(\\theta_0\\), for which \\(p(\\theta_0|y) > 0\\), from a starting distribution \\(p_0(\\theta)\\). the starting distribution might be based on an approximation or we may simply choose starting values dispersed around a crude approximate estimate. for \\(t = 1, 2, \\cdots\\): sample a proposal \\(\\theta^*\\) from a jumping distribution (or proposal distribution) at time \\(t\\), \\(j_t(\\theta^*|\\theta^{t-1})\\). for the metropolis algorithm (but not the metropolis-hastings algorithm, as discussed later in this section), the jumping distribution must be symmetric. calculate the ratio of the densities: \\begin{align} r = \\frac{p(\\theta^*|y)}{p(\\theta^{t- 1}|y)} \\end{align} set: \\begin{align} \\theta^t = \\begin{cases} \\theta^* & \\text{ with probability } \\min(r, 1) \\\\ \\theta^{t-1} \\text{ otherwise } \\end{cases} \\end{align} the acceptance/rejection rule of the metropolis algorithm can be stated as follows: if the jump increases the posterior density, set \\(\\theta^t = \\theta^*\\); if the jump decreases the posterior density, set \\(\\theta^t = \\theta^*\\) with probability equal to the density ratio, \\(r\\), otherwise set \\(\\theta_t = \\theta^{t - 1}\\) (with probability \\(1 - r\\)). the metropolis algorithm can thus be viewed as a stochastic version of a stepwise mode-finding algorithm, always accepting steps that increase the density but only sometimes accepting downward steps. to use the algorithm, we need to calculate the ratio \\(r\\) for every pair of \\((\\theta, \\theta^*)\\), and we also need to choose \\(\\theta\\) from the jumping distribution \\(j_t(\\theta^*|\\theta)\\) for all \\(\\theta\\) and \\(t\\). additionally, we need to generate a random number for step (\\(c\\)) in the process. even if the jump isn't accepted and \\(\\theta_t\\) equals \\(\\theta_{t-1}\\), it still counts as a step in the algorithm. example: bivariate unit normal density with normal jumping kernel for simplicity, we illustrate the metropolis algorithm with the simple example of the bivariate unit normal distribution. the target density is the bivariate unit normal, \\(p(\\theta|y) = \\text{n}(\\theta|0, i)\\). the jumping distribution is also bivariate normal, centered at the current iteration and scaled to \\(\\frac{1}{5}\\) the size: \\(j_t(\\theta^*|\\theta^{t−1}) = \\text{n}(\\theta^*|\\theta^{t−1}, 0.22\\cdot i)\\). at each step, it is easy to calculate the density ratio: \\begin{align} r = \\frac{\\text{n}(\\theta^*|0, i)}{\\text{n}(\\theta^{t-1}|0, i)} \\end{align} it is clear from the form of the normal distribution that the jumping rule is symmetric. figure 11.1 displays five simulation runs starting from different points. we have purposely set the scale of this jumping algorithm to be too small, relative to the target distribution, so that the algorithm will run inefficiently and its random-walk aspect will be obvious in the figure. why does the metropolis algorithm work? the proof that the sequence of iterations \\(\\theta_1, \\theta_2, \\cdots\\) converges to the target distribution has two steps: it is shown that the simulated sequence is a markov chain with a unique stationary distribution. it is shown that the stationary distribution equals the target distribution. except for trivial exceptions, the latter two conditions hold for a random walk on any proper distribution, and irreducibility holds as long as the jumping distributions jt is eventually be able to jump to all states with positive probability. to show (1) consider starting the algorithm at time \\(t − 1\\) with a draw \\(\\theta^{t−1}\\) from the target distribution \\(p(\\theta|y)\\). now consider any two such points \\(\\theta_a\\) and \\(\\theta_b\\), drawn from \\(p(\\theta|y)\\) and labeled so that \\(p(\\theta_b|y) \\geq p(\\theta_a|y)\\). the unconditional probability density of a transition from \\(\\theta_a\\) to \\(\\theta_b\\) is: \\begin{align} p(\\theta^{t - 1} = \\theta_a, \\theta^t = \\theta_b) = p(\\theta_a|y)j_t(\\theta_b|\\theta_a) \\end{align} where the acceptance probability is \\(1\\) because of our labeling of \\(a\\) and \\(b\\), and the unconditional probability density of a transition from \\(\\theta_b\\) to \\(\\theta_a\\) is: \\begin{align} p(\\theta^t = \\theta_a, \\theta^{t-1} = \\theta_b) = p(\\theta_b|y)j_t(\\theta_a|\\theta_b) \\left(\\frac{p(\\theta_a|y)}{p(\\theta_b|y)}\\right) \\end{align} \\begin{align} = p(\\theta_b|y)j_t(\\theta_a|\\theta_b) \\end{align} which is the same as the probability of a transition from \\(\\theta_a\\) to \\(\\theta_b\\), since we have required that \\(j_t(\\cdot|\\cdot)\\) be symmetric. since their joint distribution is symmetric, \\(\\theta^t\\) and \\(\\theta^{t−1}\\) have the same marginal distributions, and so \\(p(\\theta|y)\\) is the stationary distribution of the markov chain of \\(\\theta\\). the metropolis-hastings algorithm the metropolis-hastings algorithm generalizes the basic metropolis algorithm presented above in two ways. the jumping rules \\(j_t\\) need no longer be symmetric. to correct for the asymmetry in the jumping rule the ratio \\(r\\) is replaced by a ratio of ratios: \\begin{align} r = \\frac{\\frac{p(\\theta^*|y)}{j_t(\\theta^*|\\theta^{t-1})}}{\\frac{p(\\theta^{t-1}|y)}{j_t(\\theta^{t-1}|\\theta^*)}} \\end{align} allowing asymmetric jumping rules can be useful in increasing the speed of the random walk. relation between the jumping rule and efficiency of simulations the ideal metropolis-hastings jumping rule is simply to sample the proposal, \\(\\theta^*\\), from the target distribution; such that our jumping distribution is equal to the target distribution, \\(j(\\theta^*|\\theta) ≡ p(\\theta^*|y)\\). then the ratio \\(r\\) is always exactly \\(1\\), so we always choose the new sampled \\(\\theta^*\\) to update \\(\\theta^t\\) instead of remaining with \\(\\theta^{t-1}\\). a good jumping distribution has the following properties: for any \\(\\theta\\), it is easy to sample from \\(j(\\theta^*|\\theta)\\) it is easy to compute the ratio \\(r\\) each jump goes a reasonable distance in the parameter space (otherwise the random walk moves too slowly). the jumps are not rejected too frequently (otherwise the random walk wastes too much time standing still). $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/MBJ/index.html",
    "title": "Modelos Bayesianos Jerárquicos",
    "body": " index search search back modelos bayesianos jerárquicos introduccion a la inferencia bayesiana modelos jerarquicos constructing a parametrized prior distribution exchangeability and hierarchical models bayesian analysis of conjugate hierarchical models normal model with exchangeable parameters example: parallel experiments in eight schools hierarchical modeling applied to meta-analysis weakly informative priors evaluación y comparación de modelos measures of predictive accuracy information criteria and cross-validation model comparison based on predictive performance model comparison using bayes factors aspectos computacionales de la inferencia bayesiana gibbs sampler metropolis and metropolis-hastings algorithms using gibbs and metropolis as buliding blocks inference and assessing convergence effective number of simulation draws appendix t2 thanks to how little i understand this book i will use other sources in order to properly understand bayesian hierarchical modeling, the contents on the following chapter explains how hierarchical bayesian models came to be and its appeal. then on section 2 it lays out hierarchical nolmal modeling followed by an explanation on hierarchical beta-binomial modeling on section 3. bayesian hierarchical modeling introduction hierarchical normal modeling hierarchical beta-binomial modeling $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/MBJ/T2/02.html",
    "title": "Exchangeability and hierarchical models",
    "body": " index search search back exchangeability and hierarchical models contents exchangeability example exchangeability when additional information is available on the units example assumptions model formulation bayesian inference objections to exchangeable models the full bayesian treatment of the hierarchical model posterior predictive distributions let \\(e\\) be a set of experiments, such that \\(e_j = {y_i, \\theta_j}, j = 1, \\cdots, j\\) where \\(y_i\\) are the vector data, \\(\\theta_j\\) are the vector parameters and \\(p(y_j|\\theta_j)\\) is the likelihood function. exchangeability when we have no additional data on the parameters, we assume exchangeability between them, such that \\(p(\\theta_1, \\cdots, \\theta_j)\\) is invariant to permutation of the indexes. the simplest form of an exchangeable distribution has each of the parameters \\(\\theta_j\\) as an independent sample from a prior distribution governed by some unknown parameter vector \\(\\phi\\); thus: \\begin{align} p(\\theta|\\phi) = \\prod_{j = 1}^j p(\\theta_j|\\phi) \\end{align} in general, \\(\\phi\\) is unknown, so our distribution for \\(\\theta\\) must average over our uncertainty in \\(\\phi\\): \\begin{align} p(\\theta) = \\int_{\\phi} p(\\theta|\\phi)p(\\phi) d \\phi \\end{align} \\begin{align} = \\int_{\\phi} \\left(\\prod_{j = 1}^j p(\\theta_j|\\phi)\\right) p(\\phi) d \\phi \\end{align} this form, the mixture of independent identical distributions, is usually all that we need to capture exchangeability in practice. example we use a nonhierarchical example with exchangeability at the level of \\(y\\) rather than \\(\\theta\\). in this example, eight states in the united states were selected, and the divorce rate per \\(1000\\) population in each state in \\(1981\\) was recorded. since you have no information to distinguish any of the eight states from the others, you must model them exchangeably. however, you can't assign an exchangeable prior to the set of eight diverse states when there's specific information about one of them. for example, if we know that nevada differentiates itself from the others because it divorce rate is known to be unusually high, that lets us know before even seeing the data (observed values), that there's a strong reason to believe that nevada's divorce rate is higher than the other states. this means that in a bayesian analysis, the prior distribution should reflect this belief, assigning more probability mass to nevada having a higher divorce rate in comparison to the other states. exchangeability when additional information is available on the units sometimes obervations are partially or conditionally exchangeable. for example, when: in the case where observations can be grouped, a hierarchical model can be created. in this context, each group has unknown properties. the assumption of exchangeability allows for the use of a common prior distribution for these group properties, meaning that any group can be considered as a random sample of the same underlying population. if \\(y_i\\) has additional information \\(x_i\\) so that \\(y_i\\) are not exchangeable but \\((y_i, x_i)\\) still are exchangeable, then we can make a joint model for \\((y_i, x_i)\\) or a conditional model for \\(y_i|x_i\\). in general, the usual way to model exchangeability with covariates is through conditional independence: \\begin{align} p(\\theta_1, \\cdots, \\theta_j) = \\int \\left[ p(\\theta_j|\\phi,x_j)\\right]p(\\phi, x) d\\phi \\end{align} whith \\(x = [x_1, \\cdots, x_j]\\) example let's consider an example in the field of education where we want to analyze the test scores of students from different schools. we can view the test scores as observations that can be grouped by schools. let \\(y_{ij}\\) be the test score of the student \\(i\\) in school \\(j\\), where \\(i = 1, 2, \\cdots, n_j\\) and \\(j = 1, 2, \\cdots, j\\) and \\(n_j\\) are the number of students at school \\(j\\). assumptions each school \\(j\\) has an unknown mean test score \\(\\mu_j\\). the mean test scores \\(\\mu_j\\) are assumed to follow a common distribution. *exchangeability: the test scores within each school are exchangeable, implying that any school could be considered a random sample from the overall population of schools. common prior distribution: we assume a common prior distribution for the group mean test scores \\(\\mu_j\\) across schools. model formulation likelihood: the likelihood of the test scores given the group mean and variance \\begin{align} p(y_{ij}|\\mu_j, \\sigma^2) \\end{align} prior: common prior distribution for the group mean test scores \\begin{align} p(\\mu_j|\\theta) \\sim \\mathcal{n}(\\theta, \\tau^2) \\end{align} where \\(\\theta\\) represents the overall mean test score and \\(\\tau\\) is the variance parameter. hyperprior: prior distribution for the overall test score \\begin{align} p(\\theta) \\sim \\mathcal{n}(\\mu_0, \\sigma_0^2) \\end{align} where \\(\\mu_0\\) is the prior mean and \\(\\sigma_0^2\\) is the prior variance. bayesian inference the posterior distribution of the group mean test scores and the overall mean test score can be obtained using bayesian inference techniques, such as markov chain monte carlo (mcmc) sampling. objections to exchangeable models in statistical applications, it is common to raise objections to the assumption that different data or experiments are exchangeable. for example experiments may which may have been conducted at different times, with different subjects, and likely in different places. despite these differences, the text suggests that it might be acceptable to consider the data as if they were from the same distribution due to model ignorance. the full bayesian treatment of the hierarchical model the true 'hierarchical' part of the models is that some parameters are not known and thus have their own prior distributions, denoted as \\(p(\\phi)\\). the bayesian posterior distribution is of the vector \\((\\phi, \\theta)\\). the joint prior distribution is: \\begin{align} p(\\phi, \\theta) = p(\\phi)p(\\theta|\\phi) \\end{align} and the joint posterior distribution (after seeing the data \\(y\\)) is: \\begin{align} p(\\phi, \\theta|y) \\propto p(\\phi, \\theta)p(y|\\phi, \\theta) \\end{align} given that \\(p(y|\\phi, \\theta)\\) depends only on \\(\\theta\\): \\begin{align} = p(\\phi, \\theta)p(y|\\theta) \\end{align} in order to create a joint probability distribution for \\((\\phi, \\theta)\\), we must assign a prior distribution to \\(\\phi\\). it is often practical to start with a simple, relatively noninformative, prior distribution on \\(\\phi\\) and seek to add more prior information if there remains too much variation in the posterior distribution. posterior predictive distributions hierarchical models are characterized both by parameters \\(\\theta\\) and hyperparameters, \\(\\phi\\), that parametrize the prior distribution over \\(\\theta\\). there are two posterior predictive distributions that might be of interest: the distribution of future observations \\(\\tilde{y}\\) corresponding to an existing \\(j\\) \"group\" described by \\(\\theta_j\\). the distribution of future observations \\(\\tilde{y}\\) corresponding to future \\(\\theta_j\\) (a \"new group\"), denoted by \\(\\tilde{\\theta}\\), drawn from the superpopulation \\(p(\\theta|\\phi)\\). in the rat tumor example, future observations can be (1) additional rats from an existing experiment, or (2) results from a future experiment (explained by a different set of parameters \\(\\theta\\)). for (1) the posterior predictive draws \\(\\tilde{y}\\) are based on the posterior draws of \\(\\theta_j\\) (\\(p(\\theta_j|y)\\)) for the existing experiment. for (2) one must first draw \\(\\tilde{\\theta}\\) for the new experiment from the population distribution, given the posterior draws of \\(\\phi\\), and then draw \\(\\tilde{y}\\) given the simulated \\(\\tilde{\\theta}\\). $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/MBJ/T2/05_example_normal.html",
    "title": "Example: parallel experiments in eight schools",
    "body": " index search search back example: parallel experiments in eight schools contents inferences based on nonhierarchical models and their problems posterior simulation under the hierarchical model discussion a study was performed for the educational testing service to analyze the effects of special coaching programs on test scores in each of eigth schools. the outcome variable in each study was the score on a special administration of the sat-v. the scores can vary between \\(200\\) and \\(800\\), with mean about \\(500\\) and standard deviation about \\(100\\). also, there was no prior reason to believe that any of the eight programs was more effective than any other or that some were more similar in effect to each other than to any other. the results of the experiments are summarized in: inferences based on nonhierarchical models and their problems before fitting the hierarchical bayesian model, we first consider two simpler nonhierarchical methods—estimating the effects from the eight experiments independently (separate estimates), and complete pooling—and discuss why neither of these approaches is adequate for this example. consider \\(\\theta_1\\), the effect in school \\(a\\). the effect in school \\(a\\) is estimated as \\(28.4\\) with a standard error of \\(14.9\\) under the separate analysis, versus a pooled estimate of \\(7.7\\) with a standard error of \\(4.1\\) under the common-effect model. note: given a normal distribution (symmetrical with respect to it mean) the probability that an estimate takes a value under the mean is \\(\\frac{1}{2}\\) (cumulative density function), as the \\(\\mu\\) serves as the midpoint of a normal distribution such that half the area for the normal curve is contained under \\([0, \\mu]\\). the separate analyses of the eight schools imply the following posterior statement: 'the probability is \\(\\frac{1}{2}\\) that the true effect in \\(a\\) is more than \\(28.4\\)' a doubtful statement, considering the results for the other seven schools. on the other hand, the pooled model implies the following statement: 'the probability is \\(\\frac{1}{2}\\) that the true effect in a is less than \\(7.7\\),' which seems an inaccurate summary of our knowledge. as in the theoretical discussion of the previous section, neither estimate is fully satisfactory, and we would like a compromise that combines information from all eight experiments without assuming all the \\(\\theta_j\\)'s to be equal. the bayesian analysis under the hierarchical model provides exactly that. posterior simulation under the hierarchical model consequently, we compute the posterior distribution of \\(\\theta_1, \\cdots, \\theta_8\\), based on the normal model presented in section 4. we draw from the posterior distribution for the bayesian model by simulating the random variables \\(\\tau\\), \\(\\mu\\), and \\(\\theta\\), in that order, from their posterior distribution, as discussed at the end of the previous section. the sampling standard deviations, \\(\\sigma_j\\), are assumed known and equal to the values in table 5.2, and we assume independent uniform prior densities on \\(\\mu\\) and \\(\\tau\\). the marginal posterior density function, \\(p(\\tau|y)\\) from, is plotted in the next figure: values of \\(\\tau\\) near zero are mos plausible. in the normal hierarchical model, however, we learn a great deal by considering the conditional posterior distributions given \\(\\tau\\) (and averaged over \\(\\mu\\)), that is \\(\\mathbb{e}[\\theta_j|\\tau, y]\\), averaging over \\(\\mu\\). this is displayed on the following image: comparing with the previous figure, which has the same scale on the horizontal axis, we see that for most of the likely values of \\(\\tau\\), that is for \\(\\tau \\approx 0\\) the estimated effects for all the groups are relatively close together (when \\(\\tau = 0\\) you would guess they are clustered on the same point). however, as \\(\\tau\\) becomes larger, corresponding to more variability among schools, the estimates become more like the raw values shown on the first figure of this section. the lines in the following figure show the conditional standard deviations, \\(sd(\\theta_j|\\tau, y)\\), as a function of \\(\\tau\\). as \\(\\tau\\) increases, the population distribution allows the eight effects to be more different from each other, and hence the posterior uncertainty in each individual \\(\\tau_j\\) increases, approaching the standard deviations shown in the raw data in the limit of \\(\\tau \\rightarrow \\infty\\). contrary to what we saw with separate estimates and pooled estimates, for the likely values of \\(\\tau\\) (see figure for \\(p(\\tau|y)\\)), the estimates in all schools are substantially less than \\(28\\) points. for example, even at \\(\\tau = 0\\), the probability that the effect in school a is less than \\(28\\) points is \\(\\phi[(28 − 14.5)/9.1] = 93\\%\\), where \\(\\phi\\) is the standard normal cumulative distribution function. of substantial importance, we do not obtain an accurate summary of the data if we condition on the posterior mode of \\(\\tau\\) as it ignores the uncertainty associated with \\(\\tau\\) as conveyed by the full posterior distribution. in bayesian statistics, the posterior distribution encapsulates both the most likely values of parameters as well as the uncertainty or variability in those estimates. by only considering the mode (the peak or maximum) of the posterior distribution and neglecting its shape and spread, we may miss out on valuable information about the range of plausible values for τ and the associated uncertainty. discussion table 5.3 summarizes the \\(200\\) simulated effect estimates for all eight schools. the bayesian probability that the effect in school a is as large as \\(28\\) points is less than \\(10\\%\\), which is substantially less than the \\(50\\%\\) probability based on the separate estimate for school a. as an illustration of the simulation-based posterior results, \\(200\\) simulations of school a's effect are shown in figure 5.8a. having simulated the parameter \\(\\theta\\), it is easy to ask more complicated questions of this model. for example, what is the posterior distribution of \\(\\max(\\theta_j)\\), the effect of the most successful of the eight coaching programs? figure 5.8b displays a histogram of \\(200\\) values from this posterior distribution and shows that only \\(22\\) draws are larger than \\(28.4\\). for another example, we can estimate \\(pr(\\theta_1 > \\theta_3|y)\\), the posterior probability that the coaching program is more effective in school a than in school c, by the proportion of simulated draws of \\(\\theta\\) for which \\(\\theta_1 > \\theta_3\\); the result is \\(\\frac{141}{200} = 0.705\\). to sum up, the bayesian analysis of this example not only allows straightforward inferences about many parameters that may be of interest, but the hierarchical model is flexible enough to adapt to the data, thereby providing posterior inferences that account for the partial pooling as well as the uncertainty in the hyperparameters. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/MBJ/T2/06_hierarchical_meta_analysis.html",
    "title": "Hierarchical modeling applied to a meta-analysis",
    "body": " index search search back hierarchical modeling applied to a meta-analysis contents a normal approximation to the likelihood goals of inference in meta-analysis what if exchangeability is inappropriate a hierarchical model meta-analysis is an increasingly popular and important process of summarizing and integrating the findings of research studies in a particular area. the data in our medical example are displayed in the first three columns of the previous image, which summarize mortality after myocardial infarction in 22 clinical trials. the aim of a metaanalysis is to provide a combined analysis of the studies that indicates the overall strength of the evidence for a beneficial effect of the treatment under study. a normal approximation to the likelihood if clinical trial \\(j\\) (in the series to be considered for meta-analysis) involves the use of \\(n_{0j}\\) subjects in the control group and \\(n_{1j}\\) in the treatment group, giving rise to \\(y_{0j}\\) and \\(y_{1j}\\) deaths in control and treatment groups, respectively, then the usual sampling model involves two independent binomial distributions with probabilities of death \\(p_{0j}\\) and \\(p_{1j}\\), respectively. for each study \\(j\\), one can estimate \\(\\theta_j\\) by: \\begin{align} y_j = \\log\\left(\\frac{y_{1j}}{n_{1j} - y_{1j}}\\right) - \\log\\left(\\frac{y_{0j}}{n_{0j} - y_{0j}}\\right) \\end{align} with approximate sampling variance \\begin{align} \\sigma_j^2 = \\frac{1}{y_{1j}} + \\frac{1}{n_{1j} - y_{1j}} + \\frac{1}{y_{0j}} + \\frac{1}{n_{0j} - y_{0j}} \\end{align} based on empirical logits. the estimated log-odds ratios \\(y_j\\) and their estimated standard errors \\(\\sigma_j^2\\) are displayed as the fourth and fifth columns of table 5.4. goals of inference in meta-analysis our focus is on estimating meaningful parameters, and for this objective there appear to be three possibilities. complete pooling: we view the studies as identical replications of each other, in the sense we regard the individuals in all the studies as independent samples from a common population, with the same outcome measures and so on. separate estimates: the studies are so different that the results of any one study provide no information about the results of any of the others. bayesian analysis: we regard the studies as exchangeable but not necessarily either identical or completely unrelated. the first potential estimand of a meta-analysis, or a hierarchically structured problem in general, is the mean of the distribution of effect sizes, since this represents the overall ‘average’ effect across all studies that could be regarded as exchangeable with the observed studies. other possible estimands are the effect size in any of the observed studies and the effect size in another, comparable (exchangeable) unobserved study. what if exchangeability is inappropriate? what if other information (in addition to the data \\((n, y)\\)) is available to distinguish among the \\(j\\) studies in a meta-analysis, so that an exchangeable model is inappropriate? in this situation, we can expand the framework of the model to be exchangeable in the observed data and covariates. a hierarchical model let \\(y_j\\) represent generically the point estimate of the effect \\(\\theta_j\\) in the \\(j\\)th study, the sampling distribution is defined as: \\begin{align} y_j|\\theta_j, \\sigma_j \\sim \\text{n}(\\theta_j, \\sigma_j^2) \\end{align} where \\(\\sigma_j\\) represents the corresponding estimated standard error, which is assumed known without error. at the second stage of the hierarchy, we again use an exchangeable normal prior distribution, with mean \\(\\mu\\) and standard deviation \\(\\tau\\), which are unknown hyperparameters. \\begin{align} \\theta|\\mu, \\tau \\sim \\text{n}(\\mu, \\tau) \\end{align} finally, a hyperprior distribution is required for \\(\\mu\\) and \\(\\tau\\). for this problem, it is reasonable to assume a noninformative or locally uniform prior density for \\(\\mu\\). we also assume a locally uniform prior density for \\(\\tau\\). $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/MBJ/T2/01.html",
    "title": "Constructing a parametrized prior distribution",
    "body": " index search search back constructing a parametrized prior distribution contents example analysis with a fixed prior distribution approximate estimate of the population distribution using the historical data appendix to begin our description of hierarchical models, we consider the problem of estimating a parameter \\(\\theta\\) using data from a small experiment and a prior distribution constructed from similar previous experiments. example suppose the aim is to estimate \\(\\theta\\), the probability of tumor in a population of female laboratory rats of type \"f344\" that receive a zero dose of the drug (control group). it is natural to assume a binomial model for the number of tumors, given \\(\\theta\\). for convenience, we select a prior distribution for \\(\\theta\\) from the conjugate family, \\(\\theta \\sim beta(\\alpha, \\beta)\\) analysis with a fixed prior distribution from historical data, suppose we knew that the tumor probabilities \\(\\theta\\) among groups of female lab rats of type \"f344\" follow an approximate beta distribution, with known mean and standard deviation. the use of a fixed prior distribution from historical data allows for the construction of a parameterized prior distribution, which in turn influences the posterior distribution for the current experiment. then, assuming a \\(beta(\\alpha, \\beta)\\) prior distribution for \\(\\theta\\) yields a \\(beta(\\alpha + 4, \\beta + 10)\\) posterior distribution for \\(\\theta\\). approximate estimate of the population distribution using the historical data contrary to last section, typically, the mean and standard deviation of underlying tumor risks are not available, rather historical data is available from previous experiments on similar conditions. in the \\(j\\)th historical experiment, let the number of rats with tumors be \\(y_j\\) and the total number of rats be \\(n_j\\). we model the \\(y_j\\)'s (probability that \\(p\\) rats have tumor given a total of \\(n\\) rats) as independent binomial data, given sample sizes \\(n_j\\) and study-specific means \\(\\theta_j\\). we can display the hierarchical model schematically as follows: the observed sample mean and standard deviation of the 70 values \\(y_j\\), \\(n_j\\) are \\(0.136\\) and \\(0.103\\). if we set the mean and standard deviation of the population distribution to these values we can solve for \\(\\theta\\) and \\(\\beta\\). the resulting estimate for \\((\\alpha, \\beta)\\) is \\((1.4, 8.6)\\). this is not a bayesian calculation because it is not based on any specified full probability model. appendix binomial model: in probability theory and statistics, the binomial distribution with parameters \\(n\\) and \\(p\\) is the discrete probability distribution of the number of successes in a sequence of \\(n\\) independent experiments (binomial distribution) $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/MBJ/T2/12_hierarchical_normal_modeling.html",
    "title": "Hierarchical Normal Modeling",
    "body": " index search search back hierarchical normal modeling contents example ratings of animation movies [[#a hierarchical normal model with random \\(\\sigma\\)|a hierarchical normal model with random \\(\\sigma\\)]] graphical representation of the hierarchical model second-stage prior inference through mcmc describe the model by a script define the data and prior parameters mcmc diagnostics and summarization shrinkage sources of variability example: ratings of animation movies movielens is a website which provides personalized movie recommendations from users who create accounts and rate movies that they have seen. based on such information, movielens works to build a custom preference profile for each user and provide movie recommendations. a hierarchical normal model with random \\(\\sigma\\) in this situation it is reasonable to develop a model for the movie ratings where the grouping variable is the movie title. we index a rating by two subscripts, where \\(y_{ij}\\) denotes the \\(i\\)th rating for the \\(j\\)th movie title, with \\(j = 1, \\cdots, 8\\). since the ratings are continuous, it is reasonable to use the normal data model. for simplicity and ease of illustration, a common and shared unknown standard deviation \\(\\sigma\\) is assumed for all normal models (however it could also be modeled). therefore we define the sampling distribution as: \\begin{align} y_{ij} | \\mu_j, \\sigma \\sim \\text{normal}(\\mu_j, \\sigma) \\end{align} since these movies are all animations, it is reasonable to believe that the mean ratings are similar across movies. so one assigns each mean rating the same normal prior distribution at the first stage: \\begin{align} \\mu_j | \\mu, \\tau \\sim \\text{normal}(\\mu, \\tau) \\end{align} the hyperparameters \\(\\mu\\) and \\(\\tau\\) are treated as random since we are unsure about the degree of pooling of the eight sets of ratings. after observing data, inference is performed about \\(\\mu\\) and \\(\\tau\\) based on their posterior distributions. treating \\(\\mu\\) and \\(\\tau\\) as random, one arrives at the following hierarchical model: sampling for \\(j = 1, \\cdots, 8\\) and \\(i = 1, \\cdots, n_j\\): \\begin{align} y_{ij} | \\mu_j, \\sigma \\sim \\text{normal}(\\mu_j, \\sigma) \\end{align} prior for \\(\\mu_j\\), stage 1, \\(j = 1, \\cdots, 8\\): \\begin{align} \\mu_j | \\mu, \\tau \\sim \\text{normal}(\\mu, \\tau) \\end{align} prior for \\(\\mu_j\\), stage 2, the hyperprior: \\begin{align} \\mu, \\tau \\sim \\pi(\\mu, \\tau) \\end{align} to complete the model, one needs to specify a prior distribution for the standard deviation parameter, \\(\\sigma\\): \\begin{align} \\frac{1}{\\sigma^2} | a_{\\sigma}, b_{\\sigma} \\sim \\text{gamma}(a_{\\sigma}, b_{\\sigma}) \\end{align} one assigns a known gamma prior distribution for \\(\\frac{1}{\\sigma^2}\\), with fixed hyperparameter values \\(a_{\\sigma}\\) and \\(b_{\\sigma}\\). in some situations, one may consider the situation where \\(a_{\\sigma}\\) and \\(b_{\\sigma}\\) are random and assign hyperprior distributions for these unknown hyperparameters. it is helpful to contrast the two-stage prior distribution for \\(\\{\\mu_j\\}\\) and the one-stage prior distribution for \\(\\sigma\\). for the means \\(\\{\\mu_j\\}\\), we have discussed that specifying a common prior distribution for different \\(j\\) pools information across the movies. one is simultaneously estimating both a mean for each movie (the \\(\\mu_j\\)'s) and the variation among the movies (\\(\\mu\\) and \\(\\tau\\)). for the standard deviation, the hierarchical model also pools information across movies. however, all of the observations are combined in the estimation of \\(\\sigma\\). since separate values of \\(\\sigma_j\\), one cannot learn about the differences and similarities among the \\(\\sigma_j\\)'s. graphical representation of the hierarchical model an alternative way of expressing this hierarchical model uses the following graphical representation. in the middle section of the graph, \\(y_{ij}\\) represents the collection of random variables for all ratings of movie \\(j\\). the upper section of the graph focuses on the \\(\\mu_j\\)'s. all means follow the same prior, a normal distribution with mean \\(\\mu\\) and standard deviation \\(\\sigma\\). since \\(\\mu\\) and \\(\\tau\\) are random, these second-stage parameters are associated with the prior label \\(\\pi(\\mu, \\tau)\\). second-stage prior the hierarchical normal model presented in equations (10.6) through (10.9) has not specified the hyperprior distribution \\(\\pi(\\mu, \\tau)\\). how does one construct a prior on these second-stage hyperparameters? a typical approach for normal models is to assign two independent prior distributions — a normal distribution for the mean \\(\\mu\\) and a gamma distribution for the precision \\(\\frac{1}{\\tau^2}\\). such a specification facilitates the use of the gibbs sampling. using this approach, the density \\(\\pi(\\mu, \\tau)\\) is replaced by the two hyperprior distributions below: \\begin{align} \\mu | \\mu_0, \\gamma_0 \\sim \\text{normal}(\\mu_0, \\gamma_0) \\end{align} \\begin{align} \\frac{1}{\\tau^2} | a, b \\sim \\text{gamma}(a_{\\tau}, b_{\\tau}) \\end{align} the task of choosing a prior for \\((\\mu, \\tau)\\) reduces to the problem of choosing values for the four hyperparameters \\(\\mu_0, \\gamma_0, a_{\\tau}\\) and \\(b_{\\tau}\\). if one believes that \\(mu\\) is located around the value of \\(3\\) and she is not very confident of this choice, the set of values \\(\\mu_0 = 3\\) and \\(\\gamma_0 = 1\\) could be chosen. as for \\(\\tau\\), one chooses a weakly informative prior with \\(a_{\\tau} = b_{\\tau} = 1\\) as \\(\\text{gamma}(1, 1)\\). moreover, to choose a prior for \\(\\sigma\\), let \\(a_{\\sigma} = b_{\\sigma} = 1\\) to have the weakly informative \\(\\text{gamma}(1, 1)\\) prior. inference through mcmc with the specification of the prior, the complete hierarchical model is described as follows: sampling for \\(j = 1, \\cdots, 8\\) and \\(i = 1, \\cdots, n_j\\): \\begin{align} y_{ij} | \\mu_j, \\sigma \\sim \\text{normal}(\\mu_j, \\sigma) \\end{align} prior for \\(\\mu_j\\), stage 1, \\(j = 1, \\cdots, 8\\): \\begin{align} \\mu_j | \\mu, \\tau \\sim \\text{normal}(\\mu, \\tau) \\end{align} prior for \\(\\mu_j\\), stage 2: the hyperpriors: \\begin{align} \\mu \\sim \\text{normal}(3, 1) \\end{align} \\begin{align} \\frac{1}{\\tau^2} \\sim \\text{gamma}(1, 1) \\end{align} prior for \\(\\sigma\\) \\begin{align} \\frac{1}{\\sigma^2} \\sim \\text{gamma}(1, 1) \\end{align} describe the model by a script the first step in using the jags software is to write the following script defining the hierarchical model. the model is saved in the character string modelstring. modelstring <-\" model { ## sampling for (i in 1:n){ y[i] ~ dnorm(mu_j[movieindex[i]], invsigma2) } ## priors for (j in 1:j){ mu_j[j] ~ dnorm(mu, invtau2) } invsigma2 ~ dgamma(a_s, b_s) sigma <- sqrt(pow(invsigma2, -1)) ## hyperpriors mu ~ dnorm(mu0, g0) invtau2 ~ dgamma(a_t, b_t) tau <- sqrt(pow(invtau2, -1)) } \" in the sampling part of the script, note that the loop goes from 1 to n, where n is the number of observations with index i. however, because now n observations are grouped according to movies, indicated by j, one needs to create one vector, mu_j of length eight, and use movieindex[i] to grab the corresponding mu_j based on the movie index. in the priors part of the script, the loop goes from 1 to j, and j = 8 in the current example. inside the loop, the first line corresponds to the prior distribution for mu_j. due to a commonly shared sigma, invsigma2 follows dgamma(a_g, b_g) outside of the loop. in addition, sigma <- sqrt(pow(invsigma2, -1)) is added to help tracksigma directly. finally in the hyperpriors section of the script, one specifies the normal hyperprior for mu, a gamma hyperprior for invtau2. keep in mind that the arguments in the dnorm in jags are the mean and the precision (std). if one is interested instead in the standard deviation parameter tau, one could return it in the script by using tau <- sqrt(pow(invtau2, -1)), enabling the tracking of its mcmc chain in the posterior inferences. define the data and prior parameters after one has defined the model script, the next step is to provide the data and values for parameters of the prior. in the r script below, a list the_data contains the vector of observations, the vector of movie indices, the number of observations, and the number of movies. it also contains the normal hyperparameters mu0 and g0, and two sets of gamma hyperparameters (a_t and b_t) for invtau2, and (a_s and b_s) for invsigma2. y <- movieratings$rating movieindex <- movieratings$group_number n <- length(y) j <- length(unique(movieindex)) the_data <- list(\"y\" = y, \"movieindex\" = movieindex, \"n\" = n, \"j\" = j, \"mu0\" = 3, \"g0\" = 1, \"a_t\" = 1, \"b_t\" = 1, \"a_s\" = 1, \"b_s\" = 1) one uses the run.jags() function in the runjags r package to generate posterior samples by using the mcmc algorithms in jags. the script below runs one mcmc chain with \\(1000\\) iterations in the adapt period (preparing for mcmc), \\(5000\\) iterations of burn-in and an additional set of \\(5000\\) iterations to be run and collected for inference. by using monitor = c(\"mu\", \"tau\", \"mu_j\", \"sigma\"), one collects the values of all parameters in the model. in the end, the output variable posterior contains a matrix of simulated draws. posterior <- run.jags(modelstring, n.chains = 1, data = the_data, monitor = c(\"mu\", \"tau\", \"mu_j\", \"sigma\"), adapt = 1000, burnin = 5000, sample = 5000) mcmc diagnostics and summarization to perform some mcmc diagnostics in our example, one uses the plot() function, specifying the variable to be checked by the vars argument. for example, the script below returns four diagnostic plots (trace plot, empirical pdf, histogram, and autocorrelation plot) for the hyperparameter \\(\\tau\\). plot(posterior, vars = \"tau\") in practice mcmc diagnostics should be performed for all parameters to justify the overall mcmc convergence. in our example, the above diagnostics should be implemented for each of the eleven parameters in the model: \\(\\mu, \\tau, \\mu_1, \\cdots, \\mu_8\\) and \\(\\sigma\\). once diagnostics are done, one reports posterior summaries of the parameters using print(). note that these summaries are based on the 5000 iterations from the sample period, excluding the adapt and burn-in iterations. print(posterior, digits = 3) lower95 median upper95 mean sd mode mcerr mu 3.19 3.78 4.34 3.77 0.286 -- 0.00542 tau 0.357 0.638 1.08 0.677 0.2 -- 0.00365 mu_j[1] 2.96 3.47 3.99 3.47 0.262 -- 0.00376 mu_j[2] 3.38 3.81 4.25 3.82 0.221 -- 0.00313 mu_j[3] 3.07 3.91 4.75 3.91 0.425 -- 0.00677 mu_j[4] 3.21 3.74 4.31 3.74 0.285 -- 0.00428 mu_j[5] 3.09 4.15 5.43 4.18 0.588 -- 0.0115 mu_j[6] 2.7 3.84 4.99 3.85 0.576 -- 0.00915 mu_j[7] 2.74 3.53 4.27 3.51 0.388 -- 0.00595 mu_j[8] 3.58 4.12 4.66 4.12 0.276 -- 0.00423 sigma 0.763 0.92 1.12 0.93 0.0923 -- 0.00142 for example, the movies \"how to train your dragon\" (corresponding to \\(\\mu_1\\)) and \"megamind\" (corresponding to \\(\\mu_7\\)) have the lowest average ratings with short \\(90\\%\\) credible intervals, \\((2.96, 3.99)\\) and \\((2.74, 4.27)\\) respectively, whereas \"legend of the guardians: the owls of ga’hoole\" (corresponding to \\(μ_6\\)) also has a low average rating but with a wider \\(90\\%\\) credible interval \\((2.70, 4.99)\\). the differences in the width of the credible intervals stem from the sample sizes: there are eleven ratings for \"how to train your dragon\", four ratings for \"megamind\", and only a single rating for \"legend of the guardians: the owls of ga’hoole\". the smaller the sample size, the larger the variability in the inference, even if one pools information across groups. shrinkage recall that the two-stage prior specifies a shared prior normal \\((\\mu, \\tau)\\) for all \\(\\mu_j\\)'s which facilitates simultaneous estimation of the movie mean ratings (the \\(\\mu_j\\)'s), and estimation of the variation among the movie mean ratings through the parameters \\(\\mu\\) and \\(\\tau\\). the posterior mean of the rating for a particular movie \\(\\mu_j\\) shrinks the observed mean rating towards an average rating. the following figure displays a shrinkage plot which illustrates the movement of the observed sample mean ratings towards an average rating. the left side plots the sample movie rating means and lines connect the sample means to the corresponding posterior means (i.e. means of the posterior draws of \\(\\mu_j\\)). the shrinkage effect is obvious for the movie \"batman: under the red hood\" which corresponds to the dot at the value \\(5.0\\) on the left. this movie only received one rating of \\(5.0\\) and its mean rating \\(\\mu_5\\) shrinks to the value \\(4.178\\) on the right, which is still the highest posterior mean among the nine movie posterior means. a large shrinkage is desirable for a movie with a small number of ratings such as \"batman: under the red hood\". for a movie with a small sample size, information about other ratings of similar movies helps to produce a more reasonable estimate at the true average movie rating. the amount of shrinkage is more modest for movies with larger sample sizes. sources of variability we know that the prior distribution \\(\\text{normal}(\\mu, \\tau)\\) is shared among the means \\(\\mu_j\\)'s of all groups in a hierarchical normal model, and the hyperparameters \\(\\mu\\) and \\(\\tau\\) provide information about the population of \\(\\mu_j\\)'s. specifically, the standard deviation \\(\\tau\\) measures the variability among the \\(\\mu_j\\)'s. when the hierarchical model is estimated through mcmc, summaries from the simulation draws from the posterior of \\(\\tau\\) provide information about this source of variation after analyzing the data. there are actually two sources for the variability among the observed \\(y_{ij}\\)'s: sampling level: within-group variability: \\begin{align} y_{ij} \\sim \\text{normal}(\\mu_j, \\sigma) \\end{align} group level between-group variability: \\begin{align} \\mu_{j} | \\mu, \\tau \\sim \\text{normal}(\\mu, \\tau) \\end{align} when the hierarchical model is fit through mcmc, summaries from the marginal posterior distributions of \\(\\sigma\\) and \\(\\tau\\) provide information about the two sources of variability. the bayesian posterior inference in the hierarchical model is able to compare these two sources of variability, taking into account the prior belief and the information from the data. one initially provides prior beliefs about the values of the standard deviations \\(\\sigma\\) and \\(\\tau\\) through gamma distributions. what can be said about these two sources of variability after the estimation of the hierarchical model? as seen in the output of print(posterior, digits = 3), the \\(90\\%\\) credible interval for \\(\\sigma\\) is \\((0.763, 1.12)\\) and the \\(90\\%\\) credible interval for \\(\\tau\\) is \\((0.357, 1.08)\\). after observing the data, the within-group variability in the measurements is estimated to be larger than the between-group variability. to compare both variability sources we compute: \\begin{align} r = \\frac{\\tau^2}{\\tau^2 + \\sigma^2} \\end{align} it represents the fraction of the total variability in the movie ratings due to the differences between groups. if the value of \\(r\\) is close to \\(1\\), most of the total variability is attributed to the between-group variability. on the other side, if \\(r\\) is close to \\(0\\), most of the variation is within groups and there is little significant differences between groups. a \\(95\\%\\) credible interval for \\(r\\) is \\((0.149, 0.630)\\). since much of the posterior probability of \\(r\\) is located below the value \\(0.5\\), this confirms that the variation between the mean movie rating titles is smaller than the variation of the ratings within the movie titles in this example. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/MBJ/T2/11_introduction.html",
    "title": "Introduction",
    "body": " index search search back introduction contents separate estimates combined estimates a two-stage prior as a new example, consider a study in which students' scores of a standardized test such as the sat are collected from five different senior high schools in a given year. it is inappropriate to use \\(y_{ij}\\) as the random variable for the sat score of student \\(i = 1, 2, \\cdots, n_j\\) in school \\(j = 1, \\cdots, 5\\). within school \\(j\\), one assumes that sat scores are i.i.d. from a normal data model with a mean and standard deviation depending on the school: \\begin{align} y_{ij} \\sim \\text{normal}(\\mu_j, \\sigma_j) \\end{align} separate estimates? one approach for handling this group estimation problem is find separate estimates for each school. one focuses on the observations in school \\(j\\), \\(\\{y_{1j}, \\cdots, y_{n_jj}\\}\\), choose a prior distribution \\(\\pi(\\mu_j, \\sigma_j)\\) for the mean and the standard deviation parameters. this \"separate estimates\" approach may be reasonable, especially if the researcher thinks the means and the standard deviations from the five normal models are completely unrelated to each other. that is, one’s prior beliefs about the parameters of the sat score distribution in one school are unrelated to the prior beliefs about the distribution parameters in another school. combined estimates? another way to handle this group estimation problem is to ignore the fact that there is a grouping variable and estimate the parameters in the combined sample. in our school example, one ignores the school variable and simply assumes that the sat scores \\(y_i\\)'s are distributed from a single normal population with mean \\(\\mu\\) and standard deviation \\(\\sigma\\) where \\(i = 1, \\cdots, n\\) is the total number of students from all five schools. using this approach, one is effectively ignoring any differences between the five schools. a two-stage prior is there an alternative approach that compromises between the separate and combined estimate methods? for simplicity of discussion it is assumed the standard deviation \\(\\sigma_j\\) of the \\(j\\)th school is known. consider the collection of five mean parameters, \\(\\{\\mu_1, \\mu_2, \\mu_3, \\mu_4, \\mu_5\\}\\) representing the means of the five schools' sat scores. one believes that the \\(\\mu_j\\)'s are distinct, because each \\(\\mu_j\\) depends on the characteristics of school \\(j\\). one wishes to construct a prior distribution for the five mean parameters that reflects the belief that \\(\\{\\mu_1, \\mu_2, \\mu_3, \\mu_4, \\mu_5\\}\\) are related or similar in size. the prior belief in similarity of the means is constructed in two stages: [stage 1] the prior distribution for the \\(j\\)th mean \\(\\mu_j\\) is normal, where the mean and standard deviation parameters are shared among all \\(\\mu_j\\): \\begin{align} \\mu_j | \\mu, \\tau \\sim \\text{normal}(\\mu, \\tau), j = 1, \\cdots, 5 \\end{align} [stage 2] in stage 1, the parameters \\(\\mu\\) and \\(\\tau\\) are unknown. so this stage assigns the parameters a prior density \\(\\pi\\) (hyperprior): \\begin{align} \\mu, \\tau \\sim \\pi(\\mu, \\tau) \\end{align} stage 1 indicates that the \\(\\mu_j\\)'s a priori are related and thus come from the same distribution. if one considers the limit of the stage 1 prior as the standard deviation \\(\\tau\\) approaches zero, the group means \\(\\mu_j\\) will be identical. then one is in the combined groups' situation where one is pooling the sat data to learn about a single population. at the other extreme, if one allows the standard deviation \\(\\tau\\) of the stage 1 prior to approach infinity, then one is saying that the group means are unrelated and that leads to the separate estimates situation. since \\(\\mu\\) and \\(\\tau\\) are parameters in the prior distribution, they are called hyperparameters. learning about \\(\\mu\\) and \\(\\tau\\) provides information about the population of \\(\\mu_j\\). in bayesian inference, one learns about \\(\\mu_j\\) and \\(\\tau\\) by specifying a hyperprior distribution and performing inference based on the posterior distribution. it will be seen that the hierarchical model posterior estimates for one school borrows information from other schools. this process is often called partial pooling information among groups. from the structural point of view, due to the two stages of the model, this approach is called hierarchical or multilevel modeling. in essence, hierarchical modeling takes into account information from multiple levels, acknowledging differences and similarities among groups. in the posterior analysis, one learns simultaneously about each group and learns about the population of groups by pooling information across groups. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/MBJ/T2/07_weakly_informative_priors.html",
    "title": "Weakly Informative Priors",
    "body": " index search search back weakly informative priors contents concepts relating to the choice of prior distribution improper limit of a prior distribution calibration classes of noninformative and weakly informative prior distributions for hierarchical variance parameters general considerations uniform prior distributions [[#inverse-gamma\\((\u001bpsilon, \u001bpsilon)\\) prior distributions|inverse-gamma\\((\u001bpsilon, \u001bpsilon)\\) prior distributions]] half-cauchy prior distributions application to the 8-schools example application for the 3-schools problem concepts relating to the choice of prior distribution improper limit of a prior distribution improper prior densities can, but do not necessarily, lead to proper posterior distributions. calibration posterior inferences can be evaluated using the concept of calibration of the posterior mean. for any parameter \\(\\theta\\), if we label the posterior mean as \\(\\hat{\\theta} = \\mathbb{e}[\\theta|y]\\), we can define the miscalibration of the posterior mean as \\(\\mathbb{e}[\\theta|\\hat{\\theta}] - \\hat{\\theta}\\). we can judge the accuracy of our conclusions from bayesian analysis by checking how close the average value we predict (the posterior mean) is to the true value. here's how it works: if we call our predicted average value \\(\\hat{\\theta}\\), and we calculate how far off it is from the true value \\(\\theta\\), that's what we call the miscalibration of the prediction. if our initial guesses (prior distribution) are accurate and our data matches those guesses, then our predictions will be right on target, meaning the miscalibration will be zero. these are models where the probabilities don't add up to \\(1\\), which makes it impossible to draw a parameter \\(\\theta\\) from them. so, we need to expand our theory to deal with this. to see if our predictions are accurate in these cases, we need to imagine a \"true\" prior distribution where \\(\\theta\\) comes from, and compare it to the \"inferential\" prior distribution we actually use for our bayesian analysis. let's take the example of the 8 schools model. here, we consider an improper uniform distribution on \\(\\tau\\) (a parameter in the model) as a limit of uniform distributions on a range (from \\(0\\) to a really large number \\(a\\), which is getting bigger and bigger). when we use this improper uniform distribution, our inferences tend to overestimate \\(\\tau\\). let's see why: if both the \"true\" and \"inferential\" prior distributions are uniform on \\((0, a)\\), our miscalibration is zero. this means our predictions are accurate. now, if we keep the \"true\" prior distribution as \\(u(0, a)\\) but let the \"inferential\" prior distribution go to \\(u(0, \\infty)\\), our predictions tend to increase (because now we're including more and more extreme values of \\(\\theta\\)), which leads to a positive miscalibration. classes of noninformative and weakly informative prior distributions for hierarchical variance parameters general considerations we view any noninformative or weakly informative prior distribution as inherently provisional—after the model has been fit, one should look at the posterior distribution and see if it makes sense. if the posterior distribution does not make sense, this implies that additional prior knowledge is available that has not been included in the model, and that contradicts the assumptions of the prior distribution that has been used uniform prior distributions when we're setting up our model, we often start with uniform priors. but we have to be careful about how we define the scale of this uniform distribution. one common situation is when we're dealing with parameters that must be positive, like variance parameters. using a uniform prior on the logarithm of these parameters (\\(\\log \\tau\\)) might seem like a good idea, but it can lead to problems because the resulting posterior distribution becomes improper (doesn't add up to 1). an alternative is trying to set up a range for our prior distribution, like \\([-a, a]\\) where \\(a\\) is a really large number. this seems like a good idea to keep things in check, but there's a catch: the posterior distribution (our updated belief after looking at the data) can end up heavily influenced by the lower bound, \\(-a\\), of our range. when we calculate the marginal likelihood \\(p(y|\\tau)\\) of our data given a certain parameter (\\(\\tau\\)), it ends up approaching a fixed, non-zero value as \\(\\tau\\) gets really close to \\(0\\). because when we calculate the likelihood of our data given a parameter (\\(\\tau\\)), it's like asking, \"how likely is it that we'd see this data if our parameter τ were true?\" now, imagine \\(\\tau\\) is getting really close to \\(0\\). in many situations, this means we're saying there's almost no variability in our data. but even if \\(\\tau\\) is very close to \\(0\\), the likelihood of observing our data isn't exactly \\(0\\). there's still some chance, even if it's tiny, that we'd see our data just by random chance, even with very little variability. so, as \\(\\tau\\) approaches \\(0\\), the likelihood doesn't drop to \\(0\\) as well. instead, it approaches a fixed, non-zero value. another option we can consider is using a uniform prior distribution directly on the parameter \\(\\tau\\) itself. this helps avoid some of the problems we discussed earlier because it keeps the total probability finite, especially near \\(\\tau = 0\\). however, there's a drawback to this approach. it tends to lean slightly towards positive values, because it allows for the possibility of very large values of \\(\\tau\\) as well. when we're dealing with just one or two groups (\\(j = 1\\) or \\(2\\)), using this uniform prior actually results in an improper posterior density. this means that our analysis essentially concludes that \\(\\tau\\) is infinite, and it doesn't do any pooling of data from different groups. in a way, this makes sense because it's hard to decide from just a few groups how much we should pool their data together. but from a bayesian perspective, it's a bit awkward because we're making this decision before even looking at the data. when we're dealing with these improper uniform prior distributions, we can think of them as being like the limit of certain types of weakly informative priors. for example, the uniform prior distribution on the logarithm of \\(\\tau\\) is basically like saying that \\(\\tau\\) follows a distribution where the probability decreases as \\(\\tau\\) gets bigger. sometimes, in bayesian statistics, people suggest using a uniform prior distribution directly on \\(\\tau^2\\). this means that every possible value for \\(\\tau^2\\) is considered equally likely. however, we don't recommend this approach. it tends to have a bigger issue with miscalibration towards higher values compared to the other approaches we discussed earlier. plus, using this uniform prior on τ squared requires us to have at least 4 groups for the analysis to work properly and give us a reasonable posterior distribution. inverse-gamma\\((\\epsilon, \\epsilon)\\) prior distributions in the schools model, the parameter \\(\\tau\\) doesn't have any simple family of prior distributions that work well because its likelihood depends on all the data from all the groups in a complex way. however, there's a kind of distribution called the inverse-gamma family that works well in this situation. this means that if we use an inverse-gamma distribution as a prior for \\(\\tau^2\\), then after we collect our data and update our beliefs, the conditional distribution for \\(\\tau^2\\), \\(p(\\tau^2|\\mu, \\theta, y)\\) that we get is still an inverse-gamma distribution. the inverse-gamma prior distribution is a way to set up our beliefs in a noninformative (or weakly informative) manner when we're dealing with certain types of data. we choose a parameter called alpha (\\(\\alpha\\)) to control how informative the prior is. now, here's the thing: if we set alpha to a very low value, like \\(1\\) or \\(0.01\\) or \\(0.001\\), it's supposed to mean we're not putting much prior information into our model. but there's a problem: when we make alpha too small, the posterior distribution (our updated beliefs after looking at the data) can end up being improper, which means it doesn't add up to \\(1\\). to avoid this, we need to set alpha to a reasonable value, not too small. half-cauchy prior distributions we're going to look at another type of distribution called the \\(t\\) family, specifically the \\(\\text{half}-t\\) because our scale parameter (\\(\\tau\\)) has to be positive. now, we're interested in the \\(t\\) family for this problem because it's pretty flexible and can cover a wide range of situations. plus, we can use a neat trick called reparameterization to express it as a prior distribution for our scale parameter (\\(\\tau\\)) in a way that works well with our model. here's why it's helpful: the half-cauchy distribution has a wide peak around zero and just one parameter that we can adjust, which we'll call \\(a\\). we can set \\(a\\) to be a large value, and as it gets bigger and bigger (approaching infinity), the half-cauchy distribution starts to look more like a uniform distribution on our parameter \\(\\tau\\). when we set \\(a\\) to a large but finite value, it means we're using a slightly informative prior distribution. even though it's not completely flat, it's still pretty gentle, especially in the tails. this means that even if we have some prior beliefs, the data we collect can still have a big influence on our final results, especially if the data is strong. so, we're going to use the half-cauchy distribution for situations where we're estimating variance parameters from just a few groups. in these cases, our choices about our prior beliefs can really affect our results, so we want to use a prior distribution that's flexible and doesn't have a strong influence unless the data really supports it. application to the 8-schools example we demonstrate the properties of some proposed noninformative prior densities on the eight-schools example of section 5. figure 5.9 displays the posterior distributions for the 8-schools model resulting from three different choices of prior distributions that are intended to be noninformative. the first histogram (on the left) shows what we think about the parameter \\(\\tau\\) when we use a uniform prior distribution. the data suggest that \\(\\tau\\) could be anywhere below \\(20\\), but there's a small chance it could be even larger. this makes sense because we only have data from \\(8\\) groups, and it's hard to be sure about large values of \\(\\tau\\) with that little data. now, look at the second histogram (in the middle). here, we've changed our prior to something called an \\(\\text{inverse-gamma}(1, 1)\\) distribution. this changes our conclusions. now, our estimate for \\(\\tau\\) is lower, and we're more confident in our estimates for the individual group parameters (\\(\\theta_j\\)'s). to understand why this happens, let's think about the shape of our prior distribution. with the inverse-gamma prior, it's concentrated in a narrow range, from \\(0.5\\) to \\(5\\). this means it's not giving much weight to really large or really small values of \\(\\tau\\). in comparison, the uniform prior seemed less informative, meaning it didn't strongly influence our conclusions. the last histogram (on the right) in figure 5.9 shows what happens when we use a different kind of prior distribution called \\(\\text{inverse-gamma}(0.001, 0.001)\\) for \\(\\tau\\) squared. this prior is very sharply peaked near zero, meaning it puts a lot of emphasis on very small values of \\(\\tau\\). because of this, our conclusions from the data get distorted. even though the data might suggest that \\(\\tau\\) could be larger, the prior is pulling our estimates towards smaller values. the reason this happens is because the likelihood for \\(\\tau\\), stays high near zero. so even though our data might suggest that larger values of \\(\\tau\\) are possible, the strong influence of the prior near zero pulls our estimates towards smaller values. in this example, we're not considering two other options: using a uniform prior distribution on the logarithm of \\(\\tau\\), which would result in an improper posterior density with a spike at \\(\\tau = 0\\), similar to the last histogram but even more pronounced. using a uniform prior distribution directly on \\(\\tau^2\\), which would result in a posterior distribution similar to the first histogram, but with a slightly higher tail on the right side. application for the 3-schools problem the uniform prior distribution seems fine for the 8-school analysis, but problems arise if the number of groups \\(j\\) is much smaller, in which case the data supply little information about the group-level variance, and a noninformative prior distribution can lead to a posterior distribution that is improper or is proper but unrealistically broad. figure 5.10 displays the inferences for \\(\\tau\\) based on two different priors. we start with a default uniform distribution, which means we're not favoring any particular values for our parameter \\(\\tau\\). this worked well when we had data from \\(8\\) groups (as seen in figure 5.9). but now, we're looking at a new dataset with only \\(3\\) groups. unfortunately, the resulting histogram (the left one in figure 5.10) shows that the posterior distribution for \\(\\tau\\) has a really long tail on the right side. this means it's suggesting values of \\(\\tau\\) that are way too high to be reasonable. this long tail is expected because we have such a small number of groups (if we had even fewer groups, the tail would be even longer, going on forever). using this kind of posterior distribution can be a problem because it means we're not pooling the estimates of the school effects (\\(\\theta_j\\)) as much as we should be. the last histogram (on the right) in figure 5.10 shows what happens when we use a different kind of prior distribution called a half-cauchy. we set the scale parameter (\\(a\\)) of this prior to \\(25\\). we chose this value to be a bit higher than what we expect for the standard deviation of the underlying \\(\\theta_j\\)'s in our educational testing example. this way, our model only weakly constrains the parameter \\(\\tau\\). on the graph, you'll see a line that represents this prior distribution. it's highest for values of \\(\\tau\\) less than \\(50\\) and gradually falls off beyond that. this means the prior puts more weight on smaller values of \\(\\tau\\) but still allows for larger values. this half-cauchy prior distribution would also perform well in the 8-schools problem; however it was unnecessary because the default uniform prior gave reasonable results. with only 3 schools, we went to the trouble of using a weakly informative prior, a distribution that was not intended to represent our actual prior state of knowledge about \\(\\tau\\) but rather to constrain the posterior distribution, to an extent allowed by the data. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/MBJ/T2/03.html",
    "title": "Bayesian analysis of conjugate hierarchical models",
    "body": " index search search back bayesian analysis of conjugate hierarchical models contents analytic derivation of conditional and marginal distributions drawing simulations from the posterior distribution application to the model for rat tumors joint conditional and marginal posterior distributions choosing a standard parameterization and setting up a noninformative hyperprior distribution computing the marginal posterior density of the hyperparameters sampling from the joint posterior distribution of parameters and hyperparameters displaying the results analytic derivation of conditional and marginal distributions hierarchical models involve multiple levels of parameters and dependencies between them, making the analysis more intricate. the following steps are necessary to disentangle the relationships between parameters at different levels of the hierarchy and to estimate their distributions accurately. joint posterior density: combines the prior information (hyperprior distribution \\(p(\\phi)\\)), the population distribution (\\(p(\\theta|\\phi)\\)), and the likelihood function \\(p(y|\\theta)\\) to form the joint posterior distribution. \\begin{align} p(\\theta, \\phi|y) \\propto p(y|\\theta)p(\\theta|\\phi)p(\\phi) \\end{align} conditional posterior density of the parameters: calculates the posterior distribution of \\(\\theta\\) given the hyperparameters \\(\\phi\\), allows us to understan how parameters interact and influence each other. this is usually done using a priori conjugate distributions. \\begin{align} p(\\theta|\\phi, y) \\end{align} hyperparameter estimation: estimating \\(\\phi\\) through the bayesian paradigm helps in updating our knowledge about the higher-level parameters based on the observed data. this step can be perfomed by integrating the joint posterior distribution over \\(\\theta\\) in to be able to marginalize \\(\\phi\\) conditionally on \\(y\\). \\begin{align} p(\\phi|y) = \\int p(\\theta, \\phi|y)d\\theta \\end{align} for many standard models the marginal posterior distribution of \\(\\phi\\) can be computed algebraically using the conditional probability formula: \\begin{align} p(\\phi|y) = \\frac{p(\\theta, \\phi|y)}{p(\\theta|\\phi, y)} \\end{align} drawing simulations from the posterior distribution the following strategy is useful for simulating a draw from the joint posterior distribution \\(p(\\theta, \\phi|y)\\) draw the vector of hyperparameters, \\(\\phi\\), from its marginal posterior distribution, \\(p(\\phi|y)\\). draw the parameter vector \\(\\theta\\) from its conditional posterior distribution, \\(p(\\theta|\\phi, y)\\). for the examples we consider in this chapter, the factorization \\(p(\\theta|\\phi, y) = \\prod_j p(\\theta_j|\\phi, y)\\) holds. if desired, draw predictive values \\(\\tilde{y}\\) from the posterior predictive distribution. the above steps are performed \\(l\\) times in order to obtain a set of \\(l\\) draws. from the joint posterior simulations of \\(\\theta\\) and \\(\\tilde{y}\\), we can compute the posterior distribution of any estimand or predictive quantity of interest. application to the model for rat tumors the data from experiments \\(j = 1, \\cdots, j\\), \\(j = 71\\), are assumed to follow independent binomial distributions: \\begin{align} y_j \\sim bin(n_j, \\theta_j) \\end{align} this models the probability of getting exactly \\(\\theta_j\\) successes in \\(n_j\\) independent bernoulli trials. with the number of rats \\(n_j\\) unknown. the parameters \\(\\theta_j\\) are assumed to be independent samples from a beta distribution: \\begin{align} \\theta_j \\sim beta(\\alpha, \\beta) \\end{align} and we shall assign a noninformative hyperprior distribution to reflect our ignorance about the unknown hyperparameters \\(\\alpha, \\beta\\). we defer the choice of noninformative hyperprior distribution, a relatively arbitrary and unimportant part of this particular analysis, until we inspect the integrability of the posterior density. joint, conditional, and marginal posterior distributions the joint posterior distribution of all the parameters is: \\begin{align} p(\\theta, \\alpha, \\beta|y) \\propto p(\\alpha, \\beta)p(\\theta|\\alpha,\\beta)p(y|\\theta, \\alpha, \\beta) \\end{align} where \\(p(\\alpha, \\beta)\\) is the hyperprior distribution (\\(p(\\phi)\\)). then \\(p(\\theta|\\alpha,\\beta)\\) is the population distribution (\\(p(\\theta|\\phi)\\)). the pdf of \\(x \\sim beta(\\alpha, \\beta)\\), ignoring the normalization constant, is given by: \\begin{align} p(\\theta|\\alpha, \\beta) \\propto \\frac{\\gamma(\\alpha + \\beta)}{\\gamma(\\alpha)\\gamma(\\beta)} x^{\\alpha - 1} (1- x)^{\\beta - 1} \\end{align} for \\(j = 1, \\cdots, j\\) i.i.d \\(\\theta_j \\sim beta(\\alpha, \\beta)\\): \\begin{align} p(\\theta|\\alpha, \\beta) \\propto \\prod_{j=1}^j \\theta_j^{\\alpha - 1} (1- \\theta_j)^{\\beta - 1} \\end{align} and \\(p(y|\\theta, \\alpha, \\beta)\\) is the likelihood (\\(p(y|\\theta)\\)). the pdf of \\(x \\sim bin(n, p)\\) is given by: \\begin{align} p(x = k|n, p) \\propto p^k (1 - p)^{n - k} \\end{align} for \\(j = 1, \\cdots, j\\) i.i.d \\(y_j \\sim bin(n_j, \\theta_j)\\): \\begin{align} p(y_j|n_j, \\theta_j) \\propto \\theta_j^{y_j} (1 - \\theta_j)^{n_j - y_j} \\end{align} therefore we obtain: \\begin{align} \\propto p(\\alpha, \\beta) \\left(\\prod_{j=1}^j \\frac{\\gamma(\\alpha + \\beta)}{\\gamma(\\alpha)\\gamma(\\beta)}\\theta_j^{\\alpha - 1}(1 - \\theta_j)^{\\beta - 1}\\right) \\left(\\prod_{j=1}^j \\theta_j^{y_j}(1 - \\theta_j)^{n_j - y_j}\\right) \\end{align} the conditional posterior density of \\(\\theta\\) given the hyperparameters is defined using a beta-binomial conjugate prior (page 7), therefore if: \\begin{align} y_i|n_j, \\theta_j \\sim bin(n_j, \\theta_j) \\end{align} \\begin{align} \\theta_j|\\alpha,\\beta \\sim beta(\\alpha, \\beta) \\end{align} then \\begin{align} \\theta_j|\\alpha, \\beta, y_j, n_j \\sim beta(\\alpha + y_j, \\beta + n_j - y_j) \\end{align} which gives us the following pdf for a beta distribution of i.i.d \\(\\theta\\): \\begin{align} p(\\theta|\\alpha, \\beta, y) = \\prod_{j=1}^j \\frac{\\gamma(\\alpha + y_j + \\beta + n_j - y_j)}{\\gamma(\\alpha + y_j)\\gamma(\\beta + n_j - y_j)}\\theta_j^{\\alpha + y_j - 1}(1-\\theta_j)^{\\beta + n_j - y_j - 1} \\end{align} \\begin{align} = \\prod_{j=1}^j \\frac{\\gamma(\\alpha + \\beta + n_j)}{\\gamma(\\alpha + y_j)\\gamma(\\beta + n_j - y_j)}\\theta_j^{\\alpha + y_j - 1}(1-\\theta_j)^{\\beta + n_j - y_j - 1} \\end{align} we can determine the marginal posterior distribution of the hyperparameters \\((\\alpha, \\beta)\\) by substituting on the previous equations on the following formula: \\begin{align} p(\\phi|y) = \\frac{p(\\theta, \\phi|y)}{p(\\theta|\\phi, y)} \\end{align} where \\(\\phi = (\\alpha, \\beta)\\), so: \\begin{align} p(\\alpha, \\beta|y) = \\frac{p(\\theta, \\alpha, \\beta|y)}{p(\\theta|\\alpha, \\beta, y)} \\end{align} \\begin{align} \\propto \\frac{p(\\alpha, \\beta) \\left(\\prod_{j=1}^j \\frac{\\gamma(\\alpha + \\beta)}{\\gamma(\\alpha)\\gamma(\\beta)}\\theta_j^{\\alpha - 1}(1 - \\theta_j)^{\\beta - 1}\\right) \\left(\\prod_{j=1}^j \\theta_j^{y_j}(1 - \\theta_j)^{n_j - y_j}\\right)}{\\prod_{j=1}^j \\frac{\\gamma(\\alpha + \\beta + n_j)}{\\gamma(\\alpha + y_j)\\gamma(\\beta + n_j - y_j)}\\theta_j^{\\alpha + y_j - 1}(1-\\theta_j)^{\\beta + n_j - y_j - 1}} \\end{align} \\begin{align} \\propto p(\\alpha, \\beta) \\frac{\\prod_{j=1}^j \\frac{\\gamma(\\alpha + \\beta)}{\\gamma(\\alpha)\\gamma(\\beta)}\\theta_j^{\\alpha - 1}(1 - \\theta_j)^{\\beta - 1} \\theta_j^{y_j}(1 - \\theta_j)^{n_j - y_j}}{\\prod_{j=1}^j \\frac{\\gamma(\\alpha + \\beta + n_j)}{\\gamma(\\alpha + y_j)\\gamma(\\beta + n_j - y_j)}\\theta_j^{\\alpha + y_j - 1}(1-\\theta_j)^{\\beta + n_j - y_j - 1}} \\end{align} \\begin{align} \\propto p(\\alpha, \\beta) \\prod_{j=1}^j \\frac{\\frac{\\gamma(\\alpha + \\beta)}{\\gamma(\\alpha)\\gamma(\\beta)}\\theta_j^{\\alpha - 1}(1 - \\theta_j)^{\\beta - 1} \\theta_j^{y_j}(1 - \\theta_j)^{n_j - y_j}}{\\frac{\\gamma(\\alpha + \\beta + n_j)}{\\gamma(\\alpha + y_j)\\gamma(\\beta + n_j - y_j)}\\theta_j^{\\alpha + y_j - 1}(1-\\theta_j)^{\\beta + n_j - y_j - 1}} \\end{align} \\begin{align} \\propto p(\\alpha, \\beta) \\prod_{j=1}^j \\left(\\frac{\\frac{\\gamma(\\alpha + \\beta)}{\\gamma(\\alpha)\\gamma(\\beta)}}{\\frac{\\gamma(\\alpha + \\beta + n_j)}{\\gamma(\\alpha + y_j)\\gamma(\\beta + n_j - y_j)}}\\frac{\\theta_j^{\\alpha - 1}(1 - \\theta_j)^{\\beta - 1} \\theta_j^{y_j}(1 - \\theta_j)^{n_j - y_j}}{\\theta_j^{\\alpha + y_j - 1}(1-\\theta_j)^{\\beta + n_j - y_j - 1}}\\right) \\end{align} \\begin{align} \\propto p(\\alpha, \\beta) \\prod_{j=1}^j \\left(\\frac{\\gamma(\\alpha + \\beta)\\gamma(\\alpha + y_j)\\gamma(\\beta + n_j - y_j)}{\\gamma(\\alpha)\\gamma(\\beta)\\gamma(\\alpha + \\beta + n_j)}\\theta_j^{\\alpha - 1 + y_j - \\alpha - y_j + 1}(1-\\theta_j)^{\\beta - 1 + n_j - y_j - \\beta - n_j + y_j + 1}\\right) \\end{align} \\begin{align} \\propto p(\\alpha, \\beta) \\prod_{j=1}^j \\left(\\frac{\\gamma(\\alpha + \\beta)\\gamma(\\alpha + y_j)\\gamma(\\beta + n_j - y_j)}{\\gamma(\\alpha)\\gamma(\\beta)\\gamma(\\alpha + \\beta + n_j)}\\theta_j^{0}(1-\\theta_j)^{0}\\right) \\end{align} \\begin{align} \\propto p(\\alpha, \\beta) \\prod_{j=1}^j \\frac{\\gamma(\\alpha + \\beta)\\gamma(\\alpha + y_j)\\gamma(\\beta + n_j - y_j)}{\\gamma(\\alpha)\\gamma(\\beta)\\gamma(\\alpha + \\beta + n_j)} \\end{align} choosing a standard parameterization and setting up a 'noninformative' hyperprior distribution because we have no immediately available information about the distribution of tumor rates in populations of rats, we seek a relatively diffuse hyperprior distribution for \\((\\alpha, \\beta)\\). by reparameterizing the hyperparameters, we transform them into a space that may have more intuitive or meaningful interpretations. in this case, \\(logit(\\frac{\\alpha}{\\alpha + \\beta}) = \\log(\\frac{\\alpha}{\\beta})\\) represents the log-odds of \\(\\alpha\\) relative to the total of \\(\\alpha\\) and \\(\\beta\\), providing a clear interpretation of the prior mean in the beta distribution for \\(\\theta\\). similarly, \\(\\log(\\alpha + \\beta)\\) captures the logarithm of the \"sample size,\" influencing the precision or spread of the distribution. also the logit transformation helps stabilize the numerical computations, especially when dealing with probabilities or proportions that are bounded between 0 and 1. by working in the logit space, we avoid issues related to extreme values or boundaries that can arise in the original parameter space. and transforming the hyperparameters can facilitate the specification of appropriate prior distributions. one reasonable choice of diffuse hyperprior density is uniform on \\((\\frac{\\alpha}{\\alpha + \\beta}, (\\alpha + \\beta)^{−1/2})\\), which when multiplied by the appropriate jacobian yields the following densities on the original scale, \\begin{align} p(\\alpha, \\beta) \\propto (\\alpha + \\beta)^{-5/2} \\end{align} and on the natural transformed scale: \\begin{align} p(\\log(\\frac{\\alpha}{\\beta}), \\log(\\alpha + \\beta)) \\propto \\alpha\\beta(\\alpha + \\beta)^{-5/2} \\end{align} computing the marginal posterior density of the hyperparameters now that we have established a full probability model for data and parameters, we compute the marginal posterior distribution of the hyperparameters. the next figure shows a contour plot of the unnormalized marginal posterior density on a grid of values of \\((\\log(\\frac{\\alpha}{\\beta}), \\log(\\alpha + \\beta))\\) to create the plot, we first compute the logarithm of the density function of \\(p(\\alpha, \\beta|y)\\) with prior density \\(p(\\alpha, \\beta) \\propto (\\alpha + \\beta)^{-5/2}\\), multiplying by the jacobian to obtain the density \\(p(\\log(\\frac{\\alpha}{\\beta}), \\log(\\alpha + \\beta)|y)\\) the most obvious features of the contour plot are (1) the mode is not far from the point estimate (as we would expect), and (2) important parts of the marginal posterior distribution lie outside the range of the graph. we recompute the previous pdf in a different range \\((\\log(\\frac{\\alpha}{\\beta}), \\log(\\alpha + \\beta)) \\in [-2.3, -1.3] \\times [1, 5]\\). figure \\(5.3b\\) displays \\(1000\\) random draws from the numerically computed posterior distribution. the graphs show that the marginal posterior distribution of the hyperparameters, under this transformation, is approximately symmetric about the mode, roughly \\((−1.75, 2.8)\\). this corresponds to approximate values of \\((\\alpha, \\beta) = (2.4, 14.0)\\), which differs somewhat from the crude estimate obtained earlier. having computed the relative posterior density at a grid that covers the effective range of \\((\\alpha, \\beta)\\), we normalize by approximating the distribution as a step function over the grid and setting the total probability in the grid to \\(1\\). sampling from the joint posterior distribution of parameters and hyperparameters we draw \\(1000\\) random samples from the joint posterior distribution of \\((\\alpha, \\beta, \\theta_1, \\cdots, \\theta_j)\\), as follows. simulate \\(1000\\) draws of \\((\\log(\\frac{\\alpha}{\\beta}), \\log(\\alpha + \\beta))\\) from their posterior distribution using the same discrete-grid sampling procedure used to draw \\((\\alpha, \\beta)\\) for figure \\(3.3b\\). for \\(l = 1, \\cdots, 1000\\): transform the \\(l\\)th draw of \\((\\log(\\frac{\\alpha}{\\beta}), \\log(\\alpha + \\beta))\\) to the scale \\((\\alpha, \\beta)\\) to yield a draw of the hyperparameters from their marginal posterior distribution. for each \\(j = 1, \\cdots, j\\), sample \\(\\theta_j\\) from its conditional posterior distribution, \\(\\theta_j|\\alpha, \\beta, y \\sim beta(\\alpha + y_j, \\beta + n_j − y_j)\\). displaying the results figure \\(5.4\\) shows posterior medians and \\(95\\%\\) intervals for the \\(\\theta_j\\)’s, computed by simulation. the results are superficially similar to what would be obtained based on a point estimate of the hyperparameters, which makes sense in this example, because of the fairly large number of experiments. but key differences remain, notably that posterior variability is higher in the full bayesian analysis, reflecting posterior uncertainty in the hyperparameters. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/MBJ/T2/04_normal_model.html",
    "title": "Normal model with exchangeable parameters",
    "body": " index search search back normal model with exchangeable parameters contents model definition inference joint posterior distribution the conditional posterior distribution the marginal posterior distribution [[#posterior distribution of \\(\\mu\\) given \\(\tau\\)|posterior distribution of \\(\\mu\\) given \\(\tau\\)]] [[#posterior distribution \\(\tau\\)|posterior distribution \\(\tau\\)]] simulation posterior predictive distributions model definition we now present a full treatment of a simple hierarchical model based on the normal distribution, with different means for each \"group\" but with known observation variance and a normal population distribution for the group means. consider \\(j\\) independent experiments. the likelihood (sampling distribution) is defined as: \\begin{align} y_{ij} | \\theta_j \\sim \\text{n}(\\theta_j, \\sigma^2), \\text{ for } i = 1, \\cdots, n_j; j = 1, \\cdots, j. \\end{align} where we label the sample mean of each group \\(j\\) as: \\begin{align} \\overline{y}_j = \\frac{1}{n_j} \\sum_{i = 1}^{n_j} y_{ij} \\end{align} and the sampling variance as: \\begin{align} \\sigma^2_j = \\frac{\\sigma^2}{n_j} \\end{align} here we assume that \\(\\sigma\\) is a know value. we can then write the likelihood for each \\(\\theta_j\\) using the sufficient statistics, \\(\\overline{y}_j\\): \\begin{align} \\overline{y}_j | \\theta_j \\sim \\text{n}(\\theta_j, \\sigma_j^2) \\end{align} sufficient statistics are summary statistics of the data that capture all the information about the parameter of interest. in this case, the sufficient statistic \\(\\overline{y}_j\\) represents the data summary for experiment \\(j\\) that is used to estimate the parameter \\(\\theta_j\\). by using the sufficient statistic \\(\\overline{y}_j\\), the likelihood function for each \\(\\theta_j\\) is constructed based on the observed data in experiment \\(j\\). the prior distribution over \\(\\theta_j\\), assuming the prior to be normal for the sake of conjugacy is defined as: \\begin{align} \\theta_j|\\mu, \\tau \\sim \\text{n}(\\theta_j|\\mu, \\tau^2) \\end{align} assuming each \\(\\theta_j\\) to be independent we obtain the following joint distribution: \\begin{align} p(\\theta_1, \\cdots, \\theta_j|\\mu, \\tau) = \\prod_{j=1}^j \\text{n}(\\theta_j|\\mu, \\tau^2) \\end{align} and by process of marginalization: \\begin{align} p(\\theta_1, \\cdots, \\theta_j) = \\int \\left[\\prod_{j=1}^j \\text{n}(\\theta_j|\\mu, \\tau^2)\\right]p(\\mu, \\tau) d(\\mu, \\tau) \\end{align} the hyperprior over the parameters \\(\\mu\\) and \\(\\tau\\) is defined as a non-informative distribution (i.e. uniform density), such that: \\begin{align} p(\\mu, \\tau) = p(\\mu|\\tau)p(\\tau) \\propto p(\\tau) \\end{align} we define a prior distribution over \\(\\tau\\). for our illustrative analysis, we use the uniform prior distribution \\(p(\\tau) \\propto 1\\). once an initial analysis is performed using the noninformative 'uniform' prior density, a sensitivity analysis with a more realistic prior distribution is often desirable. inference joint posterior distribution this distribution combines prior information (hyperprior distribution \\(p(\\mu, \\tau)\\)) the population distribution \\(p(\\theta_j|\\mu, \\tau)\\) and the likelihood function \\(p(y_{ij}|\\theta_j)\\). we define it as follows: \\begin{align} p(\\theta, \\mu, \\tau|y) \\end{align} by bayes theorem (ignoring the normalization term): \\begin{align} \\propto p(y|\\theta) p(\\theta|\\mu, \\tau) p(\\mu, \\tau) \\end{align} here \\(p(y|\\theta)\\) is the likelihood function previously defined in terms of the sufficient statistics \\(\\overline{y}_j\\) \\begin{align} \\propto \\left[\\prod_{j=1}^j \\text{n}(\\overline{y}_j|\\theta_j, \\sigma_j^2)\\right] p(\\theta|\\mu, \\tau) p(\\mu, \\tau) \\end{align} and \\(p(\\theta|\\mu, \\tau)\\) is the prior, also previouly defined, such that: \\begin{align} \\propto \\left[\\prod_{j=1}^j \\text{n}(\\overline{y}_j|\\theta_j, \\sigma_j^2)\\right] \\left[\\prod_{j=1}^j \\text{n}(\\theta_j|\\mu, \\tau^2) p(y|\\theta)\\right] p(\\mu, \\tau) \\end{align} where we can ignore factors that depend only on \\(y\\) and the parameters \\(\\sigma_j\\), which are assumed known for this analysis. the conditional posterior distribution the conditional posterior distribution calculates the posterior distribution of \\(\\theta_j\\) given the hyperparameters \\(\\mu, \\tau\\). it allows us to understand how parameters intereact and influence each other. we define them for each \\(\\theta_j\\) as follows: \\begin{align} \\theta_j | \\mu, \\tau, y \\sim \\text{n}(\\hat{\\theta}_j, v_j) \\end{align} where: \\begin{align} \\hat{\\theta}_j = \\frac{\\frac{1}{\\sigma_j^2}\\overline{y}_j + \\frac{1}{\\tau^2}\\mu}{\\frac{1}{\\sigma_j^2} + \\frac{1}{\\tau^2}} \\end{align} and: \\begin{align} v_j = \\frac{1}{\\frac{1}{\\sigma_j^2} + \\frac{1}{\\tau^2}} \\end{align} the marginal posterior distribution this distribution allows us to estimate the hyperparameters \\(\\mu\\) and \\(\\tau\\) through the bayesian paradigm. by the conditional rule we obtain: \\begin{align} p(\\mu, \\tau|y) \\propto p(\\mu, \\tau)p(y|\\mu, \\tau) \\end{align} where: \\begin{align} \\overline{y}_j | \\mu, \\tau \\sim \\text{n}(\\mu, \\sigma_j^2 + \\tau^2) \\end{align} such that: \\begin{align} p(\\mu, \\tau|y) \\propto p(\\mu, \\tau) \\prod_{j=1}^j \\text{n}(\\overline{y}_j|\\mu, \\sigma^2_j + \\tau^2) \\end{align} posterior distribution of \\(\\mu\\) given \\(\\tau\\) we can further simplify by integrating over \\(\\mu\\), leaving a simple univariate numerical computation of \\(p(\\tau|y)\\), by the conditional rule: \\begin{align} p(\\mu, \\tau|y) = p(\\mu | \\tau, y) p(\\tau|y) \\end{align} where: \\begin{align} \\mu | \\tau, y \\sim \\text{n}(\\hat{\\mu}, v_\\mu) \\end{align} with: \\begin{align} \\hat{\\mu} = \\frac{\\sum_{j=1}^j \\frac{1}{\\sigma_j^2 + \\tau^2}\\overline{y}_j}{\\sum_{j=1}^j \\frac{1}{\\sigma_j^2 + \\tau^2}} \\end{align} and \\begin{align} v_{\\mu}^{-1} = \\sum_{j=1}^j \\frac{1}{\\sigma_j^2 + \\tau^2} \\end{align} posterior distribution \\(\\tau\\) we know from the previous section that: \\begin{align} p(\\mu, \\tau|y) = p(\\mu | \\tau, y) p(\\tau|y) \\end{align} such that: \\begin{align} p(\\tau|y) = \\frac{p(\\mu, \\tau|y)}{p(\\mu | \\tau, y)} \\end{align} we previously defined \\(\\mu | \\tau, y \\sim \\text{n}(\\hat{\\mu}, v_\\mu)\\), therefore: \\begin{align} p(\\tau|y) = \\frac{p(\\mu, \\tau|y)}{\\text{n}(\\hat{\\mu}, v_\\mu)} \\end{align} we also defined \\(p(\\mu, \\tau|y) \\propto p(\\mu, \\tau) \\prod_{j=1}^j \\text{n}(\\overline{y}_j|\\mu, \\sigma^2_j + \\tau^2)\\): \\begin{align} \\propto \\frac{p(\\tau) \\prod_{j=1}^j \\text{n}(\\overline{y}_j|\\mu, \\sigma^2_j + \\tau^2)}{\\text{n}(\\hat{\\mu}, v_\\mu)} \\end{align} simulation for this model, computation of the posterior distribution of θ is most conveniently performed via simulation, following the factorization: \\begin{align} p(\\theta, \\mu, \\tau|y) = p(\\theta|\\mu, \\tau, y) p(\\mu|\\tau, y) p(\\tau, y) \\end{align} posterior predictive distributions to obtain a draw from the posterior predictive distribution of new data \\(\\tilde{y}\\) from the current batch of parameters, \\(\\theta\\), first obtain a draw from \\(p(\\theta, \\mu, \\tau|y)\\) and then draw the predictive data \\(\\tilde{y}\\) from the sampling distribution: \\begin{align} y_{ij} | \\theta_j \\sim \\text{n}(\\theta_j, \\sigma^2), \\text{ for } i = 1, \\cdots, n_j; j = 1, \\cdots, j. \\end{align} to obtain posterior predictive simulations of new data \\(\\tilde{y}\\) for \\(\\tilde{j}\\) new groups, perform the following three steps: draw \\((\\mu, \\tau)\\) from their posterior distribution \\(p(\\mu, \\tau|y)\\) draw \\(\\tilde{j}\\) new parameters \\(\\tilde{\\theta} = \\tilde{\\theta}_1, \\cdots, \\tilde{\\theta}_{\\tilde{j}}\\) from the population distribution \\(p(\\tilde{\\theta}|\\mu, \\tau)\\). draw \\(\\tilde{y}\\) given \\(\\tilde{\\theta}\\) from the sampling distribution. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/MBJ/T2/13_hierarchical_beta_binomial_modeling.html",
    "title": "Hierarchical Beta-Binomial Modeling",
    "body": " index search search back hierarchical beta-binomial modeling contents example deaths after heart attack a hierarchical beta-binomial model graphical representation inference through mcmc second-stage prior mcmc diagnostics and summarization example: deaths after heart attack the new york state (nys) department of health collects and releases data on mortality after a heart attack. we focus on 13 hospitals in manhattan, new york city, with the goal of learning about the percentages of resulted deaths from heart attack for hospitals in this sample. a hierarchical beta-binomial model treating “cases” as trials and “deaths” as successes, the binomial sampling model is a natural choice for this data, and the objective is to learn about the death probability \\(p\\) of the hospitals. if one creates thirteen separate binomial sampling models, one for each hospital, and conducts separate inferences, one loses the ability to use potential information about the death rate from hospital \\(i\\) when making inference about that of a different hospital \\(j\\). since these are all hospitals in manhattan, new york city, they may share attributes in common related to death rates from heart attack. therefore, one builds a hierarchical model based on a common beta distribution that generalizes the beta-binomial conjugate model described in chapter 7. let \\(y_i\\) denote the number of resulted deaths from heart attack, \\(n_i\\) the number of heart attack cases, and \\(p_i\\) the death rate for hospital \\(i\\). so the sampling and first stage of the prior of our model is written as follows: sampling for \\(i = 1, \\cdots, 13\\): \\begin{align} y_i \\sim \\text{binomial}(n_i, p_i) \\end{align} prior for \\(p_i\\), \\(i = 1, \\cdots, 13\\): \\begin{align} p_i \\sim \\text{beta}(a, b) \\end{align} note that the hyperparameters \\(a\\) and \\(b\\) are shared among all hospitals. if \\(a\\) and \\(b\\) are known values, then the posterior inference for \\(p_i\\) of hospital \\(i\\) is simply another beta distribution by conjugacy (refer to beta-binomial conjugate prior (page 7)): \\begin{align} p_i | y_i \\sim \\text{beta}(a + y_i, b + n_i - y_i) \\end{align} in the general situation where the hyperparameters \\(a\\) and \\(b\\) are unknown, a second stage of the prior \\(\\pi(a, b)\\) needs to specified for these hyperparameters, such that the model is now defined as: sampling for \\(i = 1, \\cdots, 13\\): \\begin{align} y_i \\sim \\text{binomial}(n_i, p_i) \\end{align} prior for \\(p_i\\), stage 1: \\(i = 1, \\cdots, 13\\): \\begin{align} p_i \\sim \\text{beta}(a, b) \\end{align} prior for \\(p_i\\), stage 2: the hyperprior: \\begin{align} a, b \\sim \\pi(a, b) \\end{align} when we start analyzing the new york state heart attack death rate dataset, the specification of this hyperprior distribution \\(\\pi(a, b)\\) will be described. graphical representation one sees that the upper section of the graph represents the sampling density, with the arrow directing from \\(p_i\\) to \\(y_i\\). here the start of the arrow is the parameter and the end of the arrow is the random variable. the lower section of the graph represents the prior, with arrows directing from \\(a\\) and \\(b\\) to \\(p_i\\). inference through mcmc second-stage prior for a \\(\\text{beta}(a, b)\\) prior distribution for a proportion \\(p\\), one considers the parameter \\(a\\) as the prior count of “successes”, the parameter \\(b\\) as the prior count of \"failures\", and the sum \\(a + b\\) represents the prior sample size. also the expectation is given by \\(\\frac{a}{a + b}\\). from these facts a more natural parametrization of the hyperprior distribution \\(\\pi(a, b)\\) is \\(\\pi(\\mu, \\eta)\\) where \\(\\mu = \\frac{a}{a + b}\\) is the hyperprior mean and \\(\\eta = a + b\\) is the hyperprior sample size. therefore: \\begin{align} \\mu, \\eta \\sim \\pi(\\mu, \\eta) \\end{align} where \\(a = \\mu\\eta\\) and \\(b = (1 - \\mu)\\eta\\). assume \\(\\mu\\) and \\(\\eta\\) are independent which means that one's beliefs about the prior mean are independent of the beliefs about the prior sample size. the hyperprior expectation \\(\\mu\\) is the mean measure for \\(p_i\\), the average death rate across \\(13\\) hospitals. if one has little prior knowledge about the expectation \\(\\mu\\), one assigns this parameter a uniform prior which is equivalent to a \\(\\text{beta}(1, 1)\\) prior. to motivate the prior choice for the hyperparameter sample size \\(\\eta\\), consider the case where the hyperparameter values are known. if \\(y^*\\) and \\(n^*\\) are respectively the number of deaths and number of cases for one hospital, then the posterior mean of death rate parameter \\(p^*\\) is given by (refer to the beta-binomial conjugate definition): \\begin{align} \\mathbb{e}[p^*|y^*] = \\frac{y^* + \\mu\\eta}{n^* + \\eta} \\end{align} with a little algebra, the posterior mean is rewritten as \\begin{align} \\mathbb{e}[p^*|y^*] = (1 - \\lambda)\\frac{y^*}{n^*} + \\lambda\\mu \\end{align} where \\(\\lambda\\) is the shrinkage fraction: \\begin{align} \\lambda = \\frac{\\eta}{n^* + \\eta} \\end{align} the parameter \\(\\lambda\\) falls in the interval \\((0, 1)\\) and represents the degree of shrinkage of the posterior mean away from the sample proportion \\(\\frac{y^*}{n^*}\\) towards the prior mean \\(\\mu\\). suppose one believes a priori that, for a representative sample size \\(n^*\\), the shrinkage \\(\\lambda\\) is uniformly distributed on \\((0, 1)\\). by performing a transformation, this implies that the prior density for the prior sample size \\(\\eta\\) has the form: \\begin{align} \\pi(\\eta) = \\frac{n^*}{(n^* + \\eta)^2}, \\eta > 0 \\end{align} equivalently, the logarithm of \\(\\eta\\), \\(\\theta = \\log(\\eta)\\), has a logistic distribution with location \\(\\log(n^*)\\) and scale \\(1\\). we represent this distribution as \\(logistic(\\log(n^*), 1)\\), with pdf: \\begin{align} \\pi(\\theta) = \\frac{e^{-(\\theta - \\log(n^*))}}{(1 + e^{-(\\theta - \\log(n^*))})^2} \\end{align} with this specification of the hyperparameter distribution, one writes down the complete hierarchical model as follows: sampling for \\(i = 1, \\cdots, 13\\): \\begin{align} y_i \\sim \\text{binomial}(n_i, p_i) \\end{align} prior for \\(p_i\\), stage 1: \\(i = 1, \\cdots, 13\\): \\begin{align} p_i \\sim \\text{beta}(a, b) \\end{align} prior for \\(p_i\\), stage 2: the hyperpriors: \\begin{align} \\mu, \\eta \\sim \\pi(\\mu, \\eta) \\end{align} \\begin{align} \\log \\eta \\sim \\text{logistic}(\\log n^*, 1) \\end{align} where \\(a = \\mu\\eta\\) and \\(b = (1 - \\mu)\\eta\\) mcmc diagnostics and summarization after the diagnostics are performed, one reports posterior summaries of the parameters: from the posterior output, one evaluates the effect of information pooling in the hierarchical model. see figure 10.6 displays a shrinkage plot showing how the sample proportions are shrunk towards the overall death rate. to compare the posterior densities of the different \\(p_i\\), one displays the density estimates in a single graph as in the following figure: $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/AAII/T3/01_introduccion.html",
    "title": "Introduccion",
    "body": " index search search back introduccion contents bibliography while the idea of combining classifiers is not new, there is still a lot of scope for developing new combination approaches, types of features and classifiers used, and novel applications. fumera et al. presented a theoretical and experimental analysis of multiple classifiers with a focus on linear combiners. the authors particularly focused on simple and weighted averaging. their analysis showed that the performance of linear combiners depends on the accuracy of the individual classifiers and the correlation between their outputs. they also showed that the weighted averaging rule outperforms simple averaging. in weighted averaging, finding the optimal weights for each classifier is still an open problem. further research areas can involve the use of meta-heuristic optimization approaches such as the bat algorithm and other related techniques. in [8], polikar discussed the idea of combining classifiers' output labels in comparison with combination using classifiers' continuous outputs as well as their application to ensemble based systems. in combining continuous outputs, the degrees of support given to each class, by the different classifiers, are used by the combination technique. this support is referred to as score in some literatures. the classifiers output labels are mainly combined using majority voting or its variants. the author primarily reviewed conditions for which ensemble based systems outperform individual classifiers. different combination techniques were analyzed in details. in conclusion, the author stated that no single ensemble generation algorithm or combination rule is universally better than others. while there are several review papers in the literature, this paper presents a more updated survey including more recent approaches introduced during the past few years. since the last major review paper [10], several novel techniques have been introduced. these include a signal strength based combining approach [11], a novel bayes voting strategy [12], a modified weighted averaging technique using graph-theoretical clustering [13], a neural network based approach for training the combination rules [14], weighted features combination [15], and hierarchical fuzzy stack generalization [16], among others. bibliography classifiers combination techniques: a comprehensive review [10] s. chitroub, \"classifier combination and score level fusion: concepts and practical aspects,\" int. j. image data fusion, vol. 1, no. 2, pp. 113–135, jun. 2010. [11] h. he and y. cao, \"ssc: a classifier combination method based on signal strength.,\" ieee trans. neural networks learn. syst., vol. 23, no. 7, pp. 1100–17, jul. 2012. [12] c. de stefano, f. fontanella, and a. s. di freca, \"a novel naive bayes voting strategy for combining classifiers.,\" in icfhr, 2012, pp. 467–472. [13] j. hou, z.-s. feng, and b.-p. zhang, \"a graph-theoretic approach to classifier combination,\" in acoustics, speech and signal processing (icassp), 2012 ieee international conference on, 2012, pp. 1017–1020. [14] y.-d. lan and l. gao, \"a new model of combining multiple classifiers based on neural network,\" 2013 fourth int. conf. emerg. intell. data web technol., no. 2, pp. 154–159, sep. 2013. [15] h. kuang, x. zhang, y.-j. li, l. l. h. chan, and h. yan, \"nighttime vehicle detection based on bio-inspired image enhancement and weighted score-level feature fusion,\" ieee trans. intell. transp. syst., vol. 18, no. 4, pp. 927–936, apr. 2017. [16] c. senaras, m. ozay, and f. t. yarman vural, \"building detection with decision fusion,\" 2013. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/AAII/T3/04_conclusion.html",
    "title": "Conclusiones",
    "body": " index search search back conclusiones while a large number of combination techniques have been proposed, the literature still lacks a comprehensive performance analysis of such techniques for a given application. the review showed that while one strategy (e.g. fusion at decision level) may outperform others for a given application, the results from such a strategy may not be the best for another application. however overall, it was shown that classifiers combinations in general improve performance significantly over individual classifiers for most problems. an important research direction relies on adding an enhancement stage (post processing) to the classifiers output before applying combination rules. this would improve the performance of individual classifiers before the combination stage. many classifiers combination techniques have performed well under certain restrictions which include independence assumption, gaussian distribution, linear process, limited class problem (mostly 2-class problem) and low dimensional feature space. thus, future work can reconsider relaxing some of these constraints another issue that needs to be further investigated is to explore the advantages of using different strategies for the fusion including probabilistic, learning, decision based, or evidence based techniques. the discussion on voting based approaches has shown that there is a scope for improving classification accuracy. this issue also offers numerous opportunities for developing optimization techniques to determine the weights. some of the approaches including ga, pso, and ant optimization techniques, among others, can be investigated. neural networks as well as similar models such as fuzzy networks, deep neural networks; svm, etc. also offer an excellent opportunity for developing adaptive techniques to combine individual classifiers outputs. for example, can individual classifiers be considered as layers of more general architectures. computational complexity is an important issue that needs further research especially when the different algorithms are deployed over mobile or low power platform an important issue which is still open is that of finding the optimal number of classifiers to be combined for a given application. additionally, for a given number of features, is there a way to distribute these among the different classifiers to be combined. finally, the use of hybrid approaches to integrate results from different combination techniques, offers further opportunities for solving more involved applications. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/AAII/T3/02_marco_general.html",
    "title": "Marco general para la combinacion de clasificadores",
    "body": " index search search back marco general para la combinacion de clasificadores the task is seen as a problem of finding a combination function which accepts \\(n\\)-dimensional score vectors from each of the \\(m\\) classifiers, then producing a single final classification score representing the selected class. given the \\(n\\) possible classes \\(\\{\\omega_1, \\omega_2, \\cdots, \\omega_n\\}\\) and a pattern \\(z\\) (that is a data sample), let \\(x_k\\) be the measurement vector (the numerical attributes of \\(z\\)) used by the \\(k\\)th classifier (different classifiers may use different attributes to discriminate). the probability density function of the measurement vector is represented by: \\begin{align} p(x_k|\\omega_n) \\end{align} while the prior probability of the occurrence of the class is denoted by \\(p(\\omega_n)\\). the bayesian framework aims to determine the class label for the pattern \\(z\\) by considering the information provided by all \\(m\\) classifiers. the final decision is based on the aposteriori probability, which is the probability of the pattern belonging to a specific class \\(j\\) given the measurement vectors from all classifiers \\(x_1, x_2, \\cdots, x_m\\). \\begin{align} p(\\theta = \\omega_j|x_1, x_2, \\cdots, x_m) = \\max_{k} p(\\theta = \\omega_k | x_1, x_2, \\cdots, x_m) \\end{align} so the pattern \\(z\\) is assigned to class \\(\\omega_j\\) which produces the maximum a posterior probability. where the aposteriori distribution is computed as follows: \\begin{align} p(\\theta = \\omega_j|x_1, x_2, \\cdots, x_m) = \\frac{p(x_1, x_2, \\cdots, x_m|\\theta = \\omega_j)p(\\theta=\\omega_j)}{p(x_1, x_2, \\cdots, x_m)} \\end{align} provided that each classifier provides independently a decision support obtained from \\(x_k\\), where \\(p(x_1, x_2, \\cdots, x_m)\\) is the joint pdf of the observations independently of class label. the important issue is that the individual classifiers should not make identical erroneous decisions on the same observation instances, they should provide complementary information. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/AAII/T3/03_estrategias.html",
    "title": "Estrategias para la combinación de clasificadores",
    "body": " index search search back estrategias para la combinación de clasificadores contents levels of classifiers combination hard and soft level classifier combination weighted majority voting dynamic weighted consult-and-vote divide and conquer quality based combination techniques feature combination critic classifier adaptative voting technique different model combination dynamic entropy based combination technique assuming linear dependency between predictors runtime weighted opinion pool using hidden markov models assigning weights to classes combination rules assesment adaptative and non-adaptative combiners adaptative combiners ad and cm combination ann vs svm combination combination through ann incorporating a priori knowledge combining combination strategies dynamically modifying majority voting based on genetic theory fuzzy based non-adaptative combiners conclusion classification based on the number of classifiers other combination techniques references this section provides a detailed review of classifiers combination techniques first, we discuss the different levels at which combination is performed: sensors, features and decisions. we then expand on the concept of soft vs. hard combination techniques. finally, we discuss how the combination techniques can be grouped as either adaptive or non-adaptive. levels of classifiers combination classifiers combination can be carried out at three different levels: early combination at sensor data level: combination of data collected from two or more sensors before feature selection technique is applied. combination at feature level: it may simply involve basic concatenation of feature vectors with equal or different weights (might result in high dimensonal vectors, whose dimension has to be reduced). late combination at the decision level: they are based on one of three approaches: abstract, rank, and score: abstract-based: a single output label from each individual classifier is used as input to the combination scheme. rank-based: each classifier yields several labels ranked from the most likely to the least likely. this information is then used by the combination scheme to reach the final decision. score-based: each classifier outputs the \\(n\\) best labels together with their confidence scores. the combination can be density-based, transformation-based or classifier-based score fusion. hard and soft level classifier combination another way to categorize combination algorithms is whether hard thresholding or soft scoring is used with each of the classifiers. hard-level combination: uses the output of the classifier after it is hard thresholded. soft-level combination: uses estimates of the aposteriori probability of the class. the sum, product, max, min rules, etc., fall under the soft level combiners as they use the output aposteriori probability of the classifier or a score. sum rule: the class with the highest sum of probabilities is chosen as the final prediction. product rule: the class with the highest product of probabilities is chosen as the final prediction. max rule: the class with the highest posterior probability among all classifications made by individual classifiers is selected as the final prediction. min rule: the class with the lowest posterior probability among all classifications made by individual classifiers is selected as the final prediction. majority voting is a typical example of hard-level combiners and has found widespread use in the literature. there are three different versions of voting: unanimous voting. more than half voting. highest number of votes. considering the output label vector of the \\(i\\)th classifier as: \\begin{align} [d_{i, 1}, \\cdots, d_{i, n}]^t \\in [0, 1]^n \\end{align} where \\(i = 1, 2, \\cdots, m\\) and \\(d_{i, j} = 1\\) if the classifier \\(d_i\\) labels the \\(i\\)th instance as class \\(\\omega_j\\) and \\(0\\) otherwise. the majority vote results in a decision for class \\(\\omega_k\\) if: \\begin{align} \\sum_{i = 1}^m d_{i, k} = \\max_{j = 1}^n \\sum_{i = 1}^m d_{i, j} \\end{align} where \\(m\\) is the total number of classifiers and \\(n\\) is total number of classes. such that class \\(\\omega_k\\) is the most \"selected\" on all the classifier. the accuracy of the combination scheme is given as: \\begin{align} p_{maj} = \\sum_{m = \\frac{m}{2} + 1}^m \\binom{m}{m} p^m (1-p)^{m - m} \\end{align} where \\(p\\) is the probability of correct classification. majority voting provides an accurate class label when at least \\(\\frac{m}{2} + 1\\) classifiers give correct classifications, it also requires participating classifiers to have comparable accuracies. weighted majority voting weighted majority voting is used when the classifiers' accuracies are not similar, so it is reasonable to assign more weight to the most accurate classifier. now the decision rule becomes: \\begin{align} \\sum_{i = 1}^m b_i d_{i, k} = \\max_{j = 1}^n \\sum_{i = 1}^m b_i d_{i, j} \\end{align} where \\(b_i\\) is the weight associated with classifier \\(d_i\\). for the sake of convenience, it is a good practice to normalize the weights such that the sum is one. the weight selection is very important in determining the overall accuracy of the classifier combinations. therefore, to minimize the classification error of the combination, the weights are assigned as follows: \\begin{align} b_i \\propto \\log\\left(\\frac{p_i}{1 - p_i}\\right) \\end{align} where \\(p_i, \\cdots, p_m\\) are the individual accuracies for each independent classifier. dynamic weighted consult-and-vote in [30], muhlbaier et al. introduced a method for combining ensembles of classifiers using a dynamic weighted consult-and-vote approach for incremental learning of new classes. the proposed technique focuses on incremental learning, specifically for incorporating new classes into the classification system. the consult-and-vote strategy involves a dynamic process where individual classifiers within the ensemble consult with each other to determine their respective voting weights for classifying test instances. the voting weights assigned to each classifier are determined based on their relative performance on the training data. the method proposed by muhlbaier et al. represents an enhancement over a previous approach developed by the authors. the previous approach may have encountered the \"out-voting\" problem, where certain classifiers dominate the decision-making process, potentially leading to biased or inaccurate results. divide and conquer another modification of majority voting, involving a divide and conquer strategy, is described in [31]. it aims to enhance the majority voting approach by breaking down the classification task into smaller, more manageable sub-problems. each sub-problem is then addressed independently, with dedicated classifiers or classification algorithms focusing on solving the specific challenges within that subset of data. after solving each of the smaller sub-problems individually, the results or decisions from these segments are combined using a majority voting scheme. majority voting involves aggregating the outputs of the classifiers or algorithms involved in solving the sub-problems and selecting the class label that receives the most votes as the final decision. quality based combination techniques the quality-based combination approach, as referenced in [32], focuses on assigning higher weights to more reliable classifiers based on specific quality measures. quality measures used to assess the performance of classifiers may vary depending on the application domain and specific requirements. feature combination the challenge of increasing dimensionality resulting from the simple combination of features from different datasets is addressed through innovative approaches to decision-level combination, as discussed in [33]. combining features from diverse datasets can lead to a significant increase in the dimensionality of the data. the study proposed an effective approach for decision-level combination by leveraging spectral reflectance and its higher-order derivatives to classify hyperspectral land images. spectral reflectance and its derivatives provide valuable information about the characteristics of the land surface, which can aid in classification tasks. the study conducted experiments under two scenarios to address the curse of dimensionality: scenario 1 - lda-based dimensionality reduction: linear discriminant analysis (lda) was employed for dimensionality reduction. scenario 2 - multiple classifiers decision fusion (mcdf): multiple classifiers were utilized for decision fusion to enhance classification performance. critic classifier in the study referenced as [34], the authors introduced an innovative approach that focuses specifically on addressing two-class classification problems. the key feature of this approach is the incorporation of a classifier critic associated with each individual classifier, aimed at predicting the error rate of the classifier. the role of the classifier critic is to forecast the potential error or misclassification rate of its associated classifier. the approach relies on classical standard voting techniques for combining the outputs of multiple classifiers. adaptative voting technique in the study referenced as [35], the authors introduced an adaptive approach to voting techniques. the key innovation in this approach is the dynamic weighting of classifiers based on their estimated recognition performance. different model combination in [36], the authors explored the combination of three distinct classifiers - naive bayes, j48 decision tree, and decision table - using various voting techniques to enhance classification accuracy. the classifiers were combined using different voting strategies, including simple voting (where each classifier has equal weight), weighted voting (assigning different weights to classifiers based on their performance), and probability-based voting (considering the confidence or probability estimates of classifiers). the study reported that the ensemble of classifiers using weighted and probability-based voting techniques outperformed simple majority voting. in addition to classifier combination and voting strategies, the study applied a supervised dimensionality reduction algorithm to further enhance performance. dimensionality reduction techniques aim to reduce the complexity of the feature space while preserving relevant information, thereby improving classification accuracy and efficiency. in [38], a voting strategy was employed for land cover classification of remotely sensed images by utilizing an ensemble of six different classifiers. common voting techniques include simple majority voting, weighted voting, or probability-based voting, where the combined decision is based on the collective predictions of the ensemble members. in the study referenced as [39], researchers proposed an approach that combines artificial neural network (ann) and k-nearest neighbors (knn) based classifiers using a majority voting scheme. this method was specifically designed to enhance accuracy in scenarios where sensor data is prone to drift. the researchers employed a majority voting scheme to combine the predictions of the ann and knn classifiers. in this approach, each classifier in the ensemble provides a prediction, and the final decision is made based on the majority vote of the individual classifier outputs. the primary goal of the study was to leverage the complementary strengths of ann and knn classifiers to address the challenge of sensor data drift. ann models are known for their ability to learn complex patterns from data, while knn is a non-parametric method based on instance-based learning that can be effective in classification tasks. by combining multiple knn classifiers using majority voting and employing median voting for the ann classifiers, the researchers observed a substantial improvement in classification performance. the ensemble of ann and knn classifiers demonstrated enhanced accuracy in classifying sensor data, showcasing the effectiveness of the majority voting scheme in mitigating the impact of data drift on classification outcomes. dynamic entropy based combination technique in [37], the authors introduced a novel dynamic entropy-based technique for combining classifiers. the key idea behind the combination scheme is to assign weights to individual classifiers based on their confidence levels in making decisions. classifiers that exhibit high confidence in their predictions are assigned larger weights, while those with lower confidence receive smaller weights. assuming linear dependency between predictors in [40], the authors considered linear dependency of both classifiers and features. to address this, they proposed a new approach that models the dependencies between features without making any assumptions about the distribution of features (independency) or classifiers. the researchers introduced two key models as part of their framework: linear classifier dependency modelling (lcdm): this model focuses on capturing dependencies between the classifiers themselves, exploring how the outputs of different classifiers may be linearly related. linear feature dependency modelling (lfdm) : this model is designed to identify and model dependencies between the features used by the classifiers, allowing for a more comprehensive understanding of the relationships within the feature space. the results of the study demonstrated that the proposed approach outperformed existing methods in scenarios where linear dependencies between features and classifiers play a significant role. by explicitly modeling these dependencies, the framework was able to capture more complex relationships within the data and improve classification accuracy. runtime weighted opinion pool in [45], introduces a novel classifiers combination approach known as the runtime weighted opinion pool (rwop). this approach dynamically assigns weights to the classifiers during runtime based on their local performance, leading to an adaptive and context-aware combination strategy. unlike traditional weighted sum-based approaches, rwop utilizes an intuitive runtime strategy to determine the weights for combining classifier outputs. the dynamic weight assignment in rwop allows the system to adapt to changing conditions and varying input patterns, leading to more robust and accurate classification outcomes. using hidden markov models in the study referenced as [46], the authors introduce a novel approach for combining classifiers specifically designed for hidden markov model (hmm) based classifiers. unlike traditional methods where the combination typically occurs at the decision level, this new approach operates at a more elementary level within the hmm framework. assigning weights to classes in the study referenced as [12], a novel weighted majority voting approach was proposed for classifiers combination. this approach differs from traditional methods by assigning weights to different classes rather than individual base classifiers. the weights are determined by estimating the joint probability distribution of each class using the scores provided by all classifiers in the combination pool. the joint probability distribution is computed using the naïve bayes probabilistic model. combination rules in the context of multiple classifiers combination, the way individual classifiers handle input patterns can vary. some classifiers may use the same representation of the input pattern, while others may employ their own unique representations. the effectiveness of combining these classifiers using different strategies has been explored in various studies, including those referenced as [41], [42], and [43]. simple sum rule: despite being developed under restrictive assumptions, the simple sum rule was found to outperform other combination rules in certain scenarios. majority voting: the experimental results indicated that the majority voting approach was the most effective combination rule for the specific dataset used in the study. assesment fixed rule-based combination techniques in the context of multiple classifiers do not require a training stage and rely on class labels, distances, or confidences provided by individual classifiers. the efficiency of fixed rule techniques is influenced by various factors, as discussed in reference [44]. according to reference [44], fixed rule techniques are most efficient under specific conditions: availability of large training sets: adequate training data is essential for reliable performance. generation of reliable confidences: individual classifiers should provide accurate and trustworthy confidence values. training on different feature spaces: base classifiers should be trained on diverse feature representations to capture varied aspects of the data. in scenarios where the strict conditions for fixed rule techniques are not met, a trained combination rule may yield better results. adaptative and non-adaptative combiners adaptative combiners adaptive techniques for classifiers combination are mainly based on evolution or artificial intelligence algorithms. they include neural networks combination strategies and genetic algorithms as well as fuzzy set theory. techniques under these categories are summarized on the following figure: artificial neural networks are usually used as a base classifier [29], however, it has also found wide use in combination of classifiers. ad and cm combination in [48], the author introduces two innovative approaches for combining classifiers to enhance robustness and fault tolerance: the attractor dynamics (ad) algorithm and the classifier masking (cm) algorithm. the cm algorithm is described as a non-neural version of the ad algorithm, inspired by modeling properties of sensory integration in the central nervous system. both approaches are designed to promote consensus among individual classifiers and improve the overall performance of the combined system by discarding corrupted classifier outputs. ann vs svm combination in [49], the authors conducted a comparative analysis of combining the outputs of an ensemble of artificial neural networks (anns) with support vector machine (svm) classifiers for processing remotely sensed data. they employed an multi-layer perceptron (mlp) module to facilitate the non-linear combination of the outputs generated by the networks. the researchers explored two distinct approaches for optimizing coefficient selection: the bayesian method and the error correlation matrix. through experimental evaluation, the authors found that the mlp-based combination scheme yielded the most favorable results compared to the svm classifiers. combination through ann in [50], the authors proposed a novel approach where they utilized an artificial neural network (ann) as a model for combining classifiers. instead of combining the outputs of different classifiers, they integrated various training sets with distinct classifiers to train a unified combination rule within a three-layer ann architecture. in this setup, each classifier represented a unit in the hidden layer of the ann. incorporating a priori knowledge in [51], the authors delved into the significance of leveraging a priori knowledge within existing classifiers combination techniques, specifically exploring the application of the behavior knowledge space and the dempster-shafer (d-s) theory. this investigation aimed to elucidate how incorporating prior knowledge can enhance the performance of classifiers combination, particularly when dealing with strongly correlated classifiers. the study also highlighted the utilization of adaptive combiners, encompassing strategies such as adaptive weighting, associative switching, mixture of local experts (mle), and hierarchical mle combining combination strategies dynamically in [57] an adaptive approach to combining classifiers was introduced. the proposed approach dynamically selects between two different combination strategies based on the belief values obtained from each strategy. specifically, the study compared the performance of a bayesian classifiers combination approach and product and max rule combination strategy. in the bayesian method, the combination of classifiers is based on probabilistic principles, where the posterior probabilities of class labels are calculated using bayes' theorem. the product rule combines the outputs of individual classifiers by multiplying their probabilities or scores for each class. the max rule operates by selecting the class label that receives the highest score or confidence level among all the individual classifiers in the ensemble. modifying majority voting in [58] the authors introduced various modifications to the traditional majority voting rule by incorporating a bayesian framework and a genetic algorithm (ga) to determine the weights assigned to different classifiers in the ensemble. the bayesian framework allowed for the probabilistic modeling of the weights, while the ga provided an optimization technique to search for the best combination of weights that maximized the ensemble performance. the results of the study indicated that the modified majority voting rule, when combined with the bayesian framework and ga for weight optimization, achieved significant improvements in accuracy. specifically, the optimal accuracies obtained were \\(94.3\\%\\) for the majority vote, \\(95.4\\%\\) for the genetic algorithm, and 95.95% for the bayesian approach. based on genetic theory in the study referenced as [22], the authors introduced an innovative approach that involved the simultaneous extraction and selection of features and classifiers to improve the performance of gender and age classification using speech signals collected from a typical korean home environment. the authors employed a genetic algorithm to simultaneously select features and classifiers. ga is a metaheuristic optimization technique inspired by the process of natural selection and genetics, used to search for the optimal combination of features and classifiers for the classification task. the outputs of the selected classifiers were combined using the dempster-shafer theory, a mathematical theory for combining evidence from different sources to make decisions under uncertainty. in [59] a novel approach based on genetic algorithm (ga) with self-configuration capabilities was developed for classifier combination. the researchers employed a pool of twelve expert classifiers that were already trained on the task of character recognition, including both printed and handwritten characters. these expert classifiers likely had different strengths and weaknesses, making them suitable candidates for ensemble learning. the ga was integrated into the system to optimize the combination of outputs from the expert classifiers. by using the evolutionary principles of genetic algorithms, the system could iteratively adjust the weights assigned to each classifier in the ensemble to maximize the overall accuracy of the system. fuzzy based in the study referenced as [16], the authors introduced a novel approach known as fuzzy stacked generalization (fsg) to combine the outputs of multiple classifiers. fsg operates within a hierarchical framework where multiple base-layer classifiers are utilized to make individual predictions on the input data. in fsg, the decisions made by the base-layer classifiers are aggregated to form a decision vector. this decision vector is then fed into a meta-layer classifier, which combines the outputs of the base-layer classifiers to make the final decision. in [53], the authors proposed a classifiers combination technique using fuzzy templates (ft). an object is labeled with the class whose fuzzy template is closest to the objects' decision profile. the authors obtained an improved performance over majority, min, max and product rules, and unweighted average combination techniques in [54], an adaptive fuzzy integral was used to combine multiple classifiers. the parameter \\(\\lambda\\)-fuzzy, which measures performance, is adaptively adjusted depending upon the interaction among the classifiers. the essence of the parameter is to search for the maximum degree of agreement between the conflicting and complementary sources of evidence. in [55], a fuzzy decision rule was employed to combine the outputs of multiple classifiers without the need for a training stage. each classifier was independently applied to the input data, but no final decision was made based on their outputs at this stage. these classifiers are pre-existing models that have been trained on labeled data to make predictions or classifications. the results from the classifiers were aggregated using a fuzzy decision rule. this rule considered the membership degrees of the classes assigned by each classifier and selected the class with the highest membership degree (the confidence or certainty with which each classifier assigns a data point to a specific class) as the correct class. two measures of accuracy, namely information reliability and global accuracy, were utilized in the combination rule to assess the performance of the combined classifiers. in [56] the authors introduced a first-order takagi-sugeno-kang (tsk) fuzzy model for combining multiple classifiers. unlike conventional linear combination methods that assign different weights to pairs of classifiers and classes, the proposed tsk fuzzy model assigns weights to each individual classifier, class, and region of the classifier output space (decision boundary). this finer granularity in weight assignment allows for a more nuanced and adaptive combination of classifier outputs. the tsk fuzzy model is utilized to integrate the outputs of multiple classifiers. this model leverages fuzzy logic to combine the predictions of individual classifiers in a way that considers the uncertainty and variability in the classifier outputs. the study demonstrated improved accuracy compared to using individual classifiers alone. while the tsk fuzzy model showed promising results in enhancing classification accuracy, the authors did not explicitly address the potential bias and variance reduction that could arise from using a linear model for combining classifiers. non-adaptative combiners the highest confidence approach is an example of nonadaptive combination techniques. it involves ranking the individual classifiers based on their confidence then selecting the decision of the top ranked one. the borda count technique is also an example of nonadaptive methods. it is based on the principle of single winner classifier in which the individual classifiers provide a ranked list of the classes. it is a more sophisticated alternative to majority voting [60] based on ranking level [9]. it does not require training, just like averaging, sum, and voting rules [52]. conclusion in summary, adaptive combiners tend to do better than the non-adaptive types. this is due to the fact that adaptive combiners update the weights given to the individual classifier dynamically before making the final decision. given the fact that the performance of the individual classifiers can vary over input patterns, such a dynamic combination provides an edge over its non-adaptive counterpart especially when the data space is wide and diverse. classification based on the number of classifiers the most commonly used techniques for ensemble based combinations are displayed in the following figure: bagging is one of the most intuitive and simple techniques used for ensemble based combination. however, unlike bagging, in boosting, the individual classifiers are trained hierarchically to discriminate more complex regions in the feature space. adaboost is a variation of the boosting technique. it is an adaptive boosting meta-algorithm that combines outputs of weak classifiers into a weighted sum that represents the final decision. however, the technique is sensitive to noisy data and outliers. in [66], the authors used adaboost to enhance the performance of a hybrid hidden markov model (hmm) and neural network (nn) speech recognition system. hmms are commonly used for modeling sequential data like speech signals, while nns are effective in capturing complex patterns in data. the researchers evaluated the performance of the hybrid hmm/nn system with and without the adaboost algorithm under noisy environments. noise in speech signals can introduce distortions and affect the accuracy of the recognition system. by applying adaboost, the system was expected to adapt better to noisy conditions and enhance its robustness. the results of the study demonstrated that incorporating adaboost into the hybrid hmm/nn speech recognition system led to improved performance, even in the presence of noise. adaboost's ability to focus on difficult instances and adjust the weights of the classifiers based on their performance contributed to the system's ability to handle noisy environments and enhance overall recognition accuracy. in [67] the researchers explored a combination approach at the feature level using support vector machine (svm) classifiers and a global adaboost classifier. the study focused on combining features extracted from different datasets at the feature level. by utilizing svm classifiers and a global adaboost classifier, the researchers aimed to leverage the strengths of both classifiers in integrating information from multiple datasets to improve classification performance. one significant drawback identified in the study regarding feature-level combination is the issue of high dimensionality. combining features from multiple datasets can result in a large number of features, which can lead to challenges such as increased computational complexity, overfitting, and reduced interpretability of the model. other combination techniques in [68] the researchers introduced a novel classifiers combination technique based on an svm active learning algorithm. the study proposed a method that leverages support vector machine (svm) classifiers in conjunction with an active learning algorithm. active learning refers to a machine learning approach where the algorithm can select the most informative data points for labeling, thereby improving the learning process iteratively. the researchers developed a strategy where an initial classifier, likely an svm model, is used to generate class aposteriori probabilities. these probabilities serve as inputs to the classifiers-combiner, which is based on the svm active learning algorithm. the approach outperforms traditional classifiers combination rules when considering class labeling cost and classification accuracy. in [70] and [71] the researchers introduced a novel approach using eigenclassifiers for combining correlated classifiers. the proposed method involves utilizing principal component analysis (pca) projection to create eigenclassifiers from a set of initially correlated classifiers. by applying pca, the goal is to transform the correlated classifiers into uncorrelated eigen-classifiers. this transformation process aims to enhance the diversity and independence of the classifiers, enabling them to complement each other effectively during the combination stage. the results of the study indicated that the pca-based eigenclassifiers technique provided better or comparable accuracy with a reduced number of classifiers compared to bagging and adaboost. this suggests that the uncorrelation process facilitated by pca enhanced the performance of the combined classifiers, leading to improved classification results with fewer individual classifiers. similarly, in [72] the researchers explored methods to address linear and non-linear correlations among the outputs of individual classifiers by leveraging principal component analysis (pca) and a generalized kernel-based pca approach. initially, the authors identified linear correlations among the outputs of individual classifiers. to mitigate these linear correlations, the researchers applied a simple pca approach. building on the success of addressing linear correlations, the authors extended their approach to consider non-linear dependencies among the outputs of individual classifiers. o handle these non-linear dependencies, the researchers proposed a generalized kernel-based pca approach. the results of the experiments demonstrated that the generalized kernel-based pca approach outperformed alternative methods in improving classification accuracy. in [73] the researchers introduced a novel classifier combination technique that focused on extracting class boundaries and utilizing a set of local linear combination rules. the proposed technique involved extracting class boundaries, which are the decision boundaries that separate different classes in the dataset. the researchers employed a set of local linear combination rules to combine the outputs of individual classifiers. these rules likely involved linear combinations of classifier outputs within specific regions of the feature space, allowing for adaptive and context-aware decision-making. the experimental results demonstrated that the classifier combination technique based on class boundaries and local linear combination rules achieved better accuracy compared to other methods such as linear combination, voting, and decision templates. in [13], the researchers proposed a weighted averaging approach that incorporated graph-theoretical clustering and a support vector machine (svm) classifier for classifier combination. the researchers utilized graph-theoretical clustering techniques as part of the weighted averaging approach. graph theory provides a framework for analyzing relationships between data points, and clustering algorithms can group similar data points together based on certain criteria. by incorporating graph-theoretical clustering, the approach likely aimed to identify clusters of data points with similar characteristics for more effective combination of classifier outputs. in addition to clustering, the approach involved the use of an svm classifier. svms are powerful machine learning models commonly used for classification tasks. by integrating an svm classifier into the weighted averaging process, the researchers likely leveraged its ability to create optimal decision boundaries between classes in the feature space. the results obtained from the experiments indicated that the proposed approach, despite its simplicity and intuitive nature, performed comparably to more sophisticated methods. in [74], the researchers employed three different techniques - highest rank (hr), borda count (bc), and logistic regression (lr) - for combining decisions in a multi-classifier system. the decisions produced by each individual classifier were ranked based on their confidence or accuracy. the hr, bc, and lr techniques were then applied to either reduce the set of possible classes or re-rank them during the combination process. the results obtained from the experiments demonstrated a substantial improvement in the performance of the multi-classifier system. similarly, in [75] a new combination technique called mixed group rank (mgr) was introduced as a novel approach to balancing between preference and confidence in a multi-classifier system. this technique aimed to generalize the principles of highest rank (hr), borda count (bc), and logistic regression (lr) by incorporating elements of both preference-based ranking and confidence-based decision-making. in [76], the authors introduced an innovative approach that involves dynamically switching between classifier combination and classifier selection based on the characteristics of different regions in the feature space. the authors further introduced a hybrid combination scheme that integrates clustering-and-selection (cs) techniques with decision template (dt) methods. this hybrid approach likely combines the benefits of clustering for identifying regions of dominance and selection of the most appropriate classifier, along with decision templates for combining classifier outputs in a structured manner. the authors discussed the tradeoff between selecting the best classifier and combining classifiers. this tradeoff likely involves considerations of the strengths and weaknesses of individual classifiers versus the potential benefits of combining multiple classifiers. in [77], the authors introduced a method based on classifier selection that focused on identifying the most suitable candidate through confidence evaluation of distance-based classifiers. the method aimed to select the most precise candidate from a set of distance-based classifiers by evaluating their confidence levels. this process likely involved assessing the certainty or reliability of each classifier's decision-making based on the distances between data points in the feature space. the authors likely defined specific rules or criteria for selecting the precise candidate based on the confidence evaluations of the distance-based classifiers. these rules may have considered factors such as the proximity of data points to decision boundaries, the consistency of classifier outputs, or the overall confidence levels of individual classifiers. the experiments conducted in the study likely utilized distance metrics such as euclidean distance and city block distance for recognizing handwritten characters. in [78], the author used information from the confusion matrix to merge multiple classifiers using a class ranking borda type reconciliation method. the class ranking borda type reconciliation method is a technique that combines the outputs of multiple classifiers by ranking the classes based on their performance and then using a borda count approach to reconcile the rankings. the results obtained from this method were compared with three other classifier combination techniques: majority voting, sum rule, and median rule. the comparison was done using three types of confusion matrices: deterministic, uniform, and stochastic. the apborda (aposteriori borda count) and sum rule gave the overall best improvement, except in the case of a stochastic confusion matrix and disparate combination (where classifiers had a \\(10\\%\\) accuracy difference from each other). this means that in most cases, the apborda and sum rule performed better in combining the classifiers, but there were specific scenarios where they did not perform as well. in [79] a combination technique based on the f-measure was proposed for recognizing human emotions using an svm (support vector machine) classifier. in this technique, the f-measure was used to form a decision matrix to determine the final emotion. in [80], the authors proposed an approach for detecting vacant parking spaces by combining two different systems. the first system was based on analyzing image data, while the second system relied on sensor data. the experiments conducted by the authors demonstrated that combining the outputs of these two different systems resulted in a reduced error in detecting vacant parking spaces. in summary, several classifiers combination techniques have been proposed in the literature with each technique having its own strengths and weaknesses. recent techniques mostly involve hybridization or modification of previous techniques to achieve better accuracy or to remove an associated constraint on which a particular technique was built on. some of these constraints include the issue of correlated classifiers, gaussian distribution, and iid. there is still a need to develop classifiers combination strategies which are not constrained to specific distributions. references [12] c. de stefano, f. fontanella, and a. s. di freca, \"a novel naive bayes voting strategy for combining classifiers.,\" in icfhr, 2012, pp. 467–472. [16] c. senaras, m. ozay, and f. t. yarman vural, “building detection with decision fusion,” 2013. [22] y. zhan, h. leung, k.-c. kwak, and h. yoon, “automated speaker recognition for home service robots using genetic algorithm and dempster--shafer fusion technique,” instrum. meas. ieee trans., vol. 58, no. 9, pp. 3058–3068, 2009. [29] l. i. kuncheva, combining pattern classifiers: methods and algorithms. john wiley & sons, 2004. [32] n. poh and j. kittler, \"a unified framework for biometric expert fusion incorporating quality measures,\" pattern anal. mach. intell. ieee trans., vol. 34, no. 1, pp. 3–18, 2012. [33] h. r. kalluri, s. prasad, and l. m. bruce, \"decision-level fusion of spectral reflectance and derivative information for robust hyperspectral land cover classification,\" geosci. remote sensing, ieee trans., vol. 48, no. 11, pp. 4047–4058, 2010. [34] d. j. miller and l. yan, \"ensemble classification by critic-driven combining,\" in acoustics, speech, and signal processing, 1999. proceedings., 1999 ieee international conference on, 1999, vol. 2, pp. 1029–1032 [35] f. mattern, t. rohlfing, and j. denzler, \"adaptive performancebased classifier combination for generic object recognition,\" in proc. of international fall workshop vision, modeling and visualization (vmv), 2005, pp. 139–146 [36] g. jain, a. ginwala, and y. a. aslandogan, \"an approach to text classification using dimensionality reduction and combination of classifiers,\" in information reuse and integration, 2004. iri 2004. proceedings of the 2004 ieee international conference on, 2004, pp. 564–569. [37] m. magimai-doss, d. hakkani-tur, o. cetin, e. shriberg, j. fung, and n. mirghafori, \"entropy based classifier combination for sentence segmentation,\" in acoustics, speech and signal processing, 2007. icassp 2007. ieee international conference on, 2007, vol. 4, p. iv--189 [39] s. adhikari and s. saha, \"multiple classifier combination technique for sensor drift compensation using ann & knn,\" in advance computing conference (iacc), 2014 ieee international, 2014, pp. 1184–1189. [40] a. j. ma, p. c. yuen, and j.-h. lai, \"linear dependency modeling for classifier fusion and feature combination,\" pattern anal. mach. intell. ieee trans., vol. 35, no. 5, pp. 1135–1148, 2013. [43] z. wu, c.-h. li, and v. cheng, \"large margin maximum entropy machines for classifier combination,\" in wavelet analysis and pattern recognition, 2008. icwapr’08. international conference on, 2008, vol. 1, pp. 378–383 [44] r. p. w. duin, \"the combining classifier: to train or not to train?,\" in pattern recognition, 2002. proceedings. 16th international conference on, 2002, vol. 2, pp. 765–770. [45] w. wang, a. brakensiek, and g. rigoll, \"combination of multiple classifiers for handwritten word recognition,\" in frontiers in handwriting recognition, 2002. proceedings. eighth international workshop on, 2002, pp. 117–122. [48] a. v bogdanov, \"neuroinspired architecture for robust classifier fusion of multisensor imagery,\" geosci. remote sensing, ieee trans., vol. 46, no. 5, pp. 1467–1487, 2008. [49] g. pasquariello, n. ancona, p. blonda, c. tarantino, g. satalino, and a. d’addabbo, \"neural network ensemble and support vector machine classifiers for the analysis of remotely sensed data: a comparison,\" in geoscience and remote sensing symposium, 2002. igarss’02. 2002 ieee international, 2002, vol. 1, pp. 509–511. [50] y.-d. lan and l. gao, \"a new model of combining multiple classifiers based on neural network,\" in emerging intelligent data and web technologies (eidwt), 2013 fourth international conference on, 2013, pp. 154–159. [51] v. di lecce, g. dimauro, a. guerriero, s. impedovo, g. pirlo, and a. salzo, \"knowledge-based methods for classifier combination: an experimental investigation,\" in image analysis and processing, 1999. proceedings. international conference on, 1999, pp. 562–565. [52] a. k. jain, r. p. w. duin, and j. mao, “statistical pattern recognition: a review,” pattern anal. mach. intell. ieee trans., vol. 22, no. 1, pp. 4–37, 2000. [53] l. i. kuncheva, j. c. bezdek, and m. a. sutton, “on combining multiple classifiers by fuzzy templates,” in fuzzy information processing society-nafips, 1998 conference of the north american, 1998, pp. 193–197 [54] t. d. pham, “combination of multiple classifiers using adaptive fuzzy integral,” in artificial intelligence systems, 2002.(icais 2002). 2002 ieee international conference on, 2002, pp. 50–55. [55] m. fauvel, j. chanussot, and j. a. benediktsson, “decision fusion for the classification of urban remote sensing images,” geosci. remote sensing, ieee trans., vol. 44, no. 10, pp. 2828–2838, 2006. [56] m. cococcioni, b. lazzerini, and f. marcelloni, “a tsk fuzzy model for combining outputs of multiple classifiers,” in fuzzy information, 2004. processing nafips’04. ieee annual meeting of the, 2004, vol. 2, pp. 871–876. [57] y. yaslan and z. cataltepe, “co-training with adaptive bayesian classifier combination,” in computer and information sciences, 2008. iscis’08. 23rd international symposium on, 2008, pp. 1–4. [58] l. lam and c. y. suen, “optimal combinations of pattern classifiers,” pattern recognit. lett., vol. 16, no. 9, pp. 945–954, 1995. [59] k. sirlantzis and m. c. fairhurst, “optimisation of multiple classifier systems using genetic algorithms,” in image processing, 2001. proceedings. 2001 international conference on, 2001, vol. 1, pp. 1094–1097 [66] h. schwenk, “using boosting to improve a hybrid hmm/neural network speech recognizer,” in acoustics, speech, and signal processing, 1999. proceedings., 1999 ieee international conference on, 1999, vol. 2, pp. 1009–1012. [67] j. hu and y. chen, “offline signature verification using real adaboost classifier combination of pseudo-dynamic features,” in document analysis and recognition (icdar), 2013 12th international conference on, 2013, pp. 1345–1349 [68] x. yi, z. kou, and c. zhang, “classifier combination based on active learning,” in pattern recognition, 2004. icpr 2004. proceedings of the 17th international conference on, 2004, vol. 1, pp. 184–187. [69] j. kremer, k. steenstrup pedersen, and c. igel, “active learning with support vector machines,” wiley interdiscip. rev. data min. knowl. discov., vol. 4, no. 4, pp. 313–326, jul. 2014. [70] a. ulaş, o. t. yıldız, and e. alpaydın, “eigenclassifiers for combining correlated classifiers,” inf. sci. (ny)., vol. 187, pp. 109– 120, 2012. [71] e. ulaş, a., semerci, m., yıldız, o. t., & alpaydın, “incremental construction of classifier and discriminant ensembles,” inf. sci. (ny)., vol. 179, no. 9, pp. 1298–1318, 2009 [72] u. ekmekci and z. cataltepe, “classifier combination with kernelized eigenclassifiers,” in information fusion (fusion), 2013 16th international conference on, 2013, pp. 743–749. [73] m. liu, k. li, and r. zhao, “a boundary based classifier combination method,” in control and decision conference, 2009. ccdc’09. chinese, 2009, pp. 3777–3782 [74] t. k. ho, j. j. hull, and s. n. srihari, “decision combination in multiple classifier systems,” pattern anal. mach. intell. ieee trans., vol. 16, no. 1, pp. 66–75, 1994. [75] o. melnik, y. vardi, and c.-h. zhang, “mixed group ranks: preference and confidence in classifier combination,” pattern anal. mach. intell. ieee trans., vol. 26, no. 8, pp. 973–981, 2004. [76] l. i. kuncheva, “switching between selection and fusion in combining classifiers: an experiment,” syst. man, cybern. part b cybern. ieee trans., vol. 32, no. 2, pp. 146–156, 2002. [77] c.-l. liu and m. nakagawa, “precise candidate selection for large character set recognition by confidence evaluation,” pattern anal. mach. intell. ieee trans., vol. 22, no. 6, pp. 636–641, 2000. [78] j. r. parker, “combining multiple non-homogeneous classifiers: an empirical approach,” in cognitive informatics, ieee international conference on, 2002, p. 288. [79] a. agrawal and n. k. mishra, “fusion based emotion recognition system,” in 2016 international conference on computational science and computational intelligence (csci), 2016, pp. 727–732 [80] junzhao, l., mohandes, m., deriche, m., “a multi-classifier image based vacant parking detection system”, ieee international conference on electronics, circuits, and systems icesc, pp. 933-936, abu dhabi, uae, dec 8-11, 2013 $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/AAII/T4/01_introduction.html",
    "title": "Introduction",
    "body": " index search search back introduction in this chapter we address unsupervised learning. in this case one has a set of \\(n\\) observations \\((x_1,x_2, \\cdots ,x_n)\\) of a random vector \\(x\\) having joint density \\(\\text{pr}(x)\\). the goal is to directly infer the properties of this probability density without the help of a supervisor or teacher providing correct answers or degree-of-error for each observation. principal components, multidimensional scaling, self-organizing maps, and principal curves try to find simpler patterns in complex data. they look for lower-dimensional structures in the data that capture where most of the data points lie. by doing this, they help us understand how variables are related to each other and if they can be thought of as being controlled by a smaller group of underlying factors. cluster analysis looks for groups or clusters in the data that are like little \"bumps\" or \"peaks\" where the data is most concentrated, that is convex regios of the \\(x\\)-space that contain modes of \\(\\text{pr}(x)\\). it helps us see if the data can be divided into different types or categories. mixture modeling aims for the same thing. association rules try to find simple rules or patterns that describe where the data is most concentrated, especially when dealing with data that has many features and is either present or absent (binary-valued). in unsupervised learning, where we don't have clear outcomes to compare against. we often have to rely on guesswork and intuition to decide if the results make sense or not. this uncertainty has led to many different methods being proposed, but ultimately, it's hard to know for sure which one is the best since there's no straightforward way to check their effectiveness. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/AAII/T4/03_evaluation_metrics.html",
    "title": "Evaluation Metrics",
    "body": " index search search back evaluation metrics contents formal limitations of clustering methods for clustering evaluation null hypothesis testing internal validation partitional methods hierarchical methods cophenetic correlation coefficient hubert statistic external validation matching sets peer-to-peer correlation measures based on information theory hyperparameter tuning formal limitations of clustering jon kleinberg proposes three axioms that highlight the characteristics that a grouping problem should exhibit and can be considered \"good\". scale invariance: indicates that a clustering algorithm should not modify its results when all distances between points are scaled by the factor determined by a constant \\(\\alpha\\). richness: the clustering function must be flexible enough to produce any arbitrary partition/clustering of the input data set. consistency: the clustering results do not change if the distances within clusters decrease and/or the distances between clusters increase. given the above three axioms, kleinberg proves the following theorem: for every \\(n \\geq 2\\), there is no clustering function \\(f\\) that satisfies scale invariance, richness, and consistency. since the three axioms cannot hold simultaneously, clustering algorithms can be designed to violate one of the axioms while sarisfying the other two. \\(k\\)-cluster stopping condition: stop merging clusters when we have \\(k\\) clusters (violates the richness axiom). distance \\(r\\) stopping condition: stop merging clusters when the nearest pair of clusters are farther than \\(r \\) (violates scale invariance). scale-\\(\\epsilon\\) stopping condition: stop merging clusters when the nearest pair of clusters are farther than a fraction \\(\\epsilon\\) the maximum pairwise distance \\(\\delta\\). (consistency is violated). methods for clustering evaluation when analyzing clustering results, several aspects must be taken into account for the validation of the algorithm results: determining the clustering tendency in the data (i.e. whether non-random structure really exists). determining the correct number of clusters. assessing the quality of the clustering results without external information. comparing the results obtained with external information. comparing two sets of clusters to determine which one is better. the first three issues are addressed by internal or unsupervised validation, because there is no use of external information. the fourth issue is resolved by external or supervised validation. finally, the last issue can be addressed by both supervised and unsupervised validation techniques. null hypothesis testing one of the desirable characteristics of a clustering process is to show whether data exhibits some tendency to form actual clusters. in this case, the null hypothesis \\(h_0\\) is the randomness of data and, when the null hypothesis is rejected, we assume that the data is significantly unlikely to be random. one of the difficulties of null hypothesis testing in this context is determining the statistical distribution under which the randomness hypothesis can be rejected. jain and dubes propose three alternatives: random plot hypothesis \\(h_0\\): all proximity matrices of order \\(n \\times n\\) are equally likely. random label hypothesis \\(h_0\\): all permutations of labels of \\(n\\) objects are equally likely. randon position hypothesis \\(h_0\\): all sets of \\(n\\) locations is some region of a \\(d\\)-dimensional space are equally likely. internal validation internal validation methods (or internal indices) make it possible to establish the quality of the clustering structure without having access to external information. in general, two types of internal validation metrics can be combined: cohesion measures: evaluates how closely the elements of the same cluster are to each other. separation measures: quantify the level of separation between clusters. internal indices are usually employed in conjunction with two clustering algorithm families: hierarchical clustering algorithms and partitional algorithms. for partitional algorithms, metrics based on the proximity matrix, as well as metrics of cohesion and separation, such as the silhouette coefficient, are often used. for hierarchical algorithms, the cophenetic coefficient is the most common. partitional methods in general, the internal validation value of a set of \\(k\\) clusters can be decomposed as the sum of the validation values for each cluster: \\begin{align} \\text{general validity} = \\sum_{i=1}^k w_i \\text{validity}(c_i) \\end{align} this measure of validity can be cohesion, separation, or some combination of both. quite often, the weights that appear in the previous expression correspond to cluster size. the individual measures of cohesion and separation are defined as follows: \\begin{align} \\text{cohesion}(c_i) = \\sum_{x \\in c_i, y \\in c_i} \\text{proximity}(x, y) \\end{align} \\begin{align} \\text{separation}(c_i, c_j) = \\sum_{x \\in c_i, y \\in c_j} \\text{proximity}(x, y) \\end{align} it should be noted that the cohesion metric defined above is equivalent to the cluster sse [sum of squared errors]: \\begin{align} sse(c_i) = \\sum_{x \\in c_i} d(c_i, x)^2 = \\frac{1}{2m_i} \\sum_{x \\in c_i} \\sum_{y \\in c_i} d(x, y)^2 \\end{align} likewise, we can maximize the distance between clusters using a separation metric. this approach leads to the between group sum of squares, or ssb: \\begin{align} ssb = \\sum_{i = 1}^k m_i d(c_i, c)^2 = \\frac{1}{2k} \\sum_{i=1}^k \\sum_{j = 1}^k \\frac{m}{k} d(c_i, c_j)^2 \\end{align} where \\(c_i\\) is the mean of the \\(i\\)th cluster and \\(c\\) is the overall mean. instead of dealing with separate metrics for cohesion and separation, there are several metrics that try to quantify the level of separation and cohesion in a single measure: the calisnki-harabasz coefficient: it is a measure based on the internal dispersion of clusters and the dispersion between clusters. we would choose the number of clusters that maximizes the ch. \\begin{align} ch = \\frac{\\frac{ssb_m}{m - 1}}{\\frac{sse_m}{m}} \\end{align} the dunn index is the ratio of the smallest distance between data from different clusters and the largest distance between clusters. again, this ratio should be maximized: \\begin{align} d = \\min_{1 < i < k} \\left\\{\\min_{1 < j < k, i\\neq j} \\left\\{\\frac{\\delta (c_i, c_j)}{\\max_{1 < l < k} \\{\\delta (c_l)\\}}\\right\\}\\right\\} \\end{align} the xie-beni score was designed for fuzzy clustering, but it can applied to hard clustering. it is a ratio whose numerator estimates the level of compaction of the data within the same cluster and whose denominator estimates the level of separation of the data from different clusters: \\begin{align} xb = \\frac{\\sum_{i=1}^n \\sum_{k=1}^m u^2_{ik} ||x_i - c_k||^2}{n_{t \\neq s} \\min (||c_t - c_s||^2)} \\end{align} the ball-hall index is a dispersion measure based on the quadratic distances of the cluster points with respect to their centroid \\begin{align} bh = \\frac{sse_m}{m} \\end{align} the hartigan index is based on the logarithmic relationship between the sum of squares within the cluster and the sum of squares between clusters: \\begin{align} h = \\log \\left(\\frac{ssb_m}{sse_m}\\right) \\end{align} the xu coefficient takes into account the dimensionality \\(d\\) of the data, the number \\(n\\) of data examples, and the sum of squared errors \\(sse_m\\) form \\(m\\) clusters: \\begin{align} x_u = d \\log_2 \\left(\\sqrt{\\frac{sse_m}{dn^2}}\\right) + \\log m \\end{align} the silhouette coefficient is the most common way to combine the metrics of cohesion and separation in a single measure. its computation is divided into four steps: compute the average intracluster distance for each example \\(i\\): \\(a(i) = \\frac{1}{|c_a|} \\sum_{j \\in c_a, i \\neq j} d(i, j)\\) compute the minimum intercluster distance for each example \\(i\\): \\(b(i) = \\min_{c_b \\neq c_a} \\frac{1}{|c_b|} \\sum_{j \\in c_b} d(i, j)\\) compute the silhouette coefficient for each example \\(i\\): \\(s(i) = \\frac{b(i) - a(i)}{max(a(i), b(i))}\\) compute the silhouette puntuation as the average of the silhouette coefficients: \\(s = \\frac{1}{n} \\sum_{i = 1}^n s(i)\\) the silhouette is defined in the interval \\([-1, 1]\\). positive values indicate a high separation between clusters, negative values are an indication that the clusters are mixed with each other. when the silhouette coefficient is zero, it is an an indication that the data are uniformly distributed throughout the euclidean space. unfortunately, one of the main drawbacks of the silhouette coefficient is its high computational complexity. cohesion and separation metrics are not the only validation method available for partitional clustering techniques. in fact, cohesion and separation metrics do not perform well when it comes to analyzing results obtained by algorithms based on density analysis. one way to validate clustering is by comparing the actual proximity matrix with an ideal version based on the provided clustering by the algorithm. if we reorder rows and columns so that all examples of the same cluster appear together, the ideal proximity matrix has a block diagonal structure. high correlation between the actual and ideal proximity matrices indicates that examples in the same cluster are close to each other, although it may not be a good measure for density-based clustering. imagine you have a table where each row and column represents a data point, and the cells contain numbers indicating how similar or close those data points are to each other. now, if you group similar data points together into clusters, you can rearrange the rows and columns of the table so that all the data points within each cluster are together. when you do this, the table will have a diagonal pattern where each cluster forms a block of closely related data points. this diagonal pattern is what we mean by a \"block diagonal structure\" in the context of a proximity matrix. unfortunately, the mere construction of the whole proximity matrix is computationally expensive. hierarchical methods cophenetic correlation coefficient the cophenetic distance between two examples is the proximity at which an agglomerative hierarchical clustering algorithm puts the examples in the same cluster for the first time. the cophenetic correlation coefficient (cpcc) is defined as he correlation between the entries of the cophenetic matrix \\(p_c\\) containing cophenetic distances, and the proximity matrix \\(p\\), containing similarities. the cophenetic correlation coefficient is then defined as: \\begin{align} \\text{cpcc} = \\frac{\\sum_{i < j} (d_{ij} - \\overline{d})(d_{ij}^* - \\overline{d}^*)}{\\sqrt{\\sum_{i < j} (d_{ij} - \\overline{d})^2 \\sum_{i < j}(d_{ij}^* - \\overline{d}^*)}} \\end{align} where \\(d_{ij}\\) is the distance between the example pair \\((i, j)\\), \\(d_{ij}^*\\) is their cophenetic distance, \\(\\overline{d}\\) is the average of the distances in the proximity matrix and \\(d_{ij}^*\\) is the average of the cophenetic distances in the cophenetic matrix. \\begin{align} \\overline{d} = \\frac{\\sum_{i < j} d_{ij}}{2(n^2 - n)} \\end{align} \\begin{align} \\overline{d}^* = \\sqrt{\\frac{\\sum_{i < j} (d_{ij} - d_{ij}^*)^2}{\\sum_{i < j} (d_{ij}^*)^2}} \\end{align} the cophenetic correlation coefficient is a value in the interval \\([−1, 1]\\). high cpcc values indicate a high level of similarity between the two matrices, an indication that the clustering algorithm has been able to identify the underlying structure of its input data. hubert statistic first, concordance are discordance are defined for pairs of examples. a pair \\((i, j)\\) is concordant when \\(((v_{p_i} < v_{c_i}) \\& (v_{p_j} < v_{c_j}))\\) or \\(((v_{p_i} > v_{c_i}) \\& (v_{p_j} > v_{c_j}))\\). and it is said to be discordant when \\(((v_{p_i} < v_{c_i}) \\& (v_{p_j} > v_{c_j}))\\) or \\(((v_{p_i} > v_{c_i}) \\& (v_{p_j} < v_{c_j}))\\). therefore, a pair is neither concordant nor discordant if \\(v_{p_i} = v_{c_i}\\) or \\(v_{p_j} = v_{c_j}\\). let \\(s_+\\) and \\(s_-\\) be the number of concordant and discordant pairs, respectively. then, the hubert coefficient is defined as: \\begin{align} \\gamma = \\frac{s_+ - s_-}{s_+ + s_-} \\end{align} the hubert statistic is between \\(-1\\) and \\(1\\). it has been mainly used to compare the results of two hierarchical clustering algorithms. a higher hubert \\(\\gamma\\) value corresponds to a better clustering of data. external validation external validation proceeds by incorporating additional information in the clustering validation process, i.e. external class labels for the training examples. we want to compare the result of a clustering algorithm \\(c = \\{c_1, c_2, \\cdots, c_m\\}\\) to a potentially different partition of data \\(p = \\{p_1, p_2, \\cdots, p_s\\}\\) which might represent the expert knowledge of the analyst (his experience or intuition), prior knowledge of the data in the form of class labels, the results obtained by another clustering algorithm, or simply a grouping considered to be \"correct\". in order to carry out this analysis, a contingency matrix must be built to evaluate the clusters detected by the algorithm that encompasses the following data: \\(tp\\): the number of data pairs found in the same cluster, both in \\(c\\) and in \\(p\\). \\(fp\\): the number of data pairs found in the same cluster in \\(c\\) but in different clusters in \\(p\\). \\(fn\\): the number of data pairs found in different clusters in \\(c\\) but in the same cluster in \\(p\\). \\(tn\\): the number of data pairs found in different clusters, both in \\(c\\) and in \\(p\\). matching sets several measures can be defined to measure the similarity between the clusters in \\(c\\), obtained by the clustering algorithm, and the clusters if \\(p\\), corresponding to our prior (external) knowledge: precision: \\(pr = \\frac{tp}{tp + fp}\\) recall: \\(r = \\frac{tp}{tp + fn}\\) f-measure: \\(f_{\\alpha} = \\frac{1 + \\alpha}{\\frac{1}{pr} + \\frac{\\alpha}{r}}\\) quite often, precision and recall are evenly combined with an unweighted harmonic mean (\\(\\alpha = 1\\)): \\begin{align} f = \\frac{2 \\cdot pr \\cdot r}{pr + r} \\end{align} purity: evaluates whether each cluster contains only examples from the same class: \\begin{align} u = \\sum_{i} p_i (\\max_j \\frac{p_{ij}}{p_i}) \\end{align} where \\(p_i = \\frac{n_i}{n}\\), \\(p_j = \\frac{n_j}{n}\\) and \\(p_{ij} = \\frac{n_{ij}}{n}\\). where \\(n_{ij}\\) are the number of examples belonging to the class \\(i\\) found in the cluster \\(j\\) and \\(n_i\\) is the number of examples in the cluster \\(i\\). peer-to-peer correlation a second family of measures for external validation are based on the correlation between pairs, i.e. they seek to measure the similarity between two partitions under equal conditions, such as the result of a grouping process for the same set, but by means of two different methods \\(c\\) and \\(p\\). the jaccard coefficient: \\(j = \\frac{tp}{tp + fp + fn}\\) the rand coefficient: \\(rand = \\frac{tp + tn}{m}\\) the folkes and mallows coefficient: \\(fm = \\sqrt{\\frac{tp}{tp + fp} \\cdot \\frac{tp}{tp + fn}}\\) the hubert statistical coefficient: \\(\\gamma = \\frac{1}{m} \\sum_{i=1}^{n - 1} \\sum_{j = i + 1}^{n} x_{ij} y_{ij}\\) where \\(n_{ij}\\) are the number of examples belonging to the class \\(i\\) found in the cluster \\(j\\) and \\(n_i\\) is the number of examples in the cluster \\(i\\). measures based on information theory this family includes basic measures such as entropy and mutual information, as well as their respective normalized variants. entropy: \\(h = - \\sum_{i} p_i \\left(\\sum_{j} \\frac{p_{ij}}{p_i} \\log \\frac{p_{ij}}{p_i}\\right)\\) mutual information: \\(mi = \\sum_{i} \\sum_{j} p_{ij} \\log \\frac{p_{ij}}{p_i p_j}\\) where \\(p_{ij} = \\frac{n_{ij}}{n}\\) and \\(p_i = \\frac{n_i}{n}\\). hyperparameter tuning even though external validation metrics can help us evaluate whether the obtained clusters closely match the underlying categories in the training data, which the clustering algorithm tries to identify without externally-provided class labels, those metrics cannot address other issues such as the right number of clusters for our current data set. hyperparameter tuning tries to determine, for the different possible values of the parameters in \\(p_{alg}\\) , which set of parameter values is the most suitable for our particular clustering problem. we could proceed in the following way: when the algorithm does not include the number of clusters \\(n_c\\) among its parameters, we run the algorithm with different values for its parameters so that we can determine their largest range for which \\(n_c\\) remains constant. later, we choose as parameter values the values in the middle of this range. when the algorithm parameters palg include the desired number of clusters \\(n_c\\), we run the algorithm for a range of values for \\(n_c\\). for each value of \\(n_c\\), we run the algorithm multiple times using different sets of values (i.e. starting from different initial conditions) and choose the value that optimizes our desired validation metric. when we just want to determine the “right” number of clusters, \\(n_c\\), plotting the validation results for different values of \\(n_c\\) can sometimes show a relevant change in the validation metric, commonly referred to as a \"knee\" or \"elbow\". hyperparameter tuning can then be seen as a combinatorial optimization problem using different strategies: grid search: is based on a systematic exploration of the hyperparameter space. random search: chooses parameter configurations at random. smart search techniques try to optimize the problem of searching for hyperparameter values. different strategies can be implemented, such as bayesian optimization using gaussian processes and evolutionary optimization using genetic algorithms or evolution strategies. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/AAII/T4/02_cluster_analysis.html",
    "title": "Cluster Analysis",
    "body": " index search search back cluster analysis contents proximity matrices dissimilarities based on attributes quantitative variables ordinal variables categorical variables object dissimilarity clustering algorithms combinatorial algorithms k-means gaussian mixtures as soft k-means clustering vector quantization k-medoids practical issues hierarchical clustering agglomerative clustering divisive clustering cluster analysis, also called data segmentation, has a variety of goals. all relate to grouping or segmenting a collection of objects into subsets or \"clusters\", such that those within each cluster are more closely related to one another than objects assigned to different clusters. the method we use to group these objects depends on what we consider to be similar, and that decision usually comes from what we know about the subject we're studying. an object can be described by a set of measurements, or by its relation to other objects. proximity matrices sometimes the data is represented directly in terms of the proximity (alikeness or affinity) between pairs of objects. this type of data can be represented by an \\(n \\times n\\) matrix \\(d\\), where \\(n\\) is the number of objects, and each element \\(d_{ij}\\) records the proximity between the \\(j\\)th and \\(j\\)th objects. this matrix is then provided as input to the clustering algorithm. most algorithms assume symmetric dissimilarity matrices, so if the original matrix \\(d\\) is not symmetric it must be replaced by \\(\\frac{(d + d^t)}{2}\\). dissimilarities based on attributes since most of the popular clustering algorithms take a dissimilarity matrix as their input, we must first construct pairwise dissimilarities between the observations. by far the most common choice is squared distance: \\begin{align} d_j(x_{ij}, x_{i'j}) = (x_{ij} - x_{i'j})^2 \\end{align} where \\(j\\) denotes the attribute and \\(i, i'\\) denotes the instance. we first discuss alternatives in terms of the attribute type: quantitative variables measurements of this type of variable or attribute are represented by continuous real-valued numbers. one way to do this is by looking at the absolute difference between them: \\begin{align} d(x_i, x_{i'}) = l(|x_i - x_{i'}|) \\end{align} alternatively, clustering can be based on the correlation \\begin{align} \\rho (x_i, x_{i'}) = \\frac{\\sum_{j} (x_{ij} - \\overline{x}_i)(x_{ij} - \\overline{x}_i)}{\\sqrt{\\sum_{j} (x_{ij} - \\overline{x}_i)^2 \\sum_j(x_{ij} - \\overline{x}_i)^2}} \\end{align} ordinal variables error measures for ordinal variables are generally defined by replacing their \\(m\\) original values with: \\begin{align} \\frac{i - \\frac{1}{2}}{m}, i = 1, \\cdots, m \\end{align} in the prescribed order of their original values. they are then treated as quantitative variables on this scale. categorical variables if the variable assumes \\(m\\) distinct values, these can be arranged in a symmetric \\(m \\times m\\) matrix with elements: \\begin{align} m_{ij} = \\begin{cases} 0 & x_{i} = x_{j} \\\\ 1 & x_{i} \\neq x_{j} \\\\ \\end{cases} \\end{align} object dissimilarity next we define a procedure for combining the \\(p\\)-individual attribute dissimilarities \\(d_j(x_{ij},x_{i'j}), j = 1,2, \\cdots, p\\) into a single overall measure of dissimilarity \\(d(x_i, x_i')\\). this is nearly always done by means of a weighted average: \\begin{align} d(x_i, x_{i'}) = \\sum_{j=1}^p w_j d_j(x_{ij}, x_{i'j}) \\end{align} where: \\begin{align} \\sum_{j=1}^p w_j = 1 \\end{align} here \\(w_j\\) is a weight assigned to the \\(j\\)th attribute regulating the relative influence of that variable in determining the overall dissimilarity between objects. if the goal is to discover natural groupings in the data, some attributes may exhibit more of a grouping tendency than others. variables that are more relevant in separating the groups should be assigned a higher influence in defining object dissimilarity. giving all attributes equal influence in this case will tend to obscure the groups to the point where a clustering algorithm cannot uncover them. specifying an appropriate dissimilarity measure is far more important in obtaining success with clustering than choice of clustering algorithm. clustering algorithms clustering algorithms fall into three distinct types: combinatorial algorithms: work directly on the observed data with no direct reference to an underlying probability model. mixture modeling: supposes that the data is an i.i.d sample from some population described by a probability density function. mode seeking: take a nonparametric perspective, attempting to directly estimate distinct modes of the probability density function combinatorial algorithms each observation is uniquely labeled by an integer \\(i \\in {1, \\cdots, n}\\). one seeks the particular encoder \\(c^*(i)\\) that assigns the \\(i\\)th observation to the \\(k\\)th cluster that satisfies the required goal based on the dissimilarities \\(d(x_i, x_{i'})\\). the \"parameters\" of the procedure are the individual cluster assignments for each of the \\(n\\) observations. these are adjusted so as to minimize a \"loss\" function. since the goal is to assign close points to the same cluster, a natural loss function would be: \\begin{align} w(c) = \\frac{1}{2} \\sum_{k=1}^k \\sum_{c(i) = k}\\sum_{c(i') = k} d(x_i, d_{i'}) \\end{align} this measure tells us how close together the things in the same group are. it is sometimes referred to as the \"within cluster\" point scatter. the total point scatter is given by: \\begin{align} t = \\frac{1}{2} \\sum_{i=1}^n\\sum_{i'=1}^n d_{ii'} = \\frac{1}{2}\\sum_{k=1}^k\\sum_{c(i) = k} \\left(\\sum_{c(i') = k} d_{ii'} + \\sum_{c(i') \\neq k} d_{ii'}\\right) \\end{align} this basically divides, for each \\(i\\)th instance on cluster \\(k\\), so \\(c(i) = k\\), the distances into two categories, distances to instances on the same cluster \\(\\sum_{c(i') = k} d_{ii'}\\), and distances to instances on a different cluster \\(\\sum_{c(i') \\neq k} d_{ii'}\\). that is: \\begin{align} t = w(c) + b(c) \\end{align} where \\(b(c)\\) is the between-cluster point scatter: \\begin{align} b(c) = \\frac{1}{2} \\sum_{k=1}^k \\sum_{c(i) = k} \\sum_{c(i')\\neq k} d_{ii'} \\end{align} so, minimizing \\(w(c)\\) is equivalent to maximizing \\(b(c)\\) given \\(w(c) = t - b(c)\\). cluster analysis by combinatorial optimization is straightforward in principle. one simply minimizes \\(w\\) or equivalently maximizes \\(b\\) over all possible assignments of the \\(n\\) data points to \\(k\\) clusters. unfortunately, such optimization by complete enumeration is feasible only for very small data sets. for this reason, practical clustering algorithms are able to examine only a very small fraction of all possible encoders \\(k = c(i)\\). the goal is to identify a small subset that is likely to contain the optimal one, or at least a good suboptimal partition. such feasible strategies are based on iterative greedy descent. an initial partition is specified. at each iterative step, the cluster assignments are changed in such a way that the value of the criterion is improved from its previous value. clustering algorithms of this type differ in their prescriptions for modifying the cluster assignments at each iteration. when the prescription is unable to provide an improvement, the algorithm terminates with the current assignments as its solution. however, these algorithms converge to local optima which may be highly suboptimal when compared to the global optimum. k-means the k-means algorithm is one of the most popular iterative descent clustering methods, which uses the squared euclidean distance. so the within point-scatter can be written as: \\begin{align} w(c) = \\frac{1}{2} \\sum_{k=1}^k\\sum_{c(i) = k}\\sum_{c(i')=k} ||x_i - x_{i'}||^2 \\end{align} \\begin{align} = \\sum_{k=1}^k n_k \\sum_{c(i) = k} ||x_i - \\overline{x}_k||^2 \\end{align} where \\(\\overline{x}_k\\) is the mean vector associated with the \\(k\\)th cluster and \\(n_k = \\sum_{i=1}^n i(c(i) = k)\\) is the number of instances on the \\(k\\)th cluster. therefore the goal is to group the \\(n\\) observations into \\(k\\) clusters in a way that minimizes the average difference between each observation and the mean of its cluster. \\begin{align} c^* \\min_{c} \\sum_{k=1}^k n_k \\sum_{c(i) = k} ||x_i - \\overline{x}_k||^2 \\end{align} can be obtained by noting that for any set of observations \\(s\\): \\begin{align} \\overline{x}_s = \\arg \\min_{m} \\sum_{i \\in s} ||x_i - m||^2 \\end{align} that is we defined the centroid for \\(s\\) as the point \\(m\\) that minimizes the sum of distances for each instance on \\(s\\). hence we can obtain \\(c^*\\) by solving the enlarged optimization problem: \\begin{align} \\min_{\\{c, m_k\\}^k_1} \\sum_{k=1}^k n_k \\sum_{c(i) = k} ||x_i - m_k||^2 \\end{align} where for each cluster \\(k\\), we search for the encoder \\(c\\) and the optimal centroid \\(m_k\\). thus the optmimization process can be performed in two steps as seen in algorithm 14.1. on (1) we obtain the optimal centroids \\(m_i, i = 1, \\cdots, k\\), and on (2) we try to find the best encoder \\(c\\) given the set of centroids \\(\\{m_1, \\cdots, m_k\\}\\). gaussian mixtures as soft k-means clustering the k-means clustering procedure is closely related to the em algorithm for estimating a certain gaussian mixture model. the e-step of the em algorithm assigns \"responsibilities\" for each data point based in its relative density under each mixture component (cluster). while the m-step recomputes the component density parameters based on the current responsibilities. where the relative density is a monotone function of the euclidean distance between the data point and the mixture center. hence in this setup em is a \"soft\" version of k-means clustering, making probabilistic (rather than deterministic) assignments of points to cluster centers. as \\(\\sigma^2\\) tends to \\(1\\), these probabilities become \\(0\\) and \\(1\\), and the two methods coincide: vector quantization vector quantization (vq) is a technique used in data compression, particularly in the compression of digital signals or images. it involves representing a large set of data points (vectors) by a smaller set of representative values, called codewords or centroids. these centroids are selected from the original data set and are used to approximate the original data. by replacing groups of similar data points with these representative values, vector quantization can significantly reduce the amount of data needed to represent the information while minimizing the loss of quality. in this example of vector quantization, given an image of \\(1024\\times 1024\\) pixels we start by dividing the image into small blocks of \\(2\\times 2\\). each block, which contains four pixels, is treated like a tiny picture of its own. each of the \\(512 \\times 512\\) blocks of four numbers is regarded as vector in \\(\\mathbb{r}^4\\). then, using k-means clustering, we group these blocks together based on their similarity. the clustering process is called the encoding step, and the collection of centroids is called the codebook. why do we expect vq to work at all? the reason is that for typical everyday images like photographs, many of the blocks look the same. what we have described is known as lossy compression, since our images are degraded versions of the original. k-medoids the k-means algorithm can be generalized for use with arbitrarily defined dissimilarities \\(d(x_i, x_{i'})\\). the process of finding the centers of the clusters stays similar, but the way we measure similarity can change. this makes the algorithm versatile and applicable to various types of data. this gives way to the k-medoids algorithm: practical issues in order to apply k-means or k-medoids one must select the number of clusters \\(k^*\\) and an initialization. the latter can be defined by specifying an initial set of centers \\(\\{m_1,\\cdots,m_k\\}\\) or \\(\\{i_1, \\cdots,i_k\\}\\) or an initial encoder \\(c(i)\\). a choice for the number of clusters \\(k\\) depends on the goal. for data segmentation \\(k\\) is usually defined as part of the problem. data-based methods for estimating \\(k^*\\) typically examine the withincluster dissimilarity \\(w_k\\) as a function of the number of clusters \\(k\\). the corresponding values generally decrease with increasing \\(k\\). thus cross-validation techniques, so useful for model selection in supervised learning, cannot be utilized in this context. as we increase the number of clusters, the solution quality will improve because more natural groups will be captured separately. so, if we keep adding more clusters beyond the true number (\\(k > k^*\\)), some estimated clusters will start to split the real groups. however, splitting a group that's already close together won't improve the solution as much as properly separating two distinct groups. to the extent this scenario is realized, there will be a sharp decrease in successive differences in criterion value, \\(w_k − w_{k+1}\\), at \\(k = k^*\\). that is, \\(\\{w_k − w_{k+1} |k < k^*\\} \\geq \\{w_k − w_{k+1} |k \\geq k^*\\}\\). an estimate \\(\\hat{k}*\\) for \\(k^*\\) is then obtained by identifying a “kink” in the plot of \\(w_k\\) as a function of \\(k\\). the recently proposed gap statistic compares the shape of a curve based on our data to a curve we'd get if the data were spread out evenly. we're looking for a point where there's a big gap between these two curves. this point tells us the best number of clusters for our data. if \\(g(k)\\) is the gap curve at \\(k\\) clusters, the formal rule for estimating \\(k^*\\) is: \\begin{align} k^* = \\text{argmin}_{k} \\{k | g(k) \\geq g(k + 1 - s'_{k + 1}) \\} \\end{align} where \\(s_k\\) is the standard deviation. the following figure shows and example on how to choose the optimal number of clusters: hierarchical clustering as the name suggests, they produce hierarchical representations in which the clusters at each level of the hierarchy are created by merging clusters at the next lower level. at the lowest level, each cluster contains a single observation. at the highest level there is only one cluster containing all of the data. strategies for hierarchical clustering divide into two basic paradigms: agglomerative (bottom-up) and divisive (top-down). each level of the hierarchy represents a particular grouping of the data into disjoint clusters of observations. the entire hierarchy represents an ordered sequence of such groupings. it is up to the user to decide which level (if any) actually represents a \"natural\" clustering a dendrogram provides a highly interpretable complete description of the hierarchical clustering in a graphical format. cutting the dendrogram horizontally at a particular height partitions the data into disjoint clusters represented by the vertical lines that intersect it. the height at which we cut represents the level of similarity required to form a cluster. generally, groups that merge at higher levels in the dendrogram are considered more significant clusters. however, it's essential to be cautious when interpreting dendrograms because different clustering methods or slight changes in the data can lead to different dendrogram structures. also, dendrogram interpretations are only valid if the data truly exhibits the hierarchical structure imposed by the clustering algorithm. this can be assesed using the cophenetic correlation coefficient, it measures the correlation between the cophenetic dissimilarities \\(c_{ii'}\\) and the distances between observations in the original data \\(d_{ii'}\\). the cophenetic dissimilarity \\(c_{ii'}\\) between two observations \\((i, i')\\) is the intergroup dissimilarity at which observations \\(i\\) and \\(i'\\) are first joined together in the same cluster. agglomerative clustering agglomerative clustering starts with each observation as its own cluster. then, at each step, it merges the two closest clusters together until there's only one big cluster left. to measure dissimilarity between two clusters, let's call them \\(g\\) and \\(h\\). we look at all the pairs of observations, one from \\(g\\) and one from \\(h\\), and find the dissimilarity between them. single linkage (sl) or nearest neighbour agglomerative clustering chooses the closest pair of observations between the two clusters as the measure of dissimilarity between the clusters: \\begin{align} d_{sl}(g, h) = \\min_{i \\in g, i' \\in h} d_{ii'} \\end{align} complete linkage (cl) or furthest-neighbor technique agglomerative clustering measures the dissimilarity between two clusters as the distance the pair of observations that are the farthest apart. \\begin{align} d_{cl}(g, h) = \\max_{i \\in g, i' \\in h} d_{ii'} \\end{align} group average (ga) clustering uses the average dissimilarity between the groups: \\begin{align} d_{ga}(g, h) = \\frac{1}{n_g n_h} \\sum_{i \\in g} \\sum_{i \\in h} d_{ii'} \\end{align} where \\(n_g\\) and \\(n_h\\) are the respective number of observations in each group. if the data shows clear clusters that are close together and distinct from each other, all three methods—single linkage, complete linkage, and average linkage—will give similar results. however, if the data doesn't exhibit this pattern, the results of the three methods will differ. single linkage tends to join clusters even if just one pair of observations is close together, which can lead to long chains of connections between clusters. this phenomenon is known as chaining. complete linkage will tend to produce compact clusters with small diameters because it considers two groups close only if all the observations in their combined set are similar. sometimes it may violate the rule that observations within a cluster should be closer to each other than to observations in other clusters. group average clustering strikes a balance between single and complete linkage. it tries to make clusters compact while keeping them relatively far apart. however, its outcome can be affected by how the dissimilarities between observations are measured. changing the measurement scale can change the clustering result. in contrast, single and complete linkage methods are not affected by such changes in scale. divisive clustering divisive clustering starts with the entire dataset as one cluster and then splits it into smaller clusters step by step. this method isn't as widely studied as agglomerative clustering, but it has been explored, especially in engineering contexts like compression. one potential advantage of divisive clustering is when you want to divide the data into only a few clusters. divisive methods can be used recursively with techniques like k-means or k-medoids to split clusters into smaller ones. however the way you begin the splitting process at each step can influence the final outcome. a method has been developed to overcome this limitations. the divisive algorithm, proposed by macnaughton smith et al. (1965), is defined as: puts all observations in one big cluster called \\(g\\). it picks the observation that's farthest on average from all the others and makes it the first member of a new cluster called \\(h\\). at each successive step that observation in \\(g\\) whose average distance from those in \\(h\\), minus that for the remaining observations in \\(g\\) is largest, is transferred to \\(h\\). this continues until there are no more observations in \\(g\\) that are closer to those in \\(h\\). this splitting procedure is repeated for each new cluster formed at the previous level, creating a hierarchical structure. kaufman and rousseeuw (1990) suggest choosing the cluster with the largest diameter for splitting at each level, but another option is to pick the one with the largest average dissimilarity among its members. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/AAII/index.html",
    "title": "Aprendizaje Automático II",
    "body": " index search search back aprendizaje automático ii tema 1. random forests bias/variance tradeoff bootstrapping bagging random forests tema 2. intensificación (boosting) boosting ada boost boosting trees gradient boosting interpretability examples practice tema 3. otras combinaciones de modelos introducción marco general para la combinación de clasificadores estrategias para la combinación de clasificadores conclusión tema 4. aprendizaje no supervisado introducción cluster analysis evaluation metrics $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/AAII/T1/01_bias_variance_tradeoff.html",
    "title": "Bias/Variance Tradeoff",
    "body": " index search search back bias/variance tradeoff test error, also referred to as generalization error, is the prediction error over an independent test sample: \\begin{align} err_{\\mathcal{t}} = \\mathbb{e}[l(y | \\hat{f}(x)) | \\mathcal{t}] \\end{align} where \\(l\\) is the loss function. a related quantity is the expected prediction error (or expected test error): \\begin{align} err = \\mathbb{e}[err_{\\mathcal{t}}] \\end{align} where \\(err_{\\mathcal{t}}\\) is the test error. the error can always be decomposed into the sum of three fundamental quantities: the variance of \\(\\hat{f}(x_0)\\) the squared bias of \\(\\hat{f}(x_0)\\) the variance of the error terms \\(\\epsilon\\). that is, \\begin{align} \\mathbb{e}[\\left(y_0 - \\hat{f}(x_0)\\right)^2] = \\mathbb{v}[\\hat{f}(x_0)] + [bias(\\hat{f}(x_0))]^2 + \\mathbb{v}[\\epsilon] \\end{align} this amount is derived from: \\begin{align} err(x_0) = \\mathbb{e}[(y - \\hat{f}(x_0))^2] = \\mathbb{e}[y^2 + \\hat{f}(x_0)^2 - 2y\\hat{f}(x_0)] \\end{align} \\begin{align} = \\mathbb{e}[y^2] + \\mathbb{e}[\\hat{f}(x_0)^2] -2\\mathbb{e}[y]\\mathbb{e}[\\hat{f}(x_0)] \\end{align} we know that \\(\\mathbb{v}[x] = \\mathbb{e}[(x - \\mathbb{e}[x])^2] = \\mathbb{e}[x^2] - \\mathbb{e}[x]^2\\), such that: \\begin{align} = \\mathbb{v}[y] + \\mathbb{e}[y]^2 + \\mathbb{v}[\\hat{f}(x_0)] + \\mathbb{e}[\\hat{f}(x_0)]^2 -2\\mathbb{e}[y]\\mathbb{e}[\\hat{f}(x_0)] \\end{align} \\begin{align} = \\mathbb{e}[(y - \\mathbb{e}[y])^2] + \\mathbb{e}[y]^2 + \\mathbb{e}[(\\hat{f}(x_0) - \\mathbb{e}[\\hat{f}(x_0)])^2] + \\mathbb{e}[\\hat{f}(x_0)]^2 -2\\mathbb{e}[y]\\mathbb{e}[\\hat{f}(x_0)] \\end{align} note that, \\(y = f(x_0) + \\epsilon[/\\)], donde [\\(]\\mathbb{e}[\\epsilon] = 0\\), thus it follows: \\begin{align} = \\mathbb{e}[(y - \\mathbb{e}[y])^2] + (\\mathbb{e}[f(x_0)] + \\mathbb{e}[\\epsilon])^2 + \\mathbb{e}[(\\hat{f}(x_0) - \\mathbb{e}[\\hat{f}(x_0)])^2] + \\mathbb{e}[\\hat{f}(x_0)]^2 -2(\\mathbb{e}[f(x_0)] + \\mathbb{e}[\\epsilon])\\mathbb{e}[\\hat{f}(x_0)] \\end{align} \\begin{align} = \\mathbb{e}[(y - \\mathbb{e}[y])^2] + \\mathbb{e}[f(x_0)]^2 + \\mathbb{e}[(\\hat{f}(x_0) - \\mathbb{e}[\\hat{f}(x_0)])^2] + \\mathbb{e}[\\hat{f}(x_0)]^2 -2\\mathbb{e}[f(x_0)]\\mathbb{e}[\\hat{f}(x_0)] \\end{align} we know that \\((a + b)^2 = a^2 + b^2 + 2ab\\) and that \\(\\mathbb{e}[f(x_0)] = f(x_0)\\), such that: \\begin{align} = \\mathbb{e}[(y - \\mathbb{e}[y])^2] + \\mathbb{e}[(\\hat{f}(x_0) - \\mathbb{e}[\\hat{f}(x_0)])^2] + f(x_0)^2 + \\mathbb{e}[\\hat{f}(x_0)]^2 -2f(x_0)\\mathbb{e}[\\hat{f}(x_0)] \\end{align} \\begin{align} = \\mathbb{e}[(y - \\mathbb{e}[y])^2] + \\mathbb{e}[(\\hat{f}(x_0) - \\mathbb{e}[\\hat{f}(x_0)])^2] + \\left(\\mathbb{e}[\\hat{f}(x_0)] - f(x_0)\\right)^2 \\end{align} here the notation \\(\\mathbb{e}[\\left(y_0 - \\hat{f}(x_0)\\right)^2]\\) defines the expected test mse, and refers expected to the average test mse that we would obtain if we repeatedly \\(f\\) using a large number of training sets, and tested each at \\(x_0\\). the overall expected test mse can be computed by averaging \\(\\mathbb{e}[\\left(y_0 - \\hat{f}(x_0)\\right)^2]\\) over all possible values of \\(x_0\\) in the test set. the previous equation tells us that in order to minimize the expected test error, we need to select a statistical learning method that simultaneously achieves low variance and low bias. note that variance is inherently a nonnegative quantity, and squared bias is also nonnegative. hence, we see that the expected test mse can never lie below \\(\\mathbb{v}[\\epsilon]\\), the irreducible error. the variance of the error terms, \\(\\mathbb{v}[\\epsilon]\\), is the variance of the target around its true mean \\(f(x_0)\\), and cannot be avoided no matter how well we estimate \\(f(x_0)\\), unless \\(\\sigma^2 = 0\\). variance refers to the amount by which \\(\\hat{f}\\) would change if we estimated it using a different training data set. ideally the estimate for \\(f\\) should not vary too much between training sets. this is computed as the expected squared deviation of \\(\\hat{f}(x_0)\\) around its mean. bias refers to the error that is introduced by approximating a real-life problem by a simpler model. this quentifies the amount by which the average of our estimate differs from the true mean. as a general rule, as we use more flexible methods, the variance will increase and the bias will decrease. as we increase the flexibility, the bias tends to initially decrease faster than the variance increases. consequently, the expected test mse declines. at some point increasing flexibility has little impact on the bias but starts to significantly increase the variance. in a real-life situation in which \\(f\\) is unobserved, it is generally not possible to explicitly compute the test mse, bias, or variance for a statistical learning method. training error consistently decreases with model complexity, typically dropping to zero if we increase the model complexity enough. a model with zero training error is overfit to the training dat and will typically generalize poorly. it is important to note that there are in fact two separate goals: model selection: estimating the performance of different models in order to choose the best model. model assessment: having chosen a final model, estimating its prediction error (generalization error) on new data. the training set is used to fit the models. the validation set is used to estimate prediction error for model selection. the test set is used for assessment of the generalization error $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/AAII/T1/04_random_forests.html",
    "title": "Random Forests",
    "body": " index search search back random forests contents definition details of random forests variable importance proximity plots random forests and overfitting definition the idea in random forests (ilustrated on the image below) is to improve the variance reduction of bagging by reducing the correlation between the trees, without increasing the variance too much. this is achieved in the tree-growing process through random selection of the input variables. an average of \\(b\\) i.i.d. random variables, each with variance \\(\\sigma^2\\), has variance \\(\\frac{1}{b}\\sigma^2\\). if the variables are simply i.d. (identically distributed, but not necessarily independent) with positive pairwise correlation ρ, the variance of the average is: \\begin{align} \\rho\\sigma^2 + \\frac{1 - \\rho}{b}\\sigma^2 \\end{align} as \\(b\\) increases, the second term disappears, but the first remains, and hence the size of the correlation of pairs of bagged trees limits the benefits of averaging. when growing a tree on a bootstrapped dataset before each split, select \\(m \\leq p\\) of the input variables at random as candidates for splitting. after \\(b\\) such trees \\(\\{t(x; \\theta_b)\\}_1^b\\) are grown, the random forest (regression) predictor is: \\begin{align} \\hat{f}_{rf}^b(x) = \\frac{1}{b}\\sum_{b=1}^b t(x; \\theta_b) \\end{align} where \\(\\theta_b\\) characterizes the bth random forest tree in terms of split variables, cutpoints at each node, and terminal-node values. intuitively, reducing \\(m\\) will reduce the correlation between any pair of trees in the ensemble. details of random forests for classification, the default value for \\(m\\) is \\(\\lfloor \\sqrt{p} \\rfloor\\) and the minimum node size is one. for regression, the default value for \\(m\\) is \\(\\lfloor \\frac{p}{3} \\rfloor\\) and the minimum node size is five. in practice the best values for these parameters will depend on the problem, and they should be treated as tuning parameters (hyperparamters). variable importance at each split in each tree, the improvement in the split-criterion is the importance measure attributed to the splitting variable, and is accumulated over all the trees in the forest separately for each variable. random forests also use the oob samples to construct a different variable importance measure. when the bth tree is grown, the oob samples are passed down the tree, and the prediction accuracy is recorded. then the values for the jth variable are randomly permuted in the oob samples, and the accuracy is again computed. the decrease in accuracy as a result of this permuting is averaged over all trees, and is used as a measure of the importance of variable \\(j\\) in the random forest. proximity plots in growing a random forest, an \\(n \\times n\\) proximity matrix is accumulated for the training data. such that the entry \\(ij\\) contains the number of trees for which the oob sample \\(x_i\\) and the oob sample \\(x_j\\) are on the same terminal node. this proximity matrix is then represented in two dimensions using multidimensional scaling like the following example: the proximity plot gives an indication of which observations are effectively close together in the eyes of the random forest classifier. random forests and overfitting when the number of variables \\(p\\) is large, but the fraction of relevant variables small, random forests are likely to perform poorly with small \\(m\\). at each split the chance can be small that the relevant variables will be selected. another claim is that random forests “cannot overfit” the data. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/AAII/T1/03_bagging.html",
    "title": "Bagging",
    "body": " index search search back bagging contents introduction bagging on regression trees bagging on decision trees out-of-bag error estimation variable importance measures advantages of ensemble models how to generate diversity ensemble algorithms bagging boosting staking model of experts introduction the decision trees discussed suffer from high variance. in contrast, a procedure with low variance will yield similar results if applied repeatedly to distinct data sets. bootstrap aggregation, or bagging, is a procedure for reducing the variance of a statistical learning method. recall that given a set of \\(n\\) independent observations \\(z_1, \\cdots, z_n\\) each with variance \\(\\sigma^2\\), the variance of the mean \\(\\overline{z}\\) of the observations is given by \\(\\frac{\\sigma^2}{n}\\). so, averaging a set of observations reduces variance. thus, to reduce the variance and increase the prediction accuracy of a statistical learning method is to take many training sets from the population, build a separate prediction model using each training set, and average the resulting predictions. using \\(b\\) separate training sets, and average them in order to obtain a single low-variance statistical learning model, given by: \\begin{align} \\hat{f}_{avg}(x) = \\frac{1}{b}\\sum_{b=1}^b \\hat{f}^b(x) \\end{align} for each bootstrap sample \\(z^{*b}, b = 1, 2, \\cdots, b\\), we fit our model, giving prediction \\(\\hat{f}^{*b}(x)\\). the bagging estimate is defined by: \\begin{align} \\hat{f}_{bag}(x) = \\frac{1}{b}\\sum_{b=1}^b \\hat{f}^{*b}(x) \\end{align} bagging on regression trees to apply bagging to regression trees, we simply construct \\(b\\) regression trees using \\(b\\) bootstrapped training sets, and average the resulting predictions. these trees are grown deep, and are not pruned. hence each individual tree has high variance, but low bias. averaging these b trees reduces the variance. bagging on decision trees how can bagging be extended to a classification problem where y is qualitative? for a given test observation, we can record the class predicted by each of the \\(b\\) trees, and take a majority vote. suppose our tree produces a classifier \\(\\hat{g}(x)\\) for a \\(k\\)-class response. then the bagged estimate \\(\\hat{f}_{bag}(x)\\) is a \\(k\\)-vector \\([p_1(x), p_2(x), \\cdots, p_k(x)]\\), with \\(p_k(x)\\) equal to the proportion of trees predicting class \\(k\\) at \\(x\\). the bagged classifier selects the class with the most votes from the \\(b\\) trees, \\(\\hat{g}_{bag}(x) = \\arg \\max_k \\hat{f}_{bag}(x)\\). often we require the class-probability estimates at \\(x\\). for many classifiers \\(\\hat{g}(x)\\) there is already an underlying function \\(\\hat{f}(x)\\) that estimates the class probabilities at \\(x\\) (for trees, the class proportions in the terminal node). an alternative bagging strategy is to average these instead. the number of trees \\(b\\) is not a critical parameter with bagging; using a very large value of \\(b\\) will not lead to overfitting. in practice we use a value of \\(b\\) sufficiently large that the error has settled down. note that bagging a good classifier can make it better, but bagging a bad classifier can make it worse. out-of-bag error estimation there is a very straightforward way to estimate the test error of a bagged model one can show that on average, each bagged tree makes use of around two-thirds of the observations. the observations not used to fit a given bagged tree are referred to as the out-of-bag (oob) observations. an oob prediction can be obtained for each of the \\(n\\) observations on the oob observation set, from which the overall oob mse (for a regression problem) or classification error (for a classification problem) can be computed. the resulting oob error is a valid estimate of the test error for the bagged model. variable importance measures although the collection of bagged trees is much more difficult to interpret than a single tree, one can obtain an overall summary of the importance of each predictor using the rss (for bagging regression trees) or the gini index (for bagging classification trees) in the case of bagging regression trees, we can record the total amount that the rss is decreased due to splits over a given predictor, averaged over all \\(b\\) trees. for classification trees, we can add up the total amount that the gini index is decreased by splits over a given predictor, averaged over all \\(b\\) trees. advantages of ensemble models performance: it improves single models' perfomance. robustness: reduces predictions' variance. so it also improves the equilibrium between bias and variance. how to generate diversity manipulating instances: selecting a different subset of instances for each model. manipulating features: selecting a different subset of features for each model. manipulating models' definition: selecting different hyperparameters, optimization algorithm for ach model. hybridation: mix any of the previous practices. ensemble algorithms bagging models are trained concurrently with different data sets generated using bootstrapping. boosting construye múltiples modelos (típicamente modelos del mismo tipo) secuenciales, cada uno de los cuales aprende a corregir los errores de predicción de un modelo anterior en la cadena. el objetivo es desarrollar un modelo fuerte a partir de muchos modelos débiles especialmente diseñados que se combinan mediante votación simple o promediando. staking construye múltiples modelos sobre el mismo conjunto de datos, típicamente modelos de diferentes tipos (modelos de nivel 0); y un modelo supervisado o meta modelo (modelo de nivel 1) que aprende cómo combinar mejor las predicciones de los modelos primarios. model of experts podemos dividir el espacio de características de entrada en subespacios según algún conocimiento de dominio del problema. luego se puede entrenar un modelo en cada subespacio del problema, convirtiéndose de hecho en un experto en el subproblema específico. luego, un modelo aprende a qué experto recurrir para predecir nuevos ejemplos en el futuro. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/AAII/T1/02_bootstrapping.html",
    "title": "Bootstrapping",
    "body": " index search search back bootstrapping bootstrapping is a resampling technique used in statistics to estimate the sampling distribution of a statistic by sampling with replacement from the original dataset. the method is particularly useful when analytical methods for deriving the sampling distribution are complex or unavailable. here's a breakdown of the bootstrapping process: sampling with replacement: from the original dataset, randomly draw \\(n\\) samples with replacement. this means that each observation has an equal chance of being selected for the sample, and an observation may be selected multiple times. sample statistics: calculate the statistic of interest (e.g., mean, median, standard deviation, regression coefficient) on each bootstrapped sample. repeat: repeat steps \\(2\\) and \\(3\\) a large number of times to generate multiple bootstrap samples and their corresponding statistics. estimate sampling distribution: with the collection of bootstrap statistics, you can estimate the sampling distribution of the statistic of interest. this empirical distribution approximates the true sampling distribution of the statistic, providing information about its variability and uncertainty. inference: use the estimated sampling distribution to make inferences about the population parameter or to construct confidence intervals. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/AAII/T2/04_gradient_boosting.html",
    "title": "Gradient Boosting",
    "body": " index search search back gradient boosting contents numerical optimization via gradient steepest descent gradient boosting implementations of gradient boosting step length characteristics numerical optimization via gradient imagine you have a machine learning model that makes predictions, but it's not perfect. gradient boosting is like a smart way to teach this model to make better predictions over time. instead of trying to fix all the prediction errors at once, gradient boosting focuses on correcting one error at a time. it does this by looking at the direction where the error is the steepest and making adjustments to improve the prediction in that direction. by repeating this process step by step, the model gradually gets better at making predictions, leading to more accurate results. so if you have the following function you want to optimize: \\begin{align} l(f) = \\sum_{i=1}^n l(y_i, f(x_i)) \\end{align} where \\(f \\in \\mathbb{r}^n\\) is the prediction function and its evaluation at each instance \\(x_i\\) are the parameteres we want to optimize: \\begin{align} f = \\{f(x_1), \\cdots, f(x_i), \\cdots, f(x_n)\\} \\end{align} therefore the optimization problem with respect to \\(f\\) can be summarized as follows: \\begin{align} \\hat{f} = \\arg \\min_f l(f) \\end{align} solving this entire problem at once may be challenging. to make it easier, numerical optimization procedures break down this big problem into smaller pieces, represented by component vectors. each component vector addresses a specific aspect of the problem. so: \\begin{align} f_{m} = \\sum_{m = 0}^m h_m, h_m \\in \\mathbb{r}^n \\end{align} where \\(f_m\\) represents the final model or prediction function obtained after m iterations or steps of the boosting algorithm. here \\(f_m\\) represents the model at iteration \\(m\\), whereas \\(h_m\\) represents the increment to the model at iteration \\(m\\) it is the component vector added to the current model to move towards the optimized solution. each \\(h_m\\) is induced based on the current parameter vector \\(f_{m-1}\\) and contributes to the overall model improvement. here is a simple layout of how the algorithm optimizes: at the beginning of the gradient boosting process, the initial model \\(f_0\\) is set to an initial guess. as the algorithm progresses through iterations (\\(m = 1, 2, \\cdots, m\\)), each step involves updating the model based on the gradient information to reduce errors in predictions. numerical optimization methods differ in their prescriptions for computing each increment vector \\(h_m\\). steepest descent steepest descent is a method used in optimization to find the minimum value of a function. this method chooses \\(h_m = \\rho_m g_m\\) where \\(\\rho_m\\) is a scalar and \\(g_m\\) is the gradient of \\(l(f_{m-1})\\), that is, the cost function evaluated at values predicted by the \"previous model\". the components of the gradient \\(g_m\\) are defined as follows: \\begin{align} g_{im} = \\left[\\frac{\\delta l(y_i, f(x_i))}{\\delta f(x_i)}\\right]_{f_m(x_i) = f_{m-1}(x_i)} \\end{align} the step length (kinda like the learning rate): \\begin{align} \\rho_m = \\arg \\min_{\\rho} l(f_{m-1} - \\rho g_m) \\end{align} thus, at each step, the predictor is updated as follows: \\begin{align} f_m = f_{m - 1} - \\rho_m g_m \\in \\mathbb{r}^n \\end{align} this updates \\(f_m\\) towards the direction of maximum descent at \\(l(f_{m-1})\\), which is why this is often interpreted as a greedy algorithm. gradient boosting gradient boosting aims to create a strong predictive model by combining multiple weak models. it starts with a simple model and gradually enhances it to minimize errors. at each iteration, a new tree model is fit to the negative gradient of the loss function. the predictions from these trees guide the model towards better predictions. using squared error to measure closeness, this leads us to: \\begin{align} \\tilde{\\theta}_m = \\arg \\min_{\\theta} \\sum_{i=1}^n (-g_{im} - t(x_i; \\theta))^2 \\end{align} this measures how close each prediction \\(t(x_i; \\theta)\\) is to the gradient \\(-g_{im}\\). the negative gradient of the loss function represents the direction in which the model's predictions need to be adjusted to reduce errors. by fitting a new tree to this negative gradient, the model learns how to correct its predictions to move closer to the actual target values. that is at each iteration, the new tree model focuses on capturing the errors or residuals of the current ensemble model. while the exact regions where the new tree makes corrections may not match perfectly with the original model's regions, they are close enough to serve the same purpose of improving the model's accuracy. here the original model is the ensemble model. the following figure summarizes the gradients for commonly used loss functions: implementations of gradient boosting algorithm \\(10.3\\) presents the generic gradient tree-boosting algorithm for regression. specific algorithms are obtained by inserting different loss criteria \\(l(y,f(x))\\). start with an initial model \\(f_0(x)\\) that minimizes the loss function \\(l(y, f(x))\\). for each boosting round \\(m = 1, \\cdots, m\\): calculate the negative gradient for each data point \\begin{align} r_{im} = -\\left[\\frac{\\delta l(y_i, f(x_i))}{\\delta f(x_i)}\\right]_{f(x_i) = f_{m-1}(x_i)} \\end{align} fit a regression tree to the gradients \\(r_{im}\\), which gives us the regions \\(r_{jm}, j = 1, 2, \\cdots, j_m\\) the step length \\(\\gamma\\) is determined by minimizing the loss using the previous model (\\(f_{m-1}\\)): \\begin{align} \\gamma_{jm} = \\arg \\min_{\\gamma} \\sum_{x_i \\in r_{jm}} l(y_i, f_{m-1}(x_i) + \\gamma) \\end{align} update the model by adding a new tree to the ensemble \\(f_m(x) = f_{m-1}(x) + \\gamma t(x; \\theta_m)\\), where \\(t(x; \\theta)\\) is the new tree model with parameters \\(\\theta_m\\) that corrects the errors in the previous model. the output of the ensemble model is defined as \\(\\hat{f}(x) = f_m(x)\\), that is as the sum of the weaker models. step length the step length \\(\\gamma\\) is crucial in determining how much each new tree should contribute to the ensemble model. it controls the impact of the new tree on the overall model's predictions. the line search aims to find the value of γ that minimizes the loss function: \\begin{align} l(f_{m-1} - \\gamma g_m) \\end{align} this means finding the optimal step length that results in the smallest possible loss when updating the model with the new tree. by minimizing the loss function with respect to \\(\\gamma\\), the algorithm is essentially performing a form of gradient descent. characteristics two basic tuning parameters are the number of iterations \\(m\\) and the sizes of each of the constituent trees \\(j_m, m = 1, 2, \\cdots, m\\). the original implementation of this algorithm was called mart for \"multiple additive regression trees\". $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/AAII/T2/07_practice.html",
    "title": "Practice",
    "body": " index search search back practice contents boosting parameters building energy efficiency default gbm building energy efficiency tuned gbm mnist default gbm mnist tuned gbm boosting just like random forest, gbm is an ensemble method. imagine a data set just \\(10\\) examples and two numeric predictor variables, and we are trying to learn to distinguish between two possible classes: circle or cross. the very simplest decision tree we can make has just one node; i will represent it with a straight line in the following diagrams. it scored \\(60\\%\\): six right, four wrong. what we do now is train another very simple tree, but first we modify the training data to give the four rows it got wrong a higher weight. how much of a higher weight? that is where the \"gradient\" bit of gbm comes in. in the next figure the circles and crosses for the wrong items are bigger, and our next tree pays more attention to them. it got a different three items wrong so it still scores \\(60\\%\\). so, for our third tree, we tell it those four are more important; the one it has got wrong twice in a row is the biggest of all. if we stop training here, we end up with three weak models that scored \\(60\\%\\), \\(60\\%\\), and \\(80\\%\\), respectively. however, at least one of each of those three trees got every training row correct. you can see how they can work together to cover each other's weaknesses. gbm naturally focuses attention on the difficult rows in your training data, the ones that are hard to learn. that is good, but it can also be bad. if there is one outlier that each tree keeps getting wrong it is going to get boosted and boosted until it is bigger than the whole universe. this is bad when the data is a mistake instead of an outlier, as it distorts the model's accuracy. the mysterious? well, unlike (simple) decision trees, which can be really good at explaining their thinking, it becomes a bit of a black box. parameters n_trees: how many trees to make. max_depth: how deep are the trees allowed to be. learn_rate: controls the speed at which the model learns learn_rate_annealing: allows you to have the learn_rate start high, then gradually get lower as trees are added. min_rows: how many examples are needed to make a leaf node. low number might lead to overfitting. min_split_improvement: controls how much error improvement must be to perform a split. histogram_type: what type of histogram to use for finding optimal split points. nbins: for numerical columns, build a histogram of (at least) this many bins, then split at the best point. nbins_cat: for categorical columns, build a histogram of (at most) this many bins, then split at the best point. build_tree_one_node: run on one node only. building energy efficiency: default gbm this data set deals with the heating/cooling costs of various house designs. from h2o.estimators.gbm import h2ogradientboostingestimator m = h2ogradientboostingestimator(model_id=\"gbm_defaults\", nfolds=10) m.train(x, y, train) fifty trees were made, each of depth \\(5\\). on cross-validation data, the mse (mean squared error) is \\(2.462\\), and \\(r^2\\) is \\(0.962\\). under “variable importances” (shown next), which can be seen with h2o.varimp(m) you will see it is giving x5 way more importance than any of the others; this is typical for gbm models. how about on the unseen data? m.model_performance(test) is saying mse is \\(2.318\\), better than on the training data. building energy efficiency: tuned gbm i decided to start, this time, with a big random grid search. the hyperparameters tuned are the following: max_depth: the default is \\(5\\), and we tried \\(5,10,15,20,25,30,40,50,60,75,90\\). the ninth best model was max_depth=75, so high values may not be bad, as such, but they don’t appear to help. min_rows sample_rate col_sample_rate nbins what about ntrees? instead of trying to tune it, we set it high (\\(1000\\)) and used early stopping. more model results just confirmed the first impression: min_rows of \\(1\\) (or \\(2\\)) is effective with max_depth of \\(5\\), but really poor with higher values. min_rows of \\(10\\) is effective with any value of max_depth, but possibly \\(10\\) to \\(20\\) is best. curiously min_rows of \\(5\\) is mediocre. a sample_rate of \\(0.9\\) or \\(0.95\\) looks best, while there is still no clarity for col_sample_rate or nbins. let's see how it does on the test data, we obtain a mse of \\(1.640\\). this is way better than the default gbm’s 2.462, and also way better than the best tuned random forest model from the previous chapter. mnist: default gbm it is a multinomial classification, trying to look at the \\(784\\) pixels of a handwritten digit, and say which of \\(0\\) to \\(9\\) it is. m = h2o.estimators.h2ogradientboostingestimator(model_id=\"gbm_defaults\") m.train(x, y, train, validation_frame=valid) the confusion matrix on the training data (h2o.confusionmatrix(m)) shows an error rate of \\(2.08\\%\\), while on the validation data it is a bit higher at \\(4.82\\%\\). mse is \\(0.028\\) and \\(0.044\\), respectively. so we have a bit of overfitting on the training data, but not too much. on the test data the error this time is \\(4.44\\%\\) (mse is \\(0.048\\)); in other words, the validation and test sets are giving us similar numbers, which is good. mnist: tuned gbm as usual, the first thing i want to do is switch to using early stopping, so i can then give it lots of trees to work with, with the following parameters: stopping_tolerance = 0.001, stopping_rounds = 3, score_tree_interval = 10, ntrees = 400 just using this, with all other default settings, had some interesting properties training classification score was perfect after 140 trees. validation score was down to \\(2.83\\%\\). the mse and logloss of both the training data and validation data continued to fall, and so did the validation classification score. relative runtime kept increasing. that is, each new tree is taking longer. it finished up with 360 trees, with a very respectable \\(2.17\\%\\) error on the validation data. how can we improve that further? we know there is a lot of examples and variables, so we expect that lower sample ratios will be more effective. in terms of the learn_rate we know low is slower, but better… and we have a lot of data. so we use a high (quick) learn_rate for the first grid or two, then lower it later on, once we start to home in on the best parameters. this is going to be a random grid search, because we are going to use a lot of parameters. the first discovery was that a high max_depth was very slow and no better than a shallow one. also min_rows=1 seemed poor. we also found that max_depth=20 was distinctly worse than max_depth=5. we also noticed that min_rows=10 seemed to be doing best, though it was less clear. reducing the three sample rates to \\(1\\) did seem to help, though there was not enough data to draw a confident conclusion. so, another try. we'll leave max_depth and min_rows at their defaults, and just concentrate on testing sampling rates. there was not that much clarity in the parameters, but the best two had col_sample_rate of \\(0.8\\) and sample_rate of \\(0.95\\), whereas sample_rate=0.5 was only chosen once, but was the worst of the nine. the default model with just early stopping added, would have come second best in the grid measured on classification error, but fourth on mse, and seventh on logloss, whereas the “tuned” model is top on all metrics, so we have more confidence in selecting it. as a final step, we ran the chosen model on the test data and got an error rate of \\(2.33\\%\\). this compares to \\(4.44\\%\\) with the default settings. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/AAII/T2/06_examples.html",
    "title": "Examples",
    "body": " index search search back examples contents california housing california housing the dataset consists of information from \\(20,460\\) neighborhoods in california. the target variable (\\(y\\)) is the median house value in each neighborhood. predictor variables include demographic factors like median income (medinc), housing density (house), average occupancy (aveoccup), location coordinates (longitude and latitude), and house attributes like average number of rooms (averooms) and bedrooms (avebedrms). there are thus a total of eight predictors, all numeric. we fit a gradient boosting model using the mart procedure, with \\(j = 6\\) terminal nodes. the test error is seen to decrease monotonically with increasing \\(m\\), more rapidly during the early stages and then leveling off to being nearly constant as iterations increase. thus, the choice of a particular value of \\(m\\) is not critical, as long as it is not too small. the next figure displays the relative variable importances for each of the eight predictor variables. not surprisingly, median income in the neighborhood is the most relevant predictor. longitude, latitude, and average occupancy all have roughly half the relevance of income, whereas the others are somewhat less influential on the following graphs we show single-variable partial dependence plots on the most relevant nonlocation predictors. note that the plots are not strictly smooth as a consequence of using tree-based models. the hash marks at the base of each plot delineate the deciles of the data distribution of the corresponding variables. so for example, \\(90%\\) of the data have a medinc value of less than \\(6\\). the partial dependence of median house value on median income is monotonic increasing. house value is generally monotonic decreasing with increasing average occupancy, except perhaps for average occupancy rates less than one. median house value is seen to have a very weak partial dependence on house age that is inconsistent with its importance ranking. this suggests that this weak main effect may be masking stronger interaction effects with other variables. the next graph shows the two-variable partial dependence of the fitted model on joint values of longitude and latitude: there is a very strong dependence of median house value on the neighborhood location in california. it can be viewed as representing an extra premium one pays for location. this premium is seen to be relatively large near the pacific coast especially in the bay area and los angeles–san diego. in the northern, central valley, and southeastern desert regions of california, location costs considerably less. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/AAII/T2/03_boosting_trees.html",
    "title": "Boosting Trees",
    "body": " index search search back boosting trees contents variable space partitioning optimization problem boosting trees optimization problem optimization objective finding optimal consants solution for regression trees solution for classification trees appendix greedy top-down recurisve partitioning algorithm variable space partitioning partitioning the predictor variable space into regions in boosting trees involves recursively splitting the data based on predictor variables to create distinct regions with associated constant values for making predictions. starting point: entire predictor variable space is considered as one large region, \\(r_1\\). decision making: at each step, a decision tree algorithm finds the best split based on a predictor variable \\(x_j\\) and a split point \\(s\\) that minimizes a certain criterion. this split divides region \\(r_j\\) into two subregions \\(r_{left}\\) and \\(r_{right}\\). splitting criteria: it can be represented as \\((j, s) = arg \\min_{j, s} [\\sum_{x_i \\in r_{left}} l(y_i, f(x_i)) + \\sum_{x_i \\in r_{right}} l(y_i, f(x_i)]\\) recursive process: this process is repeated recursively for each resulting subregion until a stopping criterion is met. terminal nodes: the final regions, or terminal nodes, are denoted as \\(r_j\\) and are assigned constant values \\(\\gamma_j\\) representing the prediction for data points falling into that region. constant assigment: each terminal node is associated with a constant value, resulting in a piecewise constant function, such that each tree can be denoted as: \\(t(x; \\theta) = \\sum_{j=1}^j \\gamma_j i(x \\in r_j)\\) where \\(i(\\cdot)\\) is the indication function and \\(\\theta = \\{r_j, \\gamma_j\\}_1^j\\) are the parameters. prediction: when making predictions for new data points, the algorithm determines the region \\(r_j\\) that the data point belongs to based on the predictor variables. the prediction for that data point is then based on the constant value \\(\\gamma_j\\) assigned to the corresponding region. optimization problem so as we have seen the optimization problem is defined, on a simplified manner, as follows: \\begin{align} \\hat{\\theta} = \\arg \\min_{\\theta} \\sum_{j=1}^j \\sum_{x_i \\in r_j} l(y_i, \\gamma_j) \\end{align} this is a combinatorial problem that we usually aproximate using suboptimal solutions. finding \\(\\gamma_j\\) given \\(r_j\\): we usually define \\(\\hat{\\gamma}_j = \\overline{y}_j\\) for regression problems. finding \\(r_j\\): this is the difficult part. we usually resort to a greedy, top-down recursive partitioning algorithm to find \\(r_j\\). boosting trees in boosting trees, terminal-node trees refer to the individual decision trees that make up the ensemble model. each terminal-node tree is denoted as \\(t(x; \\theta_m)\\) where \\(\\theta_m = \\{r_{jm}, \\gamma_{jm}\\}_1^{j_m}\\). the boosted tree model is an additive model, where each tree is added sequentially to improve the overall prediction. the model can be expressed as \\begin{align} f_m(x) = \\sum_{m=1}^m t(x; \\theta_m) \\end{align} where \\(m\\) represents the total number of trees in the ensemble. optimization problem the optimization problem for boosting trees involves finding the optimal regions and constants for each tree in the ensemble model. optimization objective the goal is to minimize the empirical risk: \\begin{align} \\hat{\\theta} = arg \\min_{\\theta} \\sum_{x_i \\in r_j} l(y_i, \\gamma_j) \\end{align} where \\(l(y_i, \\gamma_i)\\) represents the loss incurred for pedicting the target value \\(y_i\\) with constant \\(\\gamma_j\\) in region \\(r_j\\). finding optimal consants given the regions \\(r_{jm}\\) finding the optimal constant in \\(\\gamma_j\\) in each regions involves minimizing the loss function for the data points within that region: \\begin{align} \\hat{\\gamma}_{jm} = arg \\min_{\\gamma_{jm}} \\sum_{x_i \\in r_{jm}} l(y_i, f_{m - 1}(x_i) + \\gamma_{jm}) \\end{align} \\begin{align} \\hat{\\gamma}_{jm} = arg \\min_{\\gamma_{jm}} \\sum_{x \\in r_{jm}} l(y_i, f_{m - 1}(x_i) + t(x_i; \\theta_m)) \\end{align} finding the regions is difficult, and even more difficult than for a single tree. solution for regression trees for regressions trees the solution for boosted trees consists on choosing the regression tree that best predicts the current residuals \\(y_i - f_{m-1}(x_i)\\) and \\(\\hat{\\gamma}_{jm}\\) solution for classification trees for two-class classification and exponential loss, it gives rise to the adaboost method. it can be showin that given \\(r_{jm}\\) the solution is: \\begin{align} \\hat{\\gamma}_{jm} = \\log \\frac{\\sum_{x_i \\in r_{jm}} w_i^{(m)} i(y_i = 1)}{\\sum_{x_i \\in r_{jm}} w_i^{(m)} i(y_i = -1)} \\end{align} appendix greedy top-down recurisve partitioning algorithm a greedy, top-down recursive partitioning algorithm is a method used in decision tree construction to recursively split the predictor variable space into regions in a step-by-step manner. greedy approach: at each step, it makes the best split based on the available data without considering the impact of future splits. top down process: starts at the top with the entire predictor variable space considered as one region. it then recursively divides this space into smaller regions recursive partitioning: at each step the predictor variable space is divided into two or more subregions based on a splitting criterion. this process continues recursively for each resulting subregion until a stopping criterion is met. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/AAII/T2/01_boosting.html",
    "title": "Boosting",
    "body": " index search search back boosting contents regression trees in machine learning, boosting is an ensemble meta-algorithm for primarily reducing bias, variance in supervised learning. a weak learner is defined to be a classifier that is only slightly correlated with the true classification (it can label examples better than random guessing). in contrast, a strong learner is a classifier that is arbitrarily well-correlated with the true classification. before training each weak classifier, the data is sampled based on a distribution. this distribution initially assigns equal weight to each training example. after training, the weak classifier's accuracy on the training data is evaluated. the accuracy of the weak classifier determines its importance in the final model. higher accuracy leads to greater influence. re-weighting: after adding a weak learner, the data weights are adjusted, giving more weight to misclassified examples and reducing the weight of correctly classified ones. re-weighting helps subsequent weak learners to focus more on the examples that previous weak learners struggled with. regression trees boosting regression trees, often referred to as gradient boosting machines: what is the idea behind this procedure? given the current model, we fit a decision tree to the residuals \\(r_i\\) from the model rather than the outcome \\(y\\). each of these trees can be rather small, with just a few terminal nodes, determined by the parameter \\(d\\). by fitting small trees to the residuals, we slowly improve \\(\\hat{f}\\) in areas where it does not perform well. the shrinkage parameter \\(\\lambda\\) slows the process down even further. boosting has three tuning parameters: the number of trees \\(b\\): boosting can overfit if \\(b\\) is too large. the shrinkage parameter \\(\\lambda\\): this controls the rate at which boosting learns. the number \\(d\\) of splits in each tree, which controls the complexity of the ensemble. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/AAII/T2/05_interpretability.html",
    "title": "Interpretability",
    "body": " index search search back interpretability contents importance of predictor variables decision trees additive models partial dependence plots example representation importance of predictor variables we attempt to discuss the relevance of predictor variables in a statistical modeling technique called boosting. decision trees we define the following as a measure of relevance for each predictor variable \\(x_{\\mathcal{l}}\\): \\begin{align} i_{\\mathcal{l}}^2(t) = \\sum_{t = 1}^{j - 1} \\hat{i}^2_t i(v(t) = \\mathcal{l}) \\end{align} this equation calculates the relevance of each predictor variable based on the squared improvements in error risk within the internal nodes of the tree. let's split each part of the equation: the term \\(\\hat{i}^2_t\\) represents the squared improvement in error risk at node \\(t\\) when splitting on the \\(x_{\\mathcal{l}}\\) predictor variable. the variable \\(v(t)\\) indicates which predictor variable is used for the split at node \\(t\\). each improvement is weighted by the indicator function \\(i(v(t) = \\mathcal{l})\\), which checks if the splitting variable at node \\(t\\) is the predictor variable of interest \\(x_{\\mathcal{l}}\\). this weighting ensures that only the improvements related to the predictor variable \\(x_{\\mathcal{l}}\\) are considered in the calculation. we sum these improvements over the \\(j - 1\\) internal nodes on the tree, which are not terminal nodes. additive models this importance measure is easily generalized to additive tree expansions: \\begin{align} i_{\\mathcal{l}}^2 = \\frac{1}{m}\\sum_{m = 1}^{m} i_{\\mathcal{l}}^2(t_m) \\end{align} due to the stabilizing effect of averaging, this measure turns out to be more reliable than the measure computed only over one tree. partial dependence plots partial dependence functions, by isolating the effects of selected variables, provides an interpretable analysis of their impact on the model's predictions, overcoming the challenges of information overload in high-dimensional spaces. let's define the partial dependency of \\(f(x)\\) on \\(x_s\\), \\begin{align} f_s(x_s) = \\mathbb{e}_{x_c}[f(x_s, x_c)] \\end{align} where: \\(x_s\\) is the subset of variables we want to study. \\(x_c\\) is the complement set, that is the rest of variables. \\(e_{x_c}\\) denotes the expectation operator with respect to the variables in the complement set \\(x_c\\). it averages the model's output over the variables in the complement set. \\(f\\) represents the model. \\(f_s(x_s)\\) represents the relationship between the subset of variables \\(x_s\\) and the model's output. the average can be estimated as follows: \\begin{align} \\overline{f}_s(x_s) = \\frac{1}{n} \\sum_{i=1}^n f(x_s, x_{i\\mathcal{c}}) \\end{align} we simply iterate over every data point on the training set, such that \\(x_{i\\mathcal{c}}\\) refers to the values of the variables in the complement set \\(x_c\\) for the \\(i\\)th data point. previously we measured the effects of \\(x_s\\) after accounting for the effects of the other variables \\(x_c\\) on \\(f(x)\\), they were not the effect of \\(x_s\\) on \\(f(x)\\) ignoring the effects of \\(x_c\\), that is given by: \\begin{align} \\tilde{f}_s(x_s) = \\mathbb{e}(f(x_s, x_c)|x_s) \\end{align} thus \\(\\tilde{f}_s(x_s) = \\overline{f}_s(x_s)\\) only if \\(x_s\\) and \\(x_c\\) are independent. example if we assume a purely additive effect, where the overall prediction is the sum of two components: \\begin{align} f(x) = h_1(x_s) + h_2(x_c) \\end{align} this implies that the effect of \\(x_s\\) on the prediction is independent of the other variables in \\(x_c\\). however if the prediction is defined as: \\begin{align} f(x) = h_1(x_s) \\cdot h_2(x_c) \\end{align} then this implies that the effect of \\(x_s\\) on the prediction is dependent on the values of the variables in \\(x_c\\). representation owing to the limitations of computer graphics, and human perception, the size of the subsets \\(x_s\\) must be small (\\(l \\approx 1, 2, 3\\)). $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/AAII/T2/02_ada_boost.html",
    "title": "Ada Boost",
    "body": " index search search back ada boost contents definition characteristics toy example round 1 round 2 round 3 final round definition adaboost, also known as adaptive boosting, is a machine learning algorithm that combines multiple weak classifiers to create a strong classifier. let's break down the adaboost algorithm using the pseudocode shown in: initialization: adaboost starts by initializing the weights of all training examples equally \\(d_1(i) = \\frac{1}{n}\\) for \\(i = 1, 2, \\cdots, n\\). iterative process for \\(t = 1, \\cdots, t\\): adaboost iterates through rounds, where each round involves training a weak classifier \\(h_t: \\mathcal{x} \\rightarrow \\{-1, +1\\}\\) on the data \\(d_t\\). the algorithm adjusts the weights of the training examples based on the performance of the weak classifier: \\(d_{t+1} = \\frac{d_t(i) \\cdot e^{-\\alpha_ty_th_t(x_t)}}{z_t}\\), where \\(z_t\\) is a regularization term and \\(\\alpha_t\\) is the weight of \\(h_t\\) on the final ensemble model based on its accuracy. combining classifiers: after multiple rounds, adaboost combines all the weak classifiers into a final strong classifier. the final classifier makes predictions based on a weighted voting system using the predictions of the individual weak classifiers: \\(h(x) = sign(\\sum_{t=1}^t \\alpha_t h_t(x))\\) predictions: when making predictions on new data, adaboost uses the combined classifier to predict the class label based on the weighted votes of the weak classifiers characteristics the weak learning assumption means that we assume each weak classifier makes errors that are not too close to random guessing. so the the error \\(\\epsilon_t\\) is at most \\(\\frac{1}{2} - \\gamma\\) for some small positive constant \\(\\gamma\\). it can be proven that the training error of the c ombined classifier drops exponentially fas as a function of the number of weak classifiers combined, but it says nothing about the behaviour of its generalization error computed over the test data. toy example to illustrate how adaboost works, let us look at the tiny toy learning problem shown in the following picture: round 1 on round \\(1\\), we assign equal weights to all the examples. so \\(d1_(i) = \\frac{1}{n} = \\frac{1}{10}\\). the hypothesis \\(h_1\\) classifies incorrectly three points, so its error is \\(\\epsilon_1 = 0.3\\), so it follows that the weight assigned to this first model is \\(\\alpha_1 = 0.42\\). round 2 when constructing \\(d_2\\) we increment the weight of the three points misclassified by \\(h_1\\). and we define a new hypothesis \\(h_2\\) over this data, where we can see that it classifies correctly the three points misclassified by \\(h_1\\) however it still classifies incorrectly three other points. the error of this model is \\(\\epsilon_2 = 0.21\\) and thus the weight of this model is defined as \\(\\alpha_2 = 0.65\\). round 3 we modify the weights of the data taking into account the three points previously misclassified, augmenting their weight and decresing the weight of those correctly classified. this classifier misses none of the points misclassified by \\(h_1\\) and \\(h_2\\). final round the combined classifier \\(h\\) is defiend as a weigthed vote between \\(h_1\\), \\(h_2\\) and \\(h_3\\) where the weights are given by \\(\\alpha_1\\), \\(\\alpha_2\\) and \\(\\alpha_3\\). $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/DL/04_cnn.html",
    "title": "Redes Neuronales Convolucionales en Visión Artificial",
    "body": " index search search back redes neuronales convolucionales en visión artificial contents clasificaci n de im genes aumento de muestras redes pre-entrenadas extracci n de caracter sticas ajuste fino detecci n de objetos m todos regioncnn segmentaci n sem ntica m todos aplicaciones clasificación de imágenes una cnn para clasificación de imágenes está conformada por dos bloques: conjunto de capas que llevan a cabo la extracción de caracterísitcas clasificador que toma como entrada las características extraídas por la red neuronal este tipo de redes necesita una gran cantidad de datos. en caso de no poseer un volumen elevado de datos se puede hacer uso de técnicas como el aumento de muestras y el uso de redes pre-entrenadas. aumento de muestras consiste en crear nuevas muestras a partir de muestras existentes utilizando transformaciones aleatorias: rotaciones y translaciones. recorte o zoom. voltear horizontalmente (si no hay suposiciones de simetría horizontal). añadir pequeñas cantidades de ruido. en keras esto se puede llevar a cabo utilizando imagedatagenerator. redes pre-entrenadas si la red ha sido entrenada sobre un conjunto de datos lo suficientemente grande y general entonces, entonces podemos utilizarlo sobre clases no utilizadas en el entrenamiento original. existen dos técnicas: extracción de de características: utiliza la red pre-entrenada para extraer características de los nuevos datos. con las nuevas características se entrena un clasificador desde cero. ajuste fino: utiliza unas cuantas capas de la red pre-entrenada y las entrena conjuntamente con el nuevo clasificador. extracción de características se puede hacer de dos maneras: aplicar la base convolutiva sobre el conjunto de datos y utlizarla para entrenar el clasificador. no permite el aumento de datos extender la base convolutiva con un nuevo clasificador y entrenar todo el conjunto. es mucho más lenta per permite el aumento de datos ajuste fino se lleva a cabo como sigue: se añade la nueva red sobre la cnn pre-entrenada se bloquea la red pre-entrenada, de manera que sus pesos no cambian se entrena la nueva red se desbloquean algunas capas superior (que extraer las características de más alto nivel), tal que sus pesos sí se pueden entrenar entrenar estas capas y la nueva red detección de objetos un sistema de detección de objetos debe producir el nombre de la clase asignada a la imagen, una caja de abarque (bounding box) y generalmente la probabilidad de que el objeto pertenezca a la clase. se presentan los siguientes retos a la hora de llevar a cabo la detección: oclusiones, cambios de puntos de vista y tamaños, objetos no rígidos y desenfoque por movimiento métodos antes del desarrollo de las redes neuronales se empleaban las cascadas de haar, que extraer características por convolución con kernels suma de píxeles en negro menos en blanco que seguidamente se pasan a un clasificador entrenado. por otra parte, tenemos la detección basada en cnn que consiste en modificar nuestras redes cnn para no sólo clasificar, si no también obtener la caja de abarque y la forma del objeto. dentro de estes distinguimos dos tipos: detectores de dos etapas, como por ejemeplo region cnn. son letos y no permiten su aplicación en tiempo real. detectore de una etapa, como por ejemplo single shot multibox detector. sí que permiten su aplicación en tiempo real. regioncnn se generan una serie de propuestas de caja de abarque a distintas escalas. se procesan las cajas utilizando una cnn pre-entrenada se clasifican utilizando un clasificador como svm se procesan las cajas utilizando regresión lineal para ajustar las coordenadas segmentación semántica en la segmentación clásica el objetivo consiste en agrupar píxeles contiguos de una categoría similar. la segmentación semántica se distingue de la segmentación clásica en que intenta particionar la imagen en partes con significado y clasificarlas. métodos se utiliza una especie de gan, ya que tienen una red codificadora pre-entrenada seguida de una red decodificadora: la red codificadora aprende características distintivas a baja resolución la red decodificadora proyecta semánticamente las características en el espacio de píxeles (alta resolución) aplicaciones aprendizaje de similaridad. subtitulado de imágenes. generación de imágenes. seguimiento en secuencias de imágenes. todo lo comentado aplicado a vídeo y a imagen 3d. robots: odometría y localización y creación de mapas (slam) usando cámaras. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/DL/01_foundation.html",
    "title": "T1. Fundamentos de las Redes Neuronales Profundas",
    "body": " index search search back t1. fundamentos de las redes neuronales profundas contents deep networks training deep networks the reasons for deep learning s popularity introducing popular open source libraries deep networks we could define deep learning as a class of machine learning techniques, where information is processed in hierarchical layers to understand representations and features from data in increasing levels of complexity. in practice, all deep learning algorithms are neural networks. with that in mind, let's look at the main classes of neural networks. the following list is not exhaustive, but it represents the vast majority of algorithms in use today: multi-layer perceptrons (mlps) convolutional neural networks (cnns) recurrent networks autoencoders training deep networks we can use different algorithms to train a neural network. but in practice, we almost always use stochastic gradient descent (sgd) and backpropagation. in the following section, we'll introduce momentum, the weight update rule is defined as follows: \\begin{align} w \\rightarrow w - \\lambda \\nabla (j(w)) \\end{align} where \\(\\lambda\\) is the learning rate. first we calculate the weight update value \\begin{align} \\delta w \\rightarrow \\mu\\delta w - \\lambda (\\nabla j(w)) \\end{align} we see that the first component, \\(\\mu\\delta w\\), is the momentum. the \\(\\delta w\\) represents the previous value of the weight update and \\(\\mu\\) is the coefficient, which wil determine how much the new value depends on the previous ones. then we update the weight: \\begin{align} w \\rightarrow w + \\delta w \\end{align} you may encounter other gradient descent optimizations, such as: nesterov momentum adadelta rmsprops adam the reasons for deep learning's popularity the first reason is, today, we have a lot more data than in the past. the second reason is the increased computing power. this is most visible in the drastically increased processing capacity of graphical processing units (gpus). neural networks are organized in such a way as to take advantage of the gpu's parallel architecture. introducing popular open source libraries the basic unit for data storage is the tensor. a tensor is a generalization of a matrix to higher dimensions. neural networks are represented as a computational graph of operations. the nodes of the graph represent the operations (weighted sum, activation function, and so on). the edges represent the flow of data. some common libraries: tensorflow keras: is a high-level neural net python library that runs on top of tensorflow, cntk or theano. pytorch: is a deep learning library based on torch. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/DL/05_rnn.html",
    "title": "Redes Neuronales Recurrentes",
    "body": " index search search back redes neuronales recurrentes contents introducci n a las aplicaciones del deep learning para el nlp comparaci n entre enfoques cl sico y de deep learning enfoque cl sico enfoque deep learning arquitecturas ejemplos de deep learning para natural language processing clasificaci n de textos generaci n de textos resumen de textos traducci n b squeda y eliminaci n de duplicados otras aplicaciones introducción a las aplicaciones del deep learning para el nlp comparación entre enfoques clásico y de deep learning enfoque clásico el enfoque clásico se compone de los siguientes pasos: detección de idioma pre-procesado tokenizado etiquetado gramatical (pos) eliminación de stop-words etc. modelado extracción de características (entidades (ner), categorías (pos) ...) aplicación de algoritmos de ml etc. salida análisis de sentimientos clasificación de textos traducción etc enfoque deep learning mientas que el enfoque basado en deep learning se compone de los siguientes pasos: pre-procesado tokenizado etiquetado gramatical (pos) eliminación de stop-words etc. representaciones distribuidas (word embeddings): transformación de palabras/secuencias en vectores que es la entrada que aceptan las redes neuronales. para ello se distinguen métodos como: word2vec, glove, etc. procesamiento en capas ocultas: no permite generar representación comprimida de la entradas. capa de salida análisis de sentimientos clasificación de textos traducción etc arquitecturas para llevar a cabo natural languague processing (nlp) con deep learning podemos utilizar las siguientes arquitecturas: redes recurrentes (rnn) lstm (long short term memory) gru (gated recurrent units) redes convolucionales (cnn) autoencoders ejemplos de deep learning para natural language processing clasificación de textos para la clasificación de texto se define la siguiente estructura: capa de embedding: que transforma la secuencia de palabras en una tabla de vectores capturando la semántica de las mismas. componente de representación profunda: se utiliza rnn o cnn para obtener una representación comprimida de la entrada. parte totalmente conectada: transforma la representación comprimida en clases o puntuaciones para cada clase. ver el capítulo text classification using lstm de hands-on natural language processing with python. generación de textos se utilizan rnns para crear modelos generativos, tal que la generación se puede llevar a cabo en base a caracteres o a palabras. estas son capaces de aprender dependencias a largo plazo. ver el capítulo text generation and summarization using grus de hands-on natural language processing with python. resumen de textos distinguimos entre dos tipos: extractivos: se extraen frases o palabras clave. son simples y robustos y no permiten la paráfrasis. abstractivos: la salida contiene texto no contenido en el original manteniendo el significado. ver el cap. text generation and summarization using grus de hands-on natural language processing with python. traducción distinguimos distintos sistemas que efectúan la traducción automática: sistemas expertos: se definen reglas lingüísticas y sintácticas. traducción estadística: se aprenden reglas estadísticamente a partir de un gran conjunto de datos bilingüe. tal que define un modelo de traducción que mapea textos de un lenguaje a otro. solo funciona bien traduciendo textos similares a los de entrenamiento y necesita gran cantidad de datos traducción con redes neuronales: utilizan un sólo modelo que trabaja sobre segmentos de texto, no sólo sobre palabras o frases. ver el cap. machine translation using the attention-based model de hands-on natural language processing with python. búsqueda y eliminación de duplicados se puede conseguir utilizando una cnn basada en caracteres, que proporciona la flexibilidad para entrenar modelos con caracteres desconocidos y ofrece mayor capacidad de generalición que los embeddings a nivel de palabra. ver el capítulo searching and deduplicating using cnns de hands-on natural language processing with python. otras aplicaciones preguntas-respuestas y chatbots reconocimiento de voz texto a voz $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/DL/02/01_conv_nets.html",
    "title": "Convolutional Nets",
    "body": " index search search back convolutional nets contents deep convolutional neural network local receptive fields shared weights and bias pooling layer an example of dcnn lenet understanding the power of deep learning deep convolutional neural network a deep convolutional neural network (dcnn) consists of many neural network layers. two different types of layers, convolutional and pooling, are typically alternated local receptive fields if we want to preserve spatial information, we represent each image with a matrix of pixels. convolution operation: to encode the local structure is to connect a submatrix of adjacent input neurons (pixels) into one single hidden neuron belonging to the next layer. that single hidden neuron represents one local receptive field. we can encode more information by having overlapping submatrices. a feature map is the result of applying the convolution on the input data, on the previous example the matrix on the right would be one feature map. the kernel size is the size of each the submatrices, in the previous example \\(3 \\times 3\\). the stride is the number of elements between each submatrix. with a stide of \\(1\\) we obtain the following result: this convolutional layer is usually followed by a non-linear activation function (e.g. relu). shared weights and bias to detect the same feature independently from its location on the input we define the same weights for all the neurons on a layer. this way we force the neural net to search for relevant features everywhere on the input data, instead of searching for features on specific places on the input image. pooling layer it consists on using the spatial contiguity of the output from a single feature map and aggregate the values into a single output. on the following image max pooling is being performed. other common pooling operation is average pooling. an example of dcnn — lenet it is a family of convnets trained for recognizing mnist handwritten characters with robustness to simple geometric transformations and to distortion. it is defined as follows: on the low-layers we alternate convolution operations with max-pooling operations. (using carefully chosen local receptive fields and and shared weights). on higher levels are fully connected layers based on a traditional mlp with hidden layers and softmax as the output layer. understanding the power of deep learning deep networks always outperform the simple network and the gap is bigger when the number of examples provided for training is progressively reduced. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/DL/02/02_rnn.html",
    "title": "Recurrent Neural Nets",
    "body": " index search search back recurrent neural nets contents simplernn cells rnn topologies vanishing and exploding gradients long short term memory lstm gated recurrent unit gru a recurrent neural network (rnn) is a class of neural networks that exploit the sequential nature of their input. such inputs could be text, speech, time series, and anything else where the occurrence of an element in the sequence is dependent on the elements that appeared before it. simplernn cells rnn cells incorporate this dependence by having a hidden state, or memory. the value of the hidden state is a function of the value of the hidden state at the previous time step and the value of the input at the current time step. \\begin{align} h_t = \\phi(h_{t-1}, x_t) \\end{align} where \\(h_t\\) and \\(h_{t-1}\\) are the values of the hidden states at the time steps \\(t\\) and \\(t-1\\) and \\(x_t\\) is the values of the input at time \\(t\\). note that the equation is recursive at time \\(t\\) the cell has an input \\(x_t\\) and an output \\(y_t\\). part of the output \\(y_t\\) (the hidden state \\(h_t\\)) is fed back into the cell for use at a later time step \\(t+1\\). on the previous image we show the behaviour of a single cell unrolled. notice that the weight matrices \\(u\\), \\(v\\), and \\(w\\) are shared across the steps. we can also describe the computations within an rnn in terms of equations: \\begin{align} h_t = tanh(wh_{t-1} + ux_t) \\end{align} \\begin{align} y_t = sofmax(vh_t) \\end{align} rnn topologies rnns can be arranged in many ways to solve specific problems. in the basic topology, all input sequences are of the same length and an output is produced at each time step. another example of a many to many rnn could be a machine translation network shown on the many-to-many topology. these take in a sequence and produces another sequence. for example, the input could be a sequence in english and the output could be the translation in spanish. other variants are the one-to-many network, an example of which could be an image captioning network, where the input is an image and the output a sequence of words. similarly, an example of a many-to-one network could be a network that does sentiment analysis of sentences, where the input is a sequence of words and the output is a positive or negative sentiment. vanishing and exploding gradients training the rnn involves backpropagation, where the gradient at each output depends not only on the current time step, but also on the previous ones, this process is called backpropagation through time (bptt). during backpropagation (shown by dotted lines), the gradients of the loss with respect to the parameters \\(u\\), \\(v\\), and \\(w\\) are computed at each time step and the parameters are updated with the sum of the gradients. the following equation shows the gradient of the loss with respect to \\(w\\): \\begin{align} \\frac{\\delta l}{\\delta w} = \\sum_t \\frac{\\delta l_t}{\\delta w} \\end{align} let us now look at what happens to the gradient of the loss at the last time step (\\(t=3\\)) \\begin{align} \\frac{\\delta l_3}{\\delta w} = \\frac{\\delta l_3}{\\delta y_3} \\frac{\\delta y_3}{\\delta h_2} \\frac{\\delta h_2}{\\delta_w} \\end{align} the previous equation is simply deriving by applying the chain rule, where: the loss function \\(l_3\\) is defined as a function of \\(y_3\\), then \\(y_3 = softmax(vh_2)\\) and finally \\(h_2 = tanh(wh_1 + ux_1)\\) the gradient of the hidden state \\(h_2\\) with respect to \\(w\\) can be further decomposed as the sum of the gradient of each hidden state with respect to the previous one. \\begin{align} \\frac{\\delta l_3}{\\delta w} = \\sum_{t=0}^2 \\frac{\\delta l_3}{\\delta y_3} \\frac{\\delta y_3}{\\delta h_2} \\frac{\\delta h_2}{\\delta h_t}\\frac{\\delta h_t}{\\delta_w} \\end{align} finally, each gradient of the hidden state with respect to the previous one can be further decomposed as the product of gradients of the current hidden state against the previous one. \\begin{align} \\frac{\\delta l_3}{\\delta w} = \\sum_{t=0}^2 \\frac{\\delta l_3}{\\delta y_3} \\frac{\\delta y_3}{\\delta h_2} \\left(\\prod_{j=t+1}^2 \\frac{\\delta h_j}{\\delta h_{j-1}}\\right)\\frac{\\delta h_t}{\\delta_w} \\end{align} for example for \\(t = 3\\): \\begin{align} \\frac{\\delta l_4}{\\delta w} = \\frac{\\delta l_4}{\\delta y_4} \\frac{\\delta y_4}{\\delta h_3} \\left(\\prod_{j=4}^2 \\frac{\\delta h_j}{\\delta h_{j-1}}\\right)\\frac{\\delta h_4}{\\delta_w} \\end{align} \\begin{align} \\frac{\\delta l_4}{\\delta w} = \\frac{\\delta l_4}{\\delta y_4} \\frac{\\delta y_4}{\\delta h_3} \\left(\\frac{\\delta h_4}{\\delta h_3}\\frac{\\delta h_3}{\\delta h_2}\\frac{\\delta h_2}{\\delta h_1}\\right)\\frac{\\delta h_4}{\\delta_w} \\end{align} on general: \\begin{align} \\frac{\\delta l_i}{\\delta w} = \\sum_{t=0}^i \\frac{\\delta l_i}{\\delta y_i} \\frac{\\delta y_i}{\\delta h_{i-1}} \\left(\\prod_{j=t+1}^i \\frac{\\delta h_j}{\\delta h_{j-1}}\\right)\\frac{\\delta h_i}{\\delta_w} \\end{align} consider the case where the individual gradients of a hidden state with respect to the previous one is less than one. as we backpropagate across multiple time steps, the product of gradients get smaller and smaller, leading to the problem of vanishing gradients. similarly, if the gradients are larger than one, the products get larger and larger, leading to the problem of exploding gradients. the effect of vanishing gradients is that the gradients from steps that are far away do not contribute anything to the learning process, so the rnn ends up not learning long range dependencies. while there are a few approaches to minimize the problem of vanishing gradients, such as: proper initialization of the \\(w\\) matrix using a relu instead of tanh layers pre-training the layers using unsupervised methods the most popular solution is to use the lstm or gru architectures. long short term memory — lstm the lstm is a variant of rnn that is capable of learning long term dependencies. the line across the top of the diagram is the cell state c, and represents the internal memory of the unit. the line across the bottom is the hidden state. also, \\(i\\), \\(f\\), and \\(o\\) are the input, forget, and output gates. the forget gate defines how much of the previous state \\(h_{t-1}\\) you want to allow to pass through. the input gate defines how much of the newly computed state for the current input \\(x_t\\) you want to let through. the output gate defines how much of the internal state you want to expose to the next layer. the internal hidden state \\(g\\) is computed based on the current input \\(x_t\\) and the previous hidden state \\(h_{t-1}\\). such that: \\begin{align} i = \\sigma(w_ih_{t-1} + u_ix_t) \\end{align} \\begin{align} f = \\sigma(w_fh_{t-1} + u_fx_t) \\end{align} \\begin{align} o = \\sigma(w_oh_{t-1} + u_ox_t) \\end{align} \\begin{align} g = \\tanh(w_gh_{t-1} + u_gx_t) \\end{align} \\begin{align} c_t = (c_{t-1} \\otimes f) \\oplus (g \\otimes i) \\end{align} \\begin{align} h_t = tanh(c_t) \\otimes o \\end{align} one thing to realize is that an lstm is a drop-in replacement for a simplernn on the recurrent neural network. gated recurrent unit — gru this type of cell has two gates, an update gate \\(z\\), and a reset gate \\(r\\). the update gate defines how much previous memory to keep around. the reset gate defines how to combine the new input with the previous memory. the following equations define the gating mechanism in a gru: \\begin{align} z = \\sigma(w_zh_{t-1} + u_z x_t) \\end{align} \\begin{align} r = \\sigma(w_rh_{t-1} + u_r x_t) \\end{align} \\begin{align} c_t = tanh(w_c(h_{t-1} \\otimes r) + u_cx_t) \\end{align} \\begin{align} h_t = (z \\otimes c) \\oplus ((1 - z) \\otimes h_{t-1}) \\end{align} gru and lstm have comparable performance, while grus are faster to train and need less data to generalize in situations where there is enough data, an lstm's greater expressive power may lead to better results. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/DL/02/04_autoencoders.html",
    "title": "Autoencoders",
    "body": " index search search back autoencoders contents autoencoders stacked autoencoders tying weights convolutional autoencoders recurrent autoencoders denoising autoencoders sparse autoencoders variational autoencoders generative adversarial networks the difficulties of traning gans deep convolutional gans progressive growing of gans style gans autoencoders an autoencoder is a type of artificial neural network used to learn efficient codings of unlabeled data (unsupervised learning). an autoencoder learns two functions: an encoding function that transforms the input data a decoding function that recreates the input data from the encoded representation. the autoencoder learns dense representations (encoding) for a set of data. we can force the network to learn useful features adding different types of constraints, for example: defining the dense representation such that is has a lower dimensionality than the input data. adding noise to the input data (denoising autoencoders). the number of neurons in the output layer must be equal to the number of inputs. the outputs are often called the reconstructions because the cost function contains a reconstruction loss that penalizes the model when the reconstructions are different from the inputs. undercomplete autoencoder: the internal representation has a lower dimensionality than the input data. overcomplete autoencoder: the internal representation has a higher dimensionality than the input data. stacked autoencoders stacked autoencoders are said to be autoencoders that have multiple hidden layers. tying weights an autoencoder with tied weights has decoder weights that are the transpose of the encoder weights this reduces the number of parameters of the model, thus speeds up training and limits the risk of overfitting. convolutional autoencoders used with image data. the encoder is a regular cnn composed of convolutional layers and pooling layers. it reduces the spatial dimensionality of the inputs (i.e., height and width) while increasing the depth (i.e., the number of feature maps). the decoder must do the reverse (upscale the image and reduce its depth back to the original dimensions). recurrent autoencoders used with sequential data. the encoder is typically a sequence-to-vector rnn, which compresses the input sequence down to a single vector. the decoder is a vector-to-sequence rnn that does the reverse denoising autoencoders we want to add noise to the input data, and then train the network to be able to recover the original noise-free inputs. the noise can be pure gaussian noise added to the inputs, or it can be randomly switched-off inputs, just like in dropout. sparse autoencoders a sparse autoencoder is an autoencoder whose training criterion involves a sparsity penalty. in most cases, we would construct our loss function by penalizing activations of hidden layers so that only a few nodes are encouraged to activate when a single sample is fed into the network. variational autoencoders they are probabilistic autoencoders as well as generative models. instead of directly producing a coding for a given input, the encoder produces a mean coding \\(\\mu\\) and a standard deviation \\(\\sigma\\). the actual coding is then sampled randomly from a gaussian distribution with mean \\(\\mu\\) and standard deviation \\(\\sigma\\). after that the decoder decodes the sampled coding normally. generative adversarial networks gans are composed of two neural networks: a generator that tries to generate data that looks similar to the training data a discriminator that tries to tell real data from fake data. takes either a fake image from the generator or a real image from the training set as input, and must guess whether the input image is fake or real. each training iteration is divided into two phases: we train the discriminator. a batch of data where half are real real images and the other half are fake images produced by the generator. the labels are set to \\(0\\) for fake images and \\(1\\) for real images, and the discriminator is trained on this labeled batch for one step. backpropagation only optimizes the weights of the discriminator. we train the generator: we only add fake images to the data, and all the labels are set to \\(1\\) (real). we want the generator to produce images that the discriminator will believe to be real. backpropagation only affects the weights of the generator. the generator and the discriminator compete against each other during training. the difficulties of traning gans it has been demonstrated that a gan can only reach a single nash equilibrium (we assume the training process to be finished): that’s when the generator produces perfectly realistic images, and the discriminator is forced to guess (\\(50\\%\\) real, \\(50\\%\\) fake). nothing guarantees that the equilibrium will ever be reached. the biggest difficulty is called mode collapse: this is when the generator’s outputs gradually become less diverse. such that the generator gets very good at generating data of a concrete kind, good enough to fool the discriminator, however it progressively start representing data of another kind and then forgets about the previous class of data. moreover, because the generator and the discriminator are constantly pushing against each other, their parameters may end up oscillating and becoming unstable. and since many factors affect these complex dynamics, gans are very sensitive to the hyperparameters. there are some techniques that aim to avoid this behaviour like: experience replay and mini-batch discrimination. experience replay: stores images on a buffer and the discriminator uses the images on this buffer as input for fake images. old images are then progressively replaces by newer images. mini-batch discrimination: it measures how similar are images on the batch, the discriminator uses this statistic to decide whether to reject the whole batch or not. deep convolutional gans these are gans based on deeper convolutional nets for larger images. progressive growing of gans it begins by generating images at low resolution, such as \\(4 \\times 4\\) pixels. the model is first trained on low-resolution images. once training stabilizes at this resolution, additional layers are added to the generator and discriminator to allow for the generation of higher-resolution images. after adding new layers, there is usually a transition phase where the model is trained on a mixture of images at the old and new resolutions. this gradual transition allows the model to adapt to the increased resolution without destabilizing the training process. once the training stabilizes at the new resolution, the transition phase ends, and the model continues to train exclusively on images at the higher resolution. increasing the resolution progressively allows the model to learn to capture both global and local features of the images more effectively. style gans what sets stylegans apart is the introduction of \"style\" into the generation process. in traditional gans, the generator takes random noise as input and directly generates images. in stylegans, the generator learns to separate the \"content\" of the image (e.g., facial features) from the \"style\" (e.g., lighting, color, texture). this allows for more fine-grained control over the generated images. the stylegan generator and discriminator models are trained using the progressive growing gan training method. stylegans consist of two main components: a mapping network and a synthesis network. the mapping network takes as input a latent vector (random noise) and maps it to an intermediate latent space, which controls the style of the generated image. the synthesis network then takes the intermediate latent representation and generates the final image. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/DL/02/03_boltzmann.html",
    "title": "Boltzmann Based Networks",
    "body": " index search search back boltzmann based networks contents boltzmann machines restricted boltzmann machines contrastive divergence deep belief nets deep boltzmann machines boltzmann machines they are fully connected artificial neural networks, but they are based on stochastic neurons. the working of boltzmann machine is mainly inspired by the boltzmann distribution which says that the current state of the system depends on the energy of the system and the temperature at which it is currently operating. these neurons output \\(1\\) with some probability, given by the following equation: \\begin{align} p(s_i^{\\text{next step}} = 1) \\sigma\\left(\\frac{\\sum_{j=1}^n w_{i,j}s_j + b_i}{t}\\right) \\end{align} where: \\(s_j\\) is the \\(j\\)th neuron's state (\\(0\\) or \\(1\\)). \\(w_{i,j}\\) is the connection weight between the \\(i\\)th and \\(j\\)th neurons. note that \\(w_{i,i}\\) = 0. \\(b_i\\) is the ith neuron’s bias term. \\(n\\) is the number of neurons in the network. \\(t\\) is a number called the network’s temperature; the higher the temperature, the more random the output. \\(\\sigma\\) is the logistic function. hence to implement these as neural networks, we use the energy models. the energy term was equivalent to the deviation from the actual answer. the higher the energy, the more the deviation. it has been thus important to train the model until it reaches a low-energy point. the nodes in boltzmann machines are simply categorized as visible and hidden nodes. the visible nodes take in the input. the same nodes which take in the input will return back the reconstructed input as the output. the energy function of the boltzmann machine is defined as follows: \\begin{aligned} e(v, h) = - \\sum_{i} v_ib_i - \\sum_k h_kb_k - \\sum_{i, j}v_iv_jw_{i,j} \\sum_{i,k}v_ih_kw_{i, k} - \\sum_{k,l}h_kh_kw_{k,l} \\end{aligned} where \\(v\\) are the visible units, \\(h\\) as the hidden units \\(b\\) is the bias and \\(w_{i, j}\\) are the weights between units \\(i\\) and \\(j\\). the probability of a joint configuration over both the visible unit and the hidden unit is as follows: \\begin{aligned} p(v,h) = \\frac{e^{-e(v,h)}}{\\sum_{m, n} e^{-e(m, n)}} \\end{aligned} and, for example, the probability distribution of visible units is obtained by marginalizing out hidden units: \\begin{aligned} p(v) = \\frac{\\sum_h e^{-e(v,h)}}{\\sum_{m, n} e^{-e(m, n)}} \\end{aligned} this can now be utilized to sample visible units. training a boltzmann machine means finding the parameters that will make the network approximate the training set’s probability distribution. so we have to obtain the parameters tha maximize the likelihood of the observed data. the traning algorithm runs as described: obtain the log likelihood function of visible units, by marginalizing the hidden units: \\begin{align} l(v|w) = \\log p(v|w) = \\log \\sum_h e^{-e_{v, h}} - \\log \\sum_{m, n} e^{-e_{m, n}} \\end{align} take the derivative of the log likelihood function as a function of \\(w\\): \\begin{align} \\frac{\\delta l(v|w)}{\\delta w} = \\frac{\\delta \\log \\sum_h e^{-e_{v, h}}}{\\delta \\sum_h e^{-e_{v, h}}} \\cdot \\frac{\\delta \\sum_h e^{-e_{v, h}}}{\\delta w} - \\frac{\\delta \\log \\sum_h e^{-e_{v, h}}}{\\delta \\sum_{m,n} e^{-e_{m, n}}} \\cdot \\frac{\\delta \\sum_̣{m,n} e^{-e_{m, n}}}{\\delta w} \\end{align} \\begin{align} = \\frac{1}{\\sum_h e^{-e_{v, h}}} \\cdot \\sum_h \\frac{\\delta e^{-e_{v,h}}}{\\delta w} - \\frac{1}{\\sum_{m,n} e^{-e_{m, n}}} \\cdot \\sum_{m,n} \\frac{\\delta e^{-e_{m,m}}}{\\delta w} \\end{align} \\begin{align} = \\frac{1}{\\sum_h e^{-e_{v, h}}} \\cdot \\sum_h -e^{-e_{v,h}} \\frac{\\delta e_{v,h}}{\\delta w} - \\frac{1}{\\sum_{m,n} e^{-e_{m, n}}} \\cdot \\sum_{m,n} -e^{e_{m,m}} \\frac{\\delta e_{m,m}}{\\delta w} \\end{align} \\begin{align} = -\\sum_h \\frac{e^{-e_{v,h}}}{\\sum_h e^{-e_{v, h}}} \\frac{\\delta e_{v,h}}{\\delta w} + \\sum_{m,n} \\frac{e^{e_{m,m}}}{\\sum_{m,n} e^{-e_{m, n}}} \\frac{\\delta e_{m,m}}{\\delta w} \\end{align} we know that: \\begin{align} p(h|v) = \\frac{p(v, h)}{p(v)} = \\frac{\\frac{e^{-e_{v, h}}}{\\sum_{m,n} e^{-e_{m, n}}}}{\\frac{\\sum_h e^{-e_{v, h}}}{\\sum_{m,n} e^{-e_{m, n}}}} \\end{align} by removing both \\(\\sum_{m,n} e^{-e_{m, n}}\\), we obtain: \\begin{align} = \\frac{e^{-e_{v, h}}}{\\sum_h e^{-e_{v, h}}} \\end{align} such that: \\begin{align} = -\\sum_h p(h|v) \\frac{\\delta e_{v,h}}{\\delta w} + \\sum_{m,n} p(m,n) \\frac{\\delta e_{m,m}}{\\delta w} \\end{align} and by de definition of the expected value \\(\\mathbb{e}(x) = \\sum_x x p(x)\\): \\begin{align} = - \\mathbb{e}_{p(h|v)}[\\frac{\\delta e_{v,h}}{\\delta w}] + \\mathbb{e}_̣{p(m,n)}[\\frac{\\delta e_{m,m}}{\\delta w}] \\end{align} computing these expectations is in general an intractable problem. he general approach for solving this problem is to use markov chain monte carlo (mcmc) to approximate these quantities: \\begin{align} \\frac{\\delta l(v|w)}{\\delta w} = - <s_i, s_j>_{p(h_{data}|v_{data})} + <s_i, s_j>_{p(h_{model}|v_{model})} \\end{align} here \\(<\\cdot, \\cdot>\\) denotes the expectation. restricted boltzmann machines an rbm is a boltzmann machine that only has connections between visible and hidden units. the energy function of the rbm is defined as follows: \\begin{align} e(v, h) = - \\sum_i v_ib_i - \\sum_k h_kb_k - \\sum_{i,k} v_i h_k w_{i,k} \\end{align} contrastive divergence this is a very efficient training algorithm for boltzmann machines. here is how it works: for each training instance \\(x\\), the algorithm starts by feeding it to the network by setting the state of the visible units to \\(x_1, \\cdots, x_n\\). compute the state of the hidden units by applying the output formula for a hidden neuron (see ), which gives us the vector \\(h\\), where \\(h_i\\) is the output of the ith neuron. next you compute the state of the visible units, by applying the same stochastic equation, which gives you vector \\(x'\\). once again you compute the state of the hidden units, which gives you a vector \\(h'\\). now you can update each connection weight by applying: \\begin{align} w_{i, j} = w_{i, j} + \\eta (xh^t - x'h'^t) \\end{align} the great benefit of this algorithm is that it does not require waiting for the network to reach thermal equilibrium. deep belief nets a deep belief net is an rbm where several layers of rbms can be stacked. such that the hidden units of the first-level rbm serve as the visible units for the second-layer rbm. you can train dbns one layer at a time using contrastive divergence, starting with the lower layers. their lower layers learn low-level features in the input data, while higher layers learn high-level features. thus it learns information in a hierarchical way. just like rbms, dbns are fundamentally unsupervised, but you can also train them in a semi-supervised manner by adding some visible units to represent the labels. the following describes the training process: rbm 1 is trained without supervision. rbm 2 is trained with rbm 1’s hidden units as inputs without supervision rbm 3 is trained using rbm 2’s hidden units as inputs, as well as extra visible units used to represent the target labels one advantage of this semisupervised approach is that you don't need much labeled training data. dbns can also work in reverse. if you activate one of the label units, the signal will propagate up to the hidden units of rbm 3, then down to rbm 2, and then rbm 1, and a new instance will be output by the visible units of rbm 1. this generative capability of dbns is quite powerful. for example, it has been used to automatically generate captions for images, and vice versa: first a dbn is trained (without supervision) to learn features in images, and another dbn is trained (again without supervision) to learn features in sets of captions (e.g., \"car\" often comes with \"automobile\"). then an rbm is stacked on top of both dbns and trained with a set of images along with their captions; it learns to associate high-level features in images with high-level features in captions. next, if you feed the image dbn an image of a car, the signal will propagate through the network, up to the top-level rbm, and back down to the bottom of the caption dbn, producing a caption. due to the stochastic nature of rbms and dbns, the caption will keep changing randomly a dbn, however, suffers from the following problems: inference in dbns is a problem because of the \"explaining away\" effect a dbn can only use greedy retraining and no joint optimization over all layers deep boltzmann machines the distinction between dbm and dbn from the previous section is that dbm information flows on bidirectional connections in the bottom layers. you can also train a dbm using contrastive divergence. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/DL/index.html",
    "title": "Deep Learning",
    "body": " index search search back deep learning fundamentos de las redes neuronales profundas tipologías de las redes neuronales profundas convolutional nets recurrent neural networks boltzmann based networks autoencoders herramientas y estrategias de programación e implemetación de redes neuronales frameworks computación acelerada proveedores redes neuronales convolucionales en visión artificial redes neuronales recurrentes servicios y proveedores de deep learning en la nube $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/DL/03/03_proveedores.html",
    "title": "Proveedores",
    "body": " index search search back proveedores contents deep cognition h2o ai auto ml driverless ai big ml hay básicamente dos tipos de proveedores: locales: scikit-learn,tensorflow, deeplearning4j, pio, h2o, hadoop/spark, etc. orientados a la nube: abm, bigml, google ml, amazonml ,azureml , watson ibm, etc. arquitectura: deep cognition se trata de una plataforma que incorpora un ide visual que permite definir una red neuronal. se puede utilizar: en la nube en local en una máquina virtual en una máquina de azure h2o.ai su arquitecture se detalla en la siguiente imagen: en la parte superior vemos los lenguajes que soporta: seguidamente tenemos un bloque de tradcutores (rapids en c++ y scala en java): a continuación tenemos los algoritmos definidos así como la herramienta de predcción para h2o: en la siguiente imagen tenemos la parte de la gestión de la computación que se lleva a cabo encima de clusters spark/hadoop o sobre la distribución standalone de h2o: auto ml permite evaluar modelos dado un conjunto de datos en base a una serie de métricas: driverless ai permite desarrollar el pipeline completo de h2o de forma visual, tal que permite automatizar tareas. big ml se trata de una empresa española. define algoritmos de clasificación, regresión, análisis de clusters, detección de anomalías, descubrimiento de asociación y modelado. destaca sobretodo en el preprocesamiento de datos, visualización y en la evaluación de modelo. no soporta ni cnn (no soporta capas de convolución ni de pooling) ni rnn. los parámetros soportados son los siguientes: $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/DL/03/01_frameworks.html",
    "title": "Frameworks para Deep Learning",
    "body": " index search search back frameworks para deep learning contents tensorflow arquitectura tensorflow tensorflow vs numpy modelo computacional de tensorflow lazy evaluation tensorflow hub operaciones theano keras tipos de modelos caffe torch pytorch fast ai aplicaciones de dl los frameworks principales son los siguientes: tensorflow torch/pytorch keras caffe theano (está aquí por motivos históricos) una diferencia entre los distinos frameworks radica en la forma de especificar los modelos: a través de ficheros de configuración (caffe, distbelief, cntk) a través de código (torch/pytoch, theano, tensorflow) tensorflow arquitectura tensorflow presenta un núcleo de bajo nivel (c++/cuda). además se define un api python sencillo para definir el gráfico computacional, así como apis de alto nivel (tf-learn, keras, etc) tensorflow vs numpy numpy no dispone de funciones/métodos para la creación de funciones de tensores y no computa automáticamente sus derivadas. numpy no tiene soporte para gpu. modelo computacional de tensorflow tensorflow construye grafos donde cada nodo es un tensor y cada arista es una operación entre los tensores. de tal manera que, como vemos en la figura inferior, se pueden repartir las computaciones entre distintas gpus. lazy evaluation este grafo sólo encompasa la definición de las operaciones, de tal manera que no requiere de su ejecución. si no que la ejecución sólo se produce durante el entrenamiento. tensorflow hub se trata de un repositorio de modelo pre-entrenados. operaciones a continuación mostramos una serie de operaciones soportadas por tensorflow: theano se trata de otro framework, pionero en el uso de grafos computacionales. es una herramienta generalista, tal que podemos implementar cualquier tipo de algoirtmo sobre el framework. además se puede especificar como backend a utilizar en keras, en lugar de tensorflow. sin embargo, finalizó su desarrollo a partir de la versión 1.0. librerías que usan theano keras blocks lasagne sklearn-theano pymc 3 theano-rnn morb además presenta las siguientes características: permite la evaluación lazy del grafo (precursor de esta ténica). da soporte para gpu's. permite la diferenciación simbólica. keras keras puede ser utilizado con tensorflow o también como una librería adicional. además presenta las siguientes ventajas: sencilla para comenzar, y sencilla para avanzar se ejecuta sobre theano y tensorflow disponibilidad de herramientas de visualización (tensorboard) escrita de forma modular: fácil de expandir suficientemente potente para escribir modelos serios pero también presenta las siguiente desventajas: menos flexible menos tipos: no hay modelos rbm, por ejemplo. menos proyectos disponibles online que caffe soporte multi-gpu no del 100% la idea general para la creación de modelos/algoritmos sigue el siguiente esquema: preparar los tensores de entrada y salida crear la primera capa (layer) para manejar el tensor de entrada crear la última capa (layer) para manejar el tensor de salida (targets) construir virtualmente cualquier modelo entre estas dos capas (hidden layers) las definiciones de los modelos pueden ser guardados y recuperados en formato json y en formato yaml. los parámetros también pueden ser guardados y recuperados en formato h5. tipos de modelos keras soporta dos tipos de modelos: modelo secuencial api funcional: se usa para definir modelos complejos: modelos multi-output, grafos acíclicos dirigidos (graph) o modelos con capa compartidas grafo (deprecado) caffe construido sobre c++, cuda. presenta una gran cantidad de modelos pre-entrenados la definición de modelos de hace de forma declarativa: cuáles son sus aplicaciones? object detection pixelwise prediction torch su backend está basado en c y en cuda. su frontend está escrito sobre lua. pytorch torch en python. fast.ai es muy similar a keras, fast.ai permite generar herramientas y modelos pre-entranados de manera muy sencilla. aplicaciones de dl visión speech recognition nlp $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/DL/03/02_computacion_acelerada.html",
    "title": "Computación Acelerada",
    "body": " index search search back computación acelerada contents diferencias cpu gpu proveedores flujo de procesamiento en cuda plataformas tpu por qu utilizar tpus cu ndo deber amos utilizar una tpu versiones flujo de ejecuci n de tpus diferencias cpu/gpu una cpu tiene un número limitado de cores, mientras que una gpu tiene un número muy elevado de cores. una gpu tiene procesadores menos potentes (menos operaciones por ciclo), sin embargo tiene muchas más unidades lógicas-aritméticas (alu), por lo que tiene más capacidad de cálculo a coste de tener menos capacidad de manejo de almacenamiento. proveedores nvidia: se basa en la arquitecture compute unified device architecture (cuda). amd: se basa en una arquitectura más abierta, heterogeneous system architecture (hsa), que es multiplataforma. su arquitectura se puede utilizar con distintos proveedores, p.ej. nvidia. flujo de procesamiento en cuda plataformas tpu diseñado por google especialmente diseñado para operaciones matriciales y tensores. su uso fundamental es en el entrenamiento de redes neuronales y la inferencia. por qué utilizar tpus? según google: son 30x más rápidos que gpus y cpus. presentan una gran eficiencia energética. las nn desarrolladas con tensorflow requieren muy pocas líneas de código. requieren menos tiempo -> menos dinero. cuándo deberíamos utilizar una tpu? versiones hay dos versiones: v2: hbm de 8 gb/tpu core. 1mxu (128x128) por core. tpu pod, hasta 512 cores (4tb de memoria) v3: hbm de 16 gb/tpu core. 2 mxu (128x128) por core. tpu pod, hasta 2048 cores (32 tb de memoria) flujo de ejecución de tpus $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/DL/06_cloud_services.html",
    "title": "Servicios y Proveedores de Deep Learning en la Nube",
    "body": " index search search back servicios y proveedores de deep learning en la nube contents caracter sticas capacidades modelos de despliegue google cloud platform awm machine learning no se trata de una tecnología, si no que es un servicio. se definen tres capas distintas de servicio: algunos ejemplos son: modelos de despliegue google cloud platform: machine learning engine aws machine learning microsoft azure: machine learning studio ibm watson machine learning y data studio características it services catalog global network access instant elasticity chargeback common it-resouces pool capacidades saas (software as a service): se utiliza/alquila un servicio concreto, p.ej. one drive. paas (platform as a service): permite tener entornos preconfigurados para poder ejecutar ciertos conjuntos de aplicaciones. iaas (infraestructure as a service): se da acceso a la infraestructura, tal que te permite utilizarla para ejecutar los servicios que tu convengas. modelos de despliegue como modelos de despliegue tenemos: private cloud: se cierra el acceso para que sólo la propia infraestructura tenga acceso. community cloud: conjunto de nubes públicas que comparten recursos. hybrid cloud: tiene parte pública y tiene parte a la que se restringe el acceso. public cloud: permite el acceso desde la nube pública de internet. google cloud platform a continuación mostramos el ciclo completo de desarrollo de soluciones ml, y las herramientas de gcp asociadas y disponibles para cada una de ellas: en la fase de desarrollo se definen varias herramientas: data labeling service: se encarga del etiquetamiento correcto de los datos de forma semiautomática. deep learning vm image: proporciona imágenes virtuales sobre las cuales llevar a cabo el procesamiento. api platform notebook awm machine learning la estructura se divide en tres bloques, de menor a mayor abstracción: infraestructura plataformas servicios how to use amazon sagemaker $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/index.html",
    "title": "Data Science Master",
    "body": " index search search back data science master 2c 2c aprendizaje automático ii deep learning modelos bayesianos jerárquicos 3c 1c infraestructuras computacionales para procesamiento de datos masivos $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/index.html",
    "title": "Data Science",
    "body": " index search search back data science master machine learning stanford coursera artificial intelligence in robotics online training mobile robotics standalone topics ukf $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/index.html",
    "title": "Notes",
    "body": " index search search back notes math computer science data science music other $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/CG/RTGW/02.html",
    "title": "Rendering",
    "body": " index search search back rendering contents webgl rendering pipeline vertex buffer objects vbos index buffer objects ibos vertex shader fragment shader framebuffer attributes uniform textures varyings rendering in webgl defining a geometry using javascript arrays creating webgl buffers associating attributes to vbos rendering drawing functions using drawarrays using drawelements rendering a square vertex array objects drawelements modes webgl as a state machine buffer manipulation webgl rendering pipeline webgl runs on the gpu on your computer. as such, you need to provide code that runs on that gpu. this code is comprised by two functions called vertex shader and fragment shader, written in a very strictly-typed c/c++-like language called glsl, gl shader language. together, they are called a program. a vertex shader's job is to compute vertex attributes, it outputs values that can be used to rasterize various kinds of primitives, including points, lines, and triangles. a fragment shader's job is to compute a color for each pixel of the primitive currently being drawn. let's examine what webgl's rendering pipeline. the following is a diagram of a simplified version of webgl's rendering pipeline: vertex buffer objects (vbos) vbos contain the data that is used to describe the geometry to be rendered. vertex coordinates, are usually stored and processed in webgl as vbos. index buffer objects (ibos) ibos contain information about the relationship of the vertices. it uses the index of each vertex in the vertex buffer as a value. vertex shader the vertex shader is called on each vertex. the shader manipulates per-vertex data. fragment shader each surface element (pixel) is called a fragment. the main goal of the fragment shader is to calculate the color of individual pixels. framebuffer the framebuffer is a two-dimensional buffer contains the fragments that have been processed by the fragment shader. attributes attributes are input variables that are used in the vertex shader. for example, you may put three dimensional \\(32\\)-bit vectors in a buffer. you would tell a particular attribute which buffer to pull the vectors out of, what type of data it should pull out (\\(3\\)-component, \\(32\\)-bit floating point numbers), what offset in the buffer the positions start at, and how many bytes to get from one position to the next. uniform uniforms are input variables that are available to both the vertex shader and the fragment shader. unlike attributes, uniforms are constant during a rendering cycle. textures textures are arrays of data that can be accessed in your shader program. image data is the most common thing to put in a texture. varyings varyings are used to pass data from the vertex shader to the fragment shader. the values set on a varying by a vertex shader will be interpolated while executing the fragment shader. rendering in webgl there are two data types that are fundamental: vertices and indices. vertices are the points that define the corners of 3d objects. each vertex is represented by three floating-point numbers that correspond to the x, y, and z coordinates of the vertex. indices are numeric labels for the vertices in a given 3d scene. indices allow us to tell webgl how to connect vertices in order to produce a surface. both vertices and indices are stored on a javascript array and passed to webgl's rendering pipeline. defining a geometry using javascript arrays as you can see from the preceding illustration, we have placed the coordinates sequentially in the vertex array and then indicated how these coordinates are used to draw the trapezoid in the index array. triangles in the index array are usually, but not necessarily, defined in counter-clockwise order. it's important to pick one approach and keep it consistent because programs may use the clockwise/counter-clockwise order to determine whether a face is facing forward or backward for culling and rendering purposes. in computer graphics, back-face culling determines whether a polygon of a graphical object is visible. creating webgl buffers let's render a square. we define the vertices, and create the respective buffer. these vertices are defined in clipspace coordinates, because webgl only deals with clipspace coordinates. clipspace coordinates always go from \\(-1\\) to \\(+1\\). const vertices = [ -0.5, 0.5, 0, -0.5, -0.5, 0, 0.5, -0.5, 0, 0.5, 0.5, 0 ]; const positionbuffer = gl.createbuffer(); now, when positionbuffer is made the currently-bound webgl buffer any subsequent buffer operation will be executed on this buffer until it is unbound, or another buffer is made the current one. gl.bindbuffer(gl.array_buffer, positionbuffer); the first parameter is the type of buffer we are creating: gl.array_buffer: vertex data gl.element_array_buffer: index data once we have bound a buffer, we need to pass along its contents. gl.bufferdata(gl.array_buffer, new float32array(vertices), gl.static_draw); the last argument is the type, which is a performance hint for webgl. the accepted values for type are as follows: static_draw: data in the buffer will not be changed (specified once and used many times) dynamic_draw: data will be changed frequently (specified many times and used many times) stream_draw: data will change on every rendering cycle (specified once and used once) webgl requires javascript typed array so that the buffer data can be processed in its native binary form with the objective of speeding up geometryprocessing performance. the typed arrays used by webgl include int8array, uint8array, int16array, uint16array, int32array, uint32array, float32array, and float64array. it's important to note that vertex coordinates can be float, but indices are always integers. finally, it is a good practice to unbind the buffer. gl.bindbuffer(gl.array_buffer, null); all this same process applies for the index buffer. associating attributes to vbos once we have created the vbos, we need to associate these buffers to vertex shader attributes. each vertex shader attribute will refer to one and only one buffer. we can achieve this by following these steps: bind a vbo gl.bindbuffer(gl.array_buffer, mybuffer); point an attribute to the currently-bound vbo gl.vertexattribpointer(index, size, type, normalize, stride, offset); index: attribute's index that we are bounding the currently-bound buffer to (i.e. avertexposition) size: number of values per vertex that are stored in the currently-bound buffer. type: data type of the values stored in the current buffer (fixed, byte, unsigned_byte, float, short, unsigned_short) normalize: beyond scope (set to false) stride: if stride is 0, then we are indicating that elements are stored sequentially in the buffer. offset: the position in the buffer from which we will start reading values for the corresponding attribute. generally \\(0\\). enable the attribute gl.enablevertexattribarray(positionattributelocation); unbind gl.bindbuffer(gl.array_buffer, null); rendering drawing functions the drawarrays and drawelements functions are used for writing to the framebuffer. drawarrays uses vertex data in the order in which it is defined in the buffer to create the geometry. in contrast, drawelements uses indices to access the vertex data buffers and create the geometry. both drawarrays and drawelements will only use enabled arrays. using drawarrays we will call drawarrays when information about indices is not available. in most cases, drawarrays is used when the geometry is simple enough that defining indices is overkill. when we want to render a triangle or a rectangle. in that case, webgl will create the geometry in the order in which the vertex coordinates are defined in the vbo. if you have contiguous triangles (as we did in the trapezoid example), you will have to repeat these coordinates in the vbo. if you need to repeat many vertices to create the geometry, drawarrays is not the optimal method. the more vertex data you duplicate, the more calls you will have on the vertex shader, one per vertex. the signature for drawarrays is as follows: gl.drawarrays(mode, first, count) where: mode: the type of primitive that we are going to render: gl.points, gl.line_strip, gl.line_loop, gl.lines, gl.triangle_strip, gl.triangle_fan, and gl.triangles. first: the starting element in the enabled arrays. count: the number of elements rendered. using drawelements drawelements allows us to use the ibo to tell webgl how to render the geometry. therefore, vertices are only processed once, and can be used as many times as they are defined in the ibo. this feature reduces both the memory and processing required on the gpu. when we use drawelements, we need at least two buffers: a vbo and an ibo. as the vertex shader gets executed on each vertex, the rendering pipeline assembles the geometry into triangles using the ibo. the signature for drawelements is as follows: gl.drawelements(mode, count, type, offset) where: mode: the type of primitive that we are going to render: gl.points, gl.line_strip, gl.line_loop, gl.lines, gl.triangle_strip, gl.triangle_fan, and gl.triangles. count: the number of elements rendered. type: the type of the values in indices: unsigned_byte or unsigned_short. offset: which element in the buffer will be the starting point for rendering. rendering a square we first, compile each shader as follows: /** * compiles the vertex or fragment shader */ export const compileshader = ( gl: webgl2renderingcontext, type: program_type, source: string ) => { let shader; if (type === program_type.vertex) { shader = gl.createshader(gl.vertex_shader); } else { shader = gl.createshader(gl.fragment_shader); } if (!shader) return; gl.shadersource(shader, source); gl.compileshader(shader); if (!gl.getshaderparameter(shader, gl.compile_status)) { console.error(gl.getshaderinfolog(shader)); return null; } return shader; }; we use this utility function to create the program: /** * creates a program that is made up of a vertex shader and a fragment shader */ export const createprogram = ( gl: webgl2renderingcontext, vertexshadersource: string, fragmentshadersource: string ) => { // obtain the shaders const vertexshader = compileshader( gl, program_type.vertex, vertexshadersource ); const fragmentshader = compileshader( gl, program_type.fragment, fragmentshadersource ); // create a program const program = gl.createprogram(); if (!program || !vertexshader || !fragmentshader) { throw \"could no create program\"; } // attach the shaders to this program gl.attachshader(program, vertexshader); gl.attachshader(program, fragmentshader); gl.linkprogram(program); if (!gl.getprogramparameter(program, gl.link_status)) { throw \"could not initialize shaders\"; } // use this program instance gl.useprogram(program); return program; }; once the program has been created, we populate our buffers: /** draws square on center of clipspace x in (-1, 1), y in (-1, 1) * 0->(-0.5, 0.5) 3->(0.5, 0.5) * | / | * | / | * | / | * | / | * 1->(-0.5, -0.5) 2->(0.5, -0.5) * */ // define vertices for position on space: the depth (z) is not important for now const vertices = [-0.5, 0.5, 0, -0.5, -0.5, 0, 0.5, -0.5, 0, 0.5, 0.5, 0]; // define indices for identifying triangles that make up the geometry // using counter-clock wise order // first triangle is made up from the vertices 0, 1, and 2, the second triangle // is made up of vertices 1, 2 and 3 indices = [0, 1, 3, 1, 2, 3]; // set up vbo verticesbuffer = gl.createbuffer(); gl.bindbuffer(gl.array_buffer, verticesbuffer); gl.bufferdata(gl.array_buffer, new float32array(vertices), gl.static_draw); // set up ibo indicesbuffer = gl.createbuffer(); gl.bindbuffer(gl.element_array_buffer, indicesbuffer); gl.bufferdata( gl.element_array_buffer, new uint16array(indices), gl.static_draw ); // unbind buffers gl.bindbuffer(gl.array_buffer, null); gl.bindbuffer(gl.element_array_buffer, null); now, in order to draw, we bind our buffers again and the we bind and enable the attributes: // clear the scene gl.clear(gl.color_buffer_bit | gl.depth_buffer_bit); gl.viewport(0, 0, gl.canvas.width, gl.canvas.height); // bind the vertex buffer with an attribute gl.bindbuffer(gl.array_buffer, verticesbuffer); // obtain attribute instance const vertexpositionattr = gl.getattriblocation(program, \"avertexposition\"); // bind attibute to buffer and set some metadata gl.vertexattribpointer(vertexpositionattr, 3, gl.float, false, 0, 0); // enable attribute gl.enablevertexattribarray(vertexpositionattr); // bind ibo gl.bindbuffer(gl.element_array_buffer, indicesbuffer); // draw to the scene using triangle primitives gl.drawelements(gl.triangles, indices.length, gl.unsigned_short, 0); // unbind buffers gl.bindbuffer(gl.array_buffer, null); gl.bindbuffer(gl.element_array_buffer, null); vertex array objects vertex array objects (vaos) allow you to store all of the vertex/index binding information for a set of buffers in a single, easy to manage object. this is an important feature that should always be used, since it significantly reduces rendering times. when not using vaos, all attributes data is in global webgl state, which means that calling functions such as gl.vertexattribpointer, gl.enablevertexattribarray, and gl.bindbuffer(gl.element_array_buffer, buffer) manipulates the global state. this leads to performance loss, because before any draw call, we would need to set up all vertex attributes and set the element_array_buffer where indexed data is being used. with vaos, we would set up all attributes during our application's initialization and simply bind the data at render, yielding much better performance. so how would we use a vao. there are two steps that change, firstly when we populate our data we create a vao object alongside our vbo and ibo. and we also create create and enable here our vertex attributes. // define vertices for position on space: the depth (z) is not important for now const vertices = [-0.5, 0.5, 0, -0.5, -0.5, 0, 0.5, -0.5, 0, 0.5, 0.5, 0]; // define indices for identifying triangles that make up the geometry // using counter-clock wise order // first triangle is made up from the vertices 0, 1, and 2, the second triangle // is made up of vertices 1, 2 and 3 indices = [0, 1, 3, 1, 2, 3]; // set up vao vao = gl.createvertexarray(); gl.bindvertexarray(vao); // set up vbo (used inside vao) const verticesbuffer = gl.createbuffer(); gl.bindbuffer(gl.array_buffer, verticesbuffer); gl.bufferdata(gl.array_buffer, new float32array(vertices), gl.static_draw); // tell vao how to use the current bound buffer (vertices buffer!) // refer to 01_square.html and see how now the definition of how the data should // be retrived is done now on initialization instead of on render. // obtain attribute instance const vertexpositionattr = gl.getattriblocation(program, \"avertexposition\"); gl.enablevertexattribarray(vertexpositionattr); gl.vertexattribpointer(vertexpositionattr, 3, gl.float, false, 0, 0); // set up ibo indicesbuffer = gl.createbuffer(); gl.bindbuffer(gl.element_array_buffer, indicesbuffer); gl.bufferdata( gl.element_array_buffer, new uint16array(indices), gl.static_draw ); // unbind buffers gl.bindvertexarray(null); gl.bindbuffer(gl.array_buffer, null); gl.bindbuffer(gl.element_array_buffer, null); and, in order to draw we simply bind our vao and our ibo to be used with drawelements. // clear the scene gl.clear(gl.color_buffer_bit | gl.depth_buffer_bit); gl.viewport(0, 0, gl.canvas.width, gl.canvas.height); // bind vao gl.bindvertexarray(vao); // bind ibo gl.bindbuffer(gl.element_array_buffer, indicesbuffer); // draw to the scene using triangle primitives gl.drawelements(gl.triangles, indices.length, gl.unsigned_short, 0); // unbind buffers gl.bindvertexarray(null); gl.bindbuffer(gl.element_array_buffer, null); drawelements modes triangles: webgl will use the first three indices defined in your ibo to construct the first triangle, the next three to construct the second triangle, and so on. lines: will instruct webgl to take each consecutive pair of indices defined in the ibo and draw lines by taking the coordinates of the corresponding vertices. points: webgl will not generate surfaces. instead, it will render the vertices that we had defined using the index array. lines_loop: draws a closed loop connecting the vertices defined in the ibo to the next one. line_strip: is similar to line_loop. the difference is that webgl does not connect the last vertex to the first one. triangle_strip: draws connected triangles. every vertex is specified after the first three. triangle_fan: fan creates triangles in a similar way to triangle_strip. however, the first vertex defined in the ibo is taken as the origin of the fan (the only shared vertex among consecutive triangles). webgl as a state machine: buffer manipulation when dealing with buffers for the getparameter, getbufferparameter, and isbuffer functions, new information about the state of the rendering pipeline becomes available to us. getparameter(parameter), we use parameter to retrieve a reference to the currently-bound vbo (parameter=array_buffer_binding) or to retrieve a reference to the currently-bound ibo (parameter=element_array_buffer_bindings). we can also query the size and the usage of the currently-bound vbo and ibo using getbufferparameter(type, parameter), where type can have the following values: array_buffer: to refer to the currently-bound vbo element_array_buffer: to refer to the currently-bound ibo and parameter can have the following values: buffer_size: returns the size of the requested buffer buffer_usage: returns the usage of the requested buffer finally, isbuffer(object) will return true if the object is a webgl buffer, or false with an error when the buffer is invalid. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/CG/RTGW/01.html",
    "title": "Getting Started",
    "body": " index search search back getting started contents software and hardware based rendering server and client based rendering retained and immediate mode rendering elements in a webgl application accessing the webgl context webgl is a 3d graphics library that enables modern web browsers to render 3d scenes in a standard and efficient manner. software and hardware based rendering the first distinction we should make is whether we are using any special graphics hardware. on one hand, we can talk about software-based rendering for cases where all required calculations to render 3d scenes are performed using the computer's central processing unit (cpu). on the other hand, as is the case with webgl, we use the term hardware-based rendering for scenarios where there is a gpu performing 3d graphics computations. hardware-based rendering is much more efficient than software-based rendering, because the former involves dedicated hardware handling the necessary operations. server and client based rendering the second distinction to make is whether the rendering process is happening locally or remotely. when the image that needs to be rendered is too complex, the render will most likely occur remotely. we call this server-based rendering. the opposite of this approach takes place when rendering occurs locally. we call this client-based rendering. webgl offers a client-based rendering approach: the processing required to obtain an image is all performed locally using the client's graphics hardware. webgl presents several advantages javascript programming automatic memory management pervasiveness performance zero compilation retained and immediate mode rendering in th retained-mode the graphics library maintains a scene model in memory, to change what is rendered, the application issues a command to update the scene. in the inmediate-mode each time a new frame is drawn the application issues all drawing commands required to describe the entire scene. retained-mode rendering can be simpler to use, because the api does more of the work for you, such as initialization, state maintenance, and cleanup. however, it is often less flexible since the api forces its own particular scene model; it can also have higher memory prerequisites. immediate-mode rendering, on the other hand, as offered with webgl, is much more flexible and can implement targeted optimizations. elements in a webgl application some of these common elements include: canvas: the placeholder where our scene is rendered. objects: the 3d entities that make up the scene. lights camera accessing the webgl context a webgl context is an object through which we can access webgl functions and attributes. <script type=\"text/javascript\"> 'use strict'; function init() { const canvas = document.getelementbyid('webgl-canvas'); // ensure we have a canvas if (!canvas) { console.error('sorry! no html5 canvas was found on this page'); return; } const gl = canvas.getcontext('webgl2'); } // call init once the document has loaded window.onload = init; </script> a webgl context can be understood as a state machine: once you modify attributes, the modifications persist until later modifications. for example: const color = gl.getparameter(gl.color_clear_value); here gl.color_clear_value is one of the webgl context attributes. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/CG/RTGW/index.html",
    "title": "Real-Time 3D Graphics with WebGL 2",
    "body": " index search search back real-time 3d graphics with webgl 2 getting started rendering lights camera animations colors, depth testing and alpha blending textures picking $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/CG/RTGW/03.html",
    "title": "Lights",
    "body": " index search search back lights contents positional versus directional lights normals materials using lights normals and materials in the pipeline parallelism and the difference between attributes and uniforms shading methods and light-reflection models shading interpolation methods goraud versus phong shading light-reflection models lambertian reflection model phong reflection model summary opengl es shading language essl storage qualifier types vector components operators and functions goraud shading with phong reflection model vertex shader light reflection fragment shader goraud shading with lambertian reflection model phong shading with phong lighting in practice how to create a program positional lights positional versus directional lights light sources can be positional or directional. a light source is called positional when its location will affect how the scene is lit. directional lights are lights that produce the same luminous result, regardless of their position. directional lighting assumes that the light is coming uniformly from one direction. normals normals are vectors that are perpendicular to the surface we want to illuminate. normals represent the orientation of the surface. by definition, the cross-product of vectors \\(a\\) and \\(b\\) will be a vector perpendicular to both vectors \\(a\\) and \\(b\\). what about the vertices that are shared by more than one triangle? each shared vertex normal will receive a contribution from each of the triangles in which the vertex appears. for example, say that the p1 vertex is shared by the #1 and #2 triangles, and that we have already calculated the normals for the vertices of the #1 triangle. then, we need to update the \\(p_1\\) normal by adding up the calculated normal for \\(p_1\\) on the #2 triangle. this is a vector sum. materials in webgl, the material of an object can be modeled by several parameters, including its color and texture. material colors are usually modeled as triplets in the rgb (red, green, blue) space. textures, on the other hand, correspond to images that are mapped onto the surface of the object. this process is usually called texture mapping. using lights, normals, and materials in the pipeline let's revisit the pipeline and see where lights, normals, and materials fit in: normals are defined on a vertex-per-vertex basis; therefore, normals are modeled as a vbo and are mapped using an attribute, as shown in the preceding diagram. lights and materials are passed as uniforms. uniforms are available to both the vertex shader and the fragment shader, we can calculate how the light is reflected on a vertex-by-vertex basis (vertex shader) or on a fragment-per-fragment basis (fragment shader). parallelism and the difference between attributes and uniforms when a draw call is invoked (using drawarrays or drawelements), the gpu will launch several copies of the vertex shader in parallel. each copy will receive a different set of attributes. all of the copies of the vertex shaders will receive the same uniforms. shading methods and light-reflection models shading refers to the type of interpolation that is performed to obtain the final color for every fragment in the scene. the lighting model determines how the normals, materials, and lights need to be combined to produce the final color. shading/interpolation methods goraud interpolation: calculates the final color in the vertex shader. the vertex normals are used to perform this calculation. then, using a varying variable, the final color for the vertex is passed to the fragment shader. phong interpolation: calculates the final color in the fragment shader. each vertex normal is passed from the vertex shader to the fragment shader using a varying. due to the automatic interpolation of varyings provided by the rendering pipeline, each fragment will have a color that is the result of interpolating the colors of the enclosing triangle for each fragment for goraud interpolation or its own normal in the case of phong interpolation. the following diagram summarizes the two interpolation models: the shading only specifies where (vertex or fragment shader) and the type of interpolation (vertex colors or vertex normals) to be used. goraud versus phong shading goraud shading is considered to be faster since the performed calculations are computed per vertex, whereas phong shading is calculated per fragment. the speed in performance does come at the cost of accurate or more realistic interpolation. light-reflection models lambertian reflection model lambertian reflections are commonly used in computer graphics as a model for diffuse reflections, which are the kinds of reflections where an incident light ray is reflected in many angles instead of just one angle, as is the case for specular reflections: the lambertian reflection is usually calculated as the dot product between the surface normal (vertex or fragment normal, depending on the interpolation method used) and the negative of the light-direction vector. then, the number is multiplied by the material and light source colors. the light-direction vector is the vector that starts on the surface and ends on the light source position. it is essentially the vector that maps the light's position to the surface of the geometry. \\begin{align} f = c_lc_m(-l \\circ n) \\end{align} where \\(f\\) is the final diffuse color, \\(c_l\\) is the light diffuse color and \\(c_m\\) is the material diffuse color. given: \\begin{align} -l \\cot n = |-l||n| \\circ \\emptyset \\end{align} if \\(l\\) and \\(n\\) are normalized then \\(|-l| = |n| = 1\\), thus: \\begin{align} -l \\cot n = \\cos \\emptyset \\end{align} and the final color is computed as: \\begin{align} f = c_lc_m(\\cos \\emptyset) \\end{align} phong reflection model the phong reflection model describes the way a surface reflects the light as the sum of three types of reflection. ambient: accounts for the scattered light present in the scene, independent of any light source. diffuse: corresponds to diffuse reflections. a lambertian model is typically used for this component. specular: provides mirror-like reflections. the specular reflection reaches its maximum when we look at the object at an angle that is equal to the reflected light-direction vector. the specular term is modeled by the dot product of two vectors, the eye vector and the reflected light-direction vector. the eye vector originates in the fragment and terminates in the view position (camera). the reflected light-direction vector is obtained by reflecting the light-direction vector upon the surface normal vector. when this dot product equals \\(1\\) (by working with normalized vectors), our camera will capture the maximum specular reflection. so the specular color is computed as follows: \\begin{align} f_s = c_lc_m (r \\circ e)^n \\end{align} where \\(f_s\\) is the final specular color, \\(c_l\\) is the light specular color, \\(c_l\\) is the material specular color, and \\(n\\) is the shininess factor. if \\(r\\) and \\(e\\) are normalized, then \\(r \\circ e = \\cos \\emptyset\\): \\begin{align} f_s = c_lc_m (\\cos \\emptyset)^n \\end{align} we know that the maximum value of \\(\\cos \\theta\\) is \\(1\\), and it is reached when \\(\\theta = 0\\), that is when \\(r\\) and \\(e\\) have the same direction. summary opengl es shading language (essl) the opengl es shading language (essl) is the language we'll use to write our shaders. storage qualifier variable declarations may have a storage qualifier specified in front of the type: atrribute, uniform, varying or const. types here is a non-exhaustive list of the most common essl types: void: for functions that do not return a value or for an empty parameter list bool: a conditional type, taking on values of true or false int: a signed integer float: a single floating-point scalar vec2: a two-component floating-point vector vec3: a three-component floating-point vector vec4: a four-component floating-point vector bvec2: a two-component boolean vector bvec3: a three-component boolean vector bvec4: a four-component boolean vector ivec2: a two-component integer vector ivec3: a three-component integer vector ivec4: a four-component integer vector mat2: a 2×2 floating-point matrix mat3: a 3×3 floating-point matrix mat4: a 4×4 floating-point matrix sampler2d: a handle for accessing a 2d texture sampler3d: a handle for accessing a 3d texture samplercube: a handle for accessing a cube-mapped texture struct: used to declare custom data structures based on standard types vector components we can refer to each one of the components of an essl vector by its index. however, we can also refer to each component by a letter, as demonstrated in the following table: it’s also possible to use the vector component notation to refer to subsets inside a vector: vec4 v4; v4.rgba; // is a vec4 and the same as just using v4 v4.rgb; // is a vec3 v4.b; // is a float v4.xy; // is a vec2 v4.xgba; // is illegal - the component names do not come from the same set operators and functions one of the major advantages of glsl and essl are the powerful built-in mathematical operators. let's see a few examples of these operations: -x: the negative of the \\(x\\) vector. it produces the same vector in the exact opposite direction. x + y: sum of the \\(x\\) and \\(y\\) vectors. both vectors need to have the same number of components. x - y: subtraction of the \\(x\\) and \\(y\\) vectors. both vectors need to have the same number of components. x * y: if \\(x\\) and \\(y\\) are both vectors, this operator yields a component-wise multiplication. multiplication applied to two matrices returns a linear algebraic matrix multiplication, not a component-wise multiplication. matrixcompmult(matx, maty): component-wise multiplication of matrices. they need to have the same dimensions. x / y: the division operator behaves similarly to the multiplication operator. dot(x, y): returns the dot product (scalar) of two vectors. they need to have the same dimensions. cross(vecx, vecy): returns the cross product (vector) of two vectors. they must both be vec3. normalize(x): returns a vector in the same direction but with a length of \\(1\\). reflect(t, n): reflects the \\(t\\) vector along the \\(n\\) vector. goraud shading with phong reflection model different from the lambertian reflection model, the phong reflection model considers three properties: the ambient, diffuse, and specular, and ultimately yields a more realistic reflection. so now both light and material have three properties: the ambient, diffuse, and specular colors. vertex shader let's cover a sample vertex shader. in this example we are applying goraud shading (we compute the color on the vertex shader and the pass it as a varying to the fragment shader). and in order to compute the color we use the phong reflection model. that is the color is computed as follows: \\begin{align} f_s = c_lc_m (r \\circ e) = c_lc_m (|r||e| \\cos \\emptyset) = c_l c_m (\\cos \\emptyset)^n \\end{align} where: ulightdiffuse is \\(c_l\\) umaterialdiffuse is \\(c_m\\) eyevector is \\(e\\) reflect(ulightdirection, n) is \\(r\\) so the final colo is computed as follows: finalvertexcolor = ia + id + is; // ambient ia = lightambient * materialambient; // diffuse (following lambertian model) id = lightdiffuse * materialdiffuse * lambertcoefficient; // specular is = lightspecular * materialspecular * specularcoefficient; and based on our knowledge of the phong reflection model (the final equation we saw above): float specular = pow(max(dot(lightreflection, eyevector), 0.0), shininess); and we output the computed color vvertexcolor to the fragment shader. note that not all logic is shown on this code: #version 300 es precision mediump float; uniform mat4 umodelviewmatrix; uniform mat4 uprojectionmatrix; uniform mat4 unormalmatrix; // light and materials uniform vec3 ulightdirection; uniform vec4 ulightambient; uniform vec4 ulightdiffuse; uniform vec4 ulightspecular; in vec3 avertexposition; in vec3 avertexnormal; out vec4 vvertexcolor; void main(void) { // normal vec3 n = vec3(unormalmatrix * vec4(avertexnormal, 1.0)); // light direction vec3 light = vec3(umodelviewmatrix * vec4(ulightdirection, 0.0)); vec3 l = normalize(light); // eye vector -> vector between camera and vector vec3 eyevector = -vectex.xyz; // ambient colors vec4 ia = umaterialdiffuse * ulightambient; float lambertterm = dot(n,-l); // if this value is positive the cos between the surface normal and the negative light direction is positive, that is the angle is between 0º and 90º or between 270º and 360º // which means the surface is facing the light if (lambertterm > 0.0) { // diffuse colors vec4 id = umaterialdiffuse * ulightdiffuse * lambertterm; // specular colors: note we retrieve the positive value for the dot product between r and e float specular = pow(max(dot(lightreflection, eyevector), 0.0), shininess); vec4 is = umaterialdiffuse * ulightspecular * specular; } // combine ambient and diffuse vvertexcolor = vec4(vec3(ia + id + is), 1.0); gl_position = uprojectionmatrix * umodelviewmatrix * vec4(avertexposition, 1.0); } light reflection negative light contributions are not physically realistic. light does not contribute negatively to the color intensity; it either contributes positively or not at all. when the surface is concave, some parts of the surface might face away from the light source. the light direction vector (pointing from the surface to the light source) and the normal vector (pointing out from the surface) will form an obtuse angle: the dot product between these two vectors (\\(n \\circ l\\), where \\(n\\) is the normal and \\(l\\) is the light direction) will be negative because the cosine of an obtuse angle is negative. to ensure the lambertian term contributes positively to the diffuse reflection, we clamp the dot product to the range \\([0, 1]\\) using the clamp function. by clamping to zero, we discard these unrealistic negative values. also note how we check for \\(\\cos (\\theta)\\) to be positive where \\(\\theta\\) is the angle between the negative light direction \\(-l\\) and the surface normal \\(n\\). as we have said on the example this means the surface faces the light. if the surface does not face the light it should not contribute to the diffuse reflection nor specular component of the lighting. fragment shader the fragment shader is very simple. we just assign the vvertexcolor varying to the fragcolor output variable. #version 300 es // fragment shaders don't have a default precision so we need // to pick one. mediump is a good default. it means \"medium precision\" precision mediump float; // computed color coming from the vertex shader in vec4 vvertexcolor; // we need to declare an output for the fragment shader out vec4 fragcolor; void main() { fragcolor = vvertexcolor; } remember that the value of the vvertexcolor varying will be different from the one calculated in the vertex shader since webgl will interpolate it by taking the corresponding calculated colors for the vertices surrounding the correspondent fragment (pixel). goraud shading with lambertian reflection model the lambertian reflection model only considers the interaction of diffuse material and diffuse light properties. in short, we assign the final color as follows: \\begin{align} f_d = c_lc_m (-l \\circ n) = c_lc_m (|-l||n| \\cos \\emptyset) = c_l c_m (\\cos \\emptyset) \\end{align} where: ulightdiffuse is \\(c_l\\) umaterialdiffuse is \\(c_m\\) avertexnormal is \\(n\\) ulightdirection is \\(l\\) these can be translated onto a vertex shader as follows: #version 300 es precision mediump float; uniform mat4 umodelviewmatrix; uniform mat4 uprojectionmatrix; uniform mat4 unormalmatrix; uniform vec3 ulightdirection; uniform vec3 ulightdiffuse; uniform vec3 umaterialdiffuse; in vec3 avertexposition; in vec3 avertexnormal; out vec4 vvertexcolor; void main(void) { // calculate the normal vector vec3 n = normalize(vec3(unormalmatrix * vec4(avertexnormal, 1.0))); // normalized light direction vec3 l = normalize(ulightdirection); // dot product of the normal product and negative light direction vector float lambertterm = dot(n, -l); // calculating the diffuse color based on the lambertian reflection model vec3 id = umaterialdiffuse * ulightdiffuse * lambertterm; vvertexcolor = vec4(id, 1.0); // setting the vertex position gl_position = uprojectionmatrix * umodelviewmatrix * vec4(avertexposition, 1.0); } and the fragment shader simply outputs the color computed on the vertex shader: #version 300 es precision mediump float; // expect the interpolated value fro, the vertex shader in vec4 vvertexcolor; // return the final color as fragcolor out vec4 fragcolor; void main(void) { // simply set the value passed in from the vertex shader fragcolor = vvertexcolor; } note that the umodelviewmatrix matrix contains the model-view transformation matrix. we will see how all this works in chapter 4, cameras. for now, suffice to say that this matrix allows us to update vertices' positions, and in this example, the light's position as well. phong shading with phong lighting in practice the phong interpolation calculates the final color for every fragment. this means that the calculation of the ambient, diffuse, and specular terms in the phong model are performed in the fragment shader instead of the vertex shader. this is computationally more intensive than performing a simple interpolation like with goraud shading. however, we obtain a scene that seems more realistic. whereas before we had a normal per vertex, now we need to generate a normal for every pixel so that we can calculate the lambert coefficient for each fragment. we do so by interpolating the normals that we pass to the fragment shader. now, let's take a look at the vertex shader under phong shading: #version 300 es precision mediump float; uniform mat4 umodelviewmatrix; uniform mat4 uprojectionmatrix; uniform mat4 unormalmatrix; in vec3 avertexposition; in vec3 avertexnormal; out vec3 vnormal; out vec3 veyevector; void main(void) { vec4 vertex = umodelviewmatrix * vec4(avertexposition, 1.0); vnormal = vec3(unormalmatrix * vec4(avertexnormal, 1.0)); // eye vector -> vector between camera and vector veyevector = -vec3(vertex.xyz); gl_position = uprojectionmatrix * umodelviewmatrix * vec4(avertexposition, 1.0); } we are using two varyings to pass information to the fragment shader. next we look at the fragment shader, where we can see that it is very similar to the vertex shader for the phong lighting model. #version 300 es precision mediump float; uniform float ushininess; uniform vec3 ulightdirection; uniform vec4 ulightambient; uniform vec4 ulightdiffuse; uniform vec4 ulightspecular; uniform vec4 umaterialambient; uniform vec4 umaterialdiffuse; uniform vec4 umaterialspecular; in vec3 vnormal; in vec3 veyevector; out vec4 fragcolor; void main(void) { vec3 l = normalize(ulightdirection); vec3 n = normalize(vnormal); float lambertterm = dot(n, -l); vec4 ia = ulightambient * umaterialambient; vec4 id = vec4(0.0, 0.0, 0.0, 1.0); vec4 is = vec4(0.0, 0.0, 0.0, 1.0); if (lambertterm > 0.0) { id = ulightdiffuse * umaterialdiffuse * lambertterm; vec3 e = normalize(veyevector); vec3 r = reflect(l, n); float specular = pow( max(dot(r, e), 0.0), ushininess); is = ulightspecular * umaterialspecular * specular; } fragcolor = vec4(vec3(ia + id + is), 1.0); } how to create a program we need to take a look at how we create a program using our webgl context. let's take a look at the structure of the web apps we have developed so far: in this section, we will take a closer look at the initprogram function which allows us to create and compile an essl program. let's take a step-by-step look at initprogram: const initprogram = () => { gl.clearcolor(0.5, 0.5, 0.5, 1); gl.enable(gl.depth_test); program = createprogram( gl, vertexshadersource, fragmentshadersource ); } where createprogram is defined as follows: /** * creates a program that is made up of a vertex shader and a fragment shader */ export const createprogram = ( gl: webgl2renderingcontext, vertexshadersource: string, fragmentshadersource: string ) => { // obtain the shaders const vertexshader = compileshader( gl, program_type.vertex, vertexshadersource ); const fragmentshader = compileshader( gl, program_type.fragment, fragmentshadersource ); // create a program const program = gl.createprogram(); if (!program || !vertexshader || !fragmentshader) { throw \"could no create program\"; } // attach the shaders to this program gl.attachshader(program, vertexshader); gl.attachshader(program, fragmentshader); gl.linkprogram(program); if (!gl.getprogramparameter(program, gl.link_status)) { throw \"could not initialize shaders\"; } // use this program instance gl.useprogram(program); return program; }; we use compileshader function to retrieve the contents of the vertex shader and the fragment shader, both source codes are compiled inside this function. the program's creation is done by calling createprogram, attachshader and linkprogram. /** * compiles the vertex or fragment shader */ export const compileshader = ( gl: webgl2renderingcontext, type: program_type, source: string ) => { let shader: webglshader | null; if (type === program_type.vertex) { shader = gl.createshader(gl.vertex_shader); } else { shader = gl.createshader(gl.fragment_shader); } if (!shader) return; gl.shadersource(shader, source); gl.compileshader(shader); if (!gl.getshaderparameter(shader, gl.compile_status)) { console.error(gl.getshaderinfolog(shader)); return null; } return shader; }; webgl function description createprogram() creates a new program (program) attachshader(program, shader) attaches a shader to the current program linkprogram(program) creates executable versions of the vertex and fragment shaders that are passed to the gpu. getprogramparameter(program, parameter) it allows you to query the program parameters. we use this function to verify whether the program has been successfully linked useprogram(program) it will load the program onto the gpu if the program contains valid code (that is, it has been successfully linked) we also create a mapping for the attributes and the uniforms: program.aposition = gl.getattriblocation(program, \"aposition\"); program.anormal = gl.getattriblocation(program, \"anormal\"); program.umodelviewmatrix = gl.getuniformlocation(program, \"umodelviewmatrix\"); program.uprojectionmatrix = gl.getuniformlocation( program, \"uprojectionmatrix\" ); program.unormalmatrix = gl.getuniformlocation(program, \"unormalmatrix\"); program.umaterialambientcolor = gl.getuniformlocation( program, \"umaterialambientcolor\" ); program.umaterialdiffusecolor = gl.getuniformlocation( program, \"umaterialdiffusecolor\" ); program.umaterialspecularcolor = gl.getuniformlocation( program, \"umaterialspecularcolor\" ); program.ulightambientcolor = gl.getuniformlocation( program, \"ulightambientcolor\" ); program.ulightdiffusecolor = gl.getuniformlocation( program, \"ulightdiffusecolor\" ); program.ulightspecularcolor = gl.getuniformlocation( program, \"ulightspecularcolor\" ); program.ulightdirection = gl.getuniformlocation(program, \"ulightdirection\"); program.ushininess = gl.getuniformlocation(program, \"ushininess\"); here, we have used the following webgl api functions: webgl function description getattriblocation(program, name) this function receives the current program object and a string that contains the name of the attribute that needs to be retrieved. this function then returns a reference to the respective attribute. getuniformlocation(program, name) this function receives the current program object and a string that contains the name of the uniform that needs to be retrieved. this function then returns a reference to the respective uniform. we can use the layout qualifier to look up resource locations. so instead of using getattriblocation: const vertexposition = gl.getattriblocation(program, 'avertexposition'); gl.enablevertexattribarray(vertexposition); we define the attribute's index: const vertexposition = 0; gl.enablevertexattribarray(vertexposition); const colorlocation = 1; gl.enablevertexattribarray(colorlocation); and so the vertex shader becomes: #version 300 es layout (location=0) in vec4 avertexposition; layout (location=1) in vec3 avertexcolor; out vec3 vvertexcolor; void main() { vvertexcolor = avertexcolor; gl_position = avertexposition; } positional lights now, we are going to consider a case where the light source is relatively close to the object it needs to illuminate. when working with positional lights, we need to know the location of the light. we can represent it by using a uniform that we will name ulightposition. we need to calculate each light ray separately. we will do this by using a varying that we will name vlightray. so on the following program we intent to create a positional light source using the phong shading model alongside the phong light model. the vertex shader is very similar to the vertex shader we showed for the phong shading model. but now we also compute a vlightray, that is simply the vector between the vertex (transformed by umodelviewmatrix) and the light position (transformed by umodelviewmatrix). note that now we use ulightposition instead of ulightdirection. #version 300 es uniform mat4 umodelviewmatrix; uniform mat4 unormalmatrix; uniform mat4 uprojectionmatrix; uniform vec3 ulightposition; in vec3 aposition; in vec3 anormal; out vec3 vnormal; out vec3 vlightray; out vec3 veyevector; void main(void) { // obtains transformed vertex position vec4 vertex = umodelviewmatrix * vec4(aposition, 1.0); // obtains transformed light position vec4 light = umodelviewmatrix * vec4(ulightposition, 1.0); // obtains transformed normal (use normal matrix) vnormal = vec3(unormalmatrix * vec4(anormal, 1.0)); // light ray -> vector between vertex and light vector vlightray = vertex.xyz - light.xyz; // eye vector -> vector between camera and vector veyevector = -vec3(vertex.xyz); gl_position = uprojectionmatrix * umodelviewmatrix * vec4(aposition, 1.0); } let's now look at the fragment shader. it is identical to the fragment shader shown for the phong shading model with the difference that now we use vlightray instead of ulightdirection. this basically means that we do not define infinite light sources that have the direction given by ulightdirection, but now we define a single light source that is defined by vlightray. #version 300 es precision highp float; uniform vec4 umaterialdiffusecolor; uniform vec4 umaterialspecularcolor; uniform vec4 umaterialambientcolor; uniform vec4 ulightdiffusecolor; uniform vec4 ulightambientcolor; uniform vec4 ulightspecularcolor; uniform float ushininess; in vec3 vnormal; in vec3 vlightray; in vec3 veyevector; out vec4 fragcolor; void main(void) { vec3 l = normalize(vlightray); vec3 n = normalize(vnormal); vec4 ia = umaterialambientcolor * ulightambientcolor; vec4 id = vec4(0.0, 0.0, 0.0, 1.0); vec4 is = vec4(0.0, 0.0, 0.0, 1.0); float lambertterm = dot(n, -l); if (lambertterm > 0.0) { id = ulightdiffusecolor * umaterialdiffusecolor * lambertterm; vec3 e = normalize(veyevector); vec3 r = reflect(l, n); float specular = pow(max(dot(r, e), 0.0), ushininess); is = ulightspecularcolor * umaterialspecularcolor * specular; } fragcolor = vec4(vec3(ia + id + is), 1.0); } thanks to the interpolation of varyings that is provided by essl, we automatically obtain all the light rays per pixel in the fragment shader: $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/index.html",
    "title": "Computer Science",
    "body": " index search search back computer science programming clean code computer architecture the elements of computer systems computer graphics real-time 3d graphics with webgl 2 web webdev $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/CA/ECS/10.html",
    "title": "Compiler I: Syntax Analysis",
    "body": " index search search back compiler i: syntax analysis contents background lexical analysis gammars parser specification background a compiler is a program that translates programs from a source language into a target language. the translation process, known as compilation, is conceptually based on two distinct tasks: syntax analysis: usually divided further into two substages tokenizing: grouping of input characters into language atoms called tokens. parsing: grouping of tokens into structured statements that have a meaning. code generation figure 10.1 shows these steps: given grammar—the set of rules that define the syntax of a programming language, parsing a program means to determine the exact correspondence between the program's text and the grammar's rules. to do so, we must first transform the program's text into a list of tokens. lexical analysis the first step in analyzing the program's syntax is grouping the characters into tokens, as defined by the language lexicon, while ignoring white space and comments. this task is called lexical analysis, scanning, or tokenizing. figure 10.2 presents the jack language lexicon and illustrates the tokenization of a typical code segment. gammars a grammar is written in a meta-language: a language describing a language. terminals are tokens, nonterminals are names of other rules, and qualifiers are represented by the five symbols |, *, ?, (, and ). see figure 10.3 for an example. we see that the grammar of a programming language can be used to ascertain, without ambiguity, whether given inputs are accepted or rejected. as a side effect of this parsing act, the parser produces an exact correspondence between the given input, on the one hand, and the syntactic patterns admitted by the grammar rules, on the other. the correspondence can be represented by a data structure called a parse tree, also called a derivation tree, like the one shown in figure 10.4a. how can we represent parse trees textually? see figure 10.4b for an example. parser a parser is an agent that operates according to a given grammar. the parser accepts as input a stream of tokens and attempts to produce as output the parse tree associated with the given input. there are several algorithms for constructing parse trees. the top-down approach, also known as recursive descent parsing, attempts to parse the tokenized input recursively, using the nested structures admitted by the language grammar. recursive parsing algorithms are simple and elegant. if the language is simple, a single token lookahead is all that it takes to know which parsing rule to invoke next. grammars that have this lingual property are called ll (1). these grammars can be handled simply and elegantly by recursive descent algorithms, without backtracking. the term ll comes from the observation that the grammar parses the input from left to right, performing leftmost derivation of the input. the (1) parameter informs that looking ahead \\(1\\) token. specification the complete jack grammar is specified in figure 10.5. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/CA/ECS/04.html",
    "title": "Machine Language",
    "body": " index search search back machine language contents overview hardware elements languages instructions the hack machine language background the hack language specification the a-instruction the c-instruction computation specification comp destination specification dest jump directive jump symbols predefined symbols layer symbols variable symbols input output handling overview hardware elements a machine language can be viewed as an agreed-upon formalism designed to manipulate a memory using a processor and a set of registers. memory: refers to the collection of hardware devices that store data and instructions. it is a continuous sequence of cells, also referred to as locations or memory registers, each having a unique address. processor: the processor, central processing unit, or cpu, is a device capable of performing a fixed set of primitive operations: arithmetic, locical operation, memory access operations and control (branching) operations. it consists of an alu, a set of registers, and gate logic that enables it to parse and execute binary instructions. registers: moving data from the memory to the processor is relatively slow. for this reason, processors are normally equipped with several onboard registers inside the processor's chip that serves as high-speed local memory. these registers fall into two categories: data registers, which hold data values, and address registers, which hold values that can be interpreted either as data values or as memory addresses. languages machine language programs can be written in two ways: binary and symbolic. symbolic machine languages are called assembly languages, and the programs that translate them into binary code are called assemblers. the syntax of an assembly language is tightly related to the low-level details of the target hardware: the available alu operations, number and type of registers, memory size, and so on. instructions arithmetic and logical operations: every machine language features instructions for performing basic arithmetic operations: memory access: every machine language features means for accessing and manipulating selected memory locations. this is typically done using an address register, \\(a\\). for example, suppose we wish to set memory location \\(17\\) to the value \\(1\\). we can decide to do so using the two instructions load a,17 followed by load m,1, where, by convention, \\(m\\) stands for the memory register selected by \\(a\\). flow control: to facilitate branching actions, machine languages feature several variants of conditional and unconditional goto instructions, as well as label declaration statements that mark the goto destinations (see figure 4.1). symbols: code that uses symbolic references is much easier to write, debug and maintain. also low-level code that mentions no physical addresses is said to be relocatable. the hack machine language background hack is a \\(16\\)-bit computer, meaning that the cpu and the memory units are designed to process, move, and store, chunks of \\(16\\)-bit values. memory: the hack platform uses two distinct memory units: a data memory and an instruction memory. the data memory (which we also call ram) is a read/write device. so hack instructions can read data from, and write data to, selected ram registers. the current data register is referred as \\(m\\). the instruction memory (which we also call rom) is a read-only device, and programs are loaded into it. the current instruction register is referred as the current instruction. registers: hack instructions are designed to manipulate three \\(16\\)-bit registers: a data register, denoted d, an address register, denoted a, and a selected data memory register, denoted m. addresing: the hack instruction @xxx sets the a register to the value xxx. this has two side effects: it makes the ram register whose address is xxx the selected memory register it makes the value of the rom register whose address is xxx the selected instruction which action to pursue is determined by the subsequent hack instruction. branching: for example jo jump to instruction number \\(29\\) we would use these two instructions: @29, 0;jmp. the first instruction selects the rom[29] register and the second one realizes an unconditional jump to execute said instruction. the hack language also features conditional branching. variables: the xxx in the hack instruction @xxx can be either a constant or a symbol. the use of symbols endows hack assembly programs with the ability to use variables. for example let x = 17 translates to: @17 d=a @x which basically selects the ram register whose address is the value that is bound to the symbol x, and set this register to \\(17\\). we assume that there is an agent who knows how to bind the symbols to addresses (the assembler). on the following figure the show an example of the tranlation of pseudocode to our assembly language: the hack language specification the hack machine language consists of two instructions, specified in figure 4.5. the a-instruction the a-instruction sets the a register to some \\(15\\)-bit value. the binary version consists of two fields: an operation code (op-code), which is \\(0\\), followed by fifteen bits that code a nonnegative binary number. the a-instruction is used for three different purposes: it's the only way to enter a constant into the computer. sets the stage for a subsequent c-instruction that manipulates a selected ram register. sets the stage for a subsequent c-instruction that specifies a jump. the c-instruction the c-instruction answers three questions: what to compute (an alu operation, denoted comp) where to store the computed value (dest) what to do next (jump) in the binary version, the leftmost bit is the c-instruction’s op-code, which is \\(1\\). the next two bits are not used, and are set by convention to \\(1\\). computation specification (comp) the computed function is specified by the a-bit and the six c-bits comprising the instruction's comp field. this \\(7\\)-bit pattern can potentially code \\(128\\) different calculations, of which only the twenty-eight listed in figure 4.5. in the alu the first input feeds from the d register, while the second alu input feeds either from the a register (when the a-bit is \\(0\\)) or from m, the selected data memory register (when the a-bit is \\(1\\)). destination specification (dest) the alu output can be stored in zero, one, two, or three possible destinations, simultaneously. the first and second d-bits code whether to store the computed value in the a register and in the d register, respectively. the third d-bit codes whether to store the computed value in m, the currently selected memory register. jump directive (jump) the jump field of the c-instruction specifies what to do next. there are two possibilities: fetch and execute the next instruction in the program, the default. fetch and execute some other instruction. in the latter case, we assume that the a register was already set to the address of the target instruction. whether or not to jump is determined jointly by the three j-bits. this gives eight possible jump conditions, listed on figure 4.5. symbols assembly instructions can specify memory locations (addresses) using either constants or symbols. predefined symbols r0, r1, …, r15: bound to the values \\(0\\) to \\(15\\). sp, lcl, arg, this, that: bound to the values \\(0\\), \\(1\\), \\(2\\), \\(3\\), and \\(4\\), respectively screen, kbd: bound, respectively, to the values \\(16384\\) and \\(24576\\). which are the base addresses of the screen memory map and the keyboard memory map. layer symbols the syntax (xxx) binds the symbol xxx to the address of the next instruction in the program. variable symbols any symbol xxx appearing in a hack assembly program that is not predefined and is not declared elsewhere using (xxx) is treated as a variable and is bound to a unique running number starting at \\(16\\). input/output handling the hack hardware platform can be connected to two peripheral i/o devices: a screen and a keyboard. screen: the computer interacts with a black-and-white screen organized as \\(256\\) rows of \\(512\\) pixels per row. so it is associated to a memory map stored in an \\(8\\)k memory block of \\(16\\)-bit words, starting at ram address \\(16384\\). each row in the physical screen, starting at the screen's top-left corner, is represented in the ram by \\(32\\) consecutive \\(16\\)-bit words. note that we cannot access individual pixels/bits directly, we must fetch a complete \\(16\\)-bit word (\\(16\\) pixels). keyboard: the computer can interact with a standard physical keyboard via a single-word memory map located at ram address \\(24576\\). when a key is pressed on the physical keyboard, its \\(16\\)-bit character code appears at ram[kbd]. when no key is pressed, the code \\(0\\) appears. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/CA/ECS/07.html",
    "title": "Virtual Marchine I: Processing",
    "body": " index search search back virtual marchine i: processing contents stach machine stack arithmetic virtual memory segments vm specification part i push pop commands arithmetic-logical commands implementation memory segments mapping traditionally, a separate compiler was developed specifically for any given pair of high-level language and low-level machine language. one way to decouple this dependency is to break the overall compilation process into two nearly separate stages the first program, compiler, translates the high-level code into intermediate vm commands; the second program, called vm translator, translates the vm commands further into the machine instructions of the target hardware platform. one benefit is cross-platform compatibility: since the virtual machine may be realized with relative ease on many hardware platforms stach machine the centerpiece of the stack machine is the stack, which is a sequential storage space that grows and shrinks as needed. the push operation adds a value to the top of the stack, and pop operation removes the stack's top value. note that the push/pop logic results in a last-in-first-out (lifo) access logic. stack arithmetic consider the generic operation \\(x \\text{op} y\\), where the operator \\(\\text{op}\\) is applied to the operands \\(x\\) and \\(y\\). in a stack machine, this operation is carried out as follows: the operands \\(x\\) and \\(y\\) are popped off the top of the stack. the value of \\(x \\text{op} y\\) is computed. the computed value is pushed onto the top of the stack. for example, consider the expression \\(d = (2 - x) + (y + 9)\\) shown in figure 7.3a. virtual memory segments high-level languages feature symbolic variables like \\(x, y, sum, count\\), these can be a classlevel static variable, an instance-level field of an object, or a method-level local or argument variable. in virtual machines there are no symbolic variables, instead, variables are represented as entries in virtual memory segments like static, this, local, and argument. the compiler maps the first, second, third, ... static variable found in program onto static 0, static 1, static 2, and so on. the other variable kinds are mapped on the segments this, local, and argument. our vm model features eight memory segments, whose names and roles are listed in figure 7.4. vm specification, part i a vm program is a sequence of vm commands that fall into four categories: push / pop commands arithmetic-logical commands branching commands function commands push / pop commands arithmetic-logical commands arithmetic commands: add, sub, neg comparison commands: eq, gt, lt logical commands: and, or, not the commands add, sub, eq, gt, lt, and, and or have two implicit operands. we mean that the operand is not part of the command syntax since the command is designed to always operate on the two top stack values, there is no need to specify them. implementation the vm abstraction has only one data type: a signed integer. this type is implemented on the hack platform as a two’s complement \\(16\\)-bit value. the vm boolean values true and false are represented as \\(-1\\) and \\(0\\), respectively. the host hack ram consists of \\(32\\)k \\(16\\)-bit words. vm implementations should use the top of this address space as follows: where some slots are already allocated: note that deciding where to locate virtual memory segments in the host ram is a delicate issue. how can we ensure that these open-ended memory segments will not overflow into each other and into other reserved ram areas? we will deal with this on the next chapter. vm implementations manipulate these virtual segments symbolically, using the pointer names. for example, suppose we want to push the value of the d register onto the stack. this operation can be implemented using the logic which can be expressed in hack assembly // selects ram[sp] so we obtain the base address of the top of the stack @sp // sets a to be the value under m, ram[sp] (address of the top of the stack), // so now the selected register (m) will be ram[ram[sp]] -> value of the element on top // of the stack a=m // update m to equal d, ram[ram[sp]] = m m=d // selects ram[sp] as the selected memory register, m = ram[sp] @sp // as we pushed a new element on the stack, we augment the pointer m=m+1 memory segments mapping local, argument, this, that: the base addresses of these segments are stored in the registers lcl, arg, this, and that, respectively. therefore, any access to the i-th entry of a virtual segment (in the context of a vm push/pop segmentname i command) should be translated into assembly code that accesses address in the ram. pointer: the pointer segment contains exactly two values and is mapped directly onto ram locations \\(3\\) and \\(4\\). these ram locations are also called, respectively, this and that. any access to pointer \\(0\\) should result in accessing the this pointer, and any access to pointer \\(1\\) should result in accessing the that pointer. temp: this \\(8\\)-word segment is also fixed and mapped directly on ram locations \\(5\\)–\\(12\\). constant: this virtual memory segment is truly virtual, as it does not occupy any physical ram space. instead, the vm implementation handles any access to constant \\(i\\) by simply supplying the constant \\(i\\). static: are mapped on addresses \\(16\\) to \\(255\\) of the host ram. each reference to static i in a vm program stored in file foo.vm can be translated to the assembly symbol foo.i. the hack assembler will map these symbolic variables on the host ram, starting at address \\(16\\). we note in closing that since the stack begins at address \\(256\\), the implementation limits the number of static variables in a jack program to \\(255 - 16 + 1 = 240\\). $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/CA/ECS/02.html",
    "title": "Boolean Arithmetic",
    "body": " index search search back boolean arithmetic contents binary addition signed binary numbers adders the arithmetic logic unit general-purpose computer systems are required to perform at least the following arithmetic operations on signed integers: addition sign conversion subtraction comparison multiplication division inside computers, everything is represented using binary codes. word size is a hardware term used for specifying the number of bits that computers use for representing a basic chunk of information. the fixed word size implies that there is a limit on the number of values that these registers can represent. for example, suppose we use 8-bit registers for representing integers. this representation can code \\(2^8 = 256\\). to represent numbers greater than, or less than, the maximal and minimal values permitted by the fixed register size is typically implemented by lashing together as many \\(n\\)-bit registers as necessary. binary addition a pair of binary numbers can be added bitwise from right to left by adding the two rightmost bits (lest significant bits or lsb). next, we add the resulting carry bit to the sum of the next pair of bits. we continue until the two left most significan bits (msb) are added. if the most significant bitwise addition generates a carry of 1, we have what is known as overflow. signed binary numbers we use two's complement (also known as radix complement) for representing signed numbers in binary code. given a word size of \\(n\\) bits, the two's complement for negative \\(x\\) is given by the binary code of \\(2^n - x\\). the two’s complement representation has the following attractive properties: the system codes signed numbers, ranging from \\(-(2^{n-1})\\) to \\(2^{n-1} - 1\\) the code of any nonnegative number begins with a \\(0\\). the code of any negative number begins with a \\(1\\). to obtain the binary code of \\(-x\\) flip all the bits of x and add 1 to the result. subtraction is handled as a special case of addition. adders half adders: adds two bits, outputs two bits. full adder: adds three bits, outputs two bits. adder: adds two \\(n\\)-bit numbers. incrementer: adds \\(1\\) to a given number (spoiler: this will enable fetching the next instruction from memory, after executing the current one). the arithmetic logic unit an arithmetic logic unit is a chip designed to compute a set of arithmetic and logic operations. exactly which operations an alu should feature is a design decision. this alu design is unique to the computer built in nand to tetris, named hack. as seen in figure 2.5a, the hack alu operates on two \\(16\\)-bit two's complement integers, denoted \\(x\\) and \\(y\\), and on six \\(1\\)-bit inputs, called control bits. these control bits tell the alu which function to compute. the exact specification is given in figure 2.5b. note that each one of the six control bits is associated with a standalone, conditional micro-action. the six directives are to be performed in order: we either set the \\(x\\) and \\(y\\) inputs to \\(0\\), or not we either negate the resulting values, or not we compute either \\(+\\) or \\(\\&\\) on the preprocessed values we either negate the resulting value, or not. all these settings, negations, additions, and conjunctions are \\(16\\)-bit operations. note that the alu actually computes a total of sixty-four functions, since six control bits code that many possibilities. we’ve decided to focus on, and document, only eighteen of these possibilities, since these will suffice for supporting the instruction set of our target computer system $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/CA/ECS/11.html",
    "title": "Compiler II: Code Generation",
    "body": " index search search back compiler ii: code generation contents code generation handling variables compiling expressions compiling strings compiling statements return let do if while handling objects compiling constructors compiling methods compiling arrays code generation we have to figure out how to systematically translate expressions, statements, subroutines, and the handling of variables, objects, and arrays into sequences of stack-based vm commands that execute the desired semantics on the target virtual machine. handling variables one of the basic tasks of compilers is mapping the variables declared in the source high-level program onto the host ram of the target platform. in nand to tetris there are no mapping complications: all the primitive types in jack are 16-bit wide, and so are the addresses and words of the hack ram. thus, every jack variable, including pointer variables holding 16-bit address values, can be mapped on exactly one word in memory. the second challenge faced by compilers is that variables of different kinds have different life cycles. class-level static variables are shared globally by all the subroutines in the class. therefore, a single copy of each static variable should be kept alive during the complete duration of the program’s execution. the good news is that we've already handled all these difficulties. in our two-tier compiler architecture, memory allocation and deallocation are delegated to the vm level. all we have to do now is map jack static variables on static 0, static 1, static 2, ...; field variables on this 0, this 1, ...; local variables on local 0, local 1, ...; and argument variables on argument 0, argument 1, .... the variable properties can be managed conveniently using a symbol table. when a static, field, local, or argument variable is declared in the source code, the compiler allocates it to the next available entry in the corresponding static, this, local, or argument vm segment. to enable separate namespaces, each identifier is implicitly associated with a scope. jack compilers can realize the scope abstractions by managing two separate symbol tables as seen in figure 11.2. when the compiler fails to find the variable in the table associated with the current scope, it looks it up outward. compiling expressions in jack, expressions are written using infix notation. in contrast, our compilation's target language is postfix. we need an algorithm that knows how to parse an infix expression and generate from it as output postfix code. figure 11.4 presents one such algorithm. figure 11.5 gives the complete grammatical definition of jack expressions, along with several examples of actual expressions consistent with this definition. compiling strings each time a string constant comes up in a high-level statement or expression, the compiler generates code that calls the string constructor. next, the compiler initializes the new object with the string characters by generating a sequence of calls to the string method appendchar, one for each character. compiling statements the jack programming language features five statements: let, do, return, if, and while. return first, we call the compileexpression routine, which generates vm code designed to evaluate and put the expression’s value on the stack. next, we generate the vm command return. let since parsing is a left-to-right process, we begin by remembering the varname. next, we call compileexpression, which puts the expression's value on the top of the stack. finally, we generate the vm command pop varname, (where varname is for example, local 3, static 1, and so on). with this we store the top value of the stack onto varname. do here we discuss the compilation of function calls of the form do classname.functionname (exp1, exp2, ..., expn). the do abstraction is designed to call a subroutine for its effect, ignoring the return value. to compile it we call compileexpression and then get rid of the topmost stack element (the expression's value) by generating a command like pop temp 0. if/while one of the challenges faced by compiler developers is expressing the semantics of high-level control flow statements using nothing more than goto primitives. figure 11.6 shows how this gap can be bridged systematically. the compiler starts by calling compileexpression, which generates vm commands designed to compute and push the expression's value onto the stack. the compiler then generates the vm command not, designed to negate the expression's value. next, the compiler creates a label, say l1, and uses it for generating the vm command if-goto l1. handling objects each object is implemented physically as a memory block. the reference variable, also known as an object variable, or pointer, contains the memory block's base address. the heap is used as a memory pool from which memory blocks are carved, as needed, for representing new objects. when an object is no longer needed, its memory block can be freed. any methodis designed to operate on a placeholder known as the current object, or this. when vm commands make references to this 0, this 1, this 2, and so on, they should effect the fields of the current object. how do we align the this segment with the current object? according to the vm specification, the pointer this (referred to as pointer 0) is designed to hold the base address of the memory segment this. thus, to align the this segment with the current object, we can push its value (which is an address) onto the stack and then pop it into pointer 0. versions of this initialization technique are used conspicuously in the compilation of constructors and methods. compiling constructors compiling constructor calls: first, one declares a variable of some class type. at a later stage, one can instantiate the object by calling a class constructor, for example, let p = point.new(2,3). on this second step first, the constructor allocates a memory block of the required size. second, when the constructorterminates its execution, it returns to the caller the base address of the allocated memory block. figure 11.7 shows how this abstraction can be realized. the physical addresses \\(6012\\) and \\(9543\\) are irrelevant; the high-level code as well as the compiled vm code have no idea where the objects are stored in memory; the references to these objects are strictly symbolic, via p1 and p2 in the high-level code and local 0 and local 1 in the compiled code. compiling constructors: note that a constructor is a subroutine what makes the compilation of a constructor special is that in addition to treating it as a regular subroutine, the compiler must also generate code that (i) creates a new object and (ii) makes the new object the current object (also known as this) (see figure 11.8). the creation of a new object requires finding a free ram block sufficiently large to accommodate the new object’s data and marking the block as used. these tasks are delegated to the host operating system. before calling memory.alloc, the compiler determines the size of the required memory block. this can be readily computed from the class-level symbol table. for example: push constant 2 call memory.alloc pop pointer 0 this vm code allocates a total of two words of memory and saves the base address returned by memory.alloc on this (or pointer 0). according to the jack language specification, every constructor must end with a return this statement. this convention forces the compiler to end the constructor's compiled version with push pointer 0 and return so the object's base address is on top of the stack. compiling methods we'll describe how to compile method calls and then how to compile the methods themselves. compiling method calls: unlike functions, methods are subroutines that always operate on a given object, and it's the caller's responsibility to specify this object. the compiler handles object-oriented method calls like p1.distance (p2) as if they were procedural calls like distance(p1, p2). specifically, it translates p1.distance(p2) into push p1, push p2, call distance. to compile the method call varname.methodname(exp1, exp2, ..., expn), we start by generating the command push varname. if the method call mentions no varname, we push the symbol table mapping of this. next, we call compileexpressionlist, that generates code for all the expressions defined for arguments. finally, we generate the command call classname.methodname n+1 informing that\\(n\\) arguments were pushed onto the stack. see figure 11.9 for an example. compiling methods: any is designed to operate on the current object, represented by the built-in identifier this. one can write an entire method without ever mentioning this. so how does the jack compiler handle expressions like x – other.getx()? first, it looks up x in the symbol tables and finds that it represents the first field in the current object. which, according to the method call contract, it must be the first argument that was passed by the method's caller. therefore, from the callee’s perspective, the current object must be the object whose base address is the value of argument 0. see figure 11.10 for the details. turning our attention to the compiled version, note that the code starts with push argument 0, followed by pop pointer 0. these commands set the method's this pointer to the value of argument 0, which contains the base address of the object on which the method was called to operate (p1). thus, from this point onward, the method’s this segment is properly aligned with the base address of the target object. compiling arrays arrays are similar to objects. in jack, arrays are implemented as objects, concretely as instances of an array class, which is part of the operating system. with the difference that the array abstraction allows accessing array elements using an index. using pointer notation, observe that arr[i] can be written as *(arr + i) that is, memory address arr + i. to compute the physical address of arr[i], we execute push arr, push i, add, which results in pushing the target address onto the stack. next, we execute pop pointer 1. according to the vm specification, this action stores the target address in the method’s that pointer, which has the effect of aligning the base address of the virtual segment that with the target address. see figure 11.11 for the details. it doesn’t work for a[i] = b[j]. the good news is that this flawed compilation strategy can be easily fixed to compile correctly any instance of let arr[expression1] = expression2. we generate the command push arr, calling compileexpression, and generating the command add. this sequence puts the target address (arr + expression1) at the stack's top. we call compileexpression, which will end up putting at the stack's top the value of expression2. we save this value (pop temp 0). this operation has the nice side effect of making (arr + expression1) the top stack element. thus we can now pop pointer 1 (set that to the value of (arr + expression1)), push temp 0(saves the value of expression2 on the stack), and pop that 0 (sets the value under address (arr + expression1) to expression2). $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/CA/ECS/01.html",
    "title": "Boolean Logic",
    "body": " index search search back boolean logic contents boolean algebra logic gates primitive and composite gates hardware construction specification multi-bit versions of basic gates multi-way versions of basic gates boolean algebra boolean algebra manipulates two-state binary values. on figure 1.1 we present three commonly used boolean functions, also known as boolean operators. these functions are named and, or, and not. figure 1.2 begs the question: what makes and, or, and not more interesting? a deeper answer is that various subsets of logical operators can be used for expressing any boolean function, and {and, or, not} is one such subset. also, any one of these three basic operators can be expressed using nand gates only. every boolean function can be defined using two alternative representations: truth tables or boolean expressions. given a boolean function of n variables represented by a boolean expression, we can always construct from it the function’s truth table and vice-versa. note that every boolean function can be represented by many different yet equivalent boolean expressions. so the ability to simplify a boolean expression is the first step toward hardware optimization. logic gates a gate is a physical device that implements a simple boolean function. gates can be realized with any alternative technology permitting switching and conducting capabilities. many hardware implementations of boolean functions were created, including magnetic, optical, biological, hydraulic, pneumatic, quantum-based, and even domino-based mechanisms. today, gates are typically implemented as transistors etched in silicon, packaged as chips. this means computer scientists don't have to worry about physical artifacts and can be content with the abstract notions of boolean algebra and gate logic, trusting blissfully that someone else will realize them in hardware. primitive and composite gates since all logic gates have the same input and output data types (0's and 1's), they can be combined, creating composite gates of arbitrary complexity. the right side of figure 1.5 gives the gate's internal architecture, or implementation, whereas the left side shows its interface. note that the interface of any given gate is unique, however it can be realized in many different ways. from an efficiency standpoint, the general rule is to try to use as few gates as possible. to sum up, the art of logic design can be described as follows: given a gate abstraction (also referred to as specification, or interface), find an efficient way to implement it using other gates that were already implemented. hardware construction today, hardware designers design the chip architecture using a formalism called hardware description language, or hdl by writing an hdl program. while the tests are carried out using computer simulation. the hardware designer will typically be interested in a variety of parameters such as speed of computation, energy consumption and the overall cost implied by the implementation. all these parameters can be simulated. after all tests and optimizations have been performed the final version of the hdl program can become the blueprint for the physical chip. figure 1.7, shows brief introduction to hdl, using an xor gate example. specification not: this gate outputs the opposite value of its input's value. and: returns 1 when both its inputs are 1, and 0 otherwise or: returns 1 when at least one of its inputs is 1, and 0 otherwise xor: also known as exclusive or, this gate returns 1 when exactly one of its inputs is 1, and 0 otherwise nand: realizes the following boolean function: multiplexer: a multiplexer is a three-input gate (see figure 1.9). the multiplexer uses sel to select and output the value of either \\(a\\) or \\(b\\). demultiplexer: takes a single input value and routes it to one of two possible outputs, according to a selector bit (see figure 1.10). multi-bit versions of basic gates computer hardware is often designed to process multi-bit values—for example 16-bit inputs. multi-bit not: an n-bit not gate applies the boolean operation not to every one of the bits in its n-bit input. multi-bit and: an n-bit and gate applies the boolean operation and to every respective pair in its two n-bit inputs multi-bit or: an n-bit or gate applies the boolean operation or to every respective pair in its two n-bit inputs multi-bit multiplexer: an n-bit multiplexer operates exactly the same as a basic multiplexer, except that its inputs and output are n-bits wide multi-way versions of basic gates these are logic gates that can operate on more than two inputs, for example: multi-way or: an m-way or gate outputs 1 when at least one of its m input bits is 1, and 0 otherwise. multi-way/multi-bit multiplexer: an \\(m\\)-way \\(n\\)-bit multiplexer selects one of its \\(m\\) \\(n\\)-bit inputs, and outputs it to its \\(n\\)-bit output. the selection is specified by a set of \\(k\\) selection bits, where \\(k = \\log_2 m\\). for example, a \\(4\\)-way multiplexer is shown on the following image: $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/CA/ECS/12.html",
    "title": "Operating System",
    "body": " index search search back operating system contents mathematical operations multiplication division square root strings memory management basic memory allocation algorithm improved memory allocation algorithm graphical output character output keyboard input the os is designed to close gaps between the computer's hardware and software, making the computer system more accessible. our os is minimal, aiming at: encapsulating low-level hardware-specific services in high-level programmer-friendly software services. extending high-level languages with commonly used functions and abstract data types. the dividing line between an operating system in this sense and a standard class library is not clear. further, because the os supports the execution of every program that runs on the computer, it must be highly efficient. operating systems are usually written in a high-level language and compiled into binary form. our os is no exception—it is written in jack, just like unix was written in c. mathematical operations normally, addition is implemented in hardware, at the alu level, and subtraction is gained freely, using two's complement method. other arithmetic operations can be handled either by hardware or by software, depending on cost/performance considerations. as a rule, we seek algorithms whose running time is a polynomial function of the input's word size \\(n\\). algorithms whose running time depends on the values of \\(n\\)-bit numbers are unacceptable, since these values are exponential in \\(n\\). multiplication on decimal notation, to compute \\(356\\) times \\(73\\), we line up the two numbers one on top of the other, right-justified. next, we multiply \\(356\\) by \\(3\\). next, we shift \\(356\\) to the left one position, and multiply \\(3560\\) by \\(7\\). the binary version of the multiplication procedure is illustrated in figure 12.1. for each \\(i\\)-th bit of \\(y\\), we shift \\(x\\) \\(i\\) times to the left (same as multiplying \\(x\\) by \\(2^i\\)). we look at the \\(i\\)-th bit of \\(y\\): if it is \\(1\\), we add the shifted \\(x\\) to an accumulator; otherwise, we do nothing. note that \\(2 * shiftedx\\) can be computed either by left-shifting the bitwise representation of \\(shiftedx\\) or by adding \\(shiftedx\\) to itself. either operation lends itself to primitive hardware operations. the multiplication algorithm performs \\(n\\) iterations, where \\(n\\) is the bit width of the \\(y\\) input. in the hack platform, the bit width of all data types is \\(16\\). if we assume that each iteration of the multiplication algorithm entails about ten hack machine instructions, it follows that each multiplication operation will require at most \\(160\\) clock cycles division we can try to subtract large chunks of \\(y\\)'s from \\(x\\) in each iteration. for example, suppose we have to divide \\(175\\) by \\(3\\). we start by asking: what is the largest number \\(x = (90, 80, \\cdots, 10)\\), so that \\(3 \\cdot x \\leq 175\\). the answer is \\(50\\). this accelerated subtraction leaves a remainder of \\(175 - 3 \\cdot 50 = 25\\). moving along, we now ask: what is the largest number \\(x = (9, 8, \\cdots, 1)\\), so that \\(3 \\cdot x \\leq 25\\)? we perform this steps until the remainder is less than \\(3\\). this technique is the rationale behind the dreaded school procedure known as long division. the binary version of this algorithm is identical, except that instead of accelerating the subtraction using powers of \\(10\\) we use powers of \\(2\\). figure 12.2 presents another division algorithm which is as efficient, but more elegant and easier to implement. suppose we have to divide \\(480\\) by \\(17\\). the algorithm shown in figure 12.2 is based on the insight and so on. the depth of this recursion is bounded by the number of times \\(y\\) can be multiplied by \\(2\\) before reaching \\(x\\). this also happens to be, at most, the number of bits required to represent \\(x\\). square root the square root function has two attractive properties. it is monotonically increasing. its inverse function, is a function that we already know how to compute efficiently, multiplication. taken together, these properties imply that we have all we need to compute square roots efficiently, using a form of binary search. figure 12.3 gives the details. since the number of iterations in the binary search that the algorithm performs is bound by \\(\\frac{n}{2}\\) where \\(n\\) is the number of bits in \\(x\\), the algorithm's running time is \\(o(n)\\). strings typically, the string abstraction is supplied by a string class that is part of the standard class library that supports the language. the more challenging string methods are those that convert integer values to strings and strings of digit characters to integer values. string representation of numbers: when numbers are captured from an input device like a keyboard they are cast as strings of characters, each representing one of the digits \\(0\\) to \\(9\\). the subset of relevant characters is: the integer value of character \\(c\\), where \\(48 \\leq c \\leq 57\\) is \\(c - 48\\). conversely, the character code of the integer \\(x\\), where \\(0 \\leq x \\leq 9\\) is \\(x + 48\\). these conversion algorithms can be based on either iterative or recursive logic, so figure 12.4 presents one of each. memory management each time a program creates a new array or a new object, a memory block of a certain size must be allocated for representing the new array or object. and when the array or object is no longer needed, its ram space may be recycled. these chores are done by two classical os functions called alloc and dealloc. the memory blocks for representing arrays and objects are carved from, and recycled back into, a designated ram area called a heap. the agent responsible for managing this resource is the operating system. when the os starts running, it initializes a pointer named heapbase, containing the heap's base address in the ram (in jack, the heap starts just after the stack's end, with heapbase=2048). we’ll present two heap management algorithms: basic and improved. basic memory allocation algorithm the data structure that this algorithm manages is a single pointer, named free, which points to the beginning of the heap segment that was not yet allocated. see figure 12.5a for the details. the basic heap management scheme is clearly wasteful, as it never reclaims any memory space. improved memory allocation algorithm this algorithm manages a linked list of available memory segments, called freelist (see figure 12.5b). each segment in the list begins with two housekeeping fields: the segment's length and a pointer to the next segment in the list. when asked to allocate a memory block of a given size, the algorithm has to search the freelist for a suitable segment. there are two heuristics for doing this search. best-fit: finds the shortest segment that is long enough for representing the required size first-fit: finds the first segment that is long enough next, the length of this segment is updated in the freelist, reflecting the length of the part that remained after the allocation. if no memory was left in the segment, or if the remaining part is practically too small, the entire segment is eliminated from the freelist. when asked to reclaim the memory block of an unused object, the algorithm appends the deallocated block to the end of the freelist. dynamic memory allocation algorithms like the one shown in figure 12.5b may create block fragmentation problems. hence, a defragmentation operation should be considered, that is, merging memory areas that are physically adjacent in memory but logically split into different segments in the freelist. the defragmentation can be done each time an object is deallocated, when alloc() fails to find a block of the requested size, or according to some other, periodical ad hoc condition. we end the discussion of memory management with two simple os functions that have nothing to do with resource allocation. memory.peek(addr) returns the value of the ram at address addr, and memory.poke(addr,value) sets the word in ram address addr to value. these functions play a role in various os services that manipulate the memory. graphical output modern computers render graphical output like animation and video on high-resolution color screens, using optimized graphics drivers and dedicated graphical processing units (gpus). in nand to tetris we abstract away most of this complexity, focusing instead on fundamental graphicsdrawing algorithms and techniques. we assume that the computer is connected to a physical black-and-white screen arranged as a grid of rows and columns, and at the intersection of each lies a pixel. by convention, the columns are numbered from left to right and the rows are numbered from top to bottom. thus pixel \\((0,0)\\) is located at the screen’s top-left corner. we assume that the screen is connected to the computer system through a memory map—a dedicated ram area in which each pixel is represented by one bit. the screen is refreshed from this memory map many times per second by a process that is external to the computer. the most basic operation that can be performed on the screen is drawing an individual pixel specified by \\((x,y)\\) coordinates. this is done by turning the corresponding bit in the memory map on or off. other operations like drawing a line and drawing a circle are built on top of this basic operation. the graphics package maintains a current color that can be set to black or white. all the drawing operations use the current color. since the ram is an \\(n\\)-bit device, this operation requires reading and writing an n-bit value. see figure 12.6. on the next code section we show how a pixel is drawn on our os: function int setpixelonword(int x, int idx) { var int mask; // avoid getting warning of integer constant too big let mask = powersoftwo[idx]; if (drawblack) { // or operation over 000000001000000 // where there is a 1 on the idx-th position // this ensures the idx-th bit is 1 let x = x | mask; } else { // and operation over 111111101111111 // where there is a 0 on the idx-th position // this ensures the idx-th bit is 0 let x = x & -mask; } return x; } /** draws the (x,y) pixel, using the current color. */ function void drawpixel(int x, int y) { var int screenaddress, screenvalue, wordidx; var int col, row; let col = x; let row = y; let screenaddress = basescreenmemory + (32 * row) + (col / 16); // computes the index on the 16-bit word by performing col % 16 let wordidx = col - ((col / 16) * 16); let screenvalue = memory.peek(screenaddress); let screenvalue = screen.setpixelonword(screenvalue, wordidx); do memory.poke(screenaddress, screenvalue); return; } when asked to render a continuous \"line\" between two \"points\" on a grid made of discrete pixels, the best that we can possibly do is approximate the line by drawing a series of pixels along the imaginary line connecting the two points. the procedure for drawing a line from \\((x1,y1)\\) to \\((x2,y2)\\) starts by drawing the \\((x1,y1)\\) pixel and then zigzagging in the direction of \\((x2,y2)\\) until that pixel is reached. see figure 12.7. the following code realizes this algorithm: /** draws a line from pixel (x1,y1) to pixel (x2,y2), using the current color. */ function void drawline(int x1, int y1, int x2, int y2) { var int a, b; var int dx, dy, da, db; var int xdirection, ydirection; let dx = math.abs(x2 - x1); let dy = math.abs(y2 - y1); let a = 0; let b = 0; let da = 0; let db = 0; // vertical line if (dx = 0) { do screen.drawverticalline(x1, math.min(y1, y2), dy); return; } // horizontal line if (dy = 0) { do screen.drawhorizontalline(math.max(x1, x2), y1, dx); return; } // if y1 > y2 we have to always go up, that is we have to decrement y1 if (y1 > y2) { let ydirection = -1; } else { // else we have to always go down, that is we have to increment y1 let ydirection = 1; } // if x1 > x2 we have to always go left, that is we have to decrement x1 if (x1 > x2) { let xdirection = -1; } else { // else we have to always go right, that is we have to increment x1 let xdirection = 1; } while (((da = dx) | (da < dx)) & ((db = dy) | (db < dy))) { do screen.drawpixel(x1 + a, y1 + b); // (da, db) is, let's say the current dx and dy. they store // how many times we have gone (up-down)/(right-left). da being the units to the // \"right-left\" and db being the units \"up-down\". if ((db * dx) < (da * dy)) { // if the b/a ratio, that is the slope of our current line, m1, is below the // slope of the line to be painted (dx / dy), then we should readjust the // next pixel to draw so we augment m1. that means we need to modify the height b. // go up/down let b = b + ydirection; } else { // else we need to decrement the slope m1 by modifying the x-coordinate of // the endpoint of our current line, that is a // go right/left let a = a + xdirection; } let da = math.abs(a); let db = math.abs(b); } return; } figure 12.8 presents an algorithm that uses three routines that we've already implemented: multiplication, square root, and line drawing. the algorithm is based on drawing a sequence of horizontal lines (like the typical line \\(ab\\) in the figure), one for each row in the range \\(y - r\\) to \\(y + r\\). since \\(r\\) is specified in pixels, the algorithm ends up drawing a line in every row along the circle's north-south diameter, resulting in a completely filled circle. a simple tweak can cause this algorithm to draw only the circle's outline, if so desired. and finally the next funcion shows how to implement the algorithm to draw the circle: /** draws a filled circle of radius r<=181 around (x,y), using the current color. */ function void drawcircle(int x, int y, int r) { var int dy, dx, rsquare, dysquare, ysum, ydiff; let dy = 0; let rsquare = r * r; while (dy < (r + 1)) { let dysquare = dy * dy; // y coordinate is computed using original y +- an offset of dy, which takes values in [0, r] let ysum = y + dy; let ydiff = y - dy; // x coordinate is computed using pythagorean theorem, where the triangle's // hypothenuses length is equal to the radious (r) we also know the length of // one of the cathetus equals dy, therefore dx = +-sqrt(r^2 - dy^2) let dx = math.sqrt(rsquare - dysquare); // avoid redrawing middle part of circle if (~(dy = 0)) { // draw upper part do screen.drawline(x - dx, ydiff, x + dx, ydiff); } // draw lower part do screen.drawline(x - dx, ysum, x + dx, ysum); let dy = dy + 1; } return; } character output the character sets that computers use are divided into printable and non-printable subsets. for each printable character in the hack character set, an 11-row-by-8-column bitmap image was designed. taken together, these images are called a font. to handle character spacing, each character image includes at least a \\(1\\)-pixel space before the next character in the row and at least a \\(1\\)-pixel space between adjacent rows (the exact spacing varies with the size and squiggles of individual characters). figure 12.9 shows how our font renders the uppercase letter n. on our os the pixel representation for the characters are stored on a map, indexed by the int value assigned to each character: // initializes the character map array function void initmap() { var int i; let charmaps = array.new(127); // black square, used for displaying non-printable characters. do output.create(0,63,63,63,63,63,63,63,63,63,0,0); // assigns the bitmap for each character in the charachter set. // the first parameter is the character index, the next 11 numbers // are the values of each row in the frame that represents this character. do output.create(32,0,0,0,0,0,0,0,0,0,0,0); // do output.create(97,0,0,0,14,24,30,27,27,54,0,0); // a do output.create(98,3,3,3,15,27,51,51,51,30,0,0); // b do output.create(99,0,0,0,30,51,3,3,51,30,0,0); // c do output.create(100,48,48,48,60,54,51,51,51,30,0,0); // d do output.create(101,0,0,0,30,51,63,3,51,30,0,0); // e do output.create(102,28,54,38,6,15,6,6,6,15,0,0); // f do output.create(103,0,0,30,51,51,51,62,48,51,30,0); // g do output.create(104,3,3,3,27,55,51,51,51,51,0,0); // h ... } // creates the character map array of the given character index, using the given values. function void create(int index, int a, int b, int c, int d, int e, int f, int g, int h, int i, int j, int k) { var array map; let map = array.new(11); let charmaps[index] = map; let map[0] = a; let map[1] = b; let map[2] = c; let map[3] = d; let map[4] = e; let map[5] = f; let map[6] = g; let map[7] = h; let map[8] = i; let map[9] = j; let map[10] = k; return; } the resulting font is a collection of ninetyfive rectangular bitmap images, each representing a printable character. for each printable character, we define an array that holds the character's bitmap. the array consists of 11 elements, each corresponding to a row of 8 pixels. specifically, we set the value of each array entry j to an integer value whose binary representation (bits) codes the 8 pixels appearing in the j-th row of the character’s bitmap. so for example, the number \\(4\\), whose binary representation in \\(8\\) bits is \\(00000100\\), would just color black the third column for the \\(j\\)th row. characters are usually displayed one after the other, from left to right, until the end of the line is reached. the character-writing package maintains a global cursor that keeps track of the screen location where the next character should be drawn. the cursor information consists of column and row counts, say, cursor.col and cursor.row. after a character has been displayed, we do cursor.col++. at the end of the row we do cursor.row++ and cursor.col = 0. when the bottom of the screen is reached, there is a question of what to do next. two possible actions are effecting a scrolling operation or clearing the screen and starting over by setting the cursor to \\((0,0)\\). keyboard input detecting which key is presently pressed is a hardware-specific operation that depends on the keyboard interface. in the hack computer, the keyboard continuously refreshes a \\(16\\)-bit memory register whose address is kept in a pointer named kbd. if a key is currently pressed on the keyboard, that address contains the key’s character code; otherwise, it contains \\(0\\). this contract is used for implementing the keypressed function shown in figure 12.10. the elapsed time between the key pressed and the subsequent key released events is unpredictable. hence, we have to write code that neutralizes this uncertainty. also, when users press keys on the keyboard, we want to give feedback as to which keys have been pressed. typically, we want to display some graphical cursor at the screen location where the next input goes, and, after some key has been pressed, we want to echo the inputted character by displaying its bitmap on the screen at the cursor location. all these actions are implemented by the readchar function. a multicharacter input typed by the user is considered final after the enter key has been pressed, yielding the newline character. until the enter key is pressed, the user should be allowed to backspace, delete, and retype previously typed characters. all these actions are accommodated by the readline function. our input-handling solutions are based on a cascading series of abstractions: the high-level program relies on the readline abstraction, which relies on the readchar abstraction, which relies on the keypressed abstraction, which relies on the memory.peek abstraction, which relies on the hardware. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/CA/ECS/index.html",
    "title": "The Elements of Computer Systems",
    "body": " index search search back the elements of computer systems implementation hardware boolean logic boolean arithmetic memory machine language computer architecture assembler software virtual machine i: processing virtual machine ii: control compiler i: syntax analysis compiler ii: code generation operating system $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/CA/ECS/03.html",
    "title": "Memory",
    "body": " index search search back memory contents memory devices sequential logic flip-flops combinational and sequential logic random access memory counter so far, all the chips were time independent, that is combinatorial. we introduce sequential chips, that depend not only on the inputs in the current time but also on inputs and outputs that have been processed previously. we model the progression of time using a clock that generates an ongoing train of binary signals that we call tick and tock. the time between the beginning of a tick and the end of the subsequent tock is called a cycle. memory devices a data flip flop (dff) is a time-dependent logic gate that can flip and flop between two stable states: representing \\(0\\) and \\(1\\). dffs are used as low-level chip-parts embedded deep within other memory devices (see figure 3.1.). dffs can be used to create \\(1\\)-bit registers and \\(n\\) such registers can be lashed together to create an \\(n\\)-bit register. next, a ram device is constructed using an arbitrary number of such registers. sequential logic on any operation outputs are always delayed, due to at least two reasons: the signal that represent the inputs travel from the outputs of other chips, which takes time. the computations that chips perform also take time. thus, time is an issue we must deal with. as seen at the top of figure 3.2, time is viewed as an arrow that progresses relentlessly forward. this progression is taken to be continuous: between every two time-points there is another time-point, and changes in the world can be infinitesimally small. instead of viewing time as a continuous progression, we break it into fixed-length intervals, cycles. where cycles are atomic and indivisible: changes in the world occur only during cycle transitions; within cycles, the world stands still. this discrete view of time serves two design objectives: it can be used for neutralizing the randomness associated with communications and computation time delays. second, it can be used for synchronizing the operations of different chips across the system. let's focus on the bottom part of figure 3.2, which tracks how a not gate (used as an example) responds to arbitrarily chosen inputs. when we feed the gate with \\(1\\), it takes a while before the gate's output stabilizes on \\(0\\). however, since the cycle duration is—by design—longer than the time delay, when we reach the cycle's end, the gate output has already stabilized on \\(0\\). therefore the cycle's length must be longer than the maximal time delays that can occur in the system. in practice, we design our hardware such that the cycle is sufficiently long to contain any possible time delay taking into acount that, the shorter the cycle, the faster the computer. to sum up, the cycle length is chosen to be slightly longer than the maximal time delay in any chip in the system. typically, the cycles are realized by an oscillator that alternates continuously between two phases labeled \\(0\\)−\\(1\\), low-high, or ticktock. using the hardware’s circuitry, the same master clock signal is simultaneously broadcast to every memory chip in the system. in every such chip, the clock input is funneled to the lower-level dff gates. flip-flops the low-level devices that facilitate the memory/storage abstraction are named flip-flop gates, in our case, data flip-flop or dff, whose interface includes a single-bit data input and a single-bit data output. in addition, the dff has a clock input that feeds from the master clock’s signal. taken together, the data input and the clock input enable the dff to implement the following behaviour \\(out(t) = in(t - 1)\\) combinational and sequential logic the most fundamental sequential gate is the dff, and any chip that includes it is also said to be sequential. as shown in figure 3.4, these sequential chips may also interact with combinational chips. in combinational chips, the introduction of feedback loops is problematic, because the output would depend on itself. however, if the feedback loop goes through a dff gate: the dff introduces an inherent time delay so that the output at time \\(t\\) does not depend on itself but rather on the output at time \\(t - 1\\). the time dependency of sequential chips has an important side effect that serves to synchronize the overall computer architecture. suppose we instruct the alu to compute \\(x + y\\), because of physical constraints the electric signals representing \\(x\\) and \\(y\\) will likely arrive at the alu at different times. it will take some time before the alu’s output stabilizes to the correct result. until then, the alu will generate garbage. random access memory a direct-access memory unit, also called random access memory, or ram, is an aggregate of \\(n\\) register chips (see figure 3.7). counter the counter is a chip that knows how to increment its value by 1 each time unit, aslo known as program counter or pc (see figure 3.8). $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/CA/ECS/05.html",
    "title": "Computer Architecture",
    "body": " index search search back computer architecture contents computer architecture fundamentals central processing unit input and output the hack hardware platform specification central processing unit computer computer architecture fundamentals a computer is based on a fixed hardware platform capable of executing a fixed repertoire of simple instructions which serves as building blocks. moreover the logic of these programs is temporarily stored in the computer's memory, like data. the von neumann architecture, shown in figure 5.1, is based on a central processing unit (cpu), interacting with a memory device, receiving data from some input device, and emitting data to some output device. the term random access memory derives from the important requirement that each randomly selected memory register can be reached instantaneously, that is, within the same cycle. data memory: high-level programs are designed to manipulate abstract artifacts like variables, arrays, and objects. yet at the hardware level, these data abstractions are realized by binary values stored in memory registers. intruction memory: before a high-level program can be executed on a target computer, it must first be translated into the machine language of the target computer. each high-level statement is translated into one or more low-level instructions, which are then written as binary values to a file called the binary, or executable, version of the program. before running a program, we must first load its binary version into the computer's instruction memory. central processing unit the central processing unit (cpu) is in charge of executing the instructions of the program using three main elements: an arithmetic logic unit (alu), a set of registers, and a control unit. arithmetic logic unit: performs all the low-level arithmetic and logical operations. registers: stores interim values temporarily. it the processor's immediate memory. these registers serve various purposes: data registers store interim values address registers store values that are used to address the ram program counter tores the address of the instruction that should be fetched and executed nex instruction register stores the current instruction. control: a computer instruction is a structured package of micro-codes: sequences of one or more bits designed to tell different devices what to do. before an instruction can be executed, it must first be decoded into its micro-codes. next, each micro-code is routed to its designated hardware device (alu, registers, memory). fetch-execute: in each cycle of the program's execution, the cpu fetches a binary machine instruction from the instruction memory, decodes it, and executes it. it also figures out which instruction to fetch and execute next. this is called the fetch-execute cycle. input and output computers interact with a great variety of input and output (i/o) devices. so we use a key element: memory-mapped i/o. this mapping is done by allocating, for each i/o device, a designated area in the computer's memory that acts as its memory map. then low-level computer programs can access any i/o device by manipulating its designated memory map. given the multitude of computer platforms, i/o devices, and different hardware and software vendors standars play a crucial role to realize these low-level interactions between the computer and the external devices. another necessary element is a device driver program, which is added to the computer's operating system. this program controls the way this data is actually rendered on, or generated by, the physical i/o device using the memory map.  the hack hardware platform: specification the hack cpu consists of the alu built in project 2 and three registers named data register (d), address register (a), and program counter (pc). the d register is used solely for storing data values the a register serves one of three different purposes: storing a data value selecting an address on the instruction memory selecting an address on the data memory central processing unit the hack cpu interface is shown in figure 5.2. the cpu expects to be connected to an instruction memory, from which it fetches instructions for execution, and to a data memory, from which it can read, and into which it can write, data values. if the instruction input is an a-instruction, the cpu loads the \\(16\\)-bit instruction value into the a register. if instruction is a c-instruction, then: the cpu causes the alu to perform the computation specified by the instruction the cpu causes this value to be stored in the any of the a,d, or m destination registers specified by the instruction. if one of the destination registers is m, the cpu's outm output is set to the alu output, and the cpu's writem output is set to \\(1\\). otherwise, writem is set to \\(0\\). as long as the reset input is \\(0\\), the cpu uses the alu output and the jump bits of the current instruction to decide which instruction to fetch next. if reset is \\(1\\), the cpu sets pc to \\(0\\). this realizes the fetch step on the fetch-execute cycle. the following figure shows its implementation: computer when the user sets the reset bit to \\(1\\) and then to \\(0\\), the computer starts executing the currently loaded program. this is referred as \"booting the computer.\" (see figure 5.7). for example, when you boot up a pc or a cell phone, the device is set up to run a rom-resident program. this program, in turn, loads the operating system’s kernel (also a program) into the ram and starts executing it. the following figure shows the computer implemetation: $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/CA/ECS/08.html",
    "title": "Virtual Machine II: Control",
    "body": " index search search back virtual machine ii: control contents high level magic branching functions vm specification part ii branching commands function commands high level magic whenever one function calls a function, someone must take care of the following: save the return address, which is the address within the caller's code to which execution must return after the callee completes its execution; save the memory resources of the caller allocate the memory resources required by the callee make the arguments passed by the caller available to the callee's code start executing the callee's code when the callee terminates and returns a value, someone must take care of the following: make the callee's return value available to the caller's code recycle the memory resources used by the callee reinstate the previously saved memory resources of the caller retrieve the previously saved return address resume executing the caller's code, from the return address onward. branching the vm language supports two forms of branching: unconditional branching is effected using a goto symbol command, which means: jump to execute the command just after the label symbol command in the code. conditional branching is effected using the if-goto symbol command, whose semantics is: pop the topmost value off the stack. if it's not false, jump to execute the command just after the label symbol command. otherwise, execute the next command in the code. consider a function that receives two arguments, \\(x\\) and \\(y\\), and returns the product \\(xy\\). this can be done by adding \\(x\\) repetitively to a local variable, say \\(\\text{sum}\\), \\(y\\) times, and then returning sum's value (see figure 8.1.) notice how the boolean condition !(i < y) implemented as: push i push y lt ng is pushed onto the stack just before the if-goto while_end command. functions the only difference between applying a primitive operation and invoking a function is the keyword call preceding the latter. both require the caller to set the stage by pushing arguments onto the stack, both operations are expected to consume their arguments, and both operations are expected to push return values onto the stack figure 8.2 shows a vm program that computes the function \\(\\sqrt{x^2 + y^2}\\). the bottom part of figure 8.2 shows that during run-time, each function sees a private world, consisting of its own working stack and memory segments. we use the term calling chain to refer, conceptually, to all the functions that are currently involved in the program's execution. each function in the calling chain waits for the function that it called to return. thus, the only function that is truly active in the calling chain is the last one. functions normally use local and argument variables. these variables are temporary: the memory segments that represent them must be allocated when the function starts executing and can be discarded when the function returns. this memory management task is complicated by the requirement that function calling is allowed to be arbitrarily nested, as well as recursive. the property that makes this housekeeping task tractable is the linear nature of the call-and-return logic. assume that the current function is foo. suppose that at some point foo wants to call another function, bar, for its effect. at this point we have to put foo's execution on hold until bar will terminate its execution. now, putting foo's working stack on hold is not a problem: because the stack grows only in one direction, the working stack of bar will never override previously pushed values. but how can we save foo's memory segments? if we wish to put these segments on hold, we can push their pointers onto the stack and pop them later. we use the term frame to refer, collectively, to the set of pointer values needed for saving and reinstating the function's state. as shown in figure 8.3, when handling the call functionname command, the vm implementation pushes the caller’s frame onto the stack. at the end of this housekeeping, we are ready to jump to executing the callee's code. we use the function’s name to create a unique symbolic label that marks where the function starts. thus we can generate assembly code that effects a goto functionname. returning from the callee to the caller when the former terminates can be done by: saving the return address just before control is transferred to executing the caller. retrieving the return address and jumping to it just after the callee returns. but where shall we save the return address? we can have the vm translator plant a label right after the instruction call foo and push this label onto the stack. when we later encounter a return command in the vm code, we can pop the previously saved return address off the stack—let's call it returnaddress— and effect the operation goto returnaddress . we now turn to give a step-by-step illustration of how the vm implementation supports the function call-andreturn action in figure 8.4. each call operation is implemented by saving the frame of the caller on the stack and jumping to execute the callee. each return operation is implemented by using the most recently stored frame for getting the return address within the caller’s code and reinstating its memory segments. copying the topmost stack value (the return value) onto the stack location associated with argument 0 jumping to execute the caller's code from the return address onward. figure 8.5. shows the steps taken when calling and returning from a function: vm specification, part ii branching commands label label: labels the current location in the function’s code. only labeled locations can be jumped to. goto label: effects an unconditional goto operation, causing execution to continue from the location marked by the label. if-goto label: effects a conditional goto operation. the stack's topmost value is popped; if the value is not zero, execution continues from the location marked by the label; otherwise, execution continues from the next command in the program. function commands function functionname nvars: marks the beginning of a function named functionname. call functionname nargs: calls the named function. return: transfers execution to the command just following the call command. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/CA/ECS/06.html",
    "title": "Assembler",
    "body": " index search search back assembler contents the hack machine language specification handling instructions handling symbols since the translation from mnemonics and symbols to binary code is straightforward, it makes sense to write low-level programs directly in symbolic notation and have a computer program translate them into binary code. the symbolic language is called assembly, and the translator program assembler. in general, assembly languages use symbols for three purposes: labels: mark locations on the code. variables: act as landmark for arbitrary values. predefined symbols: programs can refer to special addresses in the computer’s memory using agreed-upon symbols, for example screen nad kbd. figure 6.1 lists two versions of the same program written in the hack machine language, both symbolic and binary. the hack machine language specification we distinguish two programs: binary hack program: a binary hack program is a sequence of text lines, each consisting of sixteen 0 and 1 characters. contains the instruction data we load onto the cpu to execute. assembly hack program: an assembly hack program is a sequence of text lines, each being one of thre: assembly instruction: a symbolic a-instruction or a symbolic c-instruction. label declaration: a line of the form (xxx), where xxx is a symbol. comment: a line beginning with two slashes (//) is considered a comment and is ignored. see figure 4.5 for the specification of the hack instruction set: handling instructions for each assembly instruction, the assembler parses the instruction into its underlying fields. for each field, generates the corresponding bit-code, as specified in figure 4.5. if the instruction contains a symbolic reference, resolves the symbol into its numeric value. assembles the resulting binary codes into a string of sixteen \\(0\\) and \\(1\\) characters. writes the assembled string to the output file. handling symbols a common solution is to develop a two-pass assembler. the assembler creates a symbol table and initializes it with all the predefined symbols and their pre-allocated values. in the first pass, the assembler builds a symbol table, adds all the label symbols to the table, and generates no code in the second pass, the assembler handles the variable symbols and generates binary code, using the symbol table. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/NodeJS/events_info.html",
    "title": "Events",
    "body": " index search search back events contents event emitter more listeners http events in node.js it the event-driven approach to programming is very commonly used. meaning the flow of our program is in part controlled by events. event emitter all objects which emit events are instances of eventemitter, which is accessible from the events module: const eventemitter = require('events') const customemitter = new eventemitter() customemitter.on('response', () => { console.log('some other logic here') }) customemitter.emit('response') here we can see that we create an eventemitter object and we listen for the response event with customemitter.on(). the latter function takes the name of the event as its first argument and the callback as its second. in order to emit a concrete event we use customemitter.emit(), which takes the event name as its argument. more listeners we can have more than one listener: const eventemitter = require('events') const customemitter = new eventemitter() customemitter.on('response', (name, id) => { console.log(`data recieved user ${name} with id:${id}`) }) customemitter.on('response', () => { console.log('some other logic here') }) customemitter.emit('response', 'john', 34) where the second listener define a callback that takes name and id as arguments. so when emitting the event we can pass those arguments to the emit function. take into account that the functions' order matter, if you emit and event before you listen for it, the event will never be registered. http events because http.server extends net.server which then extends eventemitter, we can use the methods discussed above. so we can listen for the event request to handle requests from the browser. const http = require('http') // using event emitter api const server = http.createserver() // emits request event // subcribe to it / listen for it / respond to it server.on('request', (req, res) => { res.end('welcome') }) server.listen(5000) $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/NodeJS/json.html",
    "title": "JSON",
    "body": " index search search back json the method res.json() allows us to return a array of objects as the body of the http response: const express = require('express') const app = express() app.get('/', (req, res) => { res.json([{name: 'john'}, {name: 'susan'}]) }) app.listen(5000, () => { console.log('server is listening on port 5000....') }) we can also pass a json file to res.json(): const express = require('express') const app = express() const { products } = require('./data') app.get('/', (req, res) => { res.json(products) }) app.listen(5000, () => { console.log('server is listening on port 5000....') }) where data.js contains: const products = [ { id: 1, name: 'albany sofa', image: 'product-3.jpg', price: 39.95, desc: `i'm baby direct trade farm-to-table hell of`, }] module.exports = products $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/NodeJS/globals.html",
    "title": "Globals",
    "body": " index search search back globals some global variables available __dirname: path of current directory __filename require: function to use modules module: info about current module process: info about the environment where the program is bein executed note that in node there is no window object like in javascript. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/NodeJS/npm.html",
    "title": "NPM",
    "body": " index search search back npm contents installing packages package json scripts nodemon package-lock json uninstalling packages git the node package manager allows us to: reuse our own code in other projects use code written by other developers and share our own solutions. this tool is installed along node. npm calls the reusable code a package (also modules or dependencies), that is basically a folder that contains some js code. note that there is no quality control applied to the packages that are published, so it is the developer's responsibility to check whether the package is secure or not. installing packages you can install a package locally within your project as a local dependency: $ nmp i <packagename> or you can install the package globally, so it can be accessed from any project: $ npm install -g <packagename> if you want to specify a version for the package: $ npm install <packagename>@1.0.0 package.json this file stores important information about the project and the packages, it can be conceived as a manifest file. there are two ways to create it: manually: create package.json in the root folder of the project and define the properties of the project/packages. using npm following the guide (add -y to skip the questions of the guide): \t \t $ npm init \t when the project is initialized, the package.json file is as follows: { \"name\": \"08_project\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"test\": \"echo \\\"error: no test specified\\\" && exit 1\" }, \"keywords\": [], \"author\": \"\", \"license\": \"isc\" } where all those properties are set up during the guide of npm init or set as default with the flag -y. after installing a dependency $ npm i lodash the following property is added: \"dependencies\": { \"lodash\": \"^4.17.21\" } and npm creates the folder node_modules, if it does not already exist, which stores the dependencies code. also, in case of wanting to install dependencies needed only during the development process: $ npm i <package> -d $ npm i <package> --save-dev and so, the property devdependencies is created in pakage.json. scripts the object scripts, which is a property of package.json, can contain the definition of different actions, for example: \"scripts\": { \"start\": \"node app.js\" } so when running npm start our app.js will be executed. for some commands you will need to specify run and the command name as follows: $ npm run dev nodemon this is a package that lets you hot reload your project without having to execute your app constantly. for that, after installing nodemon as a local or global dependency, we specify on package.json: \"scripts\": { \"dev\": \"nodemon app.js\" } if we want to run it: $ npm run dev package-lock.json this file stores the dependencies version of the packages installed as dependencies, as to avoid installing newer version that can be the cause of bugs. because within the package.json only our project's dependencies' versions are specified. uninstalling packages in order to uninstall the package we have a command, that follows the syntax: $ npm uninstall <package> we can also remove it from the dependencies object within package.json. so when you remove package-lock.json and the node_modules folder if you run $ npm install the package that was removed will not be installed. git when using git or other version control tool, it is desirable to create a .gitignore and to specify to avoid the node_modules folder, since its size can get big very easily. so, by just pushing the source code, including package.json, if we want to install all of the project's dependencies' again, on the root folder we run: $ npm install $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/NodeJS/api_ssr.html",
    "title": "API vs SSR",
    "body": " index search search back api vs ssr in express when we talk about apis we are talking about http interfaces to interact our data. the main differences between apis and server side rendering (ssr) are:   api ssr ------------ ------------ -------------- content type json template what is sent send data send template method res.json() res.render() $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/NodeJS/http_basics.html",
    "title": "HTTP Basics",
    "body": " index search search back http basics contents headers request object html file external resources when answering to a request, node requires a method to signal to the server that all of the response headers and body have been sent, and so the server can consider the message complete. that method is res.end() const http = require('http') const server = http.createserver((req, res) => { res.end('home page') }) server.listen(5000) we create a server with http.createserver. this method takes a callback as an argument, which is called every time a user hits the server. next we specify the port on which the server will be listening for requests. the value of this port is somewhat irrelevant in the development environment. headers if we want to provide the metadata about the response we have to provide headers: const http = require('http') const server = http.createserver((req, res) => { res.writehead(200, { 'content-type': 'text/html' }) res.write('<h1>home page</h1>') res.end() }) server.listen(5000) with writehead we specify the headers, in our case we specify the status code (200: ok) and the content type of the response (text/html). the later are called mime-types or media types. then we specify the body of the response with write and finally we finalize the message with end. request object the request object that is an argument of the createserver method has several attributes: req.method: allows you to obtain the method of the user's request, i.e. get, post, put, etc. req.url: contains the url of the user's request. html file as we have seen the method write allows us to define the content of the body as html. however we do not need to write the html code inside the method we can also pass a file as input and the method will serve it's content to the response. const http = require('http') const { readfilesync } = require('fs') const homepage = readfilesync('./index.html') const server = http.createserver((req, res) => { res.writehead(200, { 'content-type': 'text/html' }) res.write(homepage) res.end() }) server.listen(5000) observe that we user readfilesync, we do so because, for one this is an example, and also the file is only read once when the server is created, not every time the user hits the server. external resources when adding external resources to a given html file we also need to handle the request to those resources in our server. const http = require('http') const { readfilesync } = require('fs') const homepage = readfilesync('./index.html') const homestyles = readfilesync('./styles.css') const homeimage = readfilesync('./logo.svg') const server = http.createserver((req, res) => { // home page if (url === '/') { res.writehead(200, { 'content-type': 'text/html' }) res.write(homepage) res.end() } \t// styles else if (url === '/styles.css') { res.writehead(200, { 'content-type': 'text/css' }) res.write(homestyles) res.end() } \t// image/logo else if (url === '/logo.svg') { res.writehead(200, { 'content-type': 'image/svg+xml' }) res.write(homeimage) res.end() } }) note that the content types differ every time, with css we use text/css, with images we use image/svg+xml. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/NodeJS/async_patterns.html",
    "title": "Asynchronous Patterns",
    "body": " index search search back asynchronous patterns contents blocking code promises node s native promises blocking code imagine we have the following piece of code: const http = require('http') const server = http.createserver((req, res) => { if (req.url === '/') { res.end('home page') } if (req.url === '/about') { // blocking code for (let i = 0; i < 1000; i++) { for (let j = 0; j < 1000; j++) { console.log(`${i} ${j}`) } } res.end('about page') } res.end('error page') }) server.listen(5000, () => { console.log('server listening on port : 5000....') }) because inside the second conditional we have a nested for loop which is computationally expensive, when a user accesses the about page, the server is blocked, and so it prevents other users from loading any other page. that is essentially because javascript is single threaded, so by running the nested conditional, the thread is occupied for a period of time, during which the server will not be able to answer to any other request until it is freed. promises a promise is an object that represents the eventual completion (or failure) of an asynchronous operation and its resulting value. so, we can wrap the asynchronous readfile function with a promise: const { readfile, writefile } = require('fs') const gettext = (path) => { return new promise((resolve, reject) => { readfile(path, 'utf8', (err, data) => { if (err) { reject(err) } else { resolve(data) } }) }) } the result of a promise can be accessed as follows: gettext('./content/first.txt') .then((result) => console.log(result)) .catch((err) => console.log(err)) and then, we can define an asynchronous function start that will wait for the execution of gettext: const start = async () => { try { const first = await gettext('./content/first.txt') const second = await gettext('./content/second.txt') console.log(first, second) } catch (error) { console.log(error) } } where you can see that we surround the call with a try-catch statement, which allows us to have more control over the execution flow node's native promises we can use the utils module in order to wrap functions with the promise object: const { readfile, writefile } = require('fs') const util = require('util') const readfilepromise = util.promisify(readfile) const writefilepromise = util.promisify(writefile) const start = async () => { try { const first = await readfilepromise('./content/first.txt', 'utf8') const second = await readfilepromise('./content/second.txt', 'utf8') \t\tawait writefilepromise( './content/result-mind-grenade.txt', `this is awesome : ${first} ${second}`, { flag: 'a' } ) console.log(first, second) } catch (error) { console.log(error) } } but, we can also avoid importing the utils module, by adding .promises when importing the asynchronous functions: const { readfile, writefile } = require('fs').promises const start = async () => { try { const first = await readfile('./content/first.txt', 'utf8') const second = await readfile('./content/second.txt', 'utf8') await writefile( './content/result-mind-grenade.txt', `this is awesome : ${first} ${second}`, { flag: 'a' } ) console.log(first, second) } catch (error) { console.log(error) } } start() $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/NodeJS/mongodb.html",
    "title": "MongoDB",
    "body": " index search search back mongodb contents intro set up mongoose installing connect to mongodb create models schemas getting saving data intro it is a nosql which is structured in collections, where each collection would be used to store a particular type of data in the form of documents: blog collection blog document blog document blog document here each document represent a single item of data, for example, each blog document represents one blog. the data is contained inside the documents in a very similar fashion to json objects, so the documents consist of key-value pairs like so: { \"id\": objectid(12345), \"title\": \"opening party\", \"snippet\": \"all about...\", \"body\": \"lorem ipsum\" } set up we can either install mongodb locally or we can use a cloud database which is already hosted for us. for the latter we will use mongodb atlas. there we create a cluster and inside this new cluster we create a new collection called blog. then we create a user accessing the security -> database access section. once we have our user created, we specify a way to connect to the database, by heading to clusters -> connect your application. we then copy the connection string that we will use as the database uri. observe that this uri needs you to input your password. mongoose now we need to actually connect to the database, we could use the mongodb api package and use the mongodb api, however we will use mongoose that makes it easier to interact with the database. mongoose is a odm (object document mapping) library, which means that it maps the standard mongodb api providing a much easier way to connect to and interact with the database. it does this by allowing us to create simple data models which have query methods to create, get, delete and update database documents. for that we first have to create a schema for the document which define the structure of a type of data or document. for example: blog schema: - title(string), required - snippet(string), required - body(string), required next, what we do is to create a model based on that schema, the model is what actually allows us to communicate with a particular database collection. each model has static methods get, save, delete, etc, that allow us to manage the data. installing $ npm install mongoose connect to mongodb so, now, we import the mongoose package and we use our database uri to connect to it, remember to change password and cluster_name to the values you specified for your database. const express = require('express'); const morgan = require('morgan'); const mongoose = require('mongoose'); // express app const app = express(); // connect to mongodb & listen for requests const dburi = \"mongodb+srv://user:<password>@test.mongodb.net/<cluster_name> mongoose.connect(dburi, { usenewurlparser: true, useunifiedtopology: true }) .then(result => app.listen(3000)) .catch(err => console.log(err)); the connect method is an asynchronous function, so it will execute a callback function when it finished connecting, or an error if the connection failed. in our case, we proceed to start our server when the database is ready. create models & schemas once we have successfully connected to our database, we will create our blog schema. for that, we first create a folder called models and inside it we create blog.js that will contain the following code: const mongoose = require('mongoose'); const schema = mongoose.schema; const blogschema = new schema({ title: { type: string, required: true, }, snippet: { type: string, required: true, }, body: { type: string, required: true }, }, { timestamps: true }); const blog = mongoose.model('blog', blogschema); module.exports = blog; as you can see, we first import mongoose and the schema object that we use to define the blog schema. in order to create a new blog schema we create a new schema object and we specify the different properties and restrictions. we also set and object of options, where we specify that we want mongodb to save the timestamps of updates, creations, etc. next we created a model that is based in the schema we just created with the function model and we pass it the model name (this name is then pluralized, as to then look up the collection that matches it) and the schema instance. getting/saving data in order to work we data, we must import the model we just created. const express = require('express'); const morgan = require('morgan'); const mongoose = require('mongoose'); const blog = require('./models/blog'); // express app const app = express(); // connect to mongodb & listen for requests const dburi = \"mongodb+srv://user:<password>@test.mongodb.net/<cluster_name> mongoose.connect(dburi, { usenewurlparser: true, useunifiedtopology: true }) .then(result => app.listen(3000)) .catch(err => console.log(err)); app.get('/blogs', (req, res) => { blog.find() .then(result => { res.send(result); }) .catch(err => { console.log(err); }); }); app.get('/blogs/:id', (req, res) => { const id = req.params.id; blog.findbyid(id) .then(result => { res.send(result); }) .catch(err => { console.log(err); }); }); here we use the find and findbyid methods to interact with our database. in order to create or delete new blogs: app.post('/blogs', (req, res) => { const blog = new blog(req.body); blog.save() .then(result => { res.redirect('/blogs'); }) .catch(err => { console.log(err); }); }); app.delete('/blogs/:id', (req, res) => { const id = req.params.id; blog.findbyidanddelete(id) .then(result => { res.json({ redirect: '/blogs' }); }) .catch(err => { console.log(err); }); }); in the post method we create a new blog object using the objects from the request body, and then we save it in our database. on the other hand, in order to delete a blog we pass the id as a parameter, we search for it on the database and we delete it. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/NodeJS/routes.html",
    "title": "Routes",
    "body": " index search search back routes contents set up router controller set up in order to set up the routes for our project, we first create a folder called routes that will contain all the javascript files that control routing functionality. in this example we create two files within routes, people.js and auth.js. once we have created them, we include them as middleware to the specific endpoints (/api/people for people.js and /login for auth.js), as follows: const express = require('express') const app = express() const people = require('./routes/people') const auth = require('./routes/auth') app.use('/api/people', people) app.use('/login', auth) app.listen(5000, () => { console.log('server is listening on port 5000....') }) router let's focus now on people.js than controls the routing of /api/people. for that we import the controller of this endpoint and we specify the functions to execute for the different http methods and for the different routes. /: this is the default endpoint /api/people there we specify that the logic for a get request is contained in the getpeople function. /:d: this endpoint allows for specifying an id as a parameter. const express = require('express') const router = express.router() const { getpeople, createperson, createpersonpostman, updateperson, deleteperson, } = require('../controllers/people') router.route('/').get(getpeople).post(createperson) router.route('/:id').put(updateperson).delete(deleteperson) module.exports = router controller the people controller contains: let { people } = require('../data') const getpeople = (req, res) => { res.status(200).json({ success: true, data: people }) } const createperson = (req, res) => { const { name } = req.body if (!name) { return res .status(400) .json({ success: false, msg: 'please provide name value' }) } res.status(201).send({ success: true, person: name }) } const createpersonpostman = (req, res) => { const { name } = req.body if (!name) { return res .status(400) .json({ success: false, msg: 'please provide name value' }) } res.status(201).send({ success: true, data: [...people, name] }) } const updateperson = (req, res) => { const { id } = req.params const { name } = req.body const person = people.find((person) => person.id === number(id)) if (!person) { return res .status(404) .json({ success: false, msg: `no person with id ${id}` }) } const newpeople = people.map((person) => { if (person.id === number(id)) { person.name = name } return person }) res.status(200).json({ success: true, data: newpeople }) } const deleteperson = (req, res) => { const person = people.find((person) => person.id === number(req.params.id)) if (!person) { return res .status(404) .json({ success: false, msg: `no person with id ${req.params.id}` }) } const newpeople = people.filter( (person) => person.id !== number(req.params.id) ) return res.status(200).json({ success: true, data: newpeople }) } module.exports = { getpeople, createperson, createpersonpostman, updateperson, deleteperson, } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/NodeJS/index.html",
    "title": "Node.js",
    "body": " index search search back node.js node.js intro globals modules npm event loop asynchronus patterns events streams http express http basics express api vs ssr json route params query strings middleware http methods routes view engines mongodb mock mongodb environment variables json web tokens projects books directory basic users system real-time chat application collaborative drawing app email sender video streaming platform web scraper $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/NodeJS/http.html",
    "title": "HTTP",
    "body": " index search search back http contents http messages http messages request message: what the user sends response message: what the server sends the messages have the following parts: info about the request: request url, request method (get is the default method), status code, etc. headers: meta information about the request/response, (e.g. \"content type: application/json\" tells the browser that the body is json) body: which is the request payload, or the content of the response. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/NodeJS/middleware.html",
    "title": "Middleware",
    "body": " index search search back middleware contents apply middleware with app use apply multiple middleware example when we are talking about middleware we are typically talking about any type of code and function between getting a certain request and sending the corresponding respond. express allows us to pass middleware as an argument to the app methods. note that middleware runs from top to bottom in our server, so order does matter when specifying middleware. const express = require('express') const app = express() const logger = (req, res, next) => { const method = req.method const url = req.url const time = new date().getfullyear() console.log(method, url, time) next() } app.get('/', logger, (req, res) => { res.send('home') }) app.get('/about', logger, (req, res) => { res.send('about') }) app.listen(5000, () => { console.log('server is listening on port 5000....') }) here we have defined a logger function that tells us some information about the request made. this function is passed as an argument to the app.get() method, and then express passes req, res and next as arguments for the middleware. the next argument is a function that is needed in order to pass the flow to the next middleware and it always has to be invoked, unless the current middleware sends a response and so finishes the message. in any other case, if the next method is not invoked then the browser will be stuck loading because the program flow was halted by not calling the next middleware. the middleware functions that we can use can be ones we code ourselves, express functions or third party software. apply middleware with app.use in order to apply a certain middleware to all the routes we first save the logger on a separate file named logger.js, then we import it into our main app, and we specify its usage as a middleware by app.use. const express = require('express') const logger = require('./logger') const app = express() app.use(logger) with this our logger will be executed every time the user accesses our server. we can also specify an argument like so: const express = require('express') const logger = require('./logger') const app = express() app.use('/api/', logger) this tells express to only use the middleware for the /api route and all its subdomains (i.e. /api/*). apply multiple middleware we now define a new middleware function, that goes by the name of authorize.js, we import it into our app.js and we add it as middleware by using an array. const express = require('express') const logger = require('./logger') const authorize = require('./authorize') const app = express() app.use([logger,authorize]) note that the order matters, meaning the first middleware executed is logger, in this instance, and then the control flow is passed to authorize. we can also define more than one middleware function on one concrete end-point: app.get('/api', [logger, authorize], (req, res) => { res.send('api home page') }) as we can see, we have specified two middleware functions, namely logger and authorize by using an array. example const authorize = (req, res, next) => { // de-structure user object const { user } = req.query if(user == 'alice'){ req.user = { name: 'alice', id: 3 } // yield control flow next() \t} else{ res.status(401).send('unauthorized') } } as you can see the authorize middleware function creates a new object within the request object, which can be accessed from the next middleware, or from the server. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/NodeJS/modules.html",
    "title": "Modules",
    "body": " index search search back modules contents exporting importing built-in modules os fs synchronous asynchronous http encapsulated code, as to only share what we want. node uses commonjs so every file is treated as a module by default. in any .js file we have the global object module: console.log(module) module { id: '.', path: '/home/alba/desktop/nodejs', exports: {}, filename: '/home/alba/desktop/nodejs/02_constants.js', loaded: false, children: [], paths: [ '/home/alba/desktop/nodejs/node_modules', '/home/alba/desktop/node_modules', '/home/alba/node_modules', '/home/node_modules', '/node_modules' ] } exporting so we can treat the attribute exports as an object and pass it whatever values we would like to show to other app that import our module: module.exports = { value1: 'value1', value2: 'value2' } where value1 is the key of the attribute and 'value1' is its value, e.g.: const name = 'john' const surname = 'tuckey' module.exports = { name: name, surname: surname } also, if we only export one object it is sufficient to type: const name = 'john' module.exports = name another way to export is to define explicitly the name of the attributes to export: module.exports.items = ['item1', 'item2'] const person = { name: 'bob' } module.exports.singleperson = person importing now, a module can be imported with the keyword require as follows: const externalmodule = require('./module') console.log(externalmodule) { name: 'john', surname: 'tukey' } another type of syntax could be unrolling the attributes of the export object: const { name, surname } = require('./module') built-in modules some built-in modules are: os path fs (filesystem) http even though there are several more built-in modules. os to import the os built-in module we do: const os = require('os') and we call it by: console.log(`the system uptime is ${os.uptime()} seconds`) fs we can also interact with the file system via the fs module. there are two ways to do so: asynchronously, which is non-blocking synchronously, that is blocking synchronous to exemply both setups, we first de-structure the read and write synchronous methods from the fs module, and then we read and write files. const { readfilesync, writefilesync } = require('fs') // read file with a given path and the corresponding encoding const first = readfilesync('./file.txt', 'utf8') const second = readfilesync('./file2.txt', 'utf8') // write to a file given a path, the content is overwritten writefilesync('./writefile', 'this content will be written') // write to a file given a path, the content is appended writefilesync('./writefile', 'this content will be written', {flag: 'a'}) asynchronous now, in order to access the file system asynchronously, we need a callback, and so we do: const { readfilesync, writefilesync } = require('fs') readfile('./file', 'utf8', (error, result) => { if(error){ console.log(error) return } else{ console.log(result) const first = result // here we can add another read call } }) writefile('./file', 'this is the content', (error, result) => { if(error){ console.log(error) return }else{ console.log(result) } }) where we specify a callback function with the es6 syntax. its first parameter is the error parameter and the second is the result of the operation. the problem with synchronous calls is that they can be very time consuming and they halt the execution, which can be critical when working on time sensitive tasks or when several user call upon these type of functions at a time. http to show the bare basics, we will set up a server: const http = require('http') const server = http.createserver((request, response) => { response.write('this is the index!') response.end() }) // define the port server.listen(5000) that can be accessed on localhost:5000. next, we can code something a little more complex, where the content handed as a response depends on the request: const http = require('http') const server = http.createserver((request, response) => { if(request.url === '/'){ response.end('this is the index') }else if(request.url === '/about'){ response.end('this is the about') }else{ response.end('404') } }) // define the port server.listen(5000) $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/NodeJS/intro.html",
    "title": "NodeJS",
    "body": " index search search back nodejs contents differences between to the browser and nodejs how to get node to evaluate our code nodejs in an environment to run javascript outside of the browser that was build on top of chrome's v8 js engine. it allows for easy development of full stack apps, since both the frontend and the backend are build in the same language, javascript. differences between to the browser and nodejs browser nodejs dom no dom window no window interactive apps server side apps no filesystem filesystem fragmentation versions es6 modules commonjs how to get node to evaluate our code repl (read, eval, print loop) $ node welcome to node.js v16.9.1. type \".help\" for more information. > cli executable $ node 00_app.js large number hey it is my first node app $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/NodeJS/view_engines.html",
    "title": "View Engines",
    "body": " index search search back view engines contents ejs installing set up rendering we have different options: pug ejs (embedded javascript) express handlebars ejs installing we will use ejs in this example. first we download it: $ npm install ejs set up now we specify in our application that we want to use it: const express = require('express') const app = express() // specify view engine and settings app.set('view engine', 'ejs') app.set('views', './views') we use the function set() that is used to specify app settings. there we define ejs as our view engine and then we indicate that the folder where our views are located is /views, which is the default folder. this means we could have omitted that last line and the functionality would remain the same. rendering inside our root folder, we create the folder views and the file index.ejs which has the same syntax as html: <html lang=\"en\"> <head> <meta charset=\"utf-8\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>blog ninja | <%= title %></title> </head> <body> <div class=\"blogs content\"> <h2>all blogs</h2> <% if (blogs.length > 0) { %> <% blogs.foreach(blog => { %> <h3 class=\"title\"><%= blog.title %></h3> <p class=\"snippet\"><%= blog.snippet %></p> <% }) %> <% } else { %> <p>there are no blogs to display...</p> <% } %> </div> </body> </html> so in order to send this template as a response we do: app.get('/', (req, res) => { const blogs = [ {title: 'yoshi finds eggs', snippet: 'lorem ipsum dolor sit amet consectetur'}, {title: 'mario finds stars', snippet: 'lorem ipsum dolor sit amet consectetur'}, {title: 'how to defeat bowser', snippet: 'lorem ipsum dolor sit amet consectetur'}, ]; res.render('index', { title: 'home', blogs }); }); note that we define an array of blog objects, and we pass them as an argument to the template. which then iterates over them to visualize each item. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/NodeJS/http_methods.html",
    "title": "HTTP Methods",
    "body": " index search search back http methods contents get post put delete in this section we will show a few examples of the different http methods in express, take into account that we are not using a database. get app.get('/api/people', (res, req) => { res.status(200).json({ success: true, data: people }) }) post observe that we use a middleware provided by express that lets us parse incoming requests with urlencoded payload, and another middleware function to parse json. app.use(express.urlencoded({ extended: false })) app.use(express.json()) app.post('/api/people', (res, req) => { const { name } = req.body if(!name){ return res .status(400) .json({ success: false, msg: 'please provide a name'}) } // send array of people adding the new person (this is not permanent) res.status(201).json({ success: true, data: [...data, { name, id: data.length + 1}] }) }) put app.put('/api/people/:id', (res, req) => { // de-structure params const { id } = req.params const { name } = req.body const person = people.find((person) => person.id === number(id)) // the person does not exist if(!person){ return res .status(400) .json({ success: false, msg: `no person with id: ${id}`}) } // update the person data const newpeople = people.map((person) => { if(person.id === number(id)){ person.name = name } return person }) res.status(200).json({ success: true, data: newpeople }) }) delete app.delete('/api/people/:id', (res, req) => { // de-structure params const { id } = req.params const { name } = req.body const person = people.find((person) => person.id === number(id)) // the person does not exist if(!person){ return res .status(400) .json({ success: false, msg: `no person with id: ${id}`}) } // filter the person data const newpeople = people.filter((person) => person.id !== id) res.status(200).json({ success: true, data: newpeople }) }) $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/NodeJS/env.html",
    "title": "Environment Variables",
    "body": " index search search back environment variables contents installing command file dotenv installing in order to pass environment variables, like mongodb credentials, to our app we can use a third party package called cross-env: $ npm install --save-dev cross-env and then we can pass environment variables as arguments to our node application like so: npx cross-env node_env=development node app.js and the environment variables can be accessed from our app as follows: console.log(process.env.node_env) command to make it easier we can modify our package.json scripts to pass these variables for us: { \"name\": \"project\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"app.js\", \"scripts\": { \"dev\": \"npx cross-env node_env=development node app\" }, \"keywords\": [], \"author\": \"\", \"license\": \"isc\" } and we start the application with: $ npm dev file another way to do it is using a .env file: node_env=development port=3000 host=localhost to pass those variables to node.js we use the eval command: $ eval $(cat .env) node app and we can also include it to package.json. { \"name\": \"project\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"app.js\", \"scripts\": { \"dev\": \"eval $(cat .env) node app\" }, \"keywords\": [], \"author\": \"\", \"license\": \"isc\" } dotenv in case of not wanting to use commands that are exclusive to our operative system, we can use the package dotenv $ npm install --save-dev dotenv and in our app we do: require('dotenv').config() $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/NodeJS/express.html",
    "title": "Express",
    "body": " index search search back express contents initializing express app app methods send html files express is a minimal and flexible node.js web app framework that allows us to develop and design web sites and apis much faster. to install: $ npm install express --save they suggest including the flag --save because in earlier versions of express if it was not specified the package would not be saved as a dependency on package.json. initializing express app in order to do so we import the express module, and the we create the instance, more or less like we did with our http servers: const express = require('express') const app = express() app methods the app instance we just created has several methods, we now list the most common: app.get: http method to read data. app.get('/', (req, res) => { res.status(200).send('home page') }) app.post: http method to insert data. app.put: http method to update data. app.delete: http method to delete data. app.all: usually used to respond when we cannot locate a resource on the server. app.all('*', (req, res) => { res.status(404).send('<h1>resource not found</h1>') }) app.use: it is responsible for the middleware. app.listen: this method listens for any requests made to the server. app.listen(5000, () => { console.log('server is listening on port 5000...') }) send html files to send html files as a response instead of plain text we have to use the sendfile method: const express = require('express') const path = require('path') const app = express() app.get('/', (req, res) => { res.sendfile(path.resolve(__dirname, './index.html')) }) app.listen(5000, () => { console.log('server is listening on port 5000...') }) now, we have to import the external resources needed by the html file: const express = require('express') const path = require('path') const app = express() app.use(express.static('./public')) app.get('/', (req, res) => { res.sendfile(path.resolve(__dirname, './index.html')) }) app.listen(5000, () => { console.log('server is listening on port 5000...') }) so we invoke app.use as to tell the server that there are static resources stored in the public folder. however, because in this case index.html is also a static file we can remove the sendfile method if we store index.html inside the public folder: const express = require('express') const path = require('path') const app = express() app.use(express.static('./public')) app.listen(5000, () => { console.log('server is listening on port 5000...') }) $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/NodeJS/route_params.html",
    "title": "Route Params",
    "body": " index search search back route params if, for example, we have a list of products, and we want to get a certain product by its id, we use route params. they can have any name, and are specified by :param. this is then stored in the request object. app.get('/api/products/:productid', (req, res) => { \t // de-structure param const { productid } = req.params // filter products by id const singleproduct = products.find( (product) => product.id === number(productid) ) \t // if it does not exist if (!singleproduct) { return res.status(404).send('product does not exist') } return res.json(singleproduct) }) note that the route params are always strings, in our case we had to convert it to a number. we can also have more that one route parameter like so: app.get('/api/products/:productid/reviews/:reviewid', (req, res) => { res.send('hello world') }) where we define productid and reviewid as route parameters, and can, therefore, filter by them. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/NodeJS/streams.html",
    "title": "Streams",
    "body": " index search search back streams contents streams on the web streams are used to read or write sequentially. there are different types: writeable readable duplex: for both writing and reading. transform: to modify data while writing or reading. they are used in order to read files which are too big to store on variables, as it would pose an error. const { createreadstream } = require('fs') const stream = createreadstream('./content/big.txt') stream.on('data', (result) => { console.log(result) }) when logging result when listening on the data event we get the amount of data that is being read, as streams read data chunk by chunk, whose default value is 64kb. in order to modify this value we specify, on the options object, the property highwatermark: const { createreadstream } = require('fs') const stream = createreadstream('./content/big.txt', { highwatermark: 90000 }) stream.on('data', (result) => { console.log(result) }) stream.on('error', (err) => console.log(err)) so, now we are reading 90kb chunks of data. in order to read the data, we specify the encoding of the file: const { createreadstream } = require('fs') const stream = createreadstream('./content/big.txt', { encoding: 'utf8' }) stream.on('data', (result) => { console.log(result) }) in order to listen for errors: const { createreadstream } = require('fs') const stream = createreadstream('./content/big.txt') stream.on('error', (err) => console.log(err)) streams on the web when reading and writing files on servers, it is highly advisable to use chunks instead of the hole file, like so: var http = require('http') var fs = require('fs') http .createserver(function (req, res) { const text = fs.readfilesync('./content/big.txt', 'utf8') res.end(text) }) .listen(5000) instead of this approach, we use streams, both for reading and for writing: var http = require('http') var fs = require('fs') http .createserver(function (req, res) { const filestream = fs.createreadstream('./content/big.txt', 'utf8') filestream.on('open', () => { filestream.pipe(res) }) filestream.on('error', (err) => { res.end(err) }) }) .listen(5000) here, we see that we use the on method to listen for the open event. and then, we use pipe to write on the stream. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/NodeJS/mock_mongo.html",
    "title": "Mocking MongoDB",
    "body": " index search search back mocking mongodb contents mongomemoryserver docker mongomemoryserver configuration example of usage we will now use the node library mongomemoryserver in order to mock our mongodb database using node.js inside a docker container. mongomemoryserver as we have mentioned we need mongomemoryserver, so we install it as a development depencendy. for that we head to our node app's root folder and we execute: $ npm install mongodb-memory-server-core --save-dev docker so, now we create our dockerfile, which holds our app source code, and where we install mongodb: from alpine:latest maintainer albamr09 # install dependencies run apk add --no-cache nodejs npm # install mongodb run echo 'http://dl-cdn.alpinelinux.org/alpine/v3.6/main' >> /etc/apk/repositories run echo 'http://dl-cdn.alpinelinux.org/alpine/v3.6/community' >> /etc/apk/repositories run apk update run apk add mongodb run apk add mongodb-tools run mkdir -p /data/db/ run chmod -r 777 /data/db # add common user run adduser -d user #run useradd --create-home --shell /bin/bash user # create app directory workdir /home/user/src/ # change permissions run chown -r user:user /home/user/src/ run chmod -r 755 /home/user/src/ user user # copy with user as owner copy --chown=user:user ./package*.json ./ # install app dependencies run npm install # copy and override src folder copy . . note that this version of mongodb is 3.4.4, mainly because we are using the alpine image. this version may not coincide with our mongodb docker image, and is not desirable. so make sure (or force) that you are installing the save versions. mongomemoryserver configuration also, we only need to install it for those images that are not supported by mongodb. furthermore, if instead of the package mongo-memory-server-core we install mongo-memory-server, the latter will include a post-install hook that will install mongodb if it is not already installed on the system. in case of manually installing mongodb we have to let know mongomemoryserver where the binary lays. so, within our package.json file we add: \"config\": { \"mongodbmemoryserver\": { \"systembinary\": \"/usr/bin/mongod\", \"version\": \"3.4.4\" } example of usage we, now, exemplify how to mock our database in our tests: const { mongomemoryserver } = require('mongodb-memory-server-core'); const mongoose = require('mongoose'); const usermodel = require('../../models/user'); const userdata = { 'name': 'test', 'email': 'test@test.com', 'password': 'test1234', 'username': 'testname' }; describe('user model tests', ()=> { let mongoserver; beforeall(async () => { mongoserver = await mongomemoryserver.create(); await mongoose.connect(mongoserver.geturi(), { usenewurlparser: true, useunifiedtopology: true, }).catch(error => console.log(error)); }); afterall(async () => { await mongoserver.stop(); await mongoose.connection.close(); }); aftereach(() => { mongoose.connection.collections['users'].drop( function() {}); }); it('create a new user', async ()=> { const user = new usermodel(userdata); const saveduser = await user.save(); expect(saveduser._id).tobedefined(); expect(saveduser.name).tobe(userdata.name); expect(saveduser.email).tobe(userdata.email); expect(saveduser.password).tobe(userdata.password); expect(saveduser.username).tobe(userdata.username); }) it('create a user with invalid fields', async ()=> { var invaliduserdata = {...userdata}; delete invaliduserdata.email; const user = new usermodel(invaliduserdata); let error; try{ const saveduser = await user.save(); error = saveduser; }catch(err){ error = err; } expect(error).tobeinstanceof(mongoose.error.validationerror); expect(error.errors.email).tobedefined(); }) it('create user that already exists', async ()=>{ await new usermodel(userdata).save(); let error; try{ const repeateduser = new usermodel(userdata); await repeateduser.save(); }catch(err){ error = err; } expect(error).tobedefined(); expect(error.code).tobe(11000); }) it('create user with undefined fields', async ()=>{ var newuserdata = {...userdata}; delete newuserdata.name; const user = new usermodel(newuserdata); await user.save(); expect(user._id).tobedefined(); expect(user.name).tobeundefined(); }) } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/NodeJS/jwt.html",
    "title": "JSON Web Tokens",
    "body": " index search search back json web tokens contents installation example of usage installation $ npm install jsonwebtoken example of usage we first create our express application and so, we import express and jsonwebtoken. and then we start the server. const express = require(\"express\"); const jwt = require(\"jsonwebtoken\"); const app = express(); app.listen(3000, () => { console.log(\"nodejs app running...\"); }); now, we define two new endpoints: /api and /api/login. app.get(\"/api\", (req , res) => { res.json({ mensaje: \"nodejs and jwt\" }); }); app.post(\"/api/login\", (req , res) => { const user = { id: 1, nombre : \"henry\", email: \"henry@email.com\" } jwt.sign({user}, 'secretkey', {expiresin: '32s'}, (err, token) => { res.json({ token }); }); }); where we use the sign method to create a new token. so, if we want to define an endpoint that requires authentication we do: // middleware function verifytoken(req, res, next){ const bearerheader = req.headers['authorization']; if(typeof bearerheader !== 'undefined'){ const bearertoken = bearerheader.split(\" \")[1]; req.token = bearertoken; next(); }else{ res.sendstatus(403); } } app.post(\"/api/posts\", verifytoken, (req , res) => { jwt.verify(req.token, 'secretkey', (error, authdata) => { if(error){ res.sendstatus(403); }else{ res.json({ mensaje: \"post fue creado\", authdata }); } }); }); where verifytoken is a middleware function that gets the token from the header, and then we use the verify method to check if the token is valid. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/NodeJS/query_strings.html",
    "title": "Query Strings",
    "body": " index search search back query strings we can use the query attribute from the request object in order to further filter our data. so whenever the user types localhost:5000/whateverendpoint?name=john, the request object passed as an argument of the callback defined for whateverendpoint will have the object {name: 'john'} stored in request.query. app.get('/whateverendpoint', (req, res) => { console.log(req.query) }) now we code the way to filter by the keywords search and limit: app.get('/api/v1/query', (req, res) => { \t \t// de-structure keys const { search, limit } = req.query // get a copy of the products let sortedproducts = [...products] // if search was specified if (search) { \t // return only the products whose name start with sortedproducts = sortedproducts.filter((product) => { return product.name.startswith(search) }) } // if limit was specified if (limit) { // return as many products as the limit specified sortedproducts = sortedproducts.slice(0, number(limit)) } // if no product matched the search if (sortedproducts.length < 1) { return res.status(200).json({ sucess: true, data: [] }) } \t // return the products filtered res.status(200).json(sortedproducts) }) so now, if we go to localhost:5000/api/v1/query?search=a&limit=2 the server will return a json object that contains at most 2 products whose name start with an \"a\". observe, that in order to avoid error for sending more than one response (note that we have two res.json() in our function), we must add the return keyword after sending each response, then the method exits. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/NodeJS/event_loop.html",
    "title": "Event Loop",
    "body": " index search search back event loop it is what allows node.js to perform non-blocking i/o operations, despite the fact that javascript is single-threaded- by offloading operations to the system kernel whenever possible. the event loop follows the next steps: an asynchronous request is made by a user the event loop registers the callback of the request when the request is completed and we are ready to execute the callback the event loop stores the callback at the end of the execution line, meaning, once the immediate tasks are done (i.e. synchronous code) the callback is executed for example, we have the following code: const { readfile, writefile } = require('fs') console.log('started a first task') readfile('./content/first.txt', 'utf8', (err, result) => { if (err) { console.log(err) return } console.log(result) console.log('completed first task') }) console.log('starting next task') which outputs: started first task starting next task hello this is first text file completed first task so we can see that the synchronous code is run first, and then the callback of the asynchronous function readfile is called upon finishing reading the file. in the next example: // started operating system process console.log('first') settimeout(() => { console.log('second') }, 0) console.log('third') // completed and exited operating system process which outputs: first third second so even though the timeout is initialized to 0, because it is an asynchronous function it is offloaded and so it is put to the end of the execution line, and then it is executed after the synchronous code. it is important to note that the listen function of the http module is also asynchronous. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/XML configuration file.html",
    "title": "Configure Spring Container with an XML file",
    "body": " index search search back configure spring container with an xml file first we create the config file <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/xmlschema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemalocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"> <!-- define your beans here --> <bean id=\"mycoach\" class=\"com.luv2code.springdemo.trackcoach\"> </bean> </beans> then we create the spring container in our application: package com.springdemo; /* class to create a spring container using xml files */ import org.springframework.context.support.classpathxmlapplicationcontext; public class myapp { \tpublic static void main(string[] args) { \t\t// load the spring configuration file \t\tclasspathxmlapplicationcontext context = \t\t\t\tnew classpathxmlapplicationcontext(\"applicationcontext.xml\"); \t\t\t\t \t\t// retrieve bean from spring container by its id \t\tcoach thecoach = context.getbean(\"mycoach\", coach.class); \t\t \t\t// call methods on the bean \t\tsystem.out.println(thecoach.getdailyworkout()); \t\t \t\t// close the context \t\tcontext.close(); \t} } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/IoC/Inversion of Control.html",
    "title": "Inversion of Control",
    "body": " index search search back inversion of control the spring container (generally known as applicationcontext) has two main functions: create and manage objects (inversion of control) inject object's dependencies (dependency injection) so inversion control is externalizing the construction and management of objects which will be handled by and object factory. this is illustrated in the following image: myapp has the main method myapp asks spring to retrieve the appropiate object based on a configuration file or an annotation, instead of having to code it manually like: package com.springdemo; public class myapp { \tpublic static void main(string[] args) { \t\tcoach thecoach = new trackcoach(); \t\t \t\t// call methods on the bean \t\tsystem.out.println(thecoach.getdailyworkout()); \t} } where we have defined an interface coach that is implemented by both trackcoach and baseballcoach package com.springdemo; public interface coach { \tpublic string getdailyworkout(); \t } package com.springdemo; public class trackcoach implements coach { \t@override \tpublic string getdailyworkout() { \t\treturn \"run a hard 5k\"; \t} } to avoid this approach we create a spring container. to configure a spring container we can use: xml configuration file (legacy) java annotations java source code however what is a spring bean? a \"spring bean\" is simply a java object. when java objects are created by the spring container, then spring refers to them as \"spring beans\". spring beans are created from normal java classes just like java objects. why do we specify the coach interface in getbean()? when we pass the interface to the method, behind the scenes spring will cast the object for you. context.getbean(\"mycoach\", coach.class) however, there are some slight differences than normal casting. behaves the same as getbean(string), but provides a measure of type safety by throwing a beannotofrequiredtypeexception if the bean is not of the required type. this means that classcastexception can't be thrown on casting the result correctly, as can happen with getbean(string). $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/MVC/View.html",
    "title": "View",
    "body": " index search search back view contents create view create view inside web-inf/view we create a file main-menu.jsp: <!doctype> <html> <body> <h2>spring mvc demo - home page</h2> </body> </html> $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/MVC/Configuration.html",
    "title": "Configuration",
    "body": " index search search back configuration contents configuration on web xml configuration on spring-mvc-demo-servlet xml add configurations to file: web-inf/web.xml configure spring mvc dispatcher servlet set up url mappings to spring mvc dispatcher servlet add configurations to spring configuration file: web-inf/spring-mvc-demo-servlet.xml add support for spring component scanning add support for conversion, formatting and validation configure spring mvc view resolver configuration on web.xml we have to add an entry for our front controller: dispatcherservlet <?xml version=\"1.0\" encoding=\"utf-8\"?> <web-app xmlns:xsi=\"http://www.w3.org/2001/xmlschema-instance\" \txmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" \txsi:schemalocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\" \tid=\"webapp_id\" version=\"3.1\"> \t<display-name>spring-mvc-demo</display-name> \t<absolute-ordering /> \t<!-- step 1: configure spring mvc dispatcher servlet --> \t<servlet> \t\t<!-- name to reference this servlet --> \t\t<servlet-name>dispatcher</servlet-name> \t\t<servlet-class>org.springframework.web.servlet.dispatcherservlet</servlet-class> \t\t<!-- file of configuration of spring application --> \t\t<init-param> \t\t\t<param-name>contextconfiglocation</param-name> \t\t\t<param-value>/web-inf/spring-mvc-demo-servlet.xml</param-value> \t\t</init-param> \t\t<load-on-startup>1</load-on-startup> \t</servlet> \t<!-- step 2: set up url mapping for spring mvc dispatcher servlet --> \t<servlet-mapping> \t\t<servlet-name>dispatcher</servlet-name> \t\t<!-- for any url that comes in pass it to the \"dispatcher\" servlet --> \t\t<url-pattern>/</url-pattern> \t</servlet-mapping> </web-app> configuration on spring-mvc-demo-servlet.xml <?xml version=\"1.0\" encoding=\"utf-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" \txmlns:xsi=\"http://www.w3.org/2001/xmlschema-instance\" \txmlns:context=\"http://www.springframework.org/schema/context\" \txmlns:mvc=\"http://www.springframework.org/schema/mvc\" \txsi:schemalocation=\" \t\thttp://www.springframework.org/schema/beans \thttp://www.springframework.org/schema/beans/spring-beans.xsd \thttp://www.springframework.org/schema/context \thttp://www.springframework.org/schema/context/spring-context.xsd \thttp://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"> \t<!-- step 3: add support for component scanning --> \t<context:component-scan base-package=\"com.springdemo\" /> \t<!-- step 4: add support for conversion, formatting and validation support --> \t<mvc:annotation-driven/> \t<!-- step 5: define spring mvc view resolver --> \t<bean \t\tclass=\"org.springframework.web.servlet.view.internalresourceviewresolver\"> \t\t<!-- specify where to look for view files --> \t\t<property name=\"prefix\" value=\"/web-inf/view/\" /> \t\t<property name=\"suffix\" value=\".jsp\" /> \t</bean> </beans> $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/MVC/Radio Buttons.html",
    "title": "Radio Buttons",
    "body": " index search search back radio buttons contents controller view model to pass and bind data from radio buttons to controllers an another views we use the form tag form:radiobutton which is surrounded by a form:form: controller add a model to the controller method for the form and create the model attribute, that holds the data and performs data binding package com.springdemo.mvc; import org.springframework.stereotype.controller; import org.springframework.ui.model; import org.springframework.web.bind.annotation.modelattribute; import org.springframework.web.bind.annotation.requestmapping; @controller @requestmapping(\"/student\") public class studentcontroller { \t \t// request to show the view that contains the form \t@requestmapping(\"/showform\") \tpublic string showform(model themodel) { \t\t \t\t// create a student object \t\tstudent thestudent = new student(); \t\t \t\t// add student object to the model \t\tthemodel.addattribute(\"student\", thestudent); \t\t \t\treturn \"student-form\"; \t} \t \t// process the submit event on the form \t@requestmapping(\"/processform\") \t// we obtain the model attribute with the following annotation \tpublic string processform(@modelattribute(\"student\") student thestudent) { \t\t \t\t// now we can retrieve the updated information from the form \t\tsystem.out.println(\"thestudent: \" + thestudent.getfirstname() \t\t\t\t\t\t\t+ \" \" + thestudent.getlastname()); \t\t \t\treturn \"student-confirmation\"; \t} } view setting the html for data binding: for student-form.jsp: <%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %> <!doctype html> <html> <head> \t<title>student registration form</title> </head> <body> \t<form:form action=\"processform\" modelattribute=\"student\"> \t\tfirst name: <form:input path=\"firstname\" /> \t\t<br><br> \t\tlast name: <form:input path=\"lastname\" /> \t\t<br><br> \t\tcountry: \t\t<!-- drop down list of country options --> \t\t<!-- we specify the variable where we store the selected value in the student object: which is country --> \t\t<form:select path=\"country\"> \t\t\t<!-- this is a list that was populated when we created the student object --> \t\t\t<!-- remember spring calls student.getcountryoptions() --> \t\t\t<form:options items=\"${student.countryoptions}\" /> \t\t</form:select> \t\t<br><br> \t\t<br><br> \t\tfavorite language: \t\t \t\t<!-- the \"path\" specifies the name of the property we are going to bind the radiobutton to, in this case \"favoritelanguage\" --> \t\t<!-- note these can also be populated from the student class or using a properties file --> \t\tjava <form:radiobutton path=\"favoritelanguage\" value=\"java\" /> \t\tc# <form:radiobutton path=\"favoritelanguage\" value=\"c#\" /> \t\tphp <form:radiobutton path=\"favoritelanguage\" value=\"php\" /> \t\truby <form:radiobutton path=\"favoritelanguage\" value=\"ruby\" /> \t\t<br><br> \t\t<input type=\"submit\" value=\"submit\" /> \t</form:form> </body> </html> for student-confirmation.jsp: <%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %> <!doctype html> <html> <head> \t<title>student confirmation</title> </head> <body> \tthe student is confirmed: ${student.firstname} ${student.lastname} \t<br><br> \tselected coutry: ${student.country} ${student.lastname} \t<br><br> \t<!-- obtain the value using the binded variable inside the student object --> \tfavorite language: ${student.favoritelanguage} </body> </html> model the model attribute \"student\" is populated with an instance of the following student class: package com.springdemo.mvc; import java.util.linkedhashmap; public class student { \tprivate string firstname; \tprivate string lastname; \t \tprivate string country; \t \tprivate linkedhashmap<string, string> countryoptions; \t \t// property we are going to bind to the radio buttons \tprivate string favoritelanguage; \t \tpublic student() { \t\t \t\t// populate country options: used iso country code \t\tcountryoptions = new linkedhashmap<>(); \t\t \t\tcountryoptions.put(\"br\", \"brazil\"); \t\tcountryoptions.put(\"fr\", \"france\"); \t\tcountryoptions.put(\"de\", \"germany\"); \t\tcountryoptions.put(\"in\", \"india\"); \t\tcountryoptions.put(\"us\", \"united states of america\");\t\t \t\t \t\t// we can also populate the favoritelanguage options from here \t\t// in the same manner we did with the country options \t} \tpublic string getfirstname() { \t\treturn firstname; \t} \tpublic void setfirstname(string firstname) { \t\tthis.firstname = firstname; \t} \tpublic string getlastname() { \t\treturn lastname; \t} \tpublic void setlastname(string lastname) { \t\tthis.lastname = lastname; \t} \tpublic string getcountry() { \t\treturn country; \t} \tpublic void setcountry(string country) { \t\tthis.country = country; \t} \tpublic linkedhashmap<string, string> getcountryoptions() { \t\treturn countryoptions; \t} \t \t// setter and getter handlers for the new binded attribute \tpublic string getfavoritelanguage() { \t\treturn favoritelanguage; \t} \tpublic void setfavoritelanguage(string favoritelanguage) { \t\tthis.favoritelanguage = favoritelanguage; \t} } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/MVC/Controller.html",
    "title": "Controller",
    "body": " index search search back controller contents create controller class create controller class package com.springdemo.mvc; import org.springframework.stereotype.controller; import org.springframework.web.bind.annotation.requestmapping; // add controller annotation @controller public class homecontroller { \t \t// add request mapping: this method controls the request coming to this url \t@requestmapping(\"/\") \tpublic string showpage() { \t // name of the view that is returned: note they are stored in web-inf/view/ \t\treturn \"main-menu\"; \t} } now, we create the view $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/MVC/Resources.html",
    "title": "Add CSS and JS",
    "body": " index search search back add css and js here are the steps on how to access static resources in a spring mvc. for example, you can use this to access images, css, javascript files etc. you can configure references to static resources in the spring-mvc-demo-servlet.xml. add the following entry to your spring mvc configuration file: spring-mvc-demo-servlet.xml <mvc:resources mapping=\"/resources/**\" location=\"/resources/\"></mvc:resources> now in your view pages, you can access the static files using this syntax: <img src=\"${pagecontext.request.contextpath}/resources/images/spring-logo.png\"> $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/MVC/Form Tags.html",
    "title": "Form Tags",
    "body": " index search search back form tags contents reference spring mvc form tags form tags are configurable an reusable: they can make use of data binding (you can automatically set and retrieve data from a java object) you can mix them in with you html web page some examples are: reference spring mvc form tags to use these tags in your web page you have to specify the spring namespace at the beginning of the jsp file: <!-- reference to the namespace --> <%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %> <!doctype html> <html> <head></head> <body> </body> </html> text fields drop down lists radio buttons checkbox $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/MVC/Text Fields.html",
    "title": "Text Fields",
    "body": " index search search back text fields contents controller view model to pass and bind data from input text fields to controllers an another views we use the form tag form:input along with form:form: controller add a model to the controller method for the form and create the model attribute, that holds the data and perfoms data binding package com.springdemo.mvc; import org.springframework.stereotype.controller; import org.springframework.ui.model; import org.springframework.web.bind.annotation.modelattribute; import org.springframework.web.bind.annotation.requestmapping; @controller @requestmapping(\"/student\") public class studentcontroller { \t \t// request to show the view that contains the form \t@requestmapping(\"/showform\") \tpublic string showform(model themodel) { \t\t \t\t// create a student object \t\tstudent thestudent = new student(); \t\t \t\t// add student object to the model \t\tthemodel.addattribute(\"student\", thestudent); \t\t \t\treturn \"student-form\"; \t} \t \t// process the submit event on the form \t@requestmapping(\"/processform\") \t// we obtain the model attribute with the following annotation \tpublic string processform(@modelattribute(\"student\") student thestudent) { \t\t \t\t// now we can retrieve the updated information from the form \t\tsystem.out.println(\"thestudent: \" + thestudent.getfirstname() \t\t\t\t\t\t\t+ \" \" + thestudent.getlastname()); \t\t \t\treturn \"student-confirmation\"; \t} } view setting the html for data binding: for student-form.jsp: <%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %> <!doctype html> <html> <head> \t<title>student registration form</title> </head> <body> \t<!-- note the modelattribute equals the attribute we added to the model in the controller--> \t<form:form action=\"processform\" modelattribute=\"student\"> \t\t<!-- to retrieve the data this maps to student.getfirstname() --> \t\tfirst name: <form:input path=\"firstname\" /> \t\t<br><br> \t\tlast name: <form:input path=\"lastname\" /> \t\t<br><br> \t\t<input type=\"submit\" value=\"submit\" /> \t</form:form> </body> </html> when we submit spring will call student.setfirstname() and student.setlastname() to save the data in the student object, so we can retrieve it from our controller method. for student-confirmation.jsp: <%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %> <!doctype html> <html> <head> \t<title>student confirmation</title> </head> <body> \t<!-- obtain data from the model: note we use the attribute's name (i.e. student) to access the object --> \tthe student is confirmed: ${student.firstname} ${student.lastname} </body> </html> model the model attribute \"student\" is populated with an instance of the following student class: package com.springdemo.mvc; import java.util.linkedhashmap; public class student { \tprivate string firstname; \tprivate string lastname; \t\t \tpublic student() {} \tpublic string getfirstname() { \t\treturn firstname; \t} \tpublic void setfirstname(string firstname) { \t\tthis.firstname = firstname; \t} \tpublic string getlastname() { \t\treturn lastname; \t} \tpublic void setlastname(string lastname) { \t\tthis.lastname = lastname; \t} } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/MVC/Adding Data.html",
    "title": "Model",
    "body": " index search search back model contents example controller view the model is a container for the application data. so in your controller you can put anything in the model (strings, objects, info from db, etc). and then you view page (jsp) can access data from the model. example controller package com.springdemo.mvc; import javax.servlet.http.httpservletrequest; import org.springframework.stereotype.controller; import org.springframework.ui.model; import org.springframework.web.bind.annotation.requestmapping; @controller public class helloworldcontroller { // new a controller method to read form data and // add data to the model @requestmapping(\"/processformversiontwo\")\t // the httpservletrequest allows you to retrieve information from the request (like the parameters of a form) // the model is our model where we will store data public string parsestring(httpservletrequest request, model model) { // read the request parameter from the html form string thename = request.getparameter(\"studentname\"); // convert the data to all caps thename = thename.touppercase(); // create the message string result = \"yo! \" + thename; // add message attribute to the model model.addattribute(\"message\", result); \t\t return \"helloworld\"; } } view now, on the view, we can access the model data: <!doctype html> <html> <body> hello world of spring! <br><br> student name: ${param.studentname} <br><br> <!-- access model data by the attribute's name--> the message: ${message} </body> </html> $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/MVC/Number Validation.html",
    "title": "Number Range Validation",
    "body": " index search search back number range validation contents add validation rule to bean perform validation in the controller display error on html in this section we will show how to perform a number range validation. add validation rule to bean we create a customer class, whose freepasses variable must be a number between 0 and 10. public class customer { \tprivate string firstname; \t \t@notnull(message=\"is required\") \t@size(min=1, message=\"is required\") \tprivate string lastname; \t// minimum value we will expect \t@min(value=0, message=\"must be greater than or equal to zero\") \t// maximum value we will expect \t@max(value=10, message=\"must be less than or equal to 10\") \tprivate int freepasses; \t \t... perform validation in the controller we also package com.springdemo.mvc; import javax.validation.valid; import org.springframework.beans.propertyeditors.stringtrimmereditor; import org.springframework.stereotype.controller; import org.springframework.ui.model; import org.springframework.validation.bindingresult; import org.springframework.web.bind.webdatabinder; import org.springframework.web.bind.annotation.initbinder; import org.springframework.web.bind.annotation.modelattribute; import org.springframework.web.bind.annotation.requestmapping; @controller @requestmapping(\"/customer\") public class customercontroller { \t// add an initbinder ... to convert trim input strings \t// remove leading and trailing whitespace \t// resolve issue for our validation \t \t@initbinder \t//@initbinder annotation works as a pre-processor \t// it will pre-process each web request to our controller \tpublic void initbinder(webdatabinder databinder) { \t\t \t\t// trim strings (true: empty strings to null) \t\tstringtrimmereditor stringtrimmereditor = new stringtrimmereditor(true); \t \t\t// for every string class apply the trim editor \t\tdatabinder.registercustomeditor(string.class, stringtrimmereditor); \t} \t \t \t@requestmapping(\"/showform\") \tpublic string showform(model themodel) { \t\t \t\tthemodel.addattribute(\"customer\", new customer()); \t\t \t\treturn \"customer-form\"; \t} \t \t@requestmapping(\"/processform\") \t// @valid: tells spring to perform validation on the customer object \t// bindingresult: results of the validation will be placed in bindingresult \tpublic string processform( \t\t\t@valid @modelattribute(\"customer\") customer thecustomer, \t\t\tbindingresult thebindingresult) { \t\t \t\tsystem.out.println(\"last name: |\" + thecustomer.getlastname() + \"|\"); \t\t \t\t// check if validation was sucessfull \t\tif (thebindingresult.haserrors()) { \t\t\t// if not sucessfull send back \t\t\treturn \"customer-form\"; \t\t} \t\telse { \t\t\t// if sucessfull \t\t\treturn \"customer-confirmation\"; \t\t} \t} } when performing spring mvc validation, the location of the bindingresult parameter is very important. in the method signature, the bindingresult parameter must appear immediately after the model attribute. display error on html <%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %> <html> <head> \t<title>customer registration form</title> \t \t<style> \t\t.error {color:red} \t</style> </head> <body> <i>fill out the form. asterisk (*) means required.</i> <br><br> \t<form:form action=\"processform\" modelattribute=\"customer\"> \t\tfirst name: <form:input path=\"firstname\" /> \t\t<br><br> \t\tlast name (*): <form:input path=\"lastname\" /> <!-- the message shown equals the messages from both of the validation annotations defined for the lastname attribute in the customer class --> \t\t<form:errors path=\"lastname\" cssclass=\"error\" /> \t\t<br><br> \t\tfree passes: <form:input path=\"freepasses\" /> <!-- the message shown equals the messages from both of the validation annotations defined for the freepasses attribute in the customer class --> \t\t<form:errors path=\"freepasses\" cssclass=\"error\" /> \t\t<br><br> \t\t<input type=\"submit\" value=\"submit\" /> \t</form:form> </body> </html> $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/MVC/Read HTML Form Data.html",
    "title": "Read HTML Form Data",
    "body": " index search search back read html form data contents controller view the flow of our example will be the following: when the user accesses the url /showform, the browser will send a request to our controller, and our controller will return the corresponding view when the user hits submit on the form the action /processform is passed to the browser that will send a request to our controller, and our controller will process the request controller package com.springdemo.mvc; import org.springframework.stereotype.controller; import org.springframework.web.bind.annotation.requestmapping; @controller public class helloworldcontroller { \t// need a controller method to show the initial html form \t@requestmapping(\"/showform\") // the method name can be anything \tpublic string showform() { \t\treturn \"helloworld-form\"; \t} \t\t \t// need a controller method to process the html form \t@requestmapping(\"/processform\") \tpublic string processform() { \t\treturn \"helloworld\"; \t} \t\t } view we create web-inf/view/helloworld-form.jsp <!doctype html> <html> <head> \t<title>hello world - input form</title> </head> <body> <!-- the action is the request url --> \t<form action=\"processform\" method=\"get\"> \t\t<input type=\"text\" name=\"studentname\" \t\t\tplaceholder=\"what's your name?\" /> \t\t<input type=\"submit\" /> \t</form> </body> </html> and we create web-inf/view/helloworld-form.jsp <!doctype html> <html> <body> hello world of spring! <br><br> <!-- name of html form field from previous jsp view --> student name: ${param.studentname} </body> </html> $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/MVC/index.html",
    "title": "Spring MVC",
    "body": " index search search back spring mvc spring mvc is a framework for building web applications in java based on the model-view-controller design patter. the front controller is known as dispatcherservlet: it is part of the spring framework pre-processes and delegates requests from the web browser to your controllers the mvc pattern is made up of: model objects: contains the data view templates: ui of the app that displays data (most common templates: jsp + jslt) controller classes: business logic (handle request, access db, etc.) it includes the features of the core spring framework (inversion of control and dependency injection) $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/MVC/Drop Down Lists.html",
    "title": "Drop Down Lists",
    "body": " index search search back drop down lists contents controller view model country options from a properties file to pass and bind data from drop down lists to controllers an another views we use the form tags form:select that encloses a set of options represented with form:option tags. and all these are surrounded by a form:form: controller add a model to the controller method for the form and create the model attribute, that holds the data and performs data binding package com.springdemo.mvc; import org.springframework.stereotype.controller; import org.springframework.ui.model; import org.springframework.web.bind.annotation.modelattribute; import org.springframework.web.bind.annotation.requestmapping; @controller @requestmapping(\"/student\") public class studentcontroller { \t \t// request to show the view that contains the form \t@requestmapping(\"/showform\") \tpublic string showform(model themodel) { \t\t \t\t// create a student object \t\tstudent thestudent = new student(); \t\t \t\t// add student object to the model \t\tthemodel.addattribute(\"student\", thestudent); \t\t \t\treturn \"student-form\"; \t} \t \t// process the submit event on the form \t@requestmapping(\"/processform\") \t// we obtain the model attribute with the following annotation \tpublic string processform(@modelattribute(\"student\") student thestudent) { \t\t \t\t// now we can retrieve the updated information from the form \t\tsystem.out.println(\"thestudent: \" + thestudent.getfirstname() \t\t\t\t\t\t\t+ \" \" + thestudent.getlastname()); \t\t \t\treturn \"student-confirmation\"; \t} } view setting the html for data binding: for student-form.jsp: <%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %> <!doctype html> <html> <head> \t<title>student registration form</title> </head> <body> \t<form:form action=\"processform\" modelattribute=\"student\"> \t\tfirst name: <form:input path=\"firstname\" /> \t\t<br><br> \t\tlast name: <form:input path=\"lastname\" /> \t\t<br><br> \t\tcountry: \t\t<!-- drop down list of country options --> \t\t<!-- we specify the variable where we store the selected value in the student object: which is country --> \t\t<form:select path=\"country\"> \t\t\t<!-- this is a list that was populated when we created the student object --> \t\t\t<!-- remember spring calls student.getcountryoptions() --> \t\t\t<form:options items=\"${student.countryoptions}\" /> \t\t</form:select> \t\t<br><br> \t\t<input type=\"submit\" value=\"submit\" /> \t</form:form> </body> </html> for student-confirmation.jsp: <%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %> <!doctype html> <html> <head> \t<title>student confirmation</title> </head> <body> \tthe student is confirmed: ${student.firstname} ${student.lastname} \t<!-- obtain the value saved in the coutry variable inside the student's object (corresponds to the selected value) --> \tselected coutry: ${student.country} ${student.lastname} </body> </html> model the model attribute \"student\" is populated with an instance of the following student class: package com.springdemo.mvc; import java.util.linkedhashmap; public class student { \tprivate string firstname; \tprivate string lastname; \t \tprivate string country; \t \tprivate linkedhashmap<string, string> countryoptions; \t \tpublic student() { \t\t \t\t// populate country options: used iso country code \t\tcountryoptions = new linkedhashmap<>(); \t\t \t\tcountryoptions.put(\"br\", \"brazil\"); \t\tcountryoptions.put(\"fr\", \"france\"); \t\tcountryoptions.put(\"de\", \"germany\"); \t\tcountryoptions.put(\"in\", \"india\"); \t\tcountryoptions.put(\"us\", \"united states of america\");\t\t \t} \tpublic string getfirstname() { \t\treturn firstname; \t} \tpublic void setfirstname(string firstname) { \t\tthis.firstname = firstname; \t} \tpublic string getlastname() { \t\treturn lastname; \t} \tpublic void setlastname(string lastname) { \t\tthis.lastname = lastname; \t} \tpublic string getcountry() { \t\treturn country; \t} \t// setter and getter handlers for the new binded attribute \tpublic void setcountry(string country) { \t\tthis.country = country; \t} \tpublic linkedhashmap<string, string> getcountryoptions() { \t\treturn countryoptions; \t} } country options from a properties file we create web-inf/countries.properties: br=brazil fr=france co=colombia in=india update configuration's file spring-mvc-dmo-servlet.xml header (to use a new set of spring tags: utils): <?xml version=\"1.0\" encoding=\"utf-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:util=\"http://www.springframework.org/schema/util\" xmlns:xsi=\"http://www.w3.org/2001/xmlschema-instance\" xsi:schemalocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd\"> load the country options properties file in the spring configuration file, with a bean id equal to \"countryoptions\": <util:properties id=\"countryoptions\" location=\"classpath:../countries.properties\" /> inject properties inside our controller: @value(\"#{countryoptions}\") private map<string, string> countryoptions; add countryoptions as an attribute of the model inside the controller method: @requestmapping(\"/showform\") public string showform(model themodel) { // create a student object student student thestudent = new student(); // add student object to the model themodel.addattribute(\"student\", thestudent); // add the country options to the model themodel.addattribute(\"thecountryoptions\", countryoptions); return \"student-form\"; } update the view as follows: <form:select path=\"country\"> <form:options items=\"${thecountryoptions}\" /> </form:select> $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/MVC/CheckBox.html",
    "title": "Check Box",
    "body": " index search search back check box contents controller view model to pass and bind data from check boxes to controllers an another views we use the form tag form:checkbox which is surrounded by a form:form: controller add a model to the controller method for the form and create the model attribute, that holds the data and performs data binding package com.springdemo.mvc; import org.springframework.stereotype.controller; import org.springframework.ui.model; import org.springframework.web.bind.annotation.modelattribute; import org.springframework.web.bind.annotation.requestmapping; @controller @requestmapping(\"/student\") public class studentcontroller { \t \t// request to show the view that contains the form \t@requestmapping(\"/showform\") \tpublic string showform(model themodel) { \t\t \t\t// create a student object \t\tstudent thestudent = new student(); \t\t \t\t// add student object to the model \t\tthemodel.addattribute(\"student\", thestudent); \t\t \t\treturn \"student-form\"; \t} \t \t// process the submit event on the form \t@requestmapping(\"/processform\") \t// we obtain the model attribute with the following annotation \tpublic string processform(@modelattribute(\"student\") student thestudent) { \t\t \t\t// now we can retrieve the updated information from the form \t\tsystem.out.println(\"thestudent: \" + thestudent.getfirstname() \t\t\t\t\t\t\t+ \" \" + thestudent.getlastname()); \t\t \t\treturn \"student-confirmation\"; \t} } view setting the html for data binding: for student-form.jsp: <%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %> <!doctype html> <html> <head> \t<title>student registration form</title> </head> <body> \t<form:form action=\"processform\" modelattribute=\"student\"> \t\tfirst name: <form:input path=\"firstname\" /> \t\t<br><br> \t\tlast name: <form:input path=\"lastname\" /> \t\t<br><br> \t\tcountry: \t\t<!-- drop down list of country options --> \t\t<!-- we specify the variable where we store the selected value in the student object: which is country --> \t\t<form:select path=\"country\"> \t\t\t<!-- this is a list that was populated when we created the student object --> \t\t\t<!-- remember spring calls student.getcountryoptions() --> \t\t\t<form:options items=\"${student.countryoptions}\" /> \t\t</form:select> \t\t<br><br> \t\t<br><br> \t\tfavorite language: \t\t \t\tjava <form:radiobutton path=\"favoritelanguage\" value=\"java\" /> \t\tc# <form:radiobutton path=\"favoritelanguage\" value=\"c#\" /> \t\tphp <form:radiobutton path=\"favoritelanguage\" value=\"php\" /> \t\truby <form:radiobutton path=\"favoritelanguage\" value=\"ruby\" /> \t\t<br><br> \t\toperating systems: \t\t \t\t<!-- the \"path\" specifies the name of the property we are going to bind the radiobutton to, in this case \"operatingsystems\" --> \t\t<!-- note these can also be populated from the student class or using a properties file --> \t\tlinux <form:checkbox path=\"operatingsystems\" value=\"linux\" /> \t\tmac os <form:checkbox path=\"operatingsystems\" value=\"mac os\" /> \t\tms windows <form:checkbox path=\"operatingsystems\" value=\"ms window\" />\t \t\t<br><br> \t\t<input type=\"submit\" value=\"submit\" /> \t</form:form> </body> </html> for student-confirmation.jsp: <%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %> <!doctype html> <html> <head> \t<title>student confirmation</title> </head> <body> \tthe student is confirmed: ${student.firstname} ${student.lastname} \t<br><br> \tselected coutry: ${student.country} ${student.lastname} \t<br><br> \t<!-- obtain the value using the binded variable inside the student object --> \tfavorite language: ${student.favoritelanguage} \t<br><br> \toperating systems: \t<!-- create an unordered list of the selected values in the checkbox --> \t\t<ul> \t\t\t<c:foreach var=\"temp\" items=\"${student.operatingsystems}\"> \t\t\t\t<li> ${temp} </li> \t\t\t</c:foreach> \t\t</ul> </body> </html> model the model attribute \"student\" is populated with an instance of the following student class: package com.springdemo.mvc; import java.util.linkedhashmap; public class student { \tprivate string firstname; \tprivate string lastname; \t \tprivate string country; \t \tprivate linkedhashmap<string, string> countryoptions; \t \tprivate string favoritelanguage; // attribute bound to the checkbox (multiple options so it is an array) private string[] operatingsystems; \t \tpublic student() { \t\t \t\t// populate country options: used iso country code \t\tcountryoptions = new linkedhashmap<>(); \t\t \t\tcountryoptions.put(\"br\", \"brazil\"); \t\tcountryoptions.put(\"fr\", \"france\"); \t\tcountryoptions.put(\"de\", \"germany\"); \t\tcountryoptions.put(\"in\", \"india\"); \t\tcountryoptions.put(\"us\", \"united states of america\");\t\t \t\t \t\t// we can also populate the favoritelanguage options from here \t\t// in the same manner we did with the country options \t} \tpublic string getfirstname() { \t\treturn firstname; \t} \tpublic void setfirstname(string firstname) { \t\tthis.firstname = firstname; \t} \tpublic string getlastname() { \t\treturn lastname; \t} \tpublic void setlastname(string lastname) { \t\tthis.lastname = lastname; \t} \tpublic string getcountry() { \t\treturn country; \t} \tpublic void setcountry(string country) { \t\tthis.country = country; \t} \tpublic linkedhashmap<string, string> getcountryoptions() { \t\treturn countryoptions; \t} \t \tpublic string getfavoritelanguage() { \t\treturn favoritelanguage; \t} \tpublic void setfavoritelanguage(string favoritelanguage) { \t\tthis.favoritelanguage = favoritelanguage; \t} \t// setter and getter handlers for the new bound attribute public string[] getoperatingsystems() { \t\treturn operatingsystems; \t} \tpublic void setoperatingsystems(string[] operatingsystems) { \t\tthis.operatingsystems = operatingsystems; \t} } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/MVC/Validation with Regular Expressions.html",
    "title": "Validation with Regular Expressions",
    "body": " index search search back validation with regular expressions contents add validation rule to bean perform validation in the controller display error on html in this section we will show how to perform a validation with regular expressions. add validation rule to bean we create a customer class, whose freepasses variable must be a number between 0 and 10. public class customer { \tprivate string firstname; \t \t@notnull(message=\"is required\") \t@size(min=1, message=\"is required\") \tprivate string lastname; \t@min(value=0, message=\"must be greater than or equal to zero\") \t@max(value=10, message=\"must be less than or equal to 10\") \tprivate int freepasses; // define the regular expression for the postalcode attribute @pattern(regexp=\"^[a-za-z0-9]{5}\", message=\"only 5 chars/digits\") \tprivate string postalcode; \t \t... perform validation in the controller we also package com.springdemo.mvc; import javax.validation.valid; import org.springframework.beans.propertyeditors.stringtrimmereditor; import org.springframework.stereotype.controller; import org.springframework.ui.model; import org.springframework.validation.bindingresult; import org.springframework.web.bind.webdatabinder; import org.springframework.web.bind.annotation.initbinder; import org.springframework.web.bind.annotation.modelattribute; import org.springframework.web.bind.annotation.requestmapping; @controller @requestmapping(\"/customer\") public class customercontroller { \t// add an initbinder ... to convert trim input strings \t// remove leading and trailing whitespace \t// resolve issue for our validation \t \t@initbinder \t//@initbinder annotation works as a pre-processor \t// it will pre-process each web request to our controller \tpublic void initbinder(webdatabinder databinder) { \t\t \t\t// trim strings (true: empty strings to null) \t\tstringtrimmereditor stringtrimmereditor = new stringtrimmereditor(true); \t \t\t// for every string class apply the trim editor \t\tdatabinder.registercustomeditor(string.class, stringtrimmereditor); \t} \t \t \t@requestmapping(\"/showform\") \tpublic string showform(model themodel) { \t\t \t\tthemodel.addattribute(\"customer\", new customer()); \t\t \t\treturn \"customer-form\"; \t} \t \t@requestmapping(\"/processform\") \t// @valid: tells spring to perform validation on the customer object \t// bindingresult: results of the validation will be placed in bindingresult \tpublic string processform( \t\t\t@valid @modelattribute(\"customer\") customer thecustomer, \t\t\tbindingresult thebindingresult) { \t\t \t\tsystem.out.println(\"last name: |\" + thecustomer.getlastname() + \"|\"); \t\t \t\t// check if validation was sucessfull \t\tif (thebindingresult.haserrors()) { \t\t\t// if not sucessfull send back \t\t\treturn \"customer-form\"; \t\t} \t\telse { \t\t\t// if sucessfull \t\t\treturn \"customer-confirmation\"; \t\t} \t} } when performing spring mvc validation, the location of the bindingresult parameter is very important. in the method signature, the bindingresult parameter must appear immediately after the model attribute. display error on html <%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %> <html> <head> \t<title>customer registration form</title> \t \t<style> \t\t.error {color:red} \t</style> </head> <body> <i>fill out the form. asterisk (*) means required.</i> <br><br> \t<form:form action=\"processform\" modelattribute=\"customer\"> \t\tfirst name: <form:input path=\"firstname\" /> \t\t<br><br> \t\tlast name (*): <form:input path=\"lastname\" /> \t\t<form:errors path=\"lastname\" cssclass=\"error\" /> \t\t<br><br> \t\tfree passes: <form:input path=\"freepasses\" /> \t\t<form:errors path=\"freepasses\" cssclass=\"error\" /> <br><br> \t\tpostal code: <form:input path=\"postalcode\" /> <!-- the message shown equals the messages from both of the validation annotations defined for the postalcode attribute in the customer class --> \t\t<form:errors path=\"postalcode\" cssclass=\"error\" /> \t\t<br><br> \t\t<input type=\"submit\" value=\"submit\" /> \t</form:form> </body> </html> $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/MVC/Form Validation.html",
    "title": "Form Validation",
    "body": " index search search back form validation contents set up java has a standard bean validation api that defines a metadata model and an api for entity validation. here is a list of bean validation features you can check: required validate length validate numbers validate with regular expressions custom validation some annotations to perform the validation are the following: set up add hibernate's library (hibernate validator)for bean validation which is fully compliant with java's bean validation api. required validation number range validation validation with regular expressions handle string in integer field custom validation $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/MVC/Required Validation.html",
    "title": "Required Validation",
    "body": " index search search back required validation contents add validation rule to bean perform validation in the controller display error on html in this section we will show how to perform a required validation. add validation rule to bean we create a customer class, whose lastname attribute must be non-null, that is, lastname is a required attribute: package com.springdemo.mvc; import javax.validation.constraints.notnull; import javax.validation.constraints.size; public class customer { \tprivate string firstname; \t // validation annotation \t@notnull(message=\"is required\") \t@size(min=1, message=\"is required\") \tprivate string lastname; \tpublic string getfirstname() { \t\treturn firstname; \t} \tpublic void setfirstname(string firstname) { \t\tthis.firstname = firstname; \t} \tpublic string getlastname() { \t\treturn lastname; \t} \tpublic void setlastname(string lastname) { \t\tthis.lastname = lastname; \t} } note that if we wanted to make an integer required, we must use the wrapper java classes (i.e. integer), that will be able to handle empty strings as inputs and nulls. the primitive types will throw an exception. perform validation in the controller we also package com.springdemo.mvc; import javax.validation.valid; import org.springframework.beans.propertyeditors.stringtrimmereditor; import org.springframework.stereotype.controller; import org.springframework.ui.model; import org.springframework.validation.bindingresult; import org.springframework.web.bind.webdatabinder; import org.springframework.web.bind.annotation.initbinder; import org.springframework.web.bind.annotation.modelattribute; import org.springframework.web.bind.annotation.requestmapping; @controller @requestmapping(\"/customer\") public class customercontroller { \t// add an initbinder ... to convert trim input strings \t// remove leading and trailing whitespace \t// resolve issue for our validation \t \t@initbinder \t//@initbinder annotation works as a pre-processor \t// it will pre-process each web request to our controller \tpublic void initbinder(webdatabinder databinder) { \t\t \t\t// trim strings (true: empty strings to null) \t\tstringtrimmereditor stringtrimmereditor = new stringtrimmereditor(true); \t \t\t// for every string class apply the trim editor \t\tdatabinder.registercustomeditor(string.class, stringtrimmereditor); \t} \t \t \t@requestmapping(\"/showform\") \tpublic string showform(model themodel) { \t\t \t\tthemodel.addattribute(\"customer\", new customer()); \t\t \t\treturn \"customer-form\"; \t} \t \t@requestmapping(\"/processform\") \t// @valid: tells spring to perform validation on the customer object \t// bindingresult: results of the validation will be placed in bindingresult \tpublic string processform( \t\t\t@valid @modelattribute(\"customer\") customer thecustomer, \t\t\tbindingresult thebindingresult) { \t\t \t\tsystem.out.println(\"last name: |\" + thecustomer.getlastname() + \"|\"); \t\t \t\t// check if validation was sucessfull \t\tif (thebindingresult.haserrors()) { \t\t\t// if not sucessfull send back \t\t\treturn \"customer-form\"; \t\t} \t\telse { \t\t\t// if sucessfull \t\t\treturn \"customer-confirmation\"; \t\t} \t} } when performing spring mvc validation, the location of the bindingresult parameter is very important. in the method signature, the bindingresult parameter must appear immediately after the model attribute. display error on html <%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %> <html> <head> \t<title>customer registration form</title> \t \t<style> \t\t.error {color:red} \t</style> </head> <body> <i>fill out the form. asterisk (*) means required.</i> <br><br> \t<form:form action=\"processform\" modelattribute=\"customer\"> \t\tfirst name: <form:input path=\"firstname\" /> \t\t<br><br> \t\tlast name (*): <form:input path=\"lastname\" /> <!-- we use the error form tag to display an error when the input is not valid --> <!-- the message shown equals the messages from both of the validation annotations defined for the lastname attribute in the customer class --> \t\t<form:errors path=\"lastname\" cssclass=\"error\" /> \t\t<br><br> \t\t<input type=\"submit\" value=\"submit\" /> \t</form:form> </body> </html> $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/MVC/Request Params and Request Mappings.html",
    "title": "Request Params and Request Mappings",
    "body": " index search search back request params and request mappings contents request params controller request mappings request params spring provides for a specific annotation that allows you to retrieve request parameters directly without using the httpservletrequest object. given the form: package com.springdemo.mvc; import javax.servlet.http.httpservletrequest; import org.springframework.stereotype.controller; import org.springframework.ui.model; import org.springframework.web.bind.annotation.requestmapping; import org.springframework.web.bind.annotation.requestparam; @controller public class helloworldcontroller { \t@requestmapping(\"/processformversionthree\")\t \tpublic string processformversionthree( // we use the annotation to obtain the parameter \t\t\t@requestparam(\"studentname\") string thename, \t\t\tmodel model) { \t\t\t\t \t\t// convert the data to all caps \t\tthename = thename.touppercase(); \t\t \t\t// create the message \t\tstring result = \"hey my friend from v3! \" + thename; \t\t \t\t// add message to the model \t\tmodel.addattribute(\"message\", result); \t\t\t\t \t\treturn \"helloworld\"; \t}\t } controller request mappings they serve as a parent mapping for the controller all request mappings on methods in the controller are relative for example: package com.springdemo.mvc; import javax.servlet.http.httpservletrequest; import org.springframework.stereotype.controller; import org.springframework.ui.model; import org.springframework.web.bind.annotation.requestmapping; import org.springframework.web.bind.annotation.requestparam; @controller // this is the request mapping for the controller @requestmapping(\"/hello\") public class helloworldcontroller { \t// both of these request mappings are relative to the parent mapping \t// that is the mapping translates to domain/hello/showform \t// need a controller method to show the initial html form \t@requestmapping(\"/showform\") \tpublic string showform() { \t\treturn \"helloworld-form\"; \t} \t\t \t// need a controller method to process the html form \t@requestmapping(\"/processform\") \tpublic string processform() { \t\treturn \"helloworld\"; \t} } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/MVC/Handle String in Integer Field.html",
    "title": "Handle String Input in Integer Field",
    "body": " index search search back handle string input in integer field contents create a custom message specify properties file in configuration if we want to avoid the trace returned by errors like inputting the wrong data type (string instead of int), we can define a custom message that will override those messages. create a custom message create a properties file in resources/messages.properties // errortype.springmodelattributename.fieldname typemismatch.customer.freepasses=invalid number specify properties file in configuration we add the following in our configuration file spring-mvc-demo-servlet.xml <?xml version=\"1.0\" encoding=\"utf-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" \txmlns:xsi=\"http://www.w3.org/2001/xmlschema-instance\" \txmlns:context=\"http://www.springframework.org/schema/context\" \txmlns:mvc=\"http://www.springframework.org/schema/mvc\" \txsi:schemalocation=\" \t\thttp://www.springframework.org/schema/beans \thttp://www.springframework.org/schema/beans/spring-beans.xsd \thttp://www.springframework.org/schema/context \thttp://www.springframework.org/schema/context/spring-context.xsd \thttp://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"> \t<context:component-scan base-package=\"com.luv2code.springdemo\" /> \t<mvc:annotation-driven/> \t<bean \t\tclass=\"org.springframework.web.servlet.view.internalresourceviewresolver\"> \t\t<property name=\"prefix\" value=\"/web-inf/view/\" /> \t\t<property name=\"suffix\" value=\".jsp\" /> \t</bean> \t <!-- load custom message resources --> <bean id=\"messagesource\" class=\"org.springframework.context.support.resourcebundlemessagesource\"> \t\t\t\t<!-- path where the properties file is stored --> <property name=\"basenames\" value=\"resources/messages\" /> </bean> </beans> $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/MVC/Custom Validation.html",
    "title": "Custom Validation",
    "body": " index search search back custom validation contents create a custom java annotation create annotation clas create validator class add custom validation perform validation on controller display error on html create a custom java annotation create annotation clas package com.springdemo.mvc.validation; import java.lang.annotation.elementtype; import java.lang.annotation.retention; import java.lang.annotation.retentionpolicy; import java.lang.annotation.target; import javax.validation.constraint; import javax.validation.payload; // specify the class that holds the validation logic @constraint(validatedby = coursecodeconstraintvalidator.class) // where you can use this annotation: on a method or on a field @target( { elementtype.method, elementtype.field } ) @retention(retentionpolicy.runtime) // note the @interface (it is needed to create the annotation) public @interface coursecode { \t// define default course code \tpublic string value() default \"luv\"; \t \t// define default error message \tpublic string message() default \"must start with luv\"; \t \t// define default groups \tpublic class<?>[] groups() default {}; \t \t// define default payloads \tpublic class<? extends payload>[] payload() default {}; } create validator class this class holds the validation logic package com.springdemo.mvc.validation; import javax.validation.constraintvalidator; import javax.validation.constraintvalidatorcontext; // implements the previous constraintvalidator interface, with generics: <annotation interface, data type> public class coursecodeconstraintvalidator \timplements constraintvalidator<coursecode, string> { \tprivate string courseprefix; \t \t@override \tpublic void initialize(coursecode thecoursecode) { \t\t// obtain prefix from the \"value\" attribute of our annotation \t\tcourseprefix = thecoursecode.value(); \t} \t@override \t// called when we use the @valid annotation \tpublic boolean isvalid(string thecode, constraintvalidatorcontext theconstraintvalidatorcontext) { \t\tboolean result; \t\t \t\t// validation logic \t\tif (thecode != null) { \t\t\tresult = thecode.startswith(courseprefix); \t\t} \t\telse { \t\t\tresult = true; \t\t} \t\t \t\treturn result; \t} } add custom validation public class customer { \tprivate string firstname; \t \t@notnull(message=\"is required\") \t@size(min=1, message=\"is required\") \tprivate string lastname; \t@notnull(message=\"is required\") \t@min(value=0, message=\"must be greater than or equal to zero\") \t@max(value=10, message=\"must be less than or equal to 10\") \tprivate integer freepasses; \t@pattern(regexp=\"^[a-za-z0-9]{5}\", message=\"only 5 chars/digits\") \tprivate string postalcode; \t // use our custom validation tag \t@coursecode(value=\"tops\", message=\"must start with tops\") \tprivate string coursecode; perform validation on controller package com.springdemo.mvc; import javax.validation.valid; import org.springframework.beans.propertyeditors.stringtrimmereditor; import org.springframework.stereotype.controller; import org.springframework.ui.model; import org.springframework.validation.bindingresult; import org.springframework.web.bind.webdatabinder; import org.springframework.web.bind.annotation.initbinder; import org.springframework.web.bind.annotation.modelattribute; import org.springframework.web.bind.annotation.requestmapping; @controller @requestmapping(\"/customer\") public class customercontroller { \t// add an initbinder ... to convert trim input strings \t// remove leading and trailing whitespace \t// resolve issue for our validation \t \t@initbinder \t//@initbinder annotation works as a pre-processor \t// it will pre-process each web request to our controller \tpublic void initbinder(webdatabinder databinder) { \t\t \t\t// trim strings (true: empty strings to null) \t\tstringtrimmereditor stringtrimmereditor = new stringtrimmereditor(true); \t \t\t// for every string class apply the trim editor \t\tdatabinder.registercustomeditor(string.class, stringtrimmereditor); \t} \t \t \t@requestmapping(\"/showform\") \tpublic string showform(model themodel) { \t\t \t\tthemodel.addattribute(\"customer\", new customer()); \t\t \t\treturn \"customer-form\"; \t} \t \t@requestmapping(\"/processform\") \t// @valid: tells spring to perform validation on the customer object \t// bindingresult: results of the validation will be placed in bindingresult \tpublic string processform( \t\t\t@valid @modelattribute(\"customer\") customer thecustomer, \t\t\tbindingresult thebindingresult) { \t\t \t\tsystem.out.println(\"last name: |\" + thecustomer.getlastname() + \"|\"); \t\t \t\t// check if validation was sucessfull \t\tif (thebindingresult.haserrors()) { \t\t\t// if not sucessfull send back \t\t\treturn \"customer-form\"; \t\t} \t\telse { \t\t\t// if sucessfull \t\t\treturn \"customer-confirmation\"; \t\t} \t} } when performing spring mvc validation, the location of the bindingresult parameter is very important. in the method signature, the bindingresult parameter must appear immediately after the model attribute. display error on html <%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %> <html> <head> \t<title>customer registration form</title> \t \t<style> \t\t.error {color:red} \t</style> </head> <body> <i>fill out the form. asterisk (*) means required.</i> <br><br> \t<form:form action=\"processform\" modelattribute=\"customer\"> \t\tfirst name: <form:input path=\"firstname\" /> \t\t<br><br> \t\tlast name (*): <form:input path=\"lastname\" /> \t\t<form:errors path=\"lastname\" cssclass=\"error\" /> \t\t<br><br> \t\tfree passes: <form:input path=\"freepasses\" /> \t\t<form:errors path=\"freepasses\" cssclass=\"error\" /> <br><br> \t\tpostal code: <form:input path=\"postalcode\" /> \t\t<form:errors path=\"postalcode\" cssclass=\"error\" /> \t\t<br><br> <!-- the message shown equals the messages from both of the validation annotations defined for the coursecode attribute in the customer class --> \t\t\tcourse code: <form:input path=\"coursecode\" /> \t\t\t<form:errors path=\"coursecode\" cssclass=\"error\" /> \t\t<br><br> \t\t<input type=\"submit\" value=\"submit\" /> \t</form:form> </body> </html> $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Maven/Overview.html",
    "title": "Maven",
    "body": " index search search back maven contents standard directory structure maven is a project management tool. the most popular use of maven is for build management and dependencies. behind the scenes what maven does is: reads the configuration file of our application: pom.xml checks on the local repository if the library is already stored (like a cache) if not, it goes to the remote repository and searches for it then it saves it to the local repository finally it uses the downloaded library to build and run the application maven also downloads the libraries' dependencies. and when you build and run your application, maven will handle the class/build path for you, based on the configuration file. standard directory structure $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Maven/Additional Repositories.html",
    "title": "Additional Repositories",
    "body": " index search search back additional repositories as we have said, if maven does not find some dependency in your local repository it goes to the central repository to search for it. but what if the dependency is not in the central repository. then we have to define the repository in our pom.xml: $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Maven/POM File Structure.html",
    "title": "POM File Structure",
    "body": " index search search back pom file structure contents project coordinates dependency coordinates find dependencies the pom file has the following structure: project metadata: information about the project dependencies: list of dependencies for the project plug-ins: additional custom tasks to run (junit tests, reports, etc) project coordinates project coordinates uniquely identify a project: where: group id: name of company, group or organization artifact id: name for the project version: a specific release version dependency coordinates to add a given dependency project, we need: group id artifact id optional: version (best practice to include the version) find dependencies search maven maven repository $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Maven/Maven Archetypes.html",
    "title": "Maven Archetypes",
    "body": " index search search back maven archetypes archetypes are used to create new maven projects, you can think of them as starter projects. some archetypes are: for standalone projects: maven-archetype-quickstart for web projects: maven-archetype-webapp $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Maven/Private Repositories.html",
    "title": "Private Repositories",
    "body": " index search search back private repositories if you want to create repositories with restricted access you can: set up your own private maven repository in your server, that is secure with credentials: id/password some maven repository manager products are: archiva artifactory nexus if you do not want to create your own server, there are also cloud based solutions like: package cloud my maven repo $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/index.html",
    "title": "Spring",
    "body": " index search search back spring introduction core spring framework spring mvc hibernate spring rest spring boot thymeleaf maven spring security aspect oriented programming intro spring docs getting ready spring framework set up core spring framework spring with xml configuration inversion of control dependency injection bean scopes and life cycle spring with java annotations java annotations spring with only java spring configuration with java code spring mvc overview configuration controller view read html form data model add css and js request params and request mappings form tags form validation hibernate overview configuration annotations usage sessions database operations advanced annotations concepts onetoone onetomany eager vs lazy loading manytomany spring rest json data binding spring rest controller pojos as json exception handling spring boot overview controller spring boot project structure spring boot starters spring boot devtools spring boot actuator application properties jpa spring data jpa spring data rest thymeleaf overview tables maven overview pom file structure maven archetypes additional repositories private repositories spring security overview java configuration basic security custom login form log out cross site request forgery display user and roles authorization jdbc database authentication aspect oriented programming (aop) overview before advice pointcut expressions pointcut declarations control aspect order joinpoints afterreturning advice afterthrowing advice after advice around advice $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Set Up.html",
    "title": "Set Up",
    "body": " index search search back set up requirements: jdk java application server (i.e. tomcat) java integrated development environment (ide) spring 5 jar files (download manually or use maven) $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Security/Custom Login Form.html",
    "title": "Custom Login Form",
    "body": " index search search back custom login form contents create the form login controller now we are going to configure the security of the access to web path in application, login, logout, etc: package com.springsecurity.demo.config; import org.springframework.context.annotation.configuration; import org.springframework.security.config.annotation.authentication.builders.authenticationmanagerbuilder; import org.springframework.security.config.annotation.web.builders.httpsecurity; import org.springframework.security.config.annotation.web.configuration.enablewebsecurity; import org.springframework.security.config.annotation.web.configuration.websecurityconfigureradapter; import org.springframework.security.core.userdetails.user; import org.springframework.security.core.userdetails.user.userbuilder; @configuration @enablewebsecurity public class demosecurityconfig extends websecurityconfigureradapter { \t@override \tprotected void configure(authenticationmanagerbuilder auth) throws exception { \t\t// add our users for in memory authentication \t\tuserbuilder users = user.withdefaultpasswordencoder(); \t\t \t\tauth.inmemoryauthentication() \t\t\t.withuser(users.username(\"john\").password(\"test123\").roles(\"employee\")) \t\t\t.withuser(users.username(\"mary\").password(\"test123\").roles(\"manager\")) \t\t\t.withuser(users.username(\"susan\").password(\"test123\").roles(\"admin\")); \t} \t@override \tprotected void configure(httpsecurity http) throws exception { // here is the control of the access to web path http.authorizerequests() // require authentication for every request .anyrequest().authenticated() // and for form login customize the login page shown .and() .formlogin() \t\t\t\t\t\t// custom jsp page .loginpage(\"/showmyloginpage\") \t\t\t\t\t\t// you do not need to create a method in your controller for this endpoint, it is handled by spring .loginprocessingurl(\"/authenticatetheuser\") .permitall(); \t\t \t} } create the form we create the login page /showmyloginpage as follows: <!-- reference the spring and jsp tags --> <%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %> <%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %> <html> <head> \t<title>custom login page</title> \t<style> \t\t.failed { \t\t\tcolor: red; \t\t} \t</style> </head> <body> <h3>my custom login page</h3> \t\t<!-- the form points to the endpoint specified preivously: \"authenticatetheuser\" --> \t\t<!-- contextpath is the domain of our app, i.e. localhost:8080 --> \t<form:form action=\"${pagecontext.request.contextpath}/authenticatetheuser\" \t\t\t method=\"post\"> \t\t<!-- check for login error --> \t\t<c:if test=\"${param.error != null}\"> \t\t\t<i class=\"failed\">sorry! you entered invalid username/password.</i> \t\t</c:if> \t\t<p> \t\t\tuser name: <input type=\"text\" name=\"username\" /> \t\t</p> \t\t<p> \t\t\tpassword: <input type=\"password\" name=\"password\" /> \t\t</p> \t\t<input type=\"submit\" value=\"login\" /> \t</form:form> </body> </html> note that spring appends a parameter error when the user fails to login. that is what we use as a condition to show our error message, that is, we check if param.error exists. also, spring security defines default names for login form fields: user name field: username password field: password login controller we also need a controller method for requests to /showmyloginpage: package com.springsecurity.demo.controller; import org.springframework.stereotype.controller; import org.springframework.web.bind.annotation.getmapping; @controller public class logincontroller { \t@getmapping(\"/showmyloginpage\") \tpublic string showmyloginpage() { \t\t \t\t// this is the custom-login.jsp we created in the previous section \t\treturn \"custom-login\"; \t\t \t} } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Security/JDBC Database Authentication.html",
    "title": "JDBC Database Authentication",
    "body": " index search search back jdbc database authentication contents set up database password encryption add dependiencies jdbc properties files spring security configuration spring security can read user account info from database by default, you have to follow spring security's predefined table schemas. you can customize the table schemas, but you will be responsible for writing the code to access the data. set up database the tables we have to create are the following: password encryption in spring security 5, passwords are stored using a specific format: {id}encodedpassword the id references the operation used to encrypt the password: noop: plain text. so the password is stored as follows in the database: {noop}test123 bcrypt: bcrypt password hashing. so the password is stored as follows in the database: {bcrypt}$2a$12$r9h/cipz0gi.urnnx3kh2opst9/pgbkqquzi.ss7kiugo2t0jwmuw etc. add dependiencies we define the dependencies in our pom.xmlfile that are needed to add support to connect to databases: \t\t<!-- add mysql and c3p0 support --> \t\t<dependency> \t\t\t<groupid>mysql</groupid> \t\t\t<artifactid>mysql-connector-java</artifactid> \t\t\t<version>8.0.16</version> \t\t</dependency> \t\t \t\t<dependency> \t\t\t<groupid>com.mchange</groupid> \t\t\t<artifactid>c3p0</artifactid> \t\t\t<version>0.9.5.4</version> \t\t</dependency> jdbc properties files inside /src/main/resources we create the properties file persistence-mysql.properties for our database connections: # # jdbc connection properties # jdbc.driver=com.mysql.jdbc.driver jdbc.url=jdbc:mysql://localhost:3306/spring_security_demo_plaintext?usessl=false jdbc.user=springstudent jdbc.password=springstudent # # connection pool properties # connection.pool.initialpoolsize=5 connection.pool.minpoolsize=5 connection.pool.maxpoolsize=20 connection.pool.maxidletime=3000 spring security configuration we have to modify our main configuration class, to include our database properties file and create the datasource package com.luv2code.springsecurity.demo.config; import java.beans.propertyvetoexception; import java.util.logging.logger; import javax.sql.datasource; import org.springframework.beans.factory.annotation.autowired; import org.springframework.context.annotation.bean; import org.springframework.context.annotation.componentscan; import org.springframework.context.annotation.configuration; import org.springframework.context.annotation.propertysource; import org.springframework.core.env.environment; import org.springframework.web.servlet.viewresolver; import org.springframework.web.servlet.config.annotation.enablewebmvc; import org.springframework.web.servlet.view.internalresourceviewresolver; import com.mchange.v2.c3p0.combopooleddatasource; @configuration @enablewebmvc @componentscan(basepackages=\"com.luv2code.springsecurity.demo\") @propertysource(\"classpath:persistence-mysql.properties\") public class demoappconfig { \t// set up variable to hold the properties \t@autowired \tprivate environment env; \t \t// set up a logger for diagnostics \tprivate logger logger = logger.getlogger(getclass().getname()); \t \t \t// define a bean for viewresolver \t@bean \tpublic viewresolver viewresolver() { \t\t \t\tinternalresourceviewresolver viewresolver = new internalresourceviewresolver(); \t\t \t\tviewresolver.setprefix(\"/web-inf/view/\"); \t\tviewresolver.setsuffix(\".jsp\"); \t\t \t\treturn viewresolver; \t} \t \t// define a bean for our security datasource \t \t@bean \tpublic datasource securitydatasource() { \t\t \t\t// create connection pool \t\tcombopooleddatasource securitydatasource \t\t\t\t\t\t\t\t\t= new combopooleddatasource(); \t\t\t\t \t\t// set the jdbc driver class \t\ttry { // obtain driver from properties file \t\t\tsecuritydatasource.setdriverclass(env.getproperty(\"jdbc.driver\")); \t\t} catch (propertyvetoexception exc) { \t\t\tthrow new runtimeexception(exc); \t\t} \t\t \t\t // obtain database info from properties file \t\tlogger.info(\">>> jdbc.url=\" + env.getproperty(\"jdbc.url\")); \t\tlogger.info(\">>> jdbc.user=\" + env.getproperty(\"jdbc.user\")); \t\t \t\t \t\t// set database connection props \t\tsecuritydatasource.setjdbcurl(env.getproperty(\"jdbc.url\")); \t\tsecuritydatasource.setuser(env.getproperty(\"jdbc.user\")); \t\tsecuritydatasource.setpassword(env.getproperty(\"jdbc.password\")); \t\t \t\t// set connection pool props \t\tsecuritydatasource.setinitialpoolsize( \t\t\t\tgetintproperty(\"connection.pool.initialpoolsize\")); \t\tsecuritydatasource.setminpoolsize( \t\t\t\tgetintproperty(\"connection.pool.minpoolsize\")); \t\tsecuritydatasource.setmaxpoolsize( \t\t\t\tgetintproperty(\"connection.pool.maxpoolsize\")); \t\tsecuritydatasource.setmaxidletime( \t\t\t\tgetintproperty(\"connection.pool.maxidletime\")); \t\t \t\treturn securitydatasource; \t} \t \t// need a helper method \t// read environment property and convert to int \t \tprivate int getintproperty(string propname) { \t\t \t\tstring propval = env.getproperty(propname); \t\t \t\t// now convert to int \t\tint intpropval = integer.parseint(propval); \t\t \t\treturn intpropval; \t} } now in our security configuration we do two things: inject the datasource we defined previouly that holds authentication information tell spring to use jdbc for authentication package com.springsecurity.demo.config; import javax.sql.datasource; import org.springframework.beans.factory.annotation.autowired; import org.springframework.context.annotation.configuration; import org.springframework.security.config.annotation.authentication.builders.authenticationmanagerbuilder; import org.springframework.security.config.annotation.web.builders.httpsecurity; import org.springframework.security.config.annotation.web.configuration.enablewebsecurity; import org.springframework.security.config.annotation.web.configuration.websecurityconfigureradapter; import org.springframework.security.core.userdetails.user; import org.springframework.security.core.userdetails.user.userbuilder; @configuration @enablewebsecurity public class demosecurityconfig extends websecurityconfigureradapter { \t// add a reference to our security data source \t@autowired \tprivate datasource securitydatasource; \t \t \t@override \tprotected void configure(authenticationmanagerbuilder auth) throws exception { \t\t// use jdbc authentication \t\tauth.jdbcauthentication().datasource(securitydatasource); \t\t \t} \t@override \tprotected void configure(httpsecurity http) throws exception { \t\thttp.authorizerequests() \t\t\t.antmatchers(\"/\").hasrole(\"employee\") \t\t\t.antmatchers(\"/leaders/**\").hasrole(\"manager\") \t\t\t.antmatchers(\"/systems/**\").hasrole(\"admin\") \t\t\t.and() \t\t\t.formlogin() \t\t\t\t.loginpage(\"/showmyloginpage\") \t\t\t\t.loginprocessingurl(\"/authenticatetheuser\") \t\t\t\t.permitall() \t\t\t.and() \t\t\t.logout().permitall() \t\t\t.and() \t\t\t.exceptionhandling().accessdeniedpage(\"/access-denied\"); \t\t \t} } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Security/Authorization.html",
    "title": "Authorization",
    "body": " index search search back authorization contents create controllers define user roles and restrict accessand restrict access display content based on roles in this section we are going to show how to restrict access based on roles. our example follows the following scheme: where only managers and above can access the /leaders endpoint and only admins can access the /systems endpoint. create controllers we create a basic controller for every endpoint: package com.springsecurity.demo.controller; import org.springframework.stereotype.controller; import org.springframework.web.bind.annotation.getmapping; @controller public class democontroller { \t// add request mapping for index page \t@getmapping(\"/\") \tpublic string showhome() { \t\t \t\treturn \"home\"; \t} \t \t// add request mapping for /leaders \t@getmapping(\"/leaders\") \tpublic string showleaders() { \t\t \t\treturn \"leaders\"; \t} \t \t// add request mapping for /systems \t@getmapping(\"/systems\") \tpublic string showsystems() { \t\t \t\treturn \"systems\"; \t} \t } we also create a controller for the /acess-denied endpoint: package com.springsecurity.demo.controller; import org.springframework.stereotype.controller; import org.springframework.web.bind.annotation.getmapping; @controller public class logincontroller { \t@getmapping(\"/showmyloginpage\") \tpublic string showmyloginpage() { \t\t \t\t// return \"plain-login\"; \t\treturn \"fancy-login\"; \t} \t \t// add request mapping for /access-denied \t@getmapping(\"/access-denied\") \tpublic string showaccessdenied() { \t\t \t\treturn \"access-denied\"; \t} } define user roles and restrict accessand restrict access in our configuration file we had saved in-memory a list of users with some defined roles, we are going to update it to have more roles. we are also going to define the authorization scheme we showed earlier. package com.springsecurity.demo.config; import org.springframework.context.annotation.configuration; import org.springframework.security.config.annotation.authentication.builders.authenticationmanagerbuilder; import org.springframework.security.config.annotation.web.builders.httpsecurity; import org.springframework.security.config.annotation.web.configuration.enablewebsecurity; import org.springframework.security.config.annotation.web.configuration.websecurityconfigureradapter; import org.springframework.security.core.userdetails.user; import org.springframework.security.core.userdetails.user.userbuilder; @configuration @enablewebsecurity public class demosecurityconfig extends websecurityconfigureradapter { @override protected void configure(authenticationmanagerbuilder auth) throws exception { // add our users for in memory authentication userbuilder users = user.withdefaultpasswordencoder(); // add more roles auth.inmemoryauthentication() .withuser(users.username(\"john\").password(\"test123\").roles(\"employee\")) .withuser(users.username(\"mary\").password(\"test123\").roles(\"employee\", \"manager\")) .withuser(users.username(\"susan\").password(\"test123\").roles(\"employee\", \"admin\")); } @override protected void configure(httpsecurity http) throws exception { // handle requests http.authorizerequests() // set role for index page .antmatchers(\"/\").hasrole(\"employee\") // set role for leaders page .antmatchers(\"/leaders/**\").hasrole(\"manager\") // set role for systems page .antmatchers(\"/systems/**\").hasrole(\"admin\") .and() .formlogin() .loginpage(\"/showmyloginpage\") .loginprocessingurl(\"/authenticatetheuser\") .permitall() .and() .logout().permitall() // also define the page where the user is redirected if it does not have access to the resource it requests .and() .exceptionhandling().accessdeniedpage(\"/access-denied\"); } } display content based on roles in our home page, we add two conditionals so only managers can see the link to the leaders page, and only admins can see the link to the systems page: <%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %> <%@ taglib prefix=\"security\" uri=\"http://www.springframework.org/security/tags\" %> <html> <head> \t<title>luv2code company home page</title> </head> <body> \t<h2>luv2code company home page</h2> \t<hr> \t<p> \twelcome to the luv2code company home page! \t</p> \t<hr> \t<!-- display user name and role --> \t<p> \t\tuser: <security:authentication property=\"principal.username\" /> \t\t<br><br> \t\trole(s): <security:authentication property=\"principal.authorities\" /> \t</p> \t<!-- check if user has the manager role, if so show the link --> \t<security:authorize access=\"hasrole('manager')\"> \t\t<!-- add a link to point to /leaders ... this is for the managers --> \t\t<p> \t\t\t<a href=\"${pagecontext.request.contextpath}/leaders\">leadership meeting</a> \t\t\t(only for manager peeps) \t\t</p> \t</security:authorize>\t \t<!-- check if user has the admin role, if so show the link --> \t<security:authorize access=\"hasrole('admin')\"> \t\t<!-- add a link to point to /systems ... this is for the admins --> \t\t<p> \t\t\t<a href=\"${pagecontext.request.contextpath}/systems\">it systems meeting</a> \t\t\t(only for admin peeps) \t\t</p> \t</security:authorize> \t<hr> \t<!-- add a logout button --> \t<form:form action=\"${pagecontext.request.contextpath}/logout\" \t\t\t method=\"post\"> \t\t<input type=\"submit\" value=\"logout\" /> \t</form:form> </body> </html> $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Security/Java Configuration.html",
    "title": "Java Configuration",
    "body": " index search search back java configuration contents web app initializer we are going to show the demoappconfig.java that holds the base configuration of our application: package com.springsecurity.demo.config; import org.springframework.context.annotation.bean; import org.springframework.context.annotation.componentscan; import org.springframework.context.annotation.configuration; import org.springframework.web.servlet.viewresolver; import org.springframework.web.servlet.config.annotation.enablewebmvc; import org.springframework.web.servlet.view.internalresourceviewresolver; // tell spring this is a configuration file @configuration // enables annotations @enablewebmvc // search for components in \"com.springsecurity.demo\" package @componentscan(basepackages=\"com.springsecurity.demo\") public class demoappconfig { \t// define a bean for viewresolver \t@bean \tpublic viewresolver viewresolver() { \t\t \t\tinternalresourceviewresolver viewresolver = new internalresourceviewresolver(); \t\t \t\tviewresolver.setprefix(\"/web-inf/view/\"); \t\tviewresolver.setsuffix(\".jsp\"); \t\t \t\treturn viewresolver; \t} } as you can see we have defined a viewresolver that prepends /web-inf/view/ to every view, and appends .jsp to every view. web app initializer spring mvc provides support for web app initialization, and makes sure your code is automatically detected. your code is used to initialize the servlet container. as an example: package com.springsecurity.demo.config; import org.springframework.web.servlet.support.abstractannotationconfigdispatcherservletinitializer; public class myspringmvcdispatcherservletinitializer extends abstractannotationconfigdispatcherservletinitializer { \t@override \tprotected class<?>[] getrootconfigclasses() { \t\t// todo auto-generated method stub \t\treturn null; \t} \t@override \t// tell spring where the configuration for the servlet is \tprotected class<?>[] getservletconfigclasses() { \t\treturn new class[] { demoappconfig.class }; \t} \t@override \t// map the servlet to the path \"/\" \tprotected string[] getservletmappings() { \t\treturn new string[] { \"/\" }; \t} } here is the correspondence with the xml servlet configuration file: $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Security/Basic Security.html",
    "title": "Basic Security",
    "body": " index search search back basic security contents create security spring initializer create spring security configuration configuration add users passwords and roles create security spring initializer spring security provides support for security initialization. your security code is used to initialize the servlet container. there is a special class to register the spring security filters. you need this class for the spring security filters to \"activate\". next we show an example: package com.springsecurity.demo.config; import org.springframework.security.web.context.abstractsecuritywebapplicationinitializer; public class securitywebapplicationinitializer \t\t\t\t\t\textends abstractsecuritywebapplicationinitializer { } create spring security configuration (@configuration) now we create our spring security configuration file: package com.springsecurity.demo.config; import org.springframework.context.annotation.configuration; import org.springframework.security.config.annotation.authentication.builders.authenticationmanagerbuilder; import org.springframework.security.config.annotation.web.builders.httpsecurity; import org.springframework.security.config.annotation.web.configuration.enablewebsecurity; import org.springframework.security.config.annotation.web.configuration.websecurityconfigureradapter; import org.springframework.security.core.userdetails.user; import org.springframework.security.core.userdetails.user.userbuilder; // tell spring this is a configuration file @configuration @enablewebsecurity public class demosecurityconfig extends websecurityconfigureradapter { \t@override \tprotected void configure(authenticationmanagerbuilder auth) throws exception { \t\t// add our users for in memory authentication (this is for test purposes only, you would usually retrieve this information encrypted from the database) \t\tuserbuilder users = user.withdefaultpasswordencoder(); \t\t // use the authenticationmanagerbuilder given by spring to handle authentication \t\tauth \t\t\t.inmemoryauthentication() \t\t\t.withuser(users.username(\"john\").password(\"test123\").roles(\"employee\")) \t\t\t.withuser(users.username(\"mary\").password(\"test123\").roles(\"manager\")) \t\t\t.withuser(users.username(\"susan\").password(\"test123\").roles(\"admin\")); \t} } add users, passwords and roles $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Security/index.html",
    "title": "Overview",
    "body": " index search search back overview spring security is implemented using servlet filters in the background there are two methods of securing a web app: declarative programmatic servlet filters servlet filters are used to pre-process/post-process web requests. they can route web requests based on security logic. spring provides a bulk of security functionality with servlet filters. this is described in the following picture: we can see spring intercepts the request to /mytopsecretstuff and uses the app's security configuration, alongside information about the user, passwords and roles to pre and post-process the request. spring security in action next we show a flowchart of the pre-processing made by spring security filters: if the resource is protected we go to step (2), else we go to step (4) if the user is authenticated we go to step (3), else we go to step (6) if the user is authorized to access the resource we go to step (4), else we go to step (5) the resource is shown to the user the access to the resource is denied we send the user to the login page, if the user logins correctly we go to step (3) declarative security you define your application's security constraints in configuration. for that, you can either: use all java configuration (@configuration) use a spring configuration file (xml) programmatic security you can also do it programmatically: spring security provides an api for custom application coding. it also provides greater customization for specific apps. authentication/authorization information about users/passwords/roles, etc can be stored: in-memory jdbc ldap custom etc maven dependencies to use this framework, you have to add the following dependency to your project: \t<dependencies> ... \t\t<!-- spring security --> \t\t<!-- spring-security-web and spring-security-config --> \t\t \t\t<dependency> \t\t <groupid>org.springframework.security</groupid> \t\t <artifactid>spring-security-web</artifactid> \t\t <version>${springsecurity.version}</version> \t\t</dependency> ... \t<dependencies> $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Security/Cross Site Request Forgery.html",
    "title": "Cross Site Request Forgery",
    "body": " index search search back cross site request forgery contents how to see the csrf token spring security protects against cross-site request forgery. csrf is a security attack where a website tricks you into executing an action on a web application that you are currently logged in. protection from this type of attack is embedded in the spring security filters. this protection is enabled by default. spring security uses the synchronizer token pattern, where each request includes a session cookie and a randomly generated token. so for request processing, spring security verifies the token before processing. how to use it? for form submissions use \"post\" instead of \"get\" the spring security tag <form:form> automatically adds the csrf token. if you do not use the tag, you must manually add the csrf token. if you do not add the token you get an error message: 403 forbidden, and further information about how the token cannot be null. how to see the csrf token? when your jsp with the <form:form> tag is processed into an html page, you will be able to see the token inside the form tag: $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Security/Display User and Roles.html",
    "title": "Display User and Roles",
    "body": " index search search back display user and roles contents add jsp tag library as dependency jsp page in this section we are going to show how to display in our jsp files the user id and its role: add jsp tag library as dependency first we add to our pom.xml file the jsp tag library: \t\t<!-- add spring security taglibs support --> \t\t<dependency> \t\t <groupid>org.springframework.security</groupid> \t\t <artifactid>spring-security-taglibs</artifactid> \t\t <version>${springsecurity.version}</version> \t\t</dependency>\t jsp page then add the tag library to the jsp page, and we use its tags to access the user id and its role: <%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %> <!-- add tag library --> <%@ taglib prefix=\"security\" uri=\"http://www.springframework.org/security/tags\" %> <html> <head> \t<title>luv2code company home page</title> </head> <body> \t<h2>luv2code company home page</h2> \t<hr> \t<p> \twelcome to the luv2code company home page! \t</p> \t<hr> \t<!-- display user name and role --> \t<p> \t\tuser: <security:authentication property=\"principal.username\" /> \t\t<br><br> \t\trole(s): <security:authentication property=\"principal.authorities\" /> \t</p> \t<hr> \t<!-- add a logout button --> \t<form:form action=\"${pagecontext.request.contextpath}/logout\" \t\t\t method=\"post\"> \t\t<input type=\"submit\" value=\"logout\" /> \t</form:form> </body> </html> $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Security/Log Out.html",
    "title": "Log Out",
    "body": " index search search back log out contents configuration log out button we are going to show in this section how to add the logout functionality to our spring application. configuration to our existing configuration we add: package com.springsecurity.demo.config; import org.springframework.context.annotation.configuration; import org.springframework.security.config.annotation.authentication.builders.authenticationmanagerbuilder; import org.springframework.security.config.annotation.web.builders.httpsecurity; import org.springframework.security.config.annotation.web.configuration.enablewebsecurity; import org.springframework.security.config.annotation.web.configuration.websecurityconfigureradapter; import org.springframework.security.core.userdetails.user; import org.springframework.security.core.userdetails.user.userbuilder; @configuration @enablewebsecurity public class demosecurityconfig extends websecurityconfigureradapter { \t@override \tprotected void configure(authenticationmanagerbuilder auth) throws exception { \t\t// add our users for in memory authentication \t\tuserbuilder users = user.withdefaultpasswordencoder(); \t\t \t\tauth.inmemoryauthentication() \t\t\t.withuser(users.username(\"john\").password(\"test123\").roles(\"employee\")) \t\t\t.withuser(users.username(\"mary\").password(\"test123\").roles(\"manager\")) \t\t\t.withuser(users.username(\"susan\").password(\"test123\").roles(\"admin\")); \t} \t@override \tprotected void configure(httpsecurity http) throws exception { // here is the control of the access to web path http.authorizerequests() // require authentication for every request .anyrequest().authenticated() .and() .formlogin() .loginpage(\"/showmyloginpage\") .loginprocessingurl(\"/authenticatetheuser\") .permitall(); // add logout functionality .and() .logout().permitall() \t\t \t} } the default url for logging out is /logout. log out button now we create the logout button in our home page: <%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %> <html> <head> \t<title>luv2code company home page</title> </head> <body> \t<h2>luv2code company home page</h2> \t<hr> \t<p> \twelcome to the luv2code company home page! \t</p> \t<!-- add a logout button: it point to \"/logout\" endpoint --> \t<form:form action=\"${pagecontext.request.contextpath}/logout\" \t\t\t method=\"post\"> \t\t<input type=\"submit\" value=\"logout\" /> \t</form:form> </body> </html> note that the logout logic is handled directly by spring, what it does is: invalidate the user's http session and remove cookies, etc. sends the user back to the login page appends a logout parameter: ?logout $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Thymeleaf/Overview.html",
    "title": "Overview",
    "body": " index search search back overview contents placement example thymeleaf is a java templating engine. a thymeleaf template can be an html page with some thymeleaf expressions and include dynamic content from thymeleaf expressions. in a web app, thymeleaf is processed on the server. to use thymeleaf you have to include it in your dependencies: ... \t\t<dependency> \t\t\t<groupid>org.springframework.boot</groupid> \t\t\t<artifactid>spring-boot-starter-thymeleaf</artifactid> \t\t</dependency> ... placement in spring boot, your thymeleaf template files go in src/main/resources/templates. and for web apps, thymeleaf templates have an .html extension. example given the following controller: @controller public class democontroller { \t// create a mapping for \"/hello\" \t@getmapping(\"/hello\") \tpublic string sayhello(model themodel) { \t\t \t\tthemodel.addattribute(\"thedate\", new java.util.date()); \t\t \t\treturn \"helloworld\"; \t} } we create the corresponding template helloworld.html: <!doctype html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> \t<title>thymeleaf demo</title> </head> <!-- we obtain the date from the model --> <body> \t<p th:text=\"'time on the server is ' + ${thedate}\" /> </body> </html> to add styles, we create a css files in src/main/resources/static/css, and then we reference the styles: <!doctype html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> \t<title>thymeleaf demo</title> \t<!-- reference css file --> \t<link rel=\"stylesheet\" \t\t th:href=\"@{/css/demo.css}\" /> </head> <body> \t<p th:text=\"'time on the server is ' + ${thedate}\" class=\"funny\" /> </body> </html> $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Thymeleaf/Tables.html",
    "title": "Tables in Thymeleaf",
    "body": " index search search back tables in thymeleaf contents controller entity template in this section we are going to show how to create a table with thymeleaf: controller we create a controller for employee, to list and add employees. package com.springboot.thymeleafdemo.controller; import java.util.arraylist; import java.util.list; import javax.annotation.postconstruct; import org.springframework.stereotype.controller; import org.springframework.ui.model; import org.springframework.web.bind.annotation.getmapping; import org.springframework.web.bind.annotation.requestmapping; import com.springboot.thymeleafdemo.model.employee; @controller @requestmapping(\"/employees\") public class employeecontroller { \t// load employee data \t \tprivate list<employee> theemployees; \t \t@postconstruct \tprivate void loaddata() { \t\t \t\t// create employees \t\temployee emp1 = new employee(1, \"leslie\", \"andrews\", \"leslie@luv2code.com\"); \t\temployee emp2 = new employee(2, \"emma\", \"baumgarten\", \"emma@luv2code.com\"); \t\temployee emp3 = new employee(3, \"avani\", \"gupta\", \"avani@luv2code.com\"); \t\t// create the list \t\ttheemployees = new arraylist<>(); \t\t \t\t// add to the list \t\ttheemployees.add(emp1); \t\ttheemployees.add(emp2); \t\ttheemployees.add(emp3); \t \t} \t \t// add mapping for \"/list\" \t@getmapping(\"/list\") \tpublic string listemployees(model themodel) { \t\t \t\t// add to the spring model \t\tthemodel.addattribute(\"employees\", theemployees); \t\t \t\treturn \"list-employees\"; \t} } entity we create the entity employee: package com.springboot.thymeleafdemo.model; public class employee { \tprivate int id; \tprivate string firstname; \tprivate string lastname; \tprivate string email; \tpublic employee() { \t\t \t} \tpublic employee(int id, string firstname, string lastname, string email) { \t\tthis.id = id; \t\tthis.firstname = firstname; \t\tthis.lastname = lastname; \t\tthis.email = email; \t} \tpublic int getid() { \t\treturn id; \t} \tpublic void setid(int id) { \t\tthis.id = id; \t} \tpublic string getfirstname() { \t\treturn firstname; \t} \tpublic void setfirstname(string firstname) { \t\tthis.firstname = firstname; \t} \tpublic string getlastname() { \t\treturn lastname; \t} \tpublic void setlastname(string lastname) { \t\tthis.lastname = lastname; \t} \tpublic string getemail() { \t\treturn email; \t} \tpublic void setemail(string email) { \t\tthis.email = email; \t} \t@override \tpublic string tostring() { \t\treturn \"employee [id=\" + id + \", firstname=\" + firstname + \", lastname=\" + lastname + \", email=\" + email + \"]\"; \t} \t\t } template finally we create the template for list-employees.html: <!doctype html> <html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"> <head> <!-- required meta tags --> <meta charset=\"utf-8\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"> <!-- bootstrap css --> <link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/css/bootstrap.min.css\" integrity=\"sha384-gjzzqfgwb1qttn6wy59fff1bugjplsa9dkkmp0dgimdm4iymj70gzwkybi706tws\" crossorigin=\"anonymous\"> <title>employee directory</title> </head> <body> <div class=\"container\"> <h3>employee directory</h3> <hr> <table class=\"table table-bordered table-striped\"> <thead class=\"thead-dark\"> <tr> <th>first name</th> <th>last name</th> <th>email</th> </tr> </thead> <tbody> <!-- for loop for all employees, stored in the model --> <tr th:each=\"tempemployee : ${employees}\"> <td th:text=\"${tempemployee.firstname}\" />\t <td th:text=\"${tempemployee.lastname}\" />\t <td th:text=\"${tempemployee.email}\" />\t </tr> </tbody>\t\t </table> </div> </body> </html> $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Bean Scopes/Life Cycle.html",
    "title": "Bean Life Cycle",
    "body": " index search search back bean life cycle contents define methods configure hooks in the configuration file main method notes the bean life cycle is as follows: as you can see you can add method/hooks: add custom code during bean initialization calling business logic methods setting up handles to resources (db, sockets, etc) add custom code during bean destruction calling business logic methods clean up handles to resources (db, sockets, etc) define methods first of all we define the methods in our bean: package com.springdemo; public class trackcoach implements coach { \tprivate fortuneservice fortuneservice; \tpublic trackcoach() { \t\t \t} \t \tpublic trackcoach(fortuneservice fortuneservice) { \t\tthis.fortuneservice = fortuneservice; \t} \t@override \tpublic string getdailyworkout() { \t\treturn \"run a hard 5k\"; \t} \t@override \tpublic string getdailyfortune() { \t\treturn \"just do it: \" + fortuneservice.getfortune(); \t} \t// add an init method \tpublic void domystartupstuff() { \t\tsystem.out.println(\"trackcoach: inside method domystartupstuff\"); \t} \t \t// add a destroy method \tpublic void domycleanupstuffyoyo() { \t\tsystem.out.println(\"trackcoach: inside method domycleanupstuffyoyo\");\t\t \t} } configure hooks in the configuration file once the initialization and clean-up methods have been defined, we configure them in our configuration file: <?xml version=\"1.0\" encoding=\"utf-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/xmlschema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemalocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"> \t<!-- define your beans here --> \t \t<!-- define the dependency --> \t<bean id=\"myfortuneservice\" \t class=\"com.springdemo.happyfortuneservice\"> \t</bean> \t \t<!-- note the new tag \"scope\" --> \t<bean id=\"mycoach\" \tclass=\"com.springdemo.trackcoach\" \t\tinit-method=\"domystartupstuff\" \t\tdestroy-method=\"domycleanupstuffyoyo\">\t \t\t \t\t<!-- set up constructor injection --> \t\t<constructor-arg ref=\"myfortuneservice\" /> \t</bean> </beans> main method now in our app, we create the bean to check that our methods are being called: package com.springdemo; import org.springframework.context.support.classpathxmlapplicationcontext; public class beanlifecycledemoapp { \t \tpublic static void main(string[] args) { \t\t// load the spring configuration file \t\tclasspathxmlapplicationcontext context = \t\t\t\tnew classpathxmlapplicationcontext(\"beanlifecycle-applicationcontext.xml\"); \t\t\t\t \t\t// retrieve bean from spring container \t\tcoach thecoach = context.getbean(\"mycoach\", coach.class); \t\tsystem.out.println(thecoach.getdailyworkout()); \t\t \t\t// close the context \t\tcontext.close(); \t} } notes when using xml configuration, i want to provide additional details regarding the method signatures of the init-method and destroy-method . access modifier: the method can have any access modifier (public, protected, private) return type: the method can have any return type. however, \"void' is most commonly used. if you give a return type just note that you will not be able to capture the return value. as a result, \"void\" is commonly used. method name: the method can have any method name. arguments: the method can not accept any arguments. the method should be no-arg. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Bean Scopes/Bean Scopes and Life cycle.html",
    "title": "Spring Bean Scopes and Life Cycle",
    "body": " index search search back spring bean scopes and life cycle scope life cycle $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Bean Scopes/Scope.html",
    "title": "Bean Scopes",
    "body": " index search search back bean scopes contents intro specify scope in xml config file main method intro the scope of a bean refers to the life cycle of the bean: how long does it live how many instances are created how is the bean shared the default scope of the bean is a singleton: the spring container creates only one instance of the bean it is cached in memory all requests to the bean will return a shared reference to the same bean other scopes are: a singleton scope is good for stateless data a prototype scope is good for stateful data (the container returns a new bean for each request). note that for this type of bean, spring does not call the destroy method. specify scope in xml config file <?xml version=\"1.0\" encoding=\"utf-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/xmlschema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemalocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"> <!-- define your beans here --> <!-- define the dependency --> <bean id=\"myfortuneservice\" class=\"com.springdemo.happyfortuneservice\"> </bean> <!-- note the new tag \"scope\" --> <bean id=\"mycoach\" class=\"com.springdemo.trackcoach\" scope=\"prototype\">\t <!-- set up constructor injection --> <constructor-arg ref=\"myfortuneservice\" /> </bean> </beans> main method now, from our application we do: package com.springdemo; import org.springframework.context.support.classpathxmlapplicationcontext; public class beanscopedemoapp { \tpublic static void main(string[] args) { \t\t// load the spring configuration file \t\tclasspathxmlapplicationcontext context = \t\t\t\tnew classpathxmlapplicationcontext(\"beanscope-applicationcontext.xml\"); \t\t\t\t \t\t// retrieve bean from spring container \t\tcoach thecoach = context.getbean(\"mycoach\", coach.class); \t\tcoach alphacoach = context.getbean(\"mycoach\", coach.class); \t\t \t\t// check if they are the same \t\tboolean result = (thecoach == alphacoach); \t\t \t\t// print out the results \t\tsystem.out.println(\"\\npointing to the same object: \" + result); \t\t \t\tsystem.out.println(\"\\nmemory location for thecoach: \" + thecoach); \t\tsystem.out.println(\"\\nmemory location for alphacoach: \" + alphacoach + \"\\n\"); \t \t\t// close the context \t\tcontext.close(); \t} } observe, the result variable should be set to false, because we are using the prototype scope. also the values of the memory location for the two objects should be distinct for that same reason. however if we were using scope=\"singleton\", then result should be true, and both objects should have the same memory location. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Spring Rest/Spring Rest Controller.html",
    "title": "Spring Rest Controller",
    "body": " index search search back spring rest controller contents hello world configuration general servlet initializer controller spring web mvc provides support for spring rest. for that we use a new annotation called restcontroller which is an extension of controller and handles rest requests and responses. spring rest will also automatically convert java pojos to json as long as the jackson project is on the classpath or pom.xml. hello world to exemplify how to set up a rest controller in spring we will create an application that upong request sends back a hello world! message: configuration first of all, make sure you have the jackson project, mvc and rest and also servlet libraries as a maven dependency or as a library in your classpath. \t<dependencies> \t\t<!-- add spring mvc and rest support --> \t\t<dependency> \t\t\t<groupid>org.springframework</groupid> \t\t\t<artifactid>spring-webmvc</artifactid> \t\t\t<version>5.0.5.release</version> \t\t</dependency> \t\t \t\t<!-- add jackson for json converters --> \t\t<dependency> \t\t\t<groupid>com.fasterxml.jackson.core</groupid> \t\t\t<artifactid>jackson-databind</artifactid> \t\t\t<version>2.9.9.2</version> \t\t</dependency> \t\t<!-- add servlet support for \t\t\t spring's abstractannotationconfigdispatcherservletinitializer --> \t\t<dependency> \t\t\t<groupid>javax.servlet</groupid> \t\t\t<artifactid>javax.servlet-api</artifactid> \t\t\t<version>3.1.0</version> \t\t</dependency> \t\t<!-- add support for jsp ... get rid of eclipse error -->\t\t\t\t \t\t<dependency> \t\t\t<groupid>javax.servlet.jsp</groupid> \t\t\t<artifactid>javax.servlet.jsp-api</artifactid> \t\t\t<version>2.3.1</version> \t\t</dependency> \t\t\t\t \t</dependencies> general we create a configuration class as follows: package com.springdemo.config; import org.springframework.context.annotation.componentscan; import org.springframework.context.annotation.configuration; import org.springframework.web.servlet.config.annotation.enablewebmvc; import org.springframework.web.servlet.config.annotation.webmvcconfigurer; // mark it as a configuration class @configuration @enablewebmvc // enable component scanning in our source code @componentscan(\"com.springdemo\") public class demoappconfig implements webmvcconfigurer { } servlet initializer we have to specify the configuration of our servlet, for this we extend abstractannotationconfigdispatcherservletinitializer: package com.springdemo.config; import org.springframework.web.servlet.support.abstractannotationconfigdispatcherservletinitializer; public class myspringmvcdispatcherservletinitializer extends abstractannotationconfigdispatcherservletinitializer { \t@override \tprotected class<?>[] getrootconfigclasses() { \t\t// todo auto-generated method stub \t\treturn null; \t} \t@override \tprotected class<?>[] getservletconfigclasses() { // specify our config class \t\treturn new class[] { demoappconfig.class }; \t} \t@override \tprotected string[] getservletmappings() { \t\treturn new string[] { \"/\" }; \t} } controller for this we need to create our server with the controller that handles this request: package com.springdemo.rest; import org.springframework.web.bind.annotation.getmapping; import org.springframework.web.bind.annotation.requestmapping; import org.springframework.web.bind.annotation.restcontroller; @restcontroller @requestmapping(\"/test\") public class demorestcontroller { \t// add code for the \"/hello\" endpoint \t \t@getmapping(\"/hello\") \tpublic string sayhello() { \t\treturn \"hello world!\"; \t} \t } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Spring Rest/POJOs as JSON.html",
    "title": "POJOs as JSON",
    "body": " index search search back pojos as json contents create pojo create service to test converting pojos to json we are going to create a service that allows us to retrieve a list of students: create pojo we are going to create the student entity: package com.springdemo.entity; public class student { \tprivate string firstname; \tprivate string lastname; \t \tpublic student() { \t\t \t} \tpublic student(string firstname, string lastname) { \t\tthis.firstname = firstname; \t\tthis.lastname = lastname; \t} \tpublic string getfirstname() { \t\treturn firstname; \t} \tpublic void setfirstname(string firstname) { \t\tthis.firstname = firstname; \t} \tpublic string getlastname() { \t\treturn lastname; \t} \tpublic void setlastname(string lastname) { \t\tthis.lastname = lastname; \t} \t } create service we now code the logic that handles the controller. package com.springdemo.rest; import java.util.arraylist; import java.util.list; import javax.annotation.postconstruct; import org.springframework.web.bind.annotation.getmapping; import org.springframework.web.bind.annotation.pathvariable; import org.springframework.web.bind.annotation.requestmapping; import org.springframework.web.bind.annotation.restcontroller; import com.luv2code.springdemo.entity.student; @restcontroller @requestmapping(\"/api\") public class studentrestcontroller { \tprivate list<student> thestudents; \t \t \t// define @postconstruct to load the student data ... only once! \t@postconstruct \tpublic void loaddata() { \t \t\tthestudents = new arraylist<>(); \t\t \t\tthestudents.add(new student(\"poornima\", \"patel\")); \t\tthestudents.add(new student(\"mario\", \"rossi\")); \t\tthestudents.add(new student(\"mary\", \"smith\"));\t\t \t} \t \t \t \t// define endpoint for \"/students\" - return list of students \t@getmapping(\"/students\") \tpublic list<student> getstudents() { \t\t\t \t\treturn thestudents; \t} \t \t// define endpoint for \"/students/{studentid}\" - return student at index \t@getmapping(\"/students/{studentid}\") \tpublic student getstudent(@pathvariable int studentid) { \t\t \t\t// just index into the list ... keep it simple for now \t\treturn thestudents.get(studentid); \t\t \t} } note that the endpoint \"/students/{studentid}\" has a path variable studentid $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Spring Rest/JSON Data Binding.html",
    "title": "Java JSON Data Binding",
    "body": " index search search back java json data binding contents set up create pojo class main app nested objects ignore unknwon properties data binding is the process of converting json data to a java pojo (the conversion goes both ways) data binding is the same as serialization/deserialization and marshalling/unmarshalling. spring uses the jackson project behind the scenes which handles data binding between json and java pojos. for conversion we use object mapper by default jackson will call appropiate getter and setter methods to populate a pojo from a json or to create a json object from a pojo. to convert from json to java, jackson calls the setter methods to convert from java to json, jackson calls the getter methods set up add jackson project as a dependency in the maven file: \t<dependencies> \t\t<!-- todo: add your dependency here --> \t\t<dependency> \t\t\t<groupid>com.fasterxml.jackson.core</groupid> \t\t\t<artifactid>jackson-databind</artifactid> \t\t\t<version>2.10.0.pr1</version> \t\t</dependency>\t \t\t\t \t</dependencies> create pojo class we now create the class we are going to convert to json (serialize): package com.jackson.json.demo; public class student { \tprivate int id; \tprivate string firstname; \tprivate string lastname; \tprivate boolean active; \t \tpublic student() { \t\t \t} \t \tpublic int getid() { \t\treturn id; \t} \t \tpublic void setid(int id) { \t\tthis.id = id; \t} \t \tpublic string getfirstname() { \t\treturn firstname; \t} \t \tpublic void setfirstname(string firstname) { \t\tthis.firstname = firstname; \t} \t \tpublic string getlastname() { \t\treturn lastname; \t} \t \tpublic void setlastname(string lastname) { \t\tthis.lastname = lastname; \t} \t \tpublic boolean isactive() { \t\treturn active; \t} \t \tpublic void setactive(boolean active) { \t\tthis.active = active; \t} \t } main app now, to test it we are going to create a student object by reading from a json object: package com.jackson.json.demo; import java.io.file; import com.fasterxml.jackson.databind.objectmapper; public class driver { \tpublic static void main(string[] args) { \t\t \t\ttry { \t\t\t// create object mapper \t\t\tobjectmapper mapper = new objectmapper(); \t\t\t \t\t\t// read json file and map/convert to java pojo: \t\t\t// data/sample-lite.json \t\t\t \t\t\tstudent thestudent = mapper.readvalue( \t\t\t\t\t\tnew file(\"data/sample-lite.json\"), student.class); \t\t} \t\tcatch (exception exc) { \t\t\texc.printstacktrace(); \t\t} \t} } nested objects but, how can we read nested properties inside a json file, like the following: { \t\"id\": 14, \t\"firstname\": \"mario\", \t\"lastname\": \"rossi\", \t\"active\": true, \t\"address\": { \t\t\"street\": \"100 main st\", \t\t\"city\": \"philadelphia\", \t\t\"state\": \"pennsylvania\", \t\t\"zip\": \"19103\", \t\t\"country\": \"usa\" \t}, \t\"languages\" : [\"java\", \"c#\", \"python\", \"javascript\"] } as you can see the address property has properties inside it. what we are going to do is create a new attribute address inside the student object, which will be a pojo object in itself. package com.jackson.json.demo; public class student { \tprivate int id; \tprivate string firstname; \tprivate string lastname; \tprivate boolean active; \t \tprivate address address; \t \tprivate string[] languages; \t \tpublic student() { \t\t \t} \t \tpublic int getid() { \t\treturn id; \t} \t \tpublic void setid(int id) { \t\tthis.id = id; \t} \t \tpublic string getfirstname() { \t\treturn firstname; \t} \t \tpublic void setfirstname(string firstname) { \t\tthis.firstname = firstname; \t} \t \tpublic string getlastname() { \t\treturn lastname; \t} \t \tpublic void setlastname(string lastname) { \t\tthis.lastname = lastname; \t} \t \tpublic boolean isactive() { \t\treturn active; \t} \t \tpublic void setactive(boolean active) { \t\tthis.active = active; \t} \tpublic address getaddress() { \t\treturn address; \t} \tpublic void setaddress(address address) { \t\tthis.address = address; \t} \tpublic string[] getlanguages() { \t\treturn languages; \t} \tpublic void setlanguages(string[] languages) { \t\tthis.languages = languages; \t} \t } we also need to create the address class: package com.jackson.json.demo; public class address { \tprivate string street; \tprivate string city; \tprivate string state; \tprivate string zip; \tprivate string country; \t \tpublic address() { \t\t \t} \tpublic string getstreet() { \t\treturn street; \t} \tpublic void setstreet(string street) { \t\tthis.street = street; \t} \tpublic string getcity() { \t\treturn city; \t} \tpublic void setcity(string city) { \t\tthis.city = city; \t} \tpublic string getstate() { \t\treturn state; \t} \tpublic void setstate(string state) { \t\tthis.state = state; \t} \tpublic string getzip() { \t\treturn zip; \t} \tpublic void setzip(string zip) { \t\tthis.zip = zip; \t} \tpublic string getcountry() { \t\treturn country; \t} \tpublic void setcountry(string country) { \t\tthis.country = country; \t} } ignore unknwon properties to ignore properties from the json file that cannot be mapped to an attribute in the pojo we use the annotation: package com.jackson.json.demo; @jsonignoreproperties(ignoreunkown=true) public class student { \tprivate int id; \tprivate string firstname; $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Spring Rest/Exception Handling.html",
    "title": "Exception Handling",
    "body": " index search search back exception handling contents create error response class create exception class rest service with exception global exception handler in this section we are going to show how to create an error page to display when there is an error on a request. create error response class package com.springdemo.rest; public class studenterrorresponse { \tprivate int status; \tprivate string message; \tprivate long timestamp; \tpublic studenterrorresponse() { \t\t \t} \t \tpublic studenterrorresponse(int status, string message, long timestamp) { \t\tthis.status = status; \t\tthis.message = message; \t\tthis.timestamp = timestamp; \t} \tpublic int getstatus() { \t\treturn status; \t} \tpublic void setstatus(int status) { \t\tthis.status = status; \t} \tpublic string getmessage() { \t\treturn message; \t} \tpublic void setmessage(string message) { \t\tthis.message = message; \t} \tpublic long gettimestamp() { \t\treturn timestamp; \t} \tpublic void settimestamp(long timestamp) { \t\tthis.timestamp = timestamp; \t} \t \t } create exception class package com.springdemo.rest; public class studentnotfoundexception extends runtimeexception { \tpublic studentnotfoundexception(string message, throwable cause) { \t\tsuper(message, cause); \t} \tpublic studentnotfoundexception(string message) { \t\tsuper(message); \t} \tpublic studentnotfoundexception(throwable cause) { \t\tsuper(cause); \t} \t } rest service with exception what we need to know is: define an exception handler method with @exceptionhandler annotation the exception handler will return a response entity response entity is a wrapper for the http response object resposneentity provides a fine-grained control to specify: http status code http headers response body package com.springdemo.rest; import java.util.arraylist; import java.util.list; import javax.annotation.postconstruct; import org.springframework.http.httpstatus; import org.springframework.http.responseentity; import org.springframework.web.bind.annotation.exceptionhandler; import org.springframework.web.bind.annotation.getmapping; import org.springframework.web.bind.annotation.pathvariable; import org.springframework.web.bind.annotation.requestmapping; import org.springframework.web.bind.annotation.restcontroller; import com.springdemo.entity.student; @restcontroller @requestmapping(\"/api\") public class studentrestcontroller { \tprivate list<student> thestudents; \t// define @postconstruct to load the student data ... only once! \t@postconstruct \tpublic void loaddata() { \t \t\tthestudents = new arraylist<>(); \t\t \t\tthestudents.add(new student(\"poornima\", \"patel\")); \t\tthestudents.add(new student(\"mario\", \"rossi\")); \t\tthestudents.add(new student(\"mary\", \"smith\"));\t\t \t} \t \t \t \t// define endpoint for \"/students\" - return list of students \t@getmapping(\"/students\") \tpublic list<student> getstudents() { \t\t\t \t\treturn thestudents; \t} \t \t// define endpoint for \"/students/{studentid}\" - return student at index \t@getmapping(\"/students/{studentid}\") \tpublic student getstudent(@pathvariable int studentid) { \t\t \t\t// just index into the list ... keep it simple for now \t\t// check the studentid against list size \t\tif ( (studentid >= thestudents.size()) || (studentid < 0) ) {\t\t\t \t\t\tthrow new studentnotfoundexception(\"student id not found - \" + studentid); \t\t} \t\t \t\treturn thestudents.get(studentid); \t\t \t} // tag it as an exception handling method \t@exceptionhandler // type of response body exception type to handle \tpublic responseentity<studenterrorresponse> handleexception(studentnotfoundexception exc) { \t\t \t\tstudenterrorresponse error = new studenterrorresponse(); \t\t // json error object \t\terror.setstatus(httpstatus.not_found.value()); \t\terror.setmessage(exc.getmessage()); \t\terror.settimestamp(system.currenttimemillis()); \t // return response with the error object and the status code \t\treturn new responseentity<>(error, httpstatus.not_found); \t } // another exception handler \t@exceptionhandler // catch any exception thrown \tpublic responseentity<studenterrorresponse> handleexception(exception exc) { \t\t \t\tstudenterrorresponse error = new studenterrorresponse(); \t\t \t\terror.setstatus(httpstatus.bad_request.value()); \t\terror.setmessage(exc.getmessage()); \t\terror.settimestamp(system.currenttimemillis()); \t\t \t\treturn new responseentity<>(error, httpstatus.bad_request); \t}\t } global exception handler instead of having the exception handling methods in every controller, we defined them globally. for that we use controlleradvice that acts as a filter between the requests and the controller. it: pre-processes requests to controllers post-processes responses to handle exceptions so, we create a class with the @controlleradvice annotation: package com.springdemo.rest; import org.springframework.http.httpstatus; import org.springframework.http.responseentity; import org.springframework.web.bind.annotation.controlleradvice; import org.springframework.web.bind.annotation.exceptionhandler; @controlleradvice public class studentrestexceptionhandler { \t// add exception handling code here \t// add an exception handler using @exceptionhandler \t@exceptionhandler \tpublic responseentity<studenterrorresponse> handleexception(studentnotfoundexception exc) { \t\t \t\t// create a studenterrorresponse \t\tstudenterrorresponse error = new studenterrorresponse(); \t\t \t\terror.setstatus(httpstatus.not_found.value()); \t\terror.setmessage(exc.getmessage()); \t\terror.settimestamp(system.currenttimemillis()); \t\t \t\t// return responseentity \t\treturn new responseentity<>(error, httpstatus.not_found); \t} \t \t// add another exception handler ... to catch any exception (catch all) \t@exceptionhandler \tpublic responseentity<studenterrorresponse> handleexception(exception exc) { \t\t \t\t// create a studenterrorresponse \t\tstudenterrorresponse error = new studenterrorresponse(); \t\terror.setstatus(httpstatus.bad_request.value()); \t\terror.setmessage(exc.getmessage()); \t\terror.settimestamp(system.currenttimemillis()); \t\t \t\t// return responseentity\t\t \t\treturn new responseentity<>(error, httpstatus.bad_request); \t} \t } and now we modify the controller to make use of this paradigm: package com.springdemo.rest; import java.util.arraylist; import java.util.list; import javax.annotation.postconstruct; import org.springframework.http.httpstatus; import org.springframework.http.responseentity; import org.springframework.web.bind.annotation.exceptionhandler; import org.springframework.web.bind.annotation.getmapping; import org.springframework.web.bind.annotation.pathvariable; import org.springframework.web.bind.annotation.requestmapping; import org.springframework.web.bind.annotation.restcontroller; import com.springdemo.entity.student; @restcontroller @requestmapping(\"/api\") public class studentrestcontroller { \tprivate list<student> thestudents; \t \t// define @postconstruct to load the student data ... only once! \t@postconstruct \tpublic void loaddata() { \t \t\tthestudents = new arraylist<>(); \t\t \t\tthestudents.add(new student(\"poornima\", \"patel\")); \t\tthestudents.add(new student(\"mario\", \"rossi\")); \t\tthestudents.add(new student(\"mary\", \"smith\"));\t\t \t} \t// define endpoint for \"/students\" - return list of students \t@getmapping(\"/students\") \tpublic list<student> getstudents() { \t\t\t \t\treturn thestudents; \t} \t \t// define endpoint for \"/students/{studentid}\" - return student at index \t@getmapping(\"/students/{studentid}\") \tpublic student getstudent(@pathvariable int studentid) { \t\t \t\t// just index into the list ... keep it simple for now \t\t// check the studentid against list size \t\tif ( (studentid >= thestudents.size()) || (studentid < 0) ) { \t\t\tthrow new studentnotfoundexception(\"student id not found - \" + studentid); \t\t} \t\t\t \t\treturn thestudents.get(studentid); \t}\t } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/SpringBoot/Spring Boot Project Structure.html",
    "title": "Spring Boot Project Structure",
    "body": " index search search back spring boot project structure contents application properties static content testing application properties by default, spring boot will load properties from: application.properties in the src project directory. we inject it in our code the same way we did it with spring static content by default, spring boot wil load static resources from \"/static\" directory testing unit tests are stored on the src directory under the /test folder $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/SpringBoot/Spring Boot Starters.html",
    "title": "Spring Boot Starters",
    "body": " index search search back spring boot starters contents spring boot starter parent spring boot staters offer a curated list of dependencies that are grouped together and tested by the spring development team. so now, if your application depends on the web and security module and also uses thymeleaf and jpa, you add the following dependencies: ... \t<dependencies> <!-- web --> \t\t<dependency> \t\t\t<groupid>org.springframework.boot</groupid> \t\t\t<artifactid>spring-boot-starter-web</artifactid> \t\t</dependency> <!-- security --> \t\t<dependency> \t\t\t<groupid>org.springframework.boot</groupid> \t\t\t<artifactid>spring-boot-starter-security</artifactid> \t\t</dependency> <!-- jpa --> \t\t<dependency> \t\t\t<groupid>org.springframework.boot</groupid> \t\t\t<artifactid>spring-boot-starter-data-jpa</artifactid> \t\t</dependency> <!-- thymeleaf --> \t\t<dependency> \t\t\t<groupid>org.springframework.boot</groupid> \t\t\t<artifactid>spring-boot-starter-thymeleaf</artifactid> \t\t</dependency> \t\t<!-- add support for automatic reloading --> \t\t<dependency> \t\t\t<groupid>org.springframework.boot</groupid> \t\t\t<artifactid>spring-boot-devtools</artifactid> \t\t</dependency> \t\t\t\t \t</dependencies> ... spring boot starter parent this is a special starter that provides defaults: default compiler level utf-8 source encoding you include it in your pom.xml file as follows: ... \t<parent> \t\t<groupid>org.springframework.boot</groupid> \t\t<artifactid>spring-boot-starter-parent</artifactid> \t\t<version>2.1.2.release</version> \t\t<relativepath/> <!-- lookup parent from repository --> \t</parent> \t<dependencies> \t... \t</dependencies> ... if you want to override a default, you use properties: ... \t<parent> \t\t<groupid>org.springframework.boot</groupid> \t\t<artifactid>spring-boot-starter-parent</artifactid> \t\t<version>2.1.2.release</version> \t\t<relativepath/> <!-- lookup parent from repository --> \t</parent> \t \t<!-- override default java version --> \t<properties> \t\t<java.version>1.8</java.version> \t</properties> \t<dependencies> \t... \t</dependencies> ... $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/SpringBoot/Spring Data JPA.html",
    "title": "Spring Data JPA",
    "body": " index search search back spring data jpa contents create repository use repository with jpa api we created a employee dao, however what if we need to create one for each entity we manage. then we would duplicate a lot of code, because the calls to the api are basically the same. that is what we use spring data jpa, we plug in the entity type and the primary key to the dao, and spring creates it an manages it for us. create repository so now the employee dao is as follows: package com.springboot.cruddemo.dao; import org.springframework.data.jpa.repository.jparepository; import com.springboot.cruddemo.entity.employee; public interface employeerepository extends jparepository<employee, integer> { } use repository and the employee service is: package com.springboot.cruddemo.service; import java.util.list; import java.util.optional; import org.springframework.beans.factory.annotation.autowired; import org.springframework.stereotype.service; import com.springboot.cruddemo.dao.employeerepository; import com.springboot.cruddemo.entity.employee; @service public class employeeserviceimpl implements employeeservice { // here we make use of the above implemented repository \tprivate employeerepository employeerepository; \t \t@autowired \tpublic employeeserviceimpl(employeerepository theemployeerepository) { \t\temployeerepository = theemployeerepository; \t} \t \t@override \tpublic list<employee> findall() { \t\treturn employeerepository.findall(); \t} \t@override \tpublic employee findbyid(int theid) { \t\toptional<employee> result = employeerepository.findbyid(theid); \t\t \t\temployee theemployee = null; \t\t \t\tif (result.ispresent()) { \t\t\ttheemployee = result.get(); \t\t} \t\telse { \t\t\t// we didn't find the employee \t\t\tthrow new runtimeexception(\"did not find employee id - \" + theid); \t\t} \t\t \t\treturn theemployee; \t} \t@override \tpublic void save(employee theemployee) { \t\temployeerepository.save(theemployee); \t} \t@override \tpublic void deletebyid(int theid) { \t\temployeerepository.deletebyid(theid); \t} } this employeeservice implements the interface: package com.springboot.cruddemo.service; import java.util.list; import com.springboot.cruddemo.entity.employee; public interface employeeservice { \tpublic list<employee> findall(); \t \tpublic employee findbyid(int theid); \t \tpublic void save(employee theemployee); \t \tpublic void deletebyid(int theid); \t } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/SpringBoot/Application Properties.html",
    "title": "Application Properties",
    "body": " index search search back application properties contents configuring the spring boot server core web actuator properties security data properties by default spring boot reads information from a standard properties file in src/main/resources/application.properties. you can define any custom properties in this file and your app can access properties using the annotation @value(we have done this before). configuring the spring boot server some properties offered by spring are: core # log levels severity mapping logging.level.org.springframework=debug logging.level.org.hibernate=trace logging.level.org.luv2code=info # log file name logging.file=date.log web # http server port server.port=7070 # context path of the application server.servlet.context-path=/my-app # default http session timeout server.servlet.session.timeout=15m actuator properties # endpoints to include by name or wildcard management.endpoints.web.exposure.include=* # endpoints to exclude by name or wildcard management.endpoints.web.exposure.exclude=beans,mapping security # default username spring.security.user.name=admin # password for default user spring.security.user.password=mypass data properties # jdbc url of the database spring.datasource.url=jdbc:mysql://localhost:3306/myapp # login username of the database spring.datasource.username=alba # login password of the database spring.datasource.password=testpass $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/SpringBoot/Controller.html",
    "title": "Rest Controller",
    "body": " index search search back rest controller contents create controller main app in this section we are going to show how to create a rest controller in a spring boot application: create controller the controller is the same as in spring rest: package com.springboot.demo.mycoolapp.rest; import java.time.localdatetime; import org.springframework.beans.factory.annotation.value; import org.springframework.web.bind.annotation.getmapping; import org.springframework.web.bind.annotation.restcontroller; @restcontroller public class funrestcontroller { \t\t \t// expose \"/\" that return \"hello world\" \t \t@getmapping(\"/\") \tpublic string sayhello() { \t\treturn \"hello world! time on server is \" + localdatetime.now(); \t} \t main app the springbootapplication is made up of three annotations: auto configuration (@enableautoconfiguration) component scanning (@componentscan) additional configuration (@configuration) package com.springboot.demo.mycoolapp; import org.springframework.boot.springapplication; import org.springframework.boot.autoconfigure.springbootapplication; // annotation to tell spring this is an spring application @springbootapplication public class mycoolappapplication { \tpublic static void main(string[] args) { \t\t// boostrap spring boot application \t\tspringapplication.run(mycoolappapplication.class, args); \t} } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/SpringBoot/Spring Boot DevTools.html",
    "title": "Spring Boot DevTools",
    "body": " index search search back spring boot devtools spring boot dev tools automatically restart your application when code is updated. the only thing you need to do is add the module to the dependencies: ... \t<dependencies> \t\t<!-- add support for automatic reloading --> \t\t<dependency> \t\t\t<groupid>org.springframework.boot</groupid> \t\t\t<artifactid>spring-boot-devtools</artifactid> \t\t</dependency> \t\t\t\t \t</dependencies> ... $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/SpringBoot/index.html",
    "title": "Overview",
    "body": " index search search back overview spring boot is a framework that: make it easier to get started with spring development minimize the amount of manual configuration perform auto-configuration based on props files and jar classpath help to resolve dependency conflicts (maven or gradle) provide an embedded http server so you can get started quickly to create a new project you just have to go to spring initiliazr, where you simply select your dependencies and lets you create a maven/gradle project and import it into an ide. so now our app is a jar file, and it includes the source code and also the embedded http server, so can be ran from the command line, from your ide, etc. however if you want to export your code as a war file, you can also do that by exporting only your source code, without the embedded server. with the jar file you can run your application by executing: $ java -jar app.jar $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/SpringBoot/JPA.html",
    "title": "JPA",
    "body": " index search search back jpa until now, to manage data we have been using the entitymanager along with the hibernate api. however now we are going to use the standard jpa api. the jpa api methods are similar to native hibernate api. it also supports a query language jpql (jpa query language) comparing hibernate to jpa: example: for managing employees with jpa, we first create the data access object: package com.springboot.cruddemo.dao; import java.util.list; import javax.persistence.entitymanager; import javax.persistence.query; import org.springframework.beans.factory.annotation.autowired; import org.springframework.stereotype.repository; import com.luv2code.springboot.cruddemo.entity.employee; @repository public class employeedaojpaimpl implements employeedao { \tprivate entitymanager entitymanager; \t \t@autowired \tpublic employeedaojpaimpl(entitymanager theentitymanager) { \t\tentitymanager = theentitymanager; \t} \t \t@override \tpublic list<employee> findall() { \t\t// create a query \t\tquery thequery = \t\t\t\tentitymanager.createquery(\"from employee\"); \t\t \t\t// execute query and get result list \t\tlist<employee> employees = thequery.getresultlist(); \t\t \t\t// return the results\t\t \t\treturn employees; \t} \t@override \tpublic employee findbyid(int theid) { \t\t// get employee \t\temployee theemployee = \t\t\t\tentitymanager.find(employee.class, theid); \t\t \t\t// return employee \t\treturn theemployee; \t} \t@override \tpublic void save(employee theemployee) { \t\t// save or update the employee \t\temployee dbemployee = entitymanager.merge(theemployee); \t\t \t\t// update with id from db ... so we can get generated id for save/insert \t\ttheemployee.setid(dbemployee.getid()); \t\t \t} \t@override \tpublic void deletebyid(int theid) { \t\t// delete object with primary key \t\tquery thequery = entitymanager.createquery( \t\t\t\t\t\t\t\"delete from employee where id=:employeeid\"); \t\t \t\tthequery.setparameter(\"employeeid\", theid); \t\t \t\tthequery.executeupdate(); \t} } and then we call it from the employee service: package com.springboot.cruddemo.service; import java.util.list; import org.springframework.beans.factory.annotation.autowired; import org.springframework.beans.factory.annotation.qualifier; import org.springframework.stereotype.service; import org.springframework.transaction.annotation.transactional; import com.springboot.cruddemo.dao.employeedao; import com.springboot.cruddemo.entity.employee; @service public class employeeserviceimpl implements employeeservice { \tprivate employeedao employeedao; \t \t@autowired \tpublic employeeserviceimpl(@qualifier(\"employeedaojpaimpl\") employeedao theemployeedao) { \t\temployeedao = theemployeedao; \t} \t \t@override \t@transactional \tpublic list<employee> findall() { \t\treturn employeedao.findall(); \t} \t@override \t@transactional \tpublic employee findbyid(int theid) { \t\treturn employeedao.findbyid(theid); \t} \t@override \t@transactional \tpublic void save(employee theemployee) { \t\temployeedao.save(theemployee); \t} \t@override \t@transactional \tpublic void deletebyid(int theid) { \t\temployeedao.deletebyid(theid); \t} } this class implements the following interface: package com.springboot.cruddemo.service; import java.util.list; import com.springboot.cruddemo.entity.employee; public interface employeeservice { \tpublic list<employee> findall(); \t \tpublic employee findbyid(int theid); \t \tpublic void save(employee theemployee); \t \tpublic void deletebyid(int theid); \t } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/SpringBoot/Spring Boot Actuator.html",
    "title": "Spring Boot Actuator",
    "body": " index search search back spring boot actuator contents add security spring boot actuator automatically exposes endpoints to monitor and manage your application. you only need to add the dependency to you pom.xml file: ... \t<dependencies> ... \t\t<!-- add support for spring boot actuator --> \t\t<dependency> \t\t\t<groupid>org.springframework.boot</groupid> \t\t\t<artifactid>spring-boot-starter-actuator</artifactid> \t\t</dependency> \t\t\t\t \t</dependencies> ... the endpoints are prefixed by /actuator, some of them are: /health: health information about your application /info: information about your project. by default it return an empty json object. you can add info through application.properties as follows: info.app.name=my super cool app info.app.description=a crazy fun app, yoohoo! info.app.version=1.0.0 /auditevents: audit events for your application /beans: list of all beans registered in the spring application context /mappings: list of all @requestmapping path by default only /health and /info are exposed, to expose all actuator endpoints you need to specify on application.properties (you can also specify only the ones you want separated by commas): management.endpoints.web.exposure.include=* add security first you need to add spring security as a dependency in your pom.xml: ... \t<dependencies> \t\t... <!-- security --> \t\t<dependency> \t\t\t<groupid>org.springframework.boot</groupid> \t\t\t<artifactid>spring-boot-starter-security</artifactid> \t\t</dependency> \t\t... \t</dependencies> ... now, when we access some endpoints like /actuator/beans spring will prompt a login to grant access to the endpoint. the default user name is \"user\" the password will be printed on the console where you start the application to override these defaults edit the application.properties file as follows: spring.security.user.name=alba spring.security.user.password=mypassword we can also exclude endpoints by adding the following declarations to the application.properties file: management.endpoints.web.exposure.exclude=health,info $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/SpringBoot/Spring Data REST.html",
    "title": "Spring Data Rest",
    "body": " index search search back spring data rest contents configuration sorting what if we want to also reduce the code for creating api, that is, what if spring could create a rest api for us using our jparepository, such that it would expose all of the basic rest api crud features automatically. what does it do? it scans your project fro jparepository it exposes rest apis for each entity type for your jparepository so now, we can remove our employee services and our rest controllers, because it is handled automatically by spring. the only thing needed is adding spring data rest as a dependency: \t<dependencies> ... \t\t<!-- add dependency for spring data rest --> \t\t<dependency> \t\t\t<groupid>org.springframework.boot</groupid> \t\t\t<artifactid>spring-boot-starter-data-rest</artifactid> \t\t</dependency> ... \t</dependencies> to sum up, now in your application you only will have: your entity: employee the corresponding jpa repository: employeerepository dependency main application the first one applies to each entity your application has. spring data rest is hateoas compliant (the responses include metadata about itself). configuration you can specify the name of the endpoint that is exposed (by the default is the plural of the entity) with: @repositoryrestresource(path=\"members\") public interface employeerepository extends jparepository<employee, integer> { } the default number of elements returned are 20, then we can use pagination to retrieve the next ones with query parameters (?page=0). some properties available to tweak in application.properties are: spring.data.rest.base-path: base path used to expose repository resources spring.data.rest.default-page-size: default size pages spring.data.rest.max-page-size: maximum size of pages sorting you can sort by the property names of your entity. on the employee example we have firstname, lastname and email, therefore we can do: http://localhost:8080/employees?sort=firstname or http://localhost:8080/employees?sort=firstname,desc $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Dependency Injection/Injecting Literal Values.html",
    "title": "Injecting Literal Values",
    "body": " index search search back injecting literal values contents define the attributes configuration file main method to inject concrete attributes into our beans: define the attributes first we define the attributes emailaddress and team in the object. also we create the set and get methods for both of them: package com.luv2code.springdemo; public class cricketcoach implements coach { \tprivate fortuneservice fortuneservice; \t \t// add new fields for emailaddress and team \tprivate string emailaddress; \tprivate string team; \t \t\t \tpublic cricketcoach() { \t\tsystem.out.println(\"cricketcoach: inside no-arg constructor\"); \t} \t /* setters and getters */ \tpublic string getemailaddress() { \t\treturn emailaddress; \t} \tpublic void setemailaddress(string emailaddress) { \t\tsystem.out.println(\"cricketcoach: inside setter method - setemailaddress\"); \t\tthis.emailaddress = emailaddress; \t} \tpublic string getteam() { \t\treturn team; \t} \tpublic void setteam(string team) { \t\tsystem.out.println(\"cricketcoach: inside setter method - setteam\"); \t\tthis.team = team; \t} /* setter injection */ \tpublic void setfortuneservice(fortuneservice fortuneservice) { \t\tsystem.out.println(\"cricketcoach: inside setter method - setfortuneservice\"); \t\tthis.fortuneservice = fortuneservice; \t} \t@override \tpublic string getdailyworkout() { \t\treturn \"practice fast bowling for 15 minutes\"; \t} \t@override \tpublic string getdailyfortune() { \t\treturn fortuneservice.getfortune(); \t} } configuration file now we define the properties in the configuration file: <?xml version=\"1.0\" encoding=\"utf-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/xmlschema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemalocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"> \t<!-- define your beans here --> \t<!-- define the dependency --> \t<bean id=\"myfortuneservice\" class=\"com.springdemo.happyfortuneservice\"> \t</bean> \t \t<bean id=\"mycoach\" \t\tclass=\"com.springdemo.trackcoach\">\t \t\t<!-- set up constructor injection --> \t\t<constructor-arg ref=\"myfortuneservice\" /> \t</bean> \t \t<bean id=\"mycricketcoach\" class=\"com.springdemo.cricketcoach\"> \t <!-- set up setter injection --> \t <!-- ref: references the id of the bean we define previously --> \t <!-- name: name of the setter method set<name>, where the first \t letter of the name is capitalized --> \t <property name=\"fortuneservice\" ref=\"myfortuneservice\" /> \t\t<!-- inject literal values, where name is the name of the attribute in the bean \t\tand value is the value to set the value to --> \t <property name=\"emailaddress\" value=\"email@email.com\" /> \t <property name=\"team\" value=\"best team\" /> \t</bean> </beans> main method now in the main method of our app we can call the getters and setters for these new attributes: package com.springdemo; import org.springframework.context.support.classpathxmlapplicationcontext; public class setterdemoapp { \tpublic static void main(string[] args) { \t\t// load the spring configuration file \t\tclasspathxmlapplicationcontext context = \t\t\t\tnew classpathxmlapplicationcontext(\"applicationcontext.xml\"); \t\t \t\t// retrieve bean from spring container \t\tcricketcoach thecoach = context.getbean(\"mycricketcoach\", cricketcoach.class); \t\t \t\t// retrieve attribute values \t\tsystem.out.println(thecoach.getteam()); \t\tsystem.out.println(thecoach.getemailaddress()); \t\t\t\t\t\t \t\t// close the context \t\tcontext.close(); \t} } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Dependency Injection/Inject Values From a Properties File.html",
    "title": "Inject Values from the Properties Files",
    "body": " index search search back inject values from the properties files contents create the properties file load the properties file main method create the properties file let's define our properties inside a properties file sport.properties: foo.email=myeasycoach@email.com foo.team=royal challengers bangalore load the properties file now we load the properties file using the context tag inside our config file: <?xml version=\"1.0\" encoding=\"utf-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/xmlschema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemalocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"> <!-- load the properties file: sport.properties --> <context:property-placeholder location=\"classpath:sport.properties\"/> <!-- define your beans here --> <!-- define the dependency --> <bean id=\"myfortuneservice\" class=\"com.springdemo.happyfortuneservice\"> </bean> <bean id=\"mycoach\" \tclass=\"com.springdemo.trackcoach\">\t \t<!-- set up constructor injection --> \t<constructor-arg ref=\"myfortuneservice\" /> </bean> <bean id=\"mycricketcoach\" class=\"com.springdemo.cricketcoach\"> <!-- set up setter injection --> <!-- ref: references the id of the bean we define previously --> <!-- name: name of the setter method set<name>, where the first letter of the name is capitalized --> <property name=\"fortuneservice\" ref=\"myfortuneservice\" /> <!-- inject literal values, where name is the name of the attribute in the bean and value is the value to set the value to --> <!-- note that we are now referencing the values from the properties file --> <property name=\"emailaddress\" value=\"${foo.email})\" /> <property name=\"team\" value=\"${foo.team}\" /> </bean> </beans> main method in the main method, we create our object as usual, and if we invoke the getter methods, we retrieve the values passed in the property file: package com.springdemo; import org.springframework.context.support.classpathxmlapplicationcontext; public class setterdemoapp { \tpublic static void main(string[] args) { \t\t// load the spring configuration file \t\tclasspathxmlapplicationcontext context = \t\t\t\tnew classpathxmlapplicationcontext(\"applicationcontext.xml\"); \t\t \t\t// retrieve bean from spring container \t\tcricketcoach thecoach = context.getbean(\"mycricketcoach\", cricketcoach.class); \t\t \t\t// retrieve attribute values from property file \t\tsystem.out.println(thecoach.getteam()); \t\tsystem.out.println(thecoach.getemailaddress()); \t\t\t\t\t\t \t\t// close the context \t\tcontext.close(); \t} } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Dependency Injection/Constructor Injection.html",
    "title": "Constructor Injection",
    "body": " index search search back constructor injection contents create dependency object establish dependency configuration file main method now we will show an example where the baseballcoach has fortuneservice as a dependency. so, first we create the dependency interface as follows: create dependency object package com.springdemo; public interface fortuneservice { \tpublic string getfortune(); \t } next we create the dependency class than implements the interface: package com.springdemo; public class happyfortuneservice implements fortuneservice { \t@override \tpublic string getfortune() { \t\treturn \"today is your lucky day!\"; \t} } establish dependency let's also update the coach interface to add a method getdailyfortune (note that all classes that implement this interface have to implement this new method): package com.springdemo; public interface coach { \tpublic string getdailyworkout(); \t \tpublic string getdailyfortune(); } now create a constructor for the dependency in the class that has the dependency package com.springdemo; public class baseballcoach implements coach { \t// define a private field for the dependency \tprivate fortuneservice fortuneservice; \t \t// define a constructor for dependency injection \tpublic baseballcoach(fortuneservice thefortuneservice) { \t\tfortuneservice = thefortuneservice; \t} \t \t@override \tpublic string getdailyworkout() { \t\treturn \"spend 30 minutes on batting practice\"; \t} \t@override \tpublic string getdailyfortune() {\t\t \t\t// use my fortuneservice to get a fortune\t\t \t\treturn fortuneservice.getfortune(); \t} } configuration file finally define the dependency in the configuration file: <?xml version=\"1.0\" encoding=\"utf-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/xmlschema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemalocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"> <!-- define your beans here --> <!-- define the dependency --> <bean id=\"myfortuneservice\" class=\"com.springdemo.happyfortuneservice\"> </bean> <!-- bean with the dependency --> <bean id=\"mycoach\" class=\"com.springdemo.trackcoach\">\t <!-- set up constructor injection, note ref=id of bean --> <constructor-arg ref=\"myfortuneservice\" /> </bean> </beans> behind the scenes, spring framework does: package com.springdemo; public class myapp { \tpublic static void main(string[] args) { \t\t// create object \t\t// from the bean with id = myfortuneservice in the config file \t\thappyfortuneservice myfortuneservice = new happyfortuneservice(); \t\t \t\t// add dependency via constructor \t\t// from the bean with id = mycoach in the config file \t\ttrackcoach mycoach = new trackcoach(fortuneservice); \t} } main method we do not need to make any modifications to the app, when we create the coach bean using spring, the framework deals with the dependency injection: package com.luv2code.springdemo; import org.springframework.context.support.classpathxmlapplicationcontext; public class hellospringapp { \tpublic static void main(string[] args) { \t\t// load the spring configuration file \t\tclasspathxmlapplicationcontext context = \t\t\t\tnew classpathxmlapplicationcontext(\"applicationcontext.xml\"); \t\t\t\t \t\t// retrieve bean from spring container (with the dependency) \t\tcoach thecoach = context.getbean(\"mycoach\", coach.class); \t\t \t\t// call methods on the bean \t\tsystem.out.println(thecoach.getdailyworkout()); \t\t \t\t// let's call our new method for fortunes \t\tsystem.out.println(thecoach.getdailyfortune()); \t\t \t\t// close the context \t\tcontext.close(); \t} } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Dependency Injection/Dependency Injection.html",
    "title": "Dependency Injection",
    "body": " index search search back dependency injection contents injection types the dependencies of the objects are managed by the spring container object factory: so instead of having to build the object and all of its dependencies, the spring factory will do this work for you. injection types there are several injection types in spring. the more common are: constructor injection setter injection injecting literal values inject values from a properties file $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Dependency Injection/Setter Injection.html",
    "title": "Setter Injection",
    "body": " index search search back setter injection contents create dependency object define dependency configuration file main method inject dependencies by calling setter methods on your class create dependency object refer to create dependency object define dependency we include a setter method that takes the dependency as an argument like: package com.springdemo; public class cricketcoach implements coach { \tprivate fortuneservice fortuneservice;\t \t \t// create a no-arg constructor \tpublic cricketcoach() { \t\tsystem.out.println(\"cricketcoach: inside no-arg constructor\"); \t} \t \t// our setter method \tpublic void setfortuneservice(fortuneservice fortuneservice) { \t\tsystem.out.println(\"cricketcoach: inside setter method - setfortuneservice\"); \t\tthis.fortuneservice = fortuneservice; \t} \t@override \tpublic string getdailyworkout() { \t\treturn \"practice fast bowling for 15 minutes\"; \t} \t@override \tpublic string getdailyfortune() { \t\treturn fortuneservice.getfortune(); \t} } configuration file <?xml version=\"1.0\" encoding=\"utf-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/xmlschema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemalocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"> <!-- define your beans here --> <!-- define the dependency --> <bean id=\"myfortuneservice\" class=\"com.springdemo.happyfortuneservice\"> </bean> <bean id=\"mycoach\" \tclass=\"com.springdemo.trackcoach\">\t \t<!-- set up constructor injection --> \t<constructor-arg ref=\"myfortuneservice\" /> </bean> <bean id=\"mycricketcoach\" class=\"com.springdemo.cricketcoach\"> <!-- set up setter injection --> <!-- ref: references the id of the bean we define previously --> <!-- name: name of the setter method set<name>, where the first letter of the name is capitalized --> <property name=\"fortuneservice\" ref=\"myfortuneservice\" /> </bean> </beans> behind the scenes, spring framework does: package com.springdemo; public class myapp { \tpublic static void main(string[] args) { \t\t// create object \t\t// from the bean with id = myfortuneservice in the config file \t\thappyfortuneservice myfortuneservice = new happyfortuneservice(); \t\t \t\t// from the bean with id = mycricketcoach in the config file \t\tcricketcoach mycricketcoach = new cricketcoach(fortuneservice); \t\t// add dependency via setter \t\tmycricketcoach.setfortuneservice(myfortuneservice); \t} } main method now, on the main method of our spring app, we create the object by reading the config file, and spring automatically injects the dependency via the setter method: package com.springdemo; import org.springframework.context.support.classpathxmlapplicationcontext; public class setterdemoapp { \tpublic static void main(string[] args) { \t\t// load the spring configuration file \t\tclasspathxmlapplicationcontext context = \t\t\t\tnew classpathxmlapplicationcontext(\"applicationcontext.xml\"); \t\t \t\t// retrieve bean from spring container \t\tcricketcoach thecoach = context.getbean(\"mycricketcoach\", cricketcoach.class); \t\t \t\t// call methods on the bean \t\tsystem.out.println(thecoach.getdailyworkout()); \t\t \t\tsystem.out.println(thecoach.getdailyfortune()); \t\t\t\t\t\t \t\t// close the context \t\tcontext.close(); \t} } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/AOP/Overview.html",
    "title": "Overview",
    "body": " index search search back overview contents advantages disadvantages terminology advice types weaving best practices aspect-oriented programming is a programming technique based on the concept of an aspect (that is something that encapsulated cross-cutting logic/functionality, which means logic that affect the project transversally like logging or security). what aop does behind the scenes is call methods from the classes/aspects (like a logging class) whenever a method is called (this depends on the configuration): advantages reusable modules resolve code tangling resolve code scatter applied selectively based on configuration disadvantages too many aspects and app flow is hard to follow minor performance cost for aspect execution terminology aspect: module of code for a cross-cutting concern (logging, security...) advice: what action is takes and when it should be applied joint point: when to apply code during program execution pointcut: a predicate expression for where advice should be applied advice types before advice: run before the method after finally advice: run after the method (like finally clause in try catch) after returning advice: run after the method (success execution) after throwing advice: run after the method (if exception if thrown) around advice: run before and after the method weaving it refers to the connection being made between aspects and target objects to create an advised object. there are different types: compile-time load-time run-time note that the slowest is the run-time weaving best practices keep the code inside the advices small keep the code fast do not perform any expensive/slow operations $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/AOP/After Advice.html",
    "title": "After Advice",
    "body": " index search search back after advice this advice runs always when the method is completed (like a finally clause inside a try catch). for example if we want to always run the advice afterfinallyfindaccountsadvice when the method findaccounts inside accountdao finishes: package com.aopdemo.aspect; import java.util.list; import org.aspectj.lang.joinpoint; import org.aspectj.lang.annotation.after; import org.aspectj.lang.annotation.afterreturning; import org.aspectj.lang.annotation.afterthrowing; import org.aspectj.lang.annotation.aspect; import org.aspectj.lang.annotation.before; import org.aspectj.lang.reflect.methodsignature; import org.springframework.core.annotation.order; import org.springframework.stereotype.component; import com.aopdemo.account; @aspect @component @order(2) public class mydemologgingaspect { \t@after(\"execution(* com.aopdemo.dao.accountdao.findaccounts(..))\") \tpublic void afterfinallyfindaccountsadvice(joinpoint thejoinpoint) { \t\t \t\t// print out which method we are advising on \t\tstring method = thejoinpoint.getsignature().toshortstring(); \t\tsystem.out.println(\"\\n=====>>> executing @after (finally) on method: \" \t\t\t\t\t\t\t+ method); \t \t} } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/AOP/AfterThrowing Advice.html",
    "title": "AfterThrowing Advice",
    "body": " index search search back afterthrowing advice this advice is run whenever the target object throws and execption. for example: package com.aopdemo.aspect; import java.util.list; import org.aspectj.lang.joinpoint; import org.aspectj.lang.annotation.afterreturning; import org.aspectj.lang.annotation.afterthrowing; import org.aspectj.lang.annotation.aspect; import org.aspectj.lang.annotation.before; import org.aspectj.lang.reflect.methodsignature; import org.springframework.core.annotation.order; import org.springframework.stereotype.component; import com.luv2code.aopdemo.account; @aspect @component @order(2) public class mydemologgingaspect { \t \t@afterthrowing( \t\t\tpointcut=\"execution(* com.aopdemo.dao.accountdao.findaccounts(..))\", \t\t\t// define the name of the parameter that holds the exception object \t\t\tthrowing=\"theexc\") \tpublic void afterthrowingfindaccountsadvice( \t\t\t\t\tjoinpoint thejoinpoint, throwable theexc) { \t\t \t\t// print out which method we are advising on \t\tstring method = thejoinpoint.getsignature().toshortstring(); \t\tsystem.out.println(\"\\n=====>>> executing @afterthrowing on method: \" + method); \t\t \t\t// log the exception \t\tsystem.out.println(\"\\n=====>>> the exception is: \" + theexc); \t \t} } in this code sample we have the advice afterthrowingfindaccountsadvice that is run whenever the method findaccounts inside accountdao throws an exception. we also make use of the throwing attribute that lets us map the exception object to a parameter inside our advice. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/AOP/JoinPoints.html",
    "title": "JoinPoints",
    "body": " index search search back joinpoints contents display method signature display method arguments when we are in an aspect, how can we access method parameters? display method signature to display the method signature we do the following: package com.aopdemo.aspect; import org.aspectj.lang.joinpoint; import org.aspectj.lang.annotation.aspect; import org.aspectj.lang.annotation.before; import org.aspectj.lang.reflect.methodsignature; import org.springframework.core.annotation.order; import org.springframework.stereotype.component; import com.aopdemo.account; @aspect @component @order(2) public class mydemologgingaspect { \t \t@before(\"com.aopdemo.aspect.luvaopexpressions.fordaopackagenogettersetter()\") \tpublic void beforeaddaccountadvice(joinpoint thejoinpoint) { \t\t \t\tsystem.out.println(\"\\n=====>>> executing @before advice on method\");\t \t\t \t\t// display the method signature \t\tmethodsignature methodsig = (methodsignature) thejoinpoint.getsignature(); \t\t \t\tsystem.out.println(\"method: \" + methodsig); \t} } display method arguments also, to display the method arguments: package com.aopdemo.aspect; import org.aspectj.lang.joinpoint; import org.aspectj.lang.annotation.aspect; import org.aspectj.lang.annotation.before; import org.aspectj.lang.reflect.methodsignature; import org.springframework.core.annotation.order; import org.springframework.stereotype.component; import com.aopdemo.account; @aspect @component @order(2) public class mydemologgingaspect { \t \t@before(\"com.aopdemo.aspect.luvaopexpressions.fordaopackagenogettersetter()\") \tpublic void beforeaddaccountadvice(joinpoint thejoinpoint) { \t\t \t\tsystem.out.println(\"\\n=====>>> executing @before advice on method\");\t \t\t// display method arguments \t\t// get args \t\tobject[] args = thejoinpoint.getargs(); \t\t \t\t// loop through args \t\tfor (object temparg : args) { \t\t\tsystem.out.println(temparg); \t\t\t \t\t\tif (temparg instanceof account) { \t\t\t\t \t\t\t\t// downcast and print account specific stuff \t\t\t\taccount theaccount = (account) temparg; \t\t\t\t \t\t\t\tsystem.out.println(\"account name: \" + theaccount.getname()); \t\t\t\tsystem.out.println(\"account level: \" + theaccount.getlevel());\t\t\t\t\t\t\t\t \t\t\t} \t\t}\t\t \t} } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/AOP/Before Advice.html",
    "title": "Before Advice",
    "body": " index search search back before advice contents add dependencies create target object spring configuration create aspect with before main app we use the tag @before to execute some code before we call the target object function: add dependencies we have to download the aspectj jar file, because spring aop depends on some on their framework's classes create target object we create a dao object: package com.aopdemo.dao; import org.springframework.stereotype.component; @component public class accountdao { \tpublic void addaccount() { \t\tsystem.out.println( \t\t\tgetclass() \t\t\t+ \": doing my db work: adding an account\" \t\t); \t} } spring configuration we now have to enable aop proxying in our app configuration: package com.aopdemo; import org.springframework.context.annotation.componentscan; import org.springframework.context.annotation.configuration; import org.springframework.context.annotation.enableaspectjautoproxy; @configuration // enable proxying to add before advice @enableaspectjautoproxy @componentscan(\"com.aopdemo\") public class democonfig { } create aspect with @before now it is time to create an aspect with @before advice: package com.aopdemo.aspect; import org.aspectj.lang.annotation.aspect; import org.aspectj.lang.annotation.before; import org.springframework.stereotype.component; @aspect @component public class mydemologgingaspect { \t// this is where we add all of our related advices for logging \t// here we specify we want to run this code before calling the \t// object method public void addaccount \t@before(\"execution(public void addaccount())\") \tpublic void beforeaddaccountadvice() { \t\tsystem.out.println(\"\\n=====>>> executing @before advice on addaccount()\"); \t} } main app we now create a demo app: package com.aopdemo; import org.springframework.context.annotation.annotationconfigapplicationcontext; import com.aopdemo.dao.accountdao; public class maindemoapp { \tpublic static void main(string[] args) { \t\t// read spring config java class \t\tannotationconfigapplicationcontext context = \t\t\t\tnew annotationconfigapplicationcontext(democonfig.class); \t\t \t\t// get the bean from spring container \t\taccountdao theaccountdao = context.getbean(\"accountdao\", accountdao.class); \t\t \t\t// call the business method \t\ttheaccountdao.addaccount(); \t\t// do it again! \t\tsystem.out.println(\"\\nlet's call it again!\\n\"); \t\t \t\t// call the business method again \t\ttheaccountdao.addaccount(); \t\t\t\t \t\t// close the context \t\tcontext.close(); \t} } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/AOP/Around Advice.html",
    "title": "Around Advice",
    "body": " index search search back around advice contents exception handling this type of advice is always called before and after the target object. when using the @around advice we have access to a reference of a proceeding join point. which is a handle to the target method, and will let us execute the taget method. so for example if we want to measure the performance of the getfortunemethod: package com.aopdemo.aspect; import java.util.list; import org.aspectj.lang.joinpoint; import org.aspectj.lang.proceedingjoinpoint; import org.aspectj.lang.annotation.after; import org.aspectj.lang.annotation.afterreturning; import org.aspectj.lang.annotation.afterthrowing; import org.aspectj.lang.annotation.around; import org.aspectj.lang.annotation.aspect; import org.aspectj.lang.annotation.before; import org.aspectj.lang.reflect.methodsignature; import org.springframework.core.annotation.order; import org.springframework.stereotype.component; import com.aopdemo.account; @aspect @component @order(2) public class mydemologgingaspect { \t \t@around(\"execution(* com.aopdemo.service.*.getfortune(..))\")\t \tpublic object aroundgetfortune( \t\t\tproceedingjoinpoint theproceedingjoinpoint) throws throwable { \t\t \t\t// print out method we are advising on \t\tstring method = theproceedingjoinpoint.getsignature().toshortstring(); \t\tsystem.out.println(\"\\n=====>>> executing @around on method: \" + method); \t\t \t\t// get begin timestamp \t\tlong begin = system.currenttimemillis(); \t\t \t\t// now, let's execute the method \t\tobject result = theproceedingjoinpoint.proceed(); \t\t \t\t// get end timestamp \t\tlong end = system.currenttimemillis(); \t\t \t\t// compute duration and display it \t\tlong duration = end - begin; \t\tsystem.out.println(\"\\n=====> duration: \" + duration / 1000.0 + \" seconds\"); \t\t \t\treturn result; \t} } the advice aroundgetfortune is called before the getfortune is called, then it proceeds to call from inside the advice and we measure how long does the method take to run. exception handling inside an advice, to handle exceptions you can: handle the exception inside the advice \t@around(\"execution(* com.aopdemo.service.*.getfortune(..))\")\t \tpublic object aroundgetfortune( \t\t\tproceedingjoinpoint theproceedingjoinpoint) throws throwable { \t\t \t\t// print out method we are advising on \t\tstring method = theproceedingjoinpoint.getsignature().toshortstring(); \t\tsystem.out.println(\"\\n=====>>> executing @around on method: \" + method); \t\t \t\t// get begin timestamp \t\tlong begin = system.currenttimemillis(); \t\t \t\ttry { \t\t\tresult = theproceedingjoinpoint.proceed(); \t\t} catch (exception e) { \t\t\t// log the exception \t\t\tmylogger.warning(e.getmessage()); \t\t\t \t\t\t// give users a custom messagee \t\t\tresult = \"major accident! but no worries, \" \t\t\t\t\t+ \"your private aop helicopter is on the way!\"; \t\t} \t\t \t\t// get end timestamp \t\tlong end = system.currenttimemillis(); \t\t \t\t// compute duration and display it \t\tlong duration = end - begin; \t\tsystem.out.println(\"\\n=====> duration: \" + duration / 1000.0 + \" seconds\"); \t\t \t\treturn result; \t} simply rethrow the exception \t@around(\"execution(* com.aopdemo.service.*.getfortune(..))\")\t \tpublic object aroundgetfortune( \t\t\tproceedingjoinpoint theproceedingjoinpoint) throws throwable { \t\t \t\t// print out method we are advising on \t\tstring method = theproceedingjoinpoint.getsignature().toshortstring(); \t\tsystem.out.println(\"\\n=====>>> executing @around on method: \" + method); \t\t \t\t// get begin timestamp \t\tlong begin = system.currenttimemillis(); \t\t \t\ttry { \t\t\tresult = theproceedingjoinpoint.proceed(); \t\t} catch (exception e) { \t\t\t// log the exception \t\t\tmylogger.warning(e.getmessage()); \t\t\t// rethrow exception \t\t\tthrow e; \t\t} \t\t \t\t// get end timestamp \t\tlong end = system.currenttimemillis(); \t\t \t\t// compute duration and display it \t\tlong duration = end - begin; \t\tsystem.out.println(\"\\n=====> duration: \" + duration / 1000.0 + \" seconds\"); \t\t \t\treturn result; \t} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/AOP/Pointcut Expressions.html",
    "title": "Pointcut Expressions",
    "body": " index search search back pointcut expressions contents execution pointcut match methods match parameters a pointcut expression is a predicate expression that tells spring when to apply a given advice. spring aop uses aspectj's pointcut expression language. execution pointcut the expression pattern is the following: execution(modifiers-pattern? return-type-pattern declaring-type-pattern? method-name-pattern(param-pattern) throws-pattern?) modifiers-pattern?: spring aop only supports public or * return-type-pattern: void, boolean, string, list<costumer>, etc declaring-type-pattern?: the class name method-name-pattern(param-pattern): method name to match, and parameters type to match throws-pattern?: exception types to match if the parameter is optional it is followed by an ?. you can also add wildcards inside the patterns. match methods some examples are: match concrete method inside a class: @before(\"execution(public void com.aopdemo.dao.accountdao.addaccount())\") match a method inside any class: @before(\"execution(public void addaccount())\") match any method that starts with add: @before(\"execution(public void add*())\") match all methods inside a given package: @before(\"execution(* com.aopdemo.dao.*.*(..))\") the first * denotes the return type, it can be anything the second * denotes the class name, it can be anything inside the package the third * denotes the method name, it can be anything lastly, .. denotes the param-type, there can be 0 or more parameters match parameters there are the following parameter pattern wildcards: (): matches a method with no arguments (*): matches a method with one argument of any type (..): matches a method with 0 or more arguments of any type for example: match addaccount methods with no arguments: @before(\"execution(* addaccount())\") match addacount methods with one account parameter: @before(\"execution(* addaccount(com.aopdemo.account))\") match addacount methods with any number of parameters: @before(\"execution(* addaccount(*))\") $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/AOP/AfterReturning Advice.html",
    "title": "AfterReturning Advice",
    "body": " index search search back afterreturning advice this advice is run after the method is done executing, and it executed successfully. the flow of this advice is the following: so for example, if you want to have an advice run everytime we call the findaccounts method inside a concrete class, and we also want to print out the result we obtained we do the following: package com.aopdemo.aspect; import java.util.list; import org.aspectj.lang.joinpoint; import org.aspectj.lang.annotation.afterreturning; import org.aspectj.lang.annotation.aspect; import org.aspectj.lang.annotation.before; import org.aspectj.lang.reflect.methodsignature; import org.springframework.core.annotation.order; import org.springframework.stereotype.component; import com.aopdemo.account; @aspect @component @order(2) public class mydemologgingaspect { \t\t \t// add a new advice for @afterreturning on the findaccounts method \t@afterreturning( \t\t\tpointcut=\"execution(* com.aopdemo.dao.accountdao.findaccounts(..))\", // this is the parameter name of the list of accounts returned by findaccounts \t\t\treturning=\"result\") \tpublic void afterreturningfindaccountsadvice( \t\t\t\t\tjoinpoint thejoinpoint, list<account> result) { \t\t \t\t// print out which method we are advising on \t\tstring method = thejoinpoint.getsignature().toshortstring(); \t\tsystem.out.println(\"\\n=====>>> executing @afterreturning on method: \" + method); \t\t\t\t \t\t// print out the results of the method call \t\tsystem.out.println(\"\\n=====>>> result is: \" + result); \t} } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/AOP/Pointcut Declarations.html",
    "title": "Pointcut Declarations",
    "body": " index search search back pointcut declarations contents create pointcut declaration reuse pointcut declaration combine pointcut declarations how can we reuse a pointcut expression? we need to: create a pointcut declaration apply the pointcut declaration to the advices we want create pointcut declaration we define the pointcut declaration with the pointcut annotation and we bind it to an arbitrary method. package com.aopdemo.aspect; import org.aspectj.lang.annotation.aspect; import org.aspectj.lang.annotation.before; import org.aspectj.lang.annotation.pointcut; import org.springframework.stereotype.component; @aspect @component public class mydemologgingaspect { \t@pointcut(\"execution(* com.aopdemo.dao.*.*(..))\") \tprivate void fordaopackage() {} } reuse pointcut declaration to reuse this declaration we simply call the method that is bound to the pointcut declaration: package com.aopdemo.aspect; import org.aspectj.lang.annotation.aspect; import org.aspectj.lang.annotation.before; import org.aspectj.lang.annotation.pointcut; import org.springframework.stereotype.component; @aspect @component public class mydemologgingaspect { \t@pointcut(\"execution(* com.aopdemo.dao.*.*(..))\") \tprivate void fordaopackage() {} \t // reuse declaration \t@before(\"fordaopackage()\") \tpublic void beforeaddaccountadvice() {\t\t \t\tsystem.out.println(\"\\n=====>>> executing @before advice on method\");\t\t \t} \t // reuse declaration \t@before(\"fordaopackage()\") \tpublic void performapianalytics() { \t\tsystem.out.println(\"\\n=====>>> performing api analytics\");\t\t \t} \t } combine pointcut declarations how can we apply multiple pointcut expressions to a single advice? well we can combine pointcut expressions using logic operators: and (&&) or (||) not (!) for example: @before(\"expressionone() && expressiontwo()\") @before(\"expressionone() || expressiontwo()\") @before(\"expressionone() && !expressiontwo()\") imagine we want to execute an advice for every method in the package except for getters and setters, then we do: package com.aopdemo.aspect; import org.aspectj.lang.annotation.aspect; import org.aspectj.lang.annotation.before; import org.aspectj.lang.annotation.pointcut; import org.springframework.stereotype.component; @aspect @component public class mydemologgingaspect { \t@pointcut(\"execution(* com.aopdemo.dao.*.*(..))\") \tprivate void fordaopackage() {} \t \t// create pointcut for getter methods \t@pointcut(\"execution(* com.aopdemo.dao.*.get*(..))\") \tprivate void getter() {} \t \t// create pointcut for setter methods \t@pointcut(\"execution(* com.aopdemo.dao.*.set*(..))\") \tprivate void setter() {} \t \t// create pointcut: include package ... exclude getter/setter \t@pointcut(\"fordaopackage() && !(getter() || setter())\") \tprivate void fordaopackagenogettersetter() {} \t \t@before(\"fordaopackagenogettersetter()\") \tpublic void beforeaddaccountadvice() {\t\t \t\tsystem.out.println(\"\\n=====>>> executing @before advice on method\");\t\t \t} \t \t@before(\"fordaopackagenogettersetter()\") \tpublic void performapianalytics() { \t\tsystem.out.println(\"\\n=====>>> performing api analytics\");\t\t \t} } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/AOP/Control Aspect Order.html",
    "title": "Control Aspect Order",
    "body": " index search search back control aspect order contents refactor and order log to cloud aspect logging aspect analytics aspect how do we control the order of advices being applied when they all match the pointcut expressions? to control order we should: refactor: place advices in separate aspects control order on aspects using the @order annotation refactor and order we are going to create three aspects separate from each other as follows: so with the ordering the aspect flow looks something like this: log to cloud aspect package com.luv2code.aopdemo.aspect; import org.aspectj.lang.annotation.aspect; import org.aspectj.lang.annotation.before; import org.springframework.core.annotation.order; import org.springframework.stereotype.component; @aspect @component // set order @order(1) public class mycloudlogasyncaspect { \t@before(\"com.aopdemo.aspect.luvaopexpressions.fordaopackagenogettersetter()\") \tpublic void logtocloudasync() { \t\tsystem.out.println(\"\\n=====>>> logging to cloud in async fashion\");\t\t \t} } logging aspect package com.aopdemo.aspect; import org.aspectj.lang.annotation.aspect; import org.aspectj.lang.annotation.before; import org.springframework.core.annotation.order; import org.springframework.stereotype.component; @aspect @component // set the order @order(2) public class mydemologgingaspect { \t \t@before(\"com.aopdemo.aspect.luvaopexpressions.fordaopackagenogettersetter()\") \tpublic void beforeaddaccountadvice() {\t\t \t\tsystem.out.println(\"\\n=====>>> executing @before advice on method\");\t\t \t} \t } analytics aspect package com.aopdemo.aspect; import org.aspectj.lang.annotation.aspect; import org.aspectj.lang.annotation.before; import org.springframework.core.annotation.order; import org.springframework.stereotype.component; @aspect @component // set the order @order(3) public class myapianalyticsaspect { \t@before(\"com.aopdemo.aspect.luvaopexpressions.fordaopackagenogettersetter()\") \tpublic void performapianalytics() { \t\tsystem.out.println(\"\\n=====>>> performing api analytics\");\t\t \t} } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Java Annotations/Field Injection.html",
    "title": "Field Injection",
    "body": " index search search back field injection contents define dependency as component specify dependency field injection allows you to inject dependencies by setting field values on your class directly (even private ones). this is accomplished by using java reflection. for this, we need to configure the autowired annotation as follows: apply it directly to the field which saves us from using setter methods for dependency injection. define dependency as component package com.springdemo; import org.springframework.stereotype.component; // we tell spring this is a bean @component public class happyfortuneservice implements fortuneservice { \t@override \tpublic string getfortune() { \t\treturn \"today is your lucky day!\"; \t} } specify dependency package com.springdemo; import org.springframework.stereotype.component; import org.springframework.beans.factory.annotation.autowired; @component public class tenniscoach implements coach { // we tell spring to search for beans (classes with @component annotation) // that implement the fortuneservice interface @autowired \tprivate fortuneservice fortuneservice; \t \tpublic tenniscoach() {} \t@override \tpublic string getdailyworkout() { \t\treturn \"practice your backhand volley\"; \t} \t@override \tpublic string getdailyfortune() { \t\treturn fortuneservice.getfortune(); \t} } the main method and the configuration files remain unchanged. and when we execute this piece of code, spring will automatically inject the dependency because of the autowired annotation. package com.springdemo; import org.springframework.context.support.classpathxmlapplicationcontext; public class annotationdemoapp { \tpublic static void main(string[] args) { \t\t// read spring config file \t\tclasspathxmlapplicationcontext context = \t\t\t\tnew classpathxmlapplicationcontext(\"applicationcontext.xml\"); \t\t \t\t// get the bean from spring container \t\tcoach thecoach = context.getbean(\"tenniscoach\", coach.class); \t\t \t\t// call a method on the bean \t\tsystem.out.println(thecoach.getdailyworkout()); \t\t// call method to get daily fortune \t\tsystem.out.println(thecoach.getdailyfortune()); \t\t\t\t \t\t// close the context \t\tcontext.close(); \t} } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Java Annotations/Method Injection.html",
    "title": "Method Injection",
    "body": " index search search back method injection contents define dependency as component specify dependency one thing to note is that you can add dependency injection on any method you want, does not have to be a setter method: define dependency as component package com.springdemo; import org.springframework.stereotype.component; // we tell spring this is a bean @component public class happyfortuneservice implements fortuneservice { \t@override \tpublic string getfortune() { \t\treturn \"today is your lucky day!\"; \t} } specify dependency we now create a setter method in our class for the injection: package com.springdemo; import org.springframework.stereotype.component; import org.springframework.beans.factory.annotation.autowired; @component public class tenniscoach implements coach { \tprivate fortuneservice fortuneservice; \t \tpublic tenniscoach() {} // we tell spring to search for beans (classes with @component annotation) // that implement the fortuneservice interface \t@autowired public anymethod(fortuneservice fortuneservice){ this.fortuneservice = fortuneservice; } \t@override \tpublic string getdailyworkout() { \t\treturn \"practice your backhand volley\"; \t} \t@override \tpublic string getdailyfortune() { \t\treturn fortuneservice.getfortune(); \t} } the main method and the configuration files remain unchanged. and when we execute this piece of code, spring will automatically inject the dependency because of the autowired annotation. package com.springdemo; import org.springframework.context.support.classpathxmlapplicationcontext; public class annotationdemoapp { \tpublic static void main(string[] args) { \t\t// read spring config file \t\tclasspathxmlapplicationcontext context = \t\t\t\tnew classpathxmlapplicationcontext(\"applicationcontext.xml\"); \t\t \t\t// get the bean from spring container \t\tcoach thecoach = context.getbean(\"tenniscoach\", coach.class); \t\t \t\t// call a method on the bean \t\tsystem.out.println(thecoach.getdailyworkout()); \t\t// call method to get daily fortune \t\tsystem.out.println(thecoach.getdailyfortune()); \t\t\t\t \t\t// close the context \t\tcontext.close(); \t} } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Java Annotations/index.html",
    "title": "Java Annotations",
    "body": " index search search back java annotations java annotations are special labels added to classes. they provide metadata about the class, and can be processed at compile time or run-time for special processing. we use annotations to minimize the xml configuration. spring scans the classes to find beans and configure them internally (as we have done with the xml configuration). in order to use this approach we need to: enable component scanning in our spring configuration file and add the @component annotation to our class inversion of control dependency injection scopes life cycles $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Java Annotations/Constructor Injection.html",
    "title": "Constructor Injection",
    "body": " index search search back constructor injection contents define dependency as component specify dependency define dependency as component package com.springdemo; import org.springframework.stereotype.component; // we tell spring this is a bean @component public class happyfortuneservice implements fortuneservice { \t@override \tpublic string getfortune() { \t\treturn \"today is your lucky day!\"; \t} } specify dependency package com.springdemo; import org.springframework.stereotype.component; import org.springframework.beans.factory.annotation.autowired; @component public class tenniscoach implements coach { \tprivate fortuneservice fortuneservice; \t // we tell spring to search for beans (classes with @component annotation) // that implement the fortuneservice interface \t@autowired \tpublic tenniscoach(fortuneservice thefortuneservice) { \t\tfortuneservice = thefortuneservice; \t} \t@override \tpublic string getdailyworkout() { \t\treturn \"practice your backhand volley\"; \t} \t@override \tpublic string getdailyfortune() { \t\treturn fortuneservice.getfortune(); \t} } the main method and the configuration files remain unchanged. package com.springdemo; import org.springframework.context.support.classpathxmlapplicationcontext; public class annotationdemoapp { \tpublic static void main(string[] args) { \t\t// read spring config file \t\tclasspathxmlapplicationcontext context = \t\t\t\tnew classpathxmlapplicationcontext(\"applicationcontext.xml\"); \t\t \t\t// get the bean from spring container \t\tcoach thecoach = context.getbean(\"tenniscoach\", coach.class); \t\t \t\t// call a method on the bean \t\tsystem.out.println(thecoach.getdailyworkout()); \t\t// call method to get daily fortune \t\tsystem.out.println(thecoach.getdailyfortune()); \t\t\t\t \t\t// close the context \t\tcontext.close(); \t} } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Java Annotations/Qualifier Annotation.html",
    "title": "Qualifier",
    "body": " index search search back qualifier contents define dependency as component specify dependency qualifier in constructor in order to specify which specific implementation of an interface we want to use, when this interface is implemented by several beans, then we use the qualifier annotation. the qualifier annotation can be used in any dependency injection implementation: constructor injection (has different syntax) setter injection method injection field injection define dependency as component package com.springdemo; import org.springframework.stereotype.component; // we tell spring this is a bean @component public class happyfortuneservice implements fortuneservice { \t@override \tpublic string getfortune() { \t\treturn \"today is your lucky day!\"; \t} } specify dependency package com.springdemo; import org.springframework.stereotype.component; import org.springframework.beans.factory.annotation.autowired; @component public class tenniscoach implements coach { \t \t// we tell spring to search for beans (classes with @component annotation) \t// that implement the fortuneservice interface whose name is \"happyfortuneservice\" \t// (note this is the default name of the component if you set one explicitly you \t// will have to specify that one in the qualifier annotation) \t@autowired \t@qualifier(\"happyfortuneservice\") \tprivate fortuneservice fortuneservice; \t \tpublic tenniscoach() {} \t \t@override \tpublic string getdailyworkout() { \t\treturn \"practice your backhand volley\"; \t} \t \t@override \tpublic string getdailyfortune() { \t\treturn fortuneservice.getfortune(); \t} } the main method and the configuration files remain unchanged. and when we execute this piece of code, spring will automatically inject the dependency because of the autowired annotation. package com.springdemo; import org.springframework.context.support.classpathxmlapplicationcontext; public class annotationdemoapp { \tpublic static void main(string[] args) { \t\t// read spring config file \t\tclasspathxmlapplicationcontext context = \t\t\t\tnew classpathxmlapplicationcontext(\"applicationcontext.xml\"); \t\t \t\t// get the bean from spring container \t\tcoach thecoach = context.getbean(\"tenniscoach\", coach.class); \t\t \t\t// call a method on the bean \t\tsystem.out.println(thecoach.getdailyworkout()); \t\t// call method to get daily fortune \t\tsystem.out.println(thecoach.getdailyfortune()); \t\t\t\t \t\t// close the context \t\tcontext.close(); \t} } qualifier in constructor package com.springdemo; import org.springframework.beans.factory.annotation.autowired; import org.springframework.beans.factory.annotation.qualifier; import org.springframework.stereotype.component; @component public class tenniscoach implements coach { private fortuneservice fortuneservice; // define a default constructor public tenniscoach() { system.out.println(\">> tenniscoach: inside default constructor\"); } @autowired public tenniscoach(@qualifier(\"happyfortuneservice\") fortuneservice thefortuneservice) { system.out.println(\">> tenniscoach: inside constructor using @autowired and @qualifier\"); fortuneservice = thefortuneservice; } } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Java Annotations/Scopes.html",
    "title": "Scopes",
    "body": " index search search back scopes to explicitly specify scopes with java annotations you do as follows: package com.springdemo; import org.springframework.stereotype.component; import org.springframework.context.annotation.scope; @component @scope(\"singleton\") public class tenniscoach implements coach { ... or package com.springdemo; import org.springframework.stereotype.component; import org.springframework.context.annotation.scope; @component @scope(\"prototype\") public class tenniscoach implements coach { ... refer to more information about scopes are in bean scopes: $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Java Annotations/Inversion of Control.html",
    "title": "Inversion of Control",
    "body": " index search search back inversion of control contents enable component scanning add component annotation to classes main method let's see how to make us of inversion of control with annotations: enable component scanning we remove all of the beans we defined, and enable component scanning: <?xml version=\"1.0\" encoding=\"utf-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/xmlschema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemalocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"> \t<!-- add entry to enable component scanning --> \t<context:component-scan base-package=\"com.springdemo\" /> </beans> now spring will scan recursively all of the files in this package. add @component annotation to classes we add the @component annotation to our classes (note we do not add it to the interfaces like coach). package com.springdemo; import org.springframework.stereotype.component; @component // we can also set the explicit name like // @component(\"mytenniscoach\") public class tenniscoach implements coach { \t \t@override \tpublic string getdailyworkout() { \t\treturn \"practice your backhand volley\"; \t} } note that we can name the component explicitly or by default. main method in our application we do not really need to change anything. we create our bean the same way we did before. the only thing to note is that if we set the name of the component explicitly, then when we instantiate the bean, we should refer to it by said name. package com.springdemo; import org.springframework.context.support.classpathxmlapplicationcontext; public class annotationdemoapp { \tpublic static void main(string[] args) { \t\t// read spring config file \t\tclasspathxmlapplicationcontext context = \t\t\t\tnew classpathxmlapplicationcontext(\"applicationcontext.xml\"); \t\t \t\t// get the bean from spring container \t\t// if we set the name explicitly \t\tcoach thecoach = context.getbean(\"mytenniscoach\", coach.class); // else \t\tcoach thecoach = context.getbean(\"tenniscoach\", coach.class); \t\t \t\t// call a method on the bean \t\tsystem.out.println(thecoach.getdailyworkout()); \t\t\t\t \t\t// close the context \t\tcontext.close(); \t\t \t} } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Java Annotations/Life Cycles.html",
    "title": "Life Cycle",
    "body": " index search search back life cycle contents notes to define methods to add when the beans is constructed or destroyed we use the postconstruct and predestroy annotation. package com.springdemo; public class trackcoach implements coach { \t \tprivate fortuneservice fortuneservice; \t \tpublic trackcoach() { \t\t \t} \t \tpublic trackcoach(fortuneservice fortuneservice) { \t\tthis.fortuneservice = fortuneservice; \t} \t \t@override \tpublic string getdailyworkout() { \t\treturn \"run a hard 5k\"; \t} \t \t@override \tpublic string getdailyfortune() { \t\treturn \"just do it: \" + fortuneservice.getfortune(); \t} \t \t// run when the bean is done creating \t@postconstruct \tpublic void domystartupstuff() { \t\tsystem.out.println(\"trackcoach: inside method domystartupstuff\"); \t} \t \t// run before the bean is destroyed \t@predestroy \tpublic void domycleanupstuffyoyo() { \t\tsystem.out.println(\"trackcoach: inside method domycleanupstuffyoyo\");\t\t \t} } refer to more information about scopes are in bean life cycle: notes access modifier: the method can have any access modifier (public, protected, private) return type: the method can have any return type. however, \"void' is most commonly used. if you give a return type just note that you will not be able to capture the return value. as a result, \"void\" is commonly used. method name: the method can have any method name. arguments: the method can not accept any arguments. the method should be no-arg. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Java Annotations/Dependency Injection.html",
    "title": "Dependency Injection",
    "body": " index search search back dependency injection contents which dependency to use we will introduce dependency injection with annotation using autowiring: spring looks for a class that matches the attribute type (call or interface) (i.e. fortuneservice) spring will inject it automatically if there are multiple implementations: tell spring which specific bean to use with the qualifier annotation constructor injection setter injection method injection field injection inject using properties file qualifier annotation which dependency to use choose a style and stay consistent in your project. you get the same functionality regardless of the type of dependency injection you use. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Java Annotations/Setter Injection.html",
    "title": "Setter Injection",
    "body": " index search search back setter injection contents define dependency as component specify dependency define dependency as component package com.springdemo; import org.springframework.stereotype.component; // we tell spring this is a bean @component public class happyfortuneservice implements fortuneservice { \t@override \tpublic string getfortune() { \t\treturn \"today is your lucky day!\"; \t} } specify dependency we now create a setter method in our class for the injection: package com.springdemo; import org.springframework.stereotype.component; import org.springframework.beans.factory.annotation.autowired; @component public class tenniscoach implements coach { \tprivate fortuneservice fortuneservice; \t \tpublic tenniscoach() {} // we tell spring to search for beans (classes with @component annotation) // that implement the fortuneservice interface \t@autowired public setfortuneservice(fortuneservice fortuneservice){ this.fortuneservice = fortuneservice; } \t@override \tpublic string getdailyworkout() { \t\treturn \"practice your backhand volley\"; \t} \t@override \tpublic string getdailyfortune() { \t\treturn fortuneservice.getfortune(); \t} } the main method and the configuration files remain unchanged. and when we execute this piece of code, spring will automatically inject the dependency because of the autowired annotation. package com.springdemo; import org.springframework.context.support.classpathxmlapplicationcontext; public class annotationdemoapp { \tpublic static void main(string[] args) { \t\t// read spring config file \t\tclasspathxmlapplicationcontext context = \t\t\t\tnew classpathxmlapplicationcontext(\"applicationcontext.xml\"); \t\t \t\t// get the bean from spring container \t\tcoach thecoach = context.getbean(\"tenniscoach\", coach.class); \t\t \t\t// call a method on the bean \t\tsystem.out.println(thecoach.getdailyworkout()); \t\t// call method to get daily fortune \t\tsystem.out.println(thecoach.getdailyfortune()); \t\t\t\t \t\t// close the context \t\tcontext.close(); \t} } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Java Annotations/Inject using Properties File.html",
    "title": "Inject properties file using Java annotations",
    "body": " index search search back inject properties file using java annotations contents create a properties file load the properties inject values this solution will show you how inject values from a properties file using annotations. the values will no longer be hard coded in the java code. create a properties file we create new text file: src/sport.properties foo.email=myeasycoach@luv2code.com foo.team=silly java coders load the properties we load the properties in the configuration xml file. for that we add the line: <context:property-placeholder location=\"classpath:sport.properties\"/> inject values lastly we inject the properties values into our bean like so: @value(\"${foo.email}\") private string email; @value(\"${foo.team}\") private string team; $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Hibernate/Concepts.html",
    "title": "Database Concepts",
    "body": " index search search back database concepts contents cascade types cascade: perform an operations on related entities on save: if we save an object, if it is related to another object, we need to also save that other object on delete: if we delete an object that is related to another object, we might need to delete that other object (depends on the use case) fetch types: when we fetch data, should we retrieve everything? eager: will retrieve everything lazy: will retrieve on request cascade types persist: if entity is persisted/saved, the related entity will also be persisted remove: if entity is removed/deleted, the related entity will also be deleted refresh: if entity is refreshed, the related entity will also be refreshed detach: if entity is detached (not associated with session), the related entity will also be detached merge: if entity is merged, the related entity will also be merged all: all of the above cascade types by default, no operations are cascaded. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Hibernate/Sessions.html",
    "title": "Sessions",
    "body": " index search search back sessions there are two key components when it comes to session handling: sessionfactory: reads the hibernate configuration file, creates sessions objects, and is created only once in the application and reused over and over again session: is a wrapper around a jdbc connection, which is the main object used to save/retrieve objects. this object is created multiple times. so to create a sessionfactory and then create session from it: public class demo { public static void main(string[] args) { // create session factory sessionfactory factory = new configuration() // configuration file in src/ (if it is not specified, hibernate will look for a file named hibernate.cfg.xml) .configure(\"hibernate.cfg.xml\") // class that was annotated to be mapped .addannotatedclass(student.class) // you can add multiple classes .addannotatedclass(...) // create the factory .buildsessionfactory(); // create session session session = factory.getcurrentsession(); try {\t\t\t // use session object to perform crud operations\t } finally { // delete session factory factory.close(); } } } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Hibernate/ManyToMany.html",
    "title": "Many To Many Relationship",
    "body": " index search search back many to many relationship contents entities main app here we demonstrate how to implement a many to many relationship between two entities. for this we need a join table: well, first of all you have to define the two database tables corresponding to these two entities. and then we define a intermediate table to act as the join table called course_student. entities we now code the two entities: package com.hibernate.demo.entity; // annotate the class as an entity and map to db table @entity @table(name=\"course\") public class course { // define the fields // annotate the fields with db column names @id @generatedvalue(strategy=generationtype.identity) @column(name=\"id\") private int id; @column(name=\"title\") private string title; // set up one to many relationship @manytoone(cascade= // on delete course, do not delete instructor {cascadetype.persist, cascadetype.merge, cascadetype.detach, cascadetype.refresh}) @joincolumn(name=\"instructor_id\") private instructor instructor; // set up unidirectional one to many relationship @onetomany(fetch=fetchtype.lazy, cascade=cascadetype.all) \t@joincolumn(name=\"course_id\") \tprivate list<review> reviews; // set up many to many relationship with lazy loading // so only courses are retrieved, and the students associated // are obtained only if needed \t@manytomany(fetch=fetchtype.lazy, \t\t\tcascade= {cascadetype.persist, cascadetype.merge, \t\t\t cascadetype.detach, cascadetype.refresh}) // specifying the join table, and the corresponding // foreign keys @jointable( // table name name=\"course_student\", // this entity's pk joincolumns=@joincolumn(name=\"course_id\"), // related entity's pk inversejoincolumns=@joincolumn(name=\"student_id\") ) private list<student> students; public course() { }\t\t ... // setters and getters } and now the student: package com.hibernate.demo.entity; @entity @table(name=\"student\") public class student { @id @generatedvalue(strategy=generationtype.identity) @column(name=\"id\") private int id; @column(name=\"first_name\") private string firstname; @column(name=\"last_name\") private string lastname; @column(name=\"email\") private string email; // set up many to many relationship with lazy loading // so only students are retrieved, and the courses associated // are obtained only if needed @manytomany(fetch=fetchtype.lazy, \t\tcascade= {cascadetype.persist, cascadetype.merge, \t\t cascadetype.detach, cascadetype.refresh}) // specifying the join table, and the corresponding // foreign keys @jointable( // table name \t\tname=\"course_student\", // this entity's pk \t\tjoincolumns=@joincolumn(name=\"student_id\"), // related entity's pk \t\tinversejoincolumns=@joincolumn(name=\"course_id\") \t\t)\t private list<course> courses; // constructor, getters, setters .... main app to test our code, we are going to get a course and add it to a student: package com.hibernate.demo; public class createdemo { public static void main(string[] args) { // create session factory // ... // create session session session = factory.getcurrentsession(); try {\t\t // start a transaction session.begintransaction(); // get the student mary from database int studentid = 2; student tempstudent = session.get(student.class, studentid); // create more courses course tempcourse1 = new course(\"rubik's cube - how to speed cube\"); course tempcourse2 = new course(\"atari 2600 - game development\"); \t\t\t // add student to courses tempcourse1.addstudent(tempstudent); tempcourse2.addstudent(tempstudent); \t\t\t // save the courses session.save(tempcourse1); session.save(tempcourse2); // commit transaction session.gettransaction().commit(); } finally { session.close(); \tfactory.close(); } } } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Hibernate/Database Operations.html",
    "title": "Database Operations",
    "body": " index search search back database operations contents save java object read java object query java object update java objects delete java objects save java object to save a java object: public ... { try {\t\t\t \t// create a student object \tstudent tempstudent = new student(\"paul\", \"doe\", \"paul@luv2code.com\"); \t \t// start a transaction \tsession.begintransaction(); \t \t// save the student object \tsession.save(tempstudent); \t \t// commit transaction \tsession.gettransaction().commit(); } finally { \tfactory.close(); } } read java object public ... { try {\t\t\t // from the student created and saved previously // find out the student's id: primary key // now get a new session and start transaction session = factory.getcurrentsession(); session.begintransaction(); // retrieve student based on the id: primary key system.out.println(\"\\ngetting student with id: \" + tempstudent.getid()); // get from the db by the primary key of the student student mystudent = session.get(student.class, tempstudent.getid()); // commit the transaction session.gettransaction().commit(); } finally { \tfactory.close(); } } query java object hibernate has a query language for retrieving objects: hql which is similar to sql. public class querystudentdemo { public static void main(string[] args) { // create session factory ... // create session session session = factory.getcurrentsession(); try {\t\t\t // start a transaction session.begintransaction(); // note we use the java object name for the table name // and the name of the attribute in the class for the name // of the column (firstname istd of first_name) // query students: lastname='doe' or firstname='daffy' thestudents = session.createquery(\"from student s where\" + \" s.lastname='doe' or s.firstname='daffy'\").getresultlist(); // query students where email like '%gmail.com' thestudents = session.createquery(\"from student s where\" \t\t+ \" s.email like '%gmail.com'\").getresultlist(); // commit transaction session.gettransaction().commit(); } finally { \tfactory.close(); } } update java objects public class updatestudentdemo { public static void main(string[] args) { // create session factory ... // create session session session = factory.getcurrentsession(); try {\t\t\t\t\t\t\t\t // update one student int studentid = 1; // now get a new session and start transaction session = factory.getcurrentsession(); session.begintransaction(); student mystudent = session.get(student.class, studentid); // update name of student mystudent.setfirstname(\"scooby\"); // commit the transaction session.gettransaction().commit(); // update several students session = factory.getcurrentsession(); session.begintransaction(); // update email for all students system.out.println(\"update email for all students\"); session.createquery(\"update student set email='foo@gmail.com'\") \t.executeupdate(); \t\t\t // commit the transaction session.gettransaction().commit(); } finally { \tfactory.close(); } } } delete java objects public class deletestudentdemo { public static void main(string[] args) { // create session factory ... // create session session session = factory.getcurrentsession(); try {\t\t\t\t\t\t\t\t int studentid = 1; \t\t\t // now get a new session and start transaction session = factory.getcurrentsession(); session.begintransaction(); // retrieve student based on the id: primary key student mystudent = session.get(student.class, studentid); // delete the student session.delete(mystudent); // delete student id=2 session.createquery(\"delete from student where id=2\").executeupdate(); // commit the transaction session.gettransaction().commit(); } finally { \tfactory.close(); } } } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Hibernate/Annotations.html",
    "title": "Configure Hibernate with Annotations",
    "body": " index search search back configure hibernate with annotations contents add hibernate configuration file annotate java class add hibernate configuration file we create the following hibernate.cfg.xml file: <!doctype hibernate-configuration public \"-//hibernate/hibernate configuration dtd 3.0//en\" \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"> <hibernate-configuration> <!-- a session factory allows us to get sessions objects to connect to the database --> <session-factory> <!-- jdbc database connection settings --> <property name=\"connection.driver_class\">com.mysql.cj.jdbc.driver</property> <property name=\"connection.url\">jdbc:mysql://localhost:3306/hb_student_tracker?usessl=false&amp;servertimezone=utc</property> <property name=\"connection.username\">hbstudent</property> <property name=\"connection.password\">hbstudent</property> <!-- jdbc connection pool settings ... using built-in test pool --> <property name=\"connection.pool_size\">1</property> <!-- select our sql dialect --> <property name=\"dialect\">org.hibernate.dialect.mysqldialect</property> <!-- echo the sql to stdout --> <property name=\"show_sql\">true</property> <!-- set the current session context --> <property name=\"current_session_context_class\">thread</property> </session-factory> </hibernate-configuration> annotate java class hibernate deals with the concept of entity, which is basically a java class with its attributes, setters and getters, that is mapped to a database table with the help of annotations. note that there are two ways of configuring the mapping: xml config file (legacy) java annotations (modern, preferred) with java annotations we have to follow these steps: map the class to a database table // let spring know this is an entity we want to map to a database table @entity // provides the actual name of the table (observe in this case it is optional // because the name of the class = the name of the database table) @table(name=\"student\") public class student { ... } map the fields to database columns public class student { // primary key @id // how to generate primary key @generatedvalue(strategy=generationtype.identity) // column name (also not needed if the name in the database and the name here are the same) @column(name=\"id\") private int id; @column(name=\"first_name\") private string firstname; @column(name=\"last_name\") private string lastname; @column(name=\"email\") private string email; ... } some other id generation strategies are: auto: pick the appropiate strategy for the given database identity: assign primary keys using database identidy column sequence: assign primary keys using a database sequence table: assign primary keys using an uderlying database table to ensure uniqueness you can also create your custom generator $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Hibernate/Eager vs Lazy Loading.html",
    "title": "Eager vs Lazy Loading",
    "body": " index search search back eager vs lazy loading contents default fetch types specify fetch type on entity avoid closed session exception eager: fetches all data all at once (with dependencies of the entity) lazy: fetches required data only lazy loading is usually preferred, that is only load data when absolutely needed. the flow of lazy loading is: load the main entity first load dependent entities on demand note than when using lazy loading you need an open hibernate session, else if you close the session and try to retrieve the data hibernate will throw an exception. default fetch types mapping defaul fetch type @onetoone fetchtype.eager @onetomany fetchtype.lazy @manytoone fetchtype.eager @manytomany fetchtype.lazy specify fetch type on entity we can specify the fetching type on the entity as follows: @entity @table(name=\"instructor\") public class instructor { \t@id \t@generatedvalue(strategy=generationtype.identity) \t@column(name=\"id\") \tprivate int id; \t \t@onetoone(cascade=cascadetype.all) \t@joincolumn(name=\"instructor_detail_id\") \tprivate instructordetail instructordetail; \t // specify fetch type (only load the courses on demand, their retrieval // is delayed) \t@onetomany(fetch=fetchtype.lazy, \t\t\t mappedby=\"instructor\", \t\t\t cascade= {cascadetype.persist, cascadetype.merge, \t\t\t\t\t\t cascadetype.detach, cascadetype.refresh}) \tprivate list<course> courses; ... avoid closed session exception to avoid the error we use the join fetch (we do override lazy loading with eager loading) of hql: public class fetchjoindemo { public static void main(string[] args) { // create session factory sessionfactory factory = ... // create session session session = factory.getcurrentsession(); try {\t\t\t // start a transaction session.begintransaction(); // hibernate query with hql to avoid exception of lazy loading when closing session // get the instructor from db int theid = 1; query<instructor> query = \t\tsession.createquery(\"select i from instructor i \" \t\t\t\t\t\t+ \"join fetch i.courses \" \t\t\t\t\t\t+ \"where i.id=:theinstructorid\", \t\t\t\tinstructor.class); // set parameter on query query.setparameter(\"theinstructorid\", theid); // execute query and get instructor instructor tempinstructor = query.getsingleresult(); system.out.println(\"luv2code: instructor: \" + tempinstructor);\t // commit transaction session.gettransaction().commit(); // close the session session.close(); system.out.println(\"\\nluv2code: the session is now closed!\\n\"); // get courses for the instructor system.out.println(\"luv2code: courses: \" + tempinstructor.getcourses()); system.out.println(\"luv2code: done!\"); } finally { // add clean up code session.close(); factory.close(); } } } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Hibernate/index.html",
    "title": "Hibernate",
    "body": " index search search back hibernate is a framework for persisting/saving java objects in a database handles all of the low-level sql minimizes the amount jdbc code to develop provides the object-to-relational mapping (orm): the developer defines a mapping between a java class and a database table hibernate uses jdbc for all database communications: $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Hibernate/OneToMany.html",
    "title": "One To Many Relationship",
    "body": " index search search back one to many relationship contents unidirectional entities main app bidirectional entities main app unidirectional bidirectional unidirectional here we demonstrate how to implement a unidirectional one to many relationship between two entities: well, first of all you have to define the two database tables corresponding to these two entities. entities we now code the two entities: package com.hibernate.demo.entity; // annotate the class as an entity and map to db table @entity @table(name=\"course\") public class course { // define the fields // annotate the fields with db column names @id @generatedvalue(strategy=generationtype.identity) @column(name=\"id\") private int id; @column(name=\"title\") private string title; // set up one to many relationship @manytoone(cascade= // on delete course, do not delete instructor {cascadetype.persist, cascadetype.merge, cascadetype.detach, cascadetype.refresh}) @joincolumn(name=\"instructor_id\") private instructor instructor; // set up unidirectional one to many relationship @onetomany(fetch=fetchtype.lazy, cascade=cascadetype.all) \t@joincolumn(name=\"course_id\") \tprivate list<review> reviews; public course() { }\t\t ... // setters and getters } and now the review: package com.hibernate.demo.entity; @entity @table(name=\"review\") public class review { \t@id \t@generatedvalue(strategy=generationtype.identity) \t@column(name=\"id\") \tprivate int id; \t \t@column(name=\"comment\") \tprivate string comment; \t \tpublic review() { \t\t \t} note that there is no reference in the review to the course. main app to test our code, we are going to get a course and the list of review objects associated. the test main app is the following: package com.hibernate.demo; public class createdemo { public static void main(string[] args) { // create session factory // ... // create session session session = factory.getcurrentsession(); try {\t\t // start a transaction session.begintransaction(); // get the course int theid = 10; course tempcourse = session.get(course.class, theid); // get reviews tempcourse.getreviews(); // commit transaction session.gettransaction().commit(); } finally { session.close(); \tfactory.close(); } } } bidirectional now we will define the following relationship: let's now see how to code a bidirectional relationship: entities package com.hibernate.demo.entity; /* annotate the class as an entity and map to db table */ @entity @table(name=\"instructor\") public class instructor { // define the fields and annotate the fields // with db column names @id @generatedvalue(strategy=generationtype.identity) @column(name=\"id\") private int id; @column(name=\"first_name\") private string firstname; @column(name=\"last_name\") private string lastname; @column(name=\"email\") private string email; // set up mapping to instructordetail entity // note the cascade type @onetoone(cascade=cascadetype.all) // define the foreign key @joincolumn(name=\"instructor_detail_id\") private instructordetail instructordetail; // bidirectional relationship with courses // the mapping information is in the instructor // property in the course class @onetomany(mappedby=\"instructor\", // on delete instructor, do not delete courses cascade= {cascadetype.persist, cascadetype.merge, cascadetype.detach, cascadetype.refresh}) private list<course> courses; public instructor() { \t } ... // setters and getters } and now the course class: package com.hibernate.demo.entity; // annotate the class as an entity and map to db table @entity @table(name=\"course\") public class course { // define the fields // annotate the fields with db column names @id @generatedvalue(strategy=generationtype.identity) @column(name=\"id\") private int id; @column(name=\"title\") private string title; // set up one to many relationship @manytoone(cascade= // on delete course, do not delete instructor {cascadetype.persist, cascadetype.merge, cascadetype.detach, cascadetype.refresh}) @joincolumn(name=\"instructor_id\") private instructor instructor; public course() { }\t\t ... // setters and getters } main app in our test main app we are going to search for an instructordetail object, and we are going to retrieve the related instructor object: package com.hibernate.demo; public class getinstructordetaildemo { public static void main(string[] args) { session = factory.getcurrentsession(); try { // start a transaction session.begintransaction(); // get the instructor from db int theid = 1; instructor tempinstructor = session.get(instructor.class, theid);\t\t // create some courses course tempcourse1 = new course(\"air guitar - the ultimate guide\"); course tempcourse2 = new course(\"the pinball masterclass\"); // add courses to instructor tempinstructor.add(tempcourse1); tempinstructor.add(tempcourse2); // save the courses session.save(tempcourse1); session.save(tempcourse2); // commit transaction session.gettransaction().commit(); } catch(exception exc){ exc.printstacktrace(); } finally { // finish session session.close(); // remove factory\t factory.close(); } } } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Hibernate/OneToOne.html",
    "title": "One To One Relationship",
    "body": " index search search back one to one relationship contents unidirectional entities main app bidirectional entities main app unidirectional bidirectional unidirectional here we demonstrate how to implement a unidirectional one to one relationship between two entities: well, first of all you have to define the two database tables corresponding to these two entities. entities we now code the two entities: package com.hibernate.demo.entity; /* annotate the class as an entity and map to db table */ @entity @table(name=\"instructor\") public class instructor { // define the fields and annotate the fields // with db column names @id @generatedvalue(strategy=generationtype.identity) @column(name=\"id\") private int id; @column(name=\"first_name\") private string firstname; @column(name=\"last_name\") private string lastname; @column(name=\"email\") private string email; // set up mapping to instructordetail entity // note the cascade type @onetoone(cascade=cascadetype.all) // define the foreign key @joincolumn(name=\"instructor_detail_id\") private instructordetail instructordetail; public instructor() { \t } ... // setters and getters } note the specification of the cascade type. and now the instructordetail: package com.hibernate.demo.entity; // annotate the class as an entity and map to db table @entity @table(name=\"instructor_detail\") public class instructordetail { \t// define the fields \t// annotate the fields with db column names \t \t@id \t@generatedvalue(strategy=generationtype.identity) \t@column(name=\"id\") \tprivate int id; \t \t@column(name=\"youtube_channel\") \tprivate string youtubechannel; \t \t@column(name=\"hobby\") \tprivate string hobby; \t \tpublic instructordetail() { }\t\t ... // setters and getters } main app to test our code, we are going to create an instructor object and an instructordetail object and save them. the test main app is the following: package com.hibernate.demo; public class createdemo { public static void main(string[] args) { // create session factory // ... // create session session session = factory.getcurrentsession(); try {\t\t\t // create the objects instructor tempinstructor = \t\tnew instructor(\"madhu\", \"patel\", \"madhu@mail.com\"); instructordetail tempinstructordetail = \t\tnew instructordetail( \t\t\t\t\"http://www.youtube.com\", \t\t\t\t\"guitar\");\t\t // associate the objects tempinstructor.setinstructordetail(tempinstructordetail); // start a transaction session.begintransaction(); // save the instructor // // note: this will also save the details object // because of cascadetype.all // session.save(tempinstructor);\t\t\t\t\t // commit transaction session.gettransaction().commit(); } finally { \tfactory.close(); } } } bidirectional now we will define the following bidirectional one to one relationship: let's now see how to code a bidirectional relationship: entities package com.hibernate.demo.entity; /* annotate the class as an entity and map to db table */ @entity @table(name=\"instructor\") public class instructor { // define the fields and annotate the fields // with db column names @id @generatedvalue(strategy=generationtype.identity) @column(name=\"id\") private int id; @column(name=\"first_name\") private string firstname; @column(name=\"last_name\") private string lastname; @column(name=\"email\") private string email; // set up mapping to instructordetail entity // note the cascade type @onetoone(cascade=cascadetype.all) // define the foreign key @joincolumn(name=\"instructor_detail_id\") private instructordetail instructordetail; public instructor() { \t } ... // setters and getters and now the instructordetail: package com.hibernate.demo.entity; // annotate the class as an entity and map to db table @entity @table(name=\"instructor_detail\") public class instructordetail { // define the fields // annotate the fields with db column names @id @generatedvalue(strategy=generationtype.identity) @column(name=\"id\") private int id; @column(name=\"youtube_channel\") private string youtubechannel; @column(name=\"hobby\") private string hobby; \t // add @onetoone annotation // mappedby refers to the instructordetail property // in the instructor class // this uses the information from the instructor class in @joincolumn // to define the mapping @onetoone(mappedby=\"instructordetail\", // different cascade types cascade={ cascadetype.detach, cascadetype.merge, cascadetype.persist, cascadetype.refresh}) private instructor instructor; public instructordetail() { }\t\t ... // setters and getters } main app in our test main app we are going to search for an instructordetail object, and we are going to retrieve the related instructor object: package com.hibernate.demo; public class getinstructordetaildemo { \tpublic static void main(string[] args) { session = factory.getcurrentsession(); try { // start a transaction session.begintransaction(); // get the instructor detail object int theid = 2999; instructordetail tempinstructordetail = \t\tsession.get(instructordetail.class, theid); \t\t\t // print the associated instructor system.out.println(\"the associated instructor: \" + \t\t\t\t\ttempinstructordetail.getinstructor()); // commit transaction session.gettransaction().commit(); } catch(exception exc){ exc.printstacktrace(); } finally { // finish session \t\t\tsession.close(); \t\t // remove factory\t \t\t\tfactory.close(); } } } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Java Configuration/Load Properties from File.html",
    "title": "Load Properties from File",
    "body": " index search search back load properties from file contents create the file load the file inject values in order to inject values read from a properties file we do the following: create the file first, we create the file sport.properties foo.email=myeasycoach@luv2code.com foo.team=awesome java coders load the file now, we load the file from our configuration class: package com.springdemo; import org.springframework.context.annotation.bean; import org.springframework.context.annotation.configuration; import org.springframework.context.annotation.propertysource; import org.springframework.context.support.propertysourcesplaceholderconfigurer; @configuration @propertysource(\"classpath:sport.properties\") public class sportconfig { \t \t// define bean for our sad fortune service \t@bean \tpublic fortuneservice sadfortuneservice() { \t\treturn new sadfortuneservice(); \t} \t \t// define bean for our swim coach and inject dependency \t@bean \tpublic coach swimcoach() { \t\tswimcoach myswimcoach = new swimcoach(sadfortuneservice()); \t\t \t\treturn myswimcoach; \t} \t } inject values we inject the values at field level in our bean: package com.springdemo; import org.springframework.beans.factory.annotation.value; public class swimcoach implements coach { \tprivate fortuneservice fortuneservice; \t@value(\"${foo.email}\") \tprivate string email; \t \t@value(\"${foo.team}\") \tprivate string team; ... $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Java Configuration/index.html",
    "title": "Spring Configuration with Java",
    "body": " index search search back spring configuration with java we are now going to use java to configure our application instead of using xml, to do that we follow the next steps: create a java class and annotate as @configuration add component scanning support with @componentscan (optional), which is xml we did as: <?xml version=\"1.0\" encoding=\"utf-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" ....> \t<!-- add entry to enable component scanning --> \t<context:component-scan base-package=\"com.springdemo\" /> </beans> in the main app read the spring java configuration class configuration with java inversion of control load properties from file dependency injection $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Java Configuration/Inversion of Control.html",
    "title": "Inversion of Control",
    "body": " index search search back inversion of control contents create the bean define the bean in the configuration class main method to define a bean, we now use our configuration class: create the bean package com.springdemo; // note there are no special annotations public class swimcoach implements coach { \tprivate fortuneservice fortuneservice; \tpublic swimcoach(fortuneservice thefortuneservice) { \t\tfortuneservice = thefortuneservice; \t} \t \t@override \tpublic string getdailyworkout() { \t\treturn \"swim 1000 meters as a warm up.\"; \t} \t@override \tpublic string getdailyfortune() { \t\treturn fortuneservice.getfortune(); \t} } we also create the sadfortuneservice bean: package com.springdemo; import org.springframework.stereotype.component; @component public class sadfortuneservice implements fortuneservice { \t@override \tpublic string getfortune() { \t\treturn \"today is a sad day :(\"; \t} } define the bean in the configuration class package com.springdemo; import org.springframework.context.annotation.bean; import org.springframework.context.annotation.configuration; @configuration public class sportconfig { \t \t// define bean for our sad fortune service \t@bean \tpublic fortuneservice sadfortuneservice() { \t\treturn new sadfortuneservice(); \t} \t \t// define bean for our swim coach and inject dependency // without springs dependency injection \t@bean \tpublic coach swimcoach() { \t\tswimcoach myswimcoach = new swimcoach(sadfortuneservice()); \t\t \t\treturn myswimcoach; \t} \t } the @bean annotation tells spring that we are creating a bean component manually. we didn't specify a scope so the default scope is singleton. public coach swimcoach(){ specifies that the bean will bean id of \"swimcoach\". the @bean annotation will intercept any requests for \"swimcoach\" bean. since we didn't specify a scope, the bean scope is singleton. so now in our main method: main method package com.luv2code.springdemo; import org.springframework.context.annotation.annotationconfigapplicationcontext; public class javaconfigdemoapp { \tpublic static void main(string[] args) { \t\t// read spring config java class \t\tannotationconfigapplicationcontext context = \t\t\t\tnew annotationconfigapplicationcontext(sportconfig.class); \t\t \t\t// get the bean from spring container by its id \t\tcoach thecoach = context.getbean(\"swimcoach\", coach.class); \t\t \t\t// call a method on the bean \t\tsystem.out.println(thecoach.getdailyworkout()); \t\t\t\t \t\t// call method to get the daily fortune \t\tsystem.out.println(thecoach.getdailyfortune()); \t\t\t\t\t \t\t// close the context \t\tcontext.close(); \t\t \t} } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Java Configuration/Configuration With Java.html",
    "title": "Configuration With Java",
    "body": " index search search back configuration with java contents create configuration class load the configuration class create configuration class package com.springdemo; import org.springframework.context.annotation.componentscan; import org.springframework.context.annotation.configuration; // 1. define configuration class @configuration // 2. add component scanning support @componentscan(\"com.springdemo\") public class sportconfig { \t } load the configuration class package com.springdemo; import org.springframework.context.annotation.annotationconfigapplicationcontext; public class javaconfigdemoapp { \tpublic static void main(string[] args) { \t\t// read spring config java class \t\tannotationconfigapplicationcontext context = \t\t\t\tnew annotationconfigapplicationcontext(sportconfig.class); \t\t \t\t// get the bean from spring container \t\tcoach thecoach = context.getbean(\"tenniscoach\", coach.class); \t\t \t\t// call a method on the bean \t\tsystem.out.println(thecoach.getdailyworkout()); \t\t\t\t \t\t// call method to get the daily fortune \t\tsystem.out.println(thecoach.getdailyfortune()); \t\t\t\t\t \t\t// close the context \t\tcontext.close(); \t\t \t} } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Spring Framework.html",
    "title": "Spring Framework",
    "body": " index search search back spring framework contents spring projects components: core container beans (define entities) core (management of beans) spel: spring expression language (annotations) context (store entities) aop (aspect oriented programming): allows you to create application wide services like messaging, logging, security, etc. and add this functionality to your objects in a declarative fashion. data access layer: establishes the connection with the database jdbc helper classes orm: provides hook to hibernate transactions oxm jms (java message service) for async messages web layer: all web related classes, holds all of the spring mvc framework servlet websocket web portlet test layer: supports tdd: unit integration mock spring projects spring modules built on top of the core spring framework: spring boot spring cloud spring batch etc spring projects $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/Reducer.html",
    "title": "Reducers and Actions",
    "body": " index search search back reducers and actions let's now see an example of a reducer, more concretely the reducer of the user slice we defined previously: // use create slice to define the slice import { createslice } from \"@reduxjs/toolkit\"; // define initial state const initialstatevalue = { name: \"\", age: 0, email: \"\" }; export const userslice = createslice({ // name of slice name: \"user\", // initial state of reducer initialstate: { value: initialstatevalue }, // possible reducers reducers: { login: (state, action) => { state.value = action.payload; }, logout: (state) => { state.value = initialstatevalue; }, }, }); // de-structure actions export const { login, logout } = userslice.actions; // export reducer export default userslice.reducer; we now $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/useReducer.html",
    "title": "useReducer",
    "body": " index search search back usereducer an alternative to usestate. accepts a reducer of type (state, action) => newstate, and returns the current state paired with a dispatch method. usereducer is usually preferable to usestate when you have complex state logic that involves multiple sub-values or when the next state depends on the previous one. usereducer also lets you optimize performance for components that trigger deep updates because you can pass dispatch down instead of callbacks. for example: import react, { usestate, usereducer } from 'react'; // components import modal from './modal'; // data import { data } from '../../../data'; // reducer dispatch function import { reducer } from './reducer'; // initial state for the reducer const defaultstate = { people: [], ismodalopen: false, modalcontent: '', }; const index = () => { // define state variables const [name, setname] = usestate(''); // define reducer: (dispatch fuction, initial state) const [state, dispatch] = usereducer(reducer, defaultstate); const handlesubmit = (e) => { // avoid the re-rendering caused by the submit event e.preventdefault(); if (name) { const newitem = { id: new date().gettime().tostring(), name }; // call reducer to update state dispatch({ type: 'add_item', payload: newitem }); setname(''); } else { // call reducer to update state dispatch({ type: 'no_value' }); } }; const closemodal = () => { // call reducer to update state dispatch({ type: 'close_modal' }); }; return ( <> {/*render modal component conditionally */} {state.ismodalopen && ( <modal closemodal={closemodal} modalcontent={state.modalcontent} /> )} {/* form to add a new person to the reducer state variable */} <form onsubmit={handlesubmit} classname='form'> <div> <input type='text' value={name} onchange={(e) => setname(e.target.value)} /> </div> <button type='submit'>add </button> </form> {/* show the people stored in the reducer state variable */} {state.people.map((person) => { return ( <div key={person.id} classname='item'> <h4>{person.name}</h4> <button onclick={() => // call reducer to update state dispatch({ type: 'remove_item', payload: person.id }) } > remove </button> </div> ); })} </> ); }; export default index; now, let's see the reducer function: /* reducer function */ export const reducer = (state, action) => { // define logic for each type of action if (action.type === 'add_item') { // add new person (action.payload) to existing people array (state.people) const newpeople = [...state.people, action.payload]; return { // always copy the value from the previous state ...state, // update the people array people: newpeople, ismodalopen: true, modalcontent: 'item added', }; } if (action.type === 'no_value') { // always copy the value from the previous state return { ...state, ismodalopen: true, modalcontent: 'please enter value' }; } if (action.type === 'close_modal') { return { ...state, ismodalopen: false }; } if (action.type === 'remove_item') { // filter people array, by removing the person const newpeople = state.people.filter( (person) => person.id !== action.payload ); // copy the previous state (...state) and update the people the array (newpeople) return { ...state, people: newpeople }; } throw new error('no matching action type'); }; $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/Event Basics.html",
    "title": "Event Basics",
    "body": " index search search back event basics list of all possible events to define an event we have to specify: attribute: like onclick, onmousehover, etc. eventhandler: the function to apply. this can be specified as a reference or as an in-line function. next, we present an example: import react from 'react' const book = ({ title, author }) => { const clickhandler = () => {alert('hello!!')} return ( <article classname='book'> <!-- here we have the eventhandler as an in-line function --> <h1 onclick={() => alert('hello!!')}>{title}</h1> <h4>{author}</h4> <!-- here we have the eventhandler as a reference --> <button type=\"button\" onclick={clickhandler}>this is a button</button> </article> ); }; export default book to pass an argument to the eventhandler we have to use a lambda function, else when we load the application will invoke the function clickhandler(author) import react from 'react' const book = ({ title, author }) => { const clickhandler = (author) => {alert(author)} return ( <article classname='book'> <h1 onclick={() => alert('hello!!')}>{title}</h1> <h4>{author}</h4> <!-- wrap function with an in-line function --> <button type=\"button\" onclick={() => clickhandler(author)}>this is a button</button> </article> ); }; export default book we can also access the event object from within the function, like: import react from 'react' const book = ({ title, author }) => { // you can always access the event object from an eventhandler const clickhandler = (author, e) => {console.log(e)} return ( <article classname='book'> <h1 onclick={() => alert('hello!!')}>{title}</h1> <h4>{author}</h4> <button type=\"button\" onclick={() => clickhandler(author)}>this is a button</button> </article> ); }; export default book $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/Controlled Inputs.html",
    "title": "Controlled Inputs",
    "body": " index search search back controlled inputs contents multiple inputs let's see how to handle inputs in a form using react: import react, { usestate } from 'react'; const controlledinputs = () => { const [firstname, setfirstname] = usestate(''); const [people, setpeople] = usestate([]); const handlesubmit = (e) => { // avoid the default behaviour in submit which re-renders the page e.preventdefault(); // our own logic for the submit action if (firstname) { // create new person object const person = { id: new date().gettime().tostring(), firstname }; // update our state (remember you need to spred the people state variable we have before, else the you would // override the people state variable and it would be assigned to only the person object) setpeople((people) => { return [...people, person]; }); // set to empty, so the value of the input is the empty string setfirstname(''); } else { // no values to create new person console.log('empty values'); } }; return ( <> <article> {/*event handler for the submit event*/} <form onsubmit={handlesubmit}> <div > <label htmlfor='firstname'>name : </label> <input type='text' id='firstname' name='firstname' {/*set the value of the input, it updates every time we change the input*/} value={firstname} {/*event handler for the change event: use a lambda function to pass the event e and get the value in the input*/} onchange={(e) => setfirstname(e.target.value)} /> </div> <button type='submit'>add person</button> </form> {/*show each person in the people array */} {people.map((person, index) => { const { id, firstname } = person; return ( <div classname='item' key={id}> <h4>{firstname}</h4> </div> ); })} </article> </> ); }; export default controlledinputs; multiple inputs how can we define an event handler for the onchange event that is generic, instead of defining one for each input? to showcase this scenario, we will use the same code as before, but with two new inputs. all of the inputs have the same onchange event handler. import react, { usestate } from 'react'; const controlledinputs = () => { // create a new state variable person, that holds the properties of the person we are currently creating const [person, setperson] = usestate({ firstname: '', email: '', age: '' }); // array of people we have already created const [people, setpeople] = usestate([]); // generic event handler const handlechange = (e) => { // obtain the name of the input/state variable const name = e.target.name; // obtain the new value for the input const value = e.target.value; // update the value of the property for the current person setperson({ ...person, [name]: value }); }; const handlesubmit = (e) => { e.preventdefault(); if (person.firstname && person.email && person.age) { const newperson = { ...person, id: new date().gettime().tostring() }; setpeople([...people, newperson]); setperson({ firstname: '', email: '', age: '' }); } }; return ( <> <article classname='form'> <form> <div classname='form-control'> <label htmlfor='firstname'>name : </label> <input type='text' id='firstname' name='firstname' // access the firstname of the person object value={person.firstname} // generic event handler onchange={handlechange} /> </div> <div classname='form-control'> <label htmlfor='email'>email : </label> <input type='email' id='email' name='email' // access the email of the person object value={person.email} // generic event handler onchange={handlechange} /> </div> <div classname='form-control'> <label htmlfor='age'>age : </label> <input type='number' id='age' name='age' // access the age of the person object value={person.age} // generic event handler onchange={handlechange} /> </div> <button type='submit' classname='btn' onclick={handlesubmit}> add person </button> </form> </article> <article> {people.map((person) => { const { id, firstname, email, age } = person; return ( <div key={id} classname='item'> <h4>{firstname}</h4> <p>{email}</p> <p>{age}</p> </div> ); })} </article> </> ); }; export default controlledinputs; $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/Get State.html",
    "title": "Get State",
    "body": " index search search back get state in order to access the state saved in our state, we do the following: import react from \"react\"; import { useselector } from \"react-redux\"; function profile() { // use the useselector hook const user = useselector((state) => state.user.value); return ( <div style={{ color: themecolor }}> <h1> profile page</h1> <!--obtain the user state--> <p> name: {user.name} </p> <p> age: {user.age}</p> <p> email: {user.email}</p> </div> ); } export default profile; $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/npm.html",
    "title": "npm",
    "body": " index search search back npm it is the node package manager: create package.json (manifest) file, with the list of dependencies $ npm init install package locally and add it to package.json, under the keyword \"dependencies\" $ npm install <package name> install package globally (requires sudo) $ npm install -g <package name> install package only for development $ npm install <package name> --save-dev the packages installed with be saved under the file node_modules to install all the dependencies listed in package.json, just run: $ npm install where the package.json is. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/Prop Drilling.html",
    "title": "Prop Drilling",
    "body": " index search search back prop drilling prop drilling refers to the scenario where we have to pass props to anidated components recursively. next up, we show and example import react, { usestate } from 'react'; // data import { data } from '../../../data'; // outer component const propdrilling = () => { // state passed as a prop const [people, setpeople] = usestate(data); // event handler passed as a prop const removeperson = (id) => { setpeople((people) => { return people.filter((person) => person.id !== id); }); }; return ( <section> <h3>prop drilling</h3> {/* pass props to the list elements */} <list people={people} removeperson={removeperson} /> </section> ); }; // middle component const list = ({ people, removeperson }) => { return ( <> {people.map((person) => { {/* pass props to the singleperson elements */} return ( <singleperson key={person.id} {...person} removeperson={removeperson} /> ); })} </> ); }; // inner component const singleperson = ({ id, name, removeperson }) => { return ( <div classname='item'> <h4>{name}</h4> <button onclick={() => removeperson(id)}>remove</button> </div> ); }; export default propdrilling; in these cases we can use the context api $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/Custom Hooks.html",
    "title": "Custom Hooks",
    "body": " index search search back custom hooks customs hooks allow us to avoid duplicating code that uses hooks and essentially in different places of your code. for example, the fetching function is very common, so we create a usefetch hook. when you define a custom hook, that is, if you define a function outside a component that uses hooks, you will have to name it use<functionname>, else you will get an error. import react, { usestate, useeffect } from 'react' // import custom hook import { usefetch } from './2-usefetch' const url = 'https://course-api.com/javascript-store-products' const example = () => { // values returned by usefetch const { loading, products } = usefetch(url) return ( <div> <h2>{loading ? 'loading...' : 'data'}</h2> </div> ) } export default example import { usestate, useeffect, usecallback } from 'react'; export const usefetch = (url) => { // state within the hook const [loading, setloading] = usestate(true); const [products, setproducts] = usestate([]); // functionality of the hook const getproducts = usecallback(async () => { const response = await fetch(url); const products = await response.json(); setproducts(products); setloading(false); }, [url]); // run whenever the url or the getproducts function changes useeffect(() => { getproducts(); }, [url, getproducts]); // values returned by the custom hook return { loading, products }; }; note we are using the hook usecallback (refer to performance optimization), we do this because we are specifying getproducts as a dependency for useeffect. however getproducts is created every time the state changes. so when we call useeffect, we change the state, and therefore create the function getproducts, which triggers useeffect, thus the state changes, and we create getproducts, and so on and so forth. to avoid this, we use usecallback, which will create the function whenever any of the dependencies in the list change. so this means, now getproducts is only created when the url changes. this allows us to avoid the infinite loop we ran into before. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/Performance Optimization.html",
    "title": "Performance Optimization",
    "body": " index search search back performance optimization contents react memo usecallback usememo even though react is fast by default (you do not need to use it), we can use different optimization techniques (mind, they do add their own cost): react.memo react.memo stores a component, and only re-renders if the props of the component change (it memoizes the component). in the next example, that means that we only re-render biglist if products change, thus, we do not re-render any singleproduct component unless products change. import react, { usestate, usecallback, usememo } from 'react' // custom hook import { usefetch } from 'usefetch' const url = 'https://course-api.com/javascript-store-products' const index = () => { const { products } = usefetch(url) const [count, setcount] = usestate(0) return ( <> <h1>count : {count}</h1> <button classname='btn' onclick={() => setcount(count + 1)}> click me </button> <biglist products={products} /> </> ) } // each time a prop or the state changes, the component re-renders, so all // the elements of the list are processed again. // however if we use react.memo we only re-render the component if products change const biglist = react.memo(({ products }) => { return ( <section classname='products'> {products.map((product) => { return ( <singleproduct key={product.id} {...product} ></singleproduct> ) })} </section> ) }) const singleproduct = ({ fields }) => { let { name, price } = fields price = price / 100 const image = fields.image[0].url return ( <article classname='product'> <img src={image} alt={name} /> <h4>{name}</h4> <p>${price}</p> </article> ) } export default index usecallback what happens if we pass a function to biglist, well if the state changes (whichever variable of the state) then the function is created again, and so the function is different. which means the props of biglist list changes, and causes react.memo to re-render the entire component. that is why we use usecallback. usecallback allows us to define when to create a function, by specifying the dependencies like we did with useeffect: if the dependency is []: then only create in the first render if there are variables in the []: create whenever those variables change if there is nothing: create always. refer to customs hooks for an use case of usecallback inside the custom hook usefetch. import react, { usestate, usecallback, usememo } from 'react' // custom hook import { usefetch } from 'usefetch' const url = 'https://course-api.com/javascript-store-products' const index = () => { const { products } = usefetch(url); const [count, setcount] = usestate(0); const [cart, setcart] = usestate(0); // we only create this function when we update the cart value // that is we memoize the function const addtocart = usecallback(() => { setcart(cart + 1) }, [cart]) return ( <> <h1>count : {count}</h1> <button classname='btn' onclick={() => setcount(count + 1)}> click me </button> <biglist products={products} addtocart={addtocart}/> </> ) } // each time a prop or the state changes, the component re-renders. because now // addtocart is define with usecallback, the re-render is not triggered const biglist = react.memo(({ products, addtocart }) => { return ( <section classname='products'> {products.map((product) => { return ( <singleproduct key={product.id} {...product} addtocart={addtocart} ></singleproduct> ) })} </section> ) }) const singleproduct = ({ fields, addtocart }) => { let { name, price } = fields price = price / 100 const image = fields.image[0].url return ( <article classname='product'> <img src={image} alt={name} /> <h4>{name}</h4> <p>${price}</p> <button onclick={addtocart}>add to cart</button> </article> ) } export default index; usememo note that this hook deals with values (which is the traditional functionality of the idea of memoizing), whilst react.memo look for changes in the props. in the next example we create a function that returns a value, and we memoize the function, so it only computes the value whenever the products change (the argument of the function), else it returns the value stored before: import react, { usestate, usecallback, usememo } from 'react' // custom hook import { usefetch } from 'usefetch' const url = 'https://course-api.com/javascript-store-products' // define the function we are going to memoize const calculatemostexpensive = (data) => { return ( data.reduce((total, item) => { const price = item.fields.price if (price >= total) { total = price } return total }, 0) / 100 ) } const index = () => { const { products } = usefetch(url); const [count, setcount] = usestate(0); const [cart, setcart] = usestate(0); const addtocart = usecallback(() => { setcart(cart + 1) }, [cart]) // memoize the function with usememo const mostexpensive = usememo(() => calculatemostexpensive(products), [ products, ]) return ( <> <h1>count : {count}</h1> <button classname='btn' onclick={() => setcount(count + 1)}> click me </button> <!-- show most expensive product --> <h1>most expensive : ${mostexpensive}</h1> <biglist products={products} addtocart={addtocart}/> </> ) } const biglist = react.memo(({ products, addtocart }) => { return ( <section classname='products'> {products.map((product) => { return ( <singleproduct key={product.id} {...product} addtocart={addtocart} ></singleproduct> ) })} </section> ) }) const singleproduct = ({ fields, addtocart }) => { let { name, price } = fields price = price / 100 const image = fields.image[0].url return ( <article classname='product'> <img src={image} alt={name} /> <h4>{name}</h4> <p>${price}</p> <button onclick={addtocart}>add to cart</button> </article> ) } export default index; $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/Basics.html",
    "title": "Basics",
    "body": " index search search back basics contents handle an action install redux first steps redux is a complex state management tool, with a single store (javascrip object) as a cds (central data storage). components store: object that holds the state reducers: events handler that manages the state and returns the new updated state. the reducers get the arguments and return the state modified. actions: describe the event handler by the reducer and has two properties: type: is the identifier of the action payload: holds the data dispatch: is used to send actions to update the data so redux is composed by: handle an action the process of handling an action is the following: we create an action object and dispatch it: the store forwards the action to the reducer: the reducer updates the state and returns it the store notifies the ui components of the change of the state install redux $ npm install redux react-redux first steps inside src create a store folder inside the store folder create an index.js that holds all of the react states in this file $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/Children in Props.html",
    "title": "Children in Props",
    "body": " index search search back children in props you can nest content inside your component. if we have the following: import react from 'react'; import reactdom from 'react-dom'; // css import './index.css'; import book from './book' const singlebook = { title: 'book title', author: 'book author' } reactdom.render( <book {...singlebook}> <p> i am nested!</p> </book>, document.getelementbyid('root') ); you can access the nested object from your component: import react from 'react' // de-structure the children prop const book = ({ title, author, children }) => { return ( <article classname='book'> <h1>{title}</h1> <h4>{author}</h4> {children} </article> ); }; export default book $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/PropTypes.html",
    "title": "PropTypes",
    "body": " index search search back proptypes contents default props proptypes allows us to validate our props. import react from 'react' import product from './product' import { usefetch } from './usefetch' const url = 'https://course-api.com/react-prop-types-example' const index = () => { const { products } = usefetch(url) return ( <div> <h2>products</h2> <section classname='products'> {products.map((product) => { // pass the props return <product key={product.id} {...product} /> })} </section> </div> ) } export default index in this product component we show how to use proptypes to parametrize the props, and how to use conditional render to avoid getting an error when some of the props are missing. import react from 'react'; import proptypes from 'prop-types'; import defaultimage from './assets/default-image.jpeg'; const product = ({ image, name, price }) => { const url = image && image.url; return ( <article classname='product'> {/*use conditional rendering in case the data does not exist */} <img src={url || defaultimage} alt={name || 'default name'} /> <h4>{name}</h4> <p>${price || 3.99}</p> </article> ); }; // define the proptypes for the object product.proptypes = { image: proptypes.object.isrequired, name: proptypes.string.isrequired, price: proptypes.number.isrequired, }; export default product; default props in this other product component, we show how to use defaultprops instead of conditional rendering. import react from 'react'; import proptypes from 'prop-types'; import defaultimage from './assets/default-image.jpeg'; const product = ({ image, name, price }) => { return ( <article classname='product'> {/*use conditional rendering in case the data does not exist */} <img src={image.url} alt={name} /> <h4>{name}</h4> <p>${price}</p> </article> ); }; // define the proptypes for the object product.proptypes = { image: proptypes.object.isrequired, name: proptypes.string.isrequired, price: proptypes.number.isrequired, }; product.defaultprops = { name: 'default name', price: 3.99, image: defaultimage, }; export default product; $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/useState.html",
    "title": "useState",
    "body": " index search search back usestate contents error asynchronous functions error in the next piece of code we show how, if we change the value of a variable in react, it does not change in our web app because it is not re-rendered: import react from 'react'; const errorexample = () => { let title = 'random title'; const handleclick = () => { title = 'hello people'; console.log(title); }; return ( <react.fragment> <h2>{title}</h2> <button type='button' onclick={handleclick}> change title </button> </react.fragment> ); }; export default errorexample; that is why we will need to use the hook usestate, so we change handle state changes. import react, { usestate } from 'react'; const usestatebasics = () => { const [text, settext] = usestate('random title'); const handleclick = () => { if (text === 'random title') { settext('hello world'); } else { settext('random title'); } }; return ( <react.fragment> <h1>{text}</h1> <button type='button' onclick={handleclick}> change title </button> </react.fragment> ); }; export default usestatebasics; when we invoke usestate we have to pass as an argument the initial value of the state variable. usestate is a function that returns an array: the first element: the state variable the second element: the handler that controls the value of the state value when using usestate with objects, whenever you update one property of the object, you have to pass the object to the handler (with the spread operator), and then override the property you want to update: import react, { usestate } from 'react'; const usestateobject = () => { // object const [person, setperson] = usestate({ name: 'peter', age: 24, message: 'random message', }); const changemessage = () => { // pass the person object with the spread operator // and override the message property setperson({ ...person, message: 'hello world' }); }; return ( <> <h3>{person.name}</h3> <h3>{person.age}</h3> <h4>{person.message}</h4> <button classname='btn' onclick={changemessage}> change message </button> </> ); }; export default usestateobject; asynchronous functions if we want to update a value asynchronally, and fetch the value of the state variable when the change happens, and not when the function is defined, then: import react, { usestate } from 'react'; const usestatecounter = () => { const [value, setvalue] = usestate(0); const reset = () => { setvalue(0); }; const complexincrease = () => { settimeout(() => { // value is the value of the state variable when the timeout is defined // if you call it multiple times consecutively you get the same value, because they all get value = 0 // setvalue(value + 1); // prevstate is the value of the state variable when the timeout finished // if you call it multiple times consecutively you get different values, because value has already been updated // by another settimeout. // if you call it multiple times setvalue((prevstate) => { return prevstate + 1; }); }, 2000); }; return ( <> <section style={{ margin: '4rem 0' }}> <h2>more complex counter</h2> <h1>{value}</h1> <button classname='btn' onclick={complexincrease}> increase later </button> </section> </> ); }; export default usestatecounter; $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/Dispatch.html",
    "title": "Dispatch",
    "body": " index search search back dispatch in order to dispatch actions in our reducers we do as follows: import react from \"react\"; // get dispatch hook import { usedispatch } from \"react-redux\"; // get actions import { login, logout } from \"../features/user\"; function login() { // initialize dispatch hook const dispatch = usedispatch(); return ( <div> <button onclick={() => { // dispatch login action dispatch(login({ name: \"pedro\", age: 20, email: \"pedro@gmail.com\" })); }} > login </button> <button onclick={() => { // dispatch logout action dispatch(logout()); }} > logout </button> </div> ); } export default login; $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/index.html",
    "title": "React",
    "body": " index search search back react basic react npm create-react-app babel file structure start in indexjs jsx rules css in jsx props children in props list of components event basics advanced react properties hooks usestate useeffect conditional rendering controlled inputs useref usereducer prop drilling context api custom hooks proptypes react router performance optimization redux basics index reducers and actions get state dispatch $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/List of components.html",
    "title": "List of Components",
    "body": " index search search back list of components react has one restriction for list of objects, and that is: they have to have a key. so, for example: import react from 'react'; import reactdom from 'react-dom'; // css import './index.css'; import book from './book' // data to create book object const books = [ { id: '1', title: 'book title', author: 'book author' }, { id: '2', title: 'book title', author: 'book author' }, ] const booklist = books.map((book) => { // de-structure book object return <book key={book.id} {...book} />; }) reactdom.render( <div> booklist </div>, document.getelementbyid('root') ); $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/React Router.html",
    "title": "React Router",
    "body": " index search search back react router contents links in react routing behaves differently than in traditional html applications: it does not fetch the html page from the server, it is done in the client side. there is no re-rendering even though we change the url. here we have an example: import react from 'react'; // react router import { browserrouter as router, route, switch } from 'react-router-dom'; // pages import home from './home'; import about from './about'; import people from './people'; import error from './error'; import person from './person'; // navbar import navbar from './navbar'; const reactroutersetup = () => { return ( <router> <navbar /> <!-- with the switch component only the first one that matches is displayed --> <switch> <!-- match the path exactly, else this will be rendered always along the other components --> <route exact path='/'> <!-- component to display --> <home /> </route> <!-- match the path --> <route path='/about'> <about /> </route> <!-- match the path --> <route path='/people'> <people /> </route> <!-- match the path and pass id as a parameter --> <!-- specify children property because it will be a list of components --> <route path='/person/:id' children={<person />}></route> <!-- match any path (this is only displayed when the other paths do not match if we use the switch component)--> <route path='*'> <error /> </route> </switch> </router> ); }; export default reactroutersetup; links how do we navigate through our application, well by using links. so, for example, in the navbar: import react from 'react'; import { link } from 'react-router-dom'; const navbar = () => { return ( <nav> <ul> <li> <!-- specify the path --> <link to='/'>home</link> </li> <li> <!-- specify the path --> <link to='/about'>about</link> </li> <li> <!-- specify the path --> <link to='/people'>people</link> </li> </ul> </nav> ); }; export default navbar; to pass a parameter to the link we can do the following: import react, { usestate } from 'react'; import { data } from '../../../data'; import { link } from 'react-router-dom'; const people = () => { // list of people const [people, setpeople] = usestate(data); return ( <div> <h1>people page</h1> {people.map((person) => { return ( <div key={person.id} classname='item'> <h4>{person.name}</h4> <!-- specify the path and pass the id of the current person as a parameter --> <link to={`/person/${person.id}`}>learn more</link> </div> ); })} </div> ); }; export default people; now in the person component, we can fetch the parameter: import react, { usestate, useeffect } from 'react'; import { data } from '../../../data'; import { link, useparams } from 'react-router-dom'; const person = () => { // state const [name, setname] = usestate('default name'); // useparams hook to fetch the parameter // the name of the parameter (id), is specified in the \"route\" component // in our case the path to person was: /person/:id const { id } = useparams(); useeffect(() => { const newperson = data.find((person) => person.id === parseint(id)); setname(newperson.name); }, []); return ( <div> <h1>{name}</h1> <!-- go to the previous page of the list of people --> <link to='/people' classname='btn'> back to people </link> </div> ); }; export default person; $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/JSX Rules.html",
    "title": "JSX Rules",
    "body": " index search search back jsx rules always return something always return a single element or div, section, article or react.fragment (does not create a div) enclosing the element use camelcase for html attribute use classname instead of class close every element $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/File Structure.html",
    "title": "File Structure",
    "body": " index search search back file structure node_modules: folder that contains all of the dependencies package.json: is the manifest file for the project scripts start: runs the development server build: creates a production version for the project inside a folder called build, where the optimized files resulting of the build are stored. the rest of the files created by create-react-app are mostly useless: app.js app.css app.test.js logo.svg serviceworker.js setuptests.js also all of the contents of index.js can be removed. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/CSS in JSX.html",
    "title": "CSS in JSX",
    "body": " index search search back css in jsx we can define the style inside jsx, for that we use the prop style. the first curly braces takes us back to javascript, and the second are to specify the creation of an object. also note that we do not write font-size but we use the react convention of writing fontsize const author = () => ( <h4 style={{fontsize: '1px'}}> test </h4> ); this level has higher preference (overrides) than the css imported from a css file. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/create-react-app.html",
    "title": "create-react-app",
    "body": " index search search back create-react-app you do not need create-react-app to create a react app, but it makes it way easier: npx create-react-app <app-name> cd <app-name> npm start $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/useRef.html",
    "title": "useRef",
    "body": " index search search back useref useref returns a mutable ref object whose .current property is initialized to the passed argument. some properties: preserves the value of the object does not trigger re-render assigned to dom nodes/elements import react, { useeffect, useref } from 'react'; const userefbasics = () => { // create the container const refcontainer = useref(null); const handlesubmit = (e) => { e.preventdefault(); // print the value inside the input console.log(refcontainer.current.value); }; useeffect(() => { // focus on the input element whenever we render the application refcontainer.current.focus(); }); return ( <> <form classname='form' onsubmit={handlesubmit}> <div> {/*the refcontainer points to the input element*/} <input type='text' ref={refcontainer} /> </div> <button type='submit'>submit</button> </form> </> ); }; export default userefbasics; $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/Index.html",
    "title": "Index file",
    "body": " index search search back index file in the following piece of code we create our store object, where we are going to save the state of our application. as you may note, in this store there are three slices defined. that is because we differentiate three different states (slices). so our store is defined as: { user: {...} theme: {...} } import { configurestore } from \"@reduxjs/toolkit\"; // different slices import userslice from \"./features/userslice.js\"; import themeslice from \"./features/themeslice.js\"; // create store const store = configurestore({ reducer: { // in each case obtain the reducer user: userslice.reducer, theme: themeslice.reducer, }, }); export default store; now, we have to wrap our application with our store: import react from \"react\"; import reactdom from \"react-dom\"; import app from \"./app\"; // import our store as a provider import { provider } from \"react-redux\"; import store from \"./store\"; reactdom.render( <react.strictmode> <provider store={store}> <app /> </provider> </react.strictmode>, document.getelementbyid(\"root\") ); $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/useEffect.html",
    "title": "useEffect",
    "body": " index search search back useeffect contents dependencies clean up function fetch data this hook is used for any work needed to be made outside of the component: fetch data, changing the document title, signing up for a subscription, setting up an event listener. runs after every re-render cleanup function second parameter import react, { usestate, useeffect } from 'react'; const useeffectbasics = () => { // callback called whenever the component is rendered useeffect(() => { document.title = `new messages(${value})`; }); return ( <> <h1>{value}</h1> <button classname='btn'}> click me </button> </> ); }; export default useeffectbasics; dependencies the useeffect definition allows you to pass an array of dependencies: if it is specified as []: useeffect will only be triggered in the first render if it is an array of state variables: it will be triggered every time the state variable is updated. import react, { usestate, useeffect } from 'react'; const useeffectbasics = () => { const [value, setvalue] = usestate(0); // only trigger on first render // useeffect(() => { // document.title = `new messages(${value})`; // }, []); // call whenever value is updated useeffect(() => { document.title = `new messages(${value})`; }, [value]); return ( <> <h1>{value}</h1> <button classname='btn'}> click me </button> </> ); }; export default useeffectbasics; clean up function useeffect lets us define a function that is invoked once we exit the function: import react, { usestate, useeffect } from 'react'; const useeffectcleanup = () => { const [size, setsize] = usestate(window.innerwidth); const checksize = () => { setsize(window.innerwidth); }; useeffect(() => { console.log('useeffect'); window.addeventlistener('resize', checksize); // clean up function return () => { console.log('cleanup'); window.removeeventlistener('resize', checksize); }; }, []); console.log('render'); return ( <> <h1>window</h1> <h2>{size} px</h2> </> ); }; export default useeffectcleanup; fetch data up next we will show how to get data using useeffect. note, if we do not specify the restriction of only triggering on the first render: useeffect calls getusers getusers updates the state, and so the component re-renders because there is a re-render, useeffect is called again thus, we end in an infinite loop import react, { usestate, useeffect } from 'react'; const url = 'https://api.github.com/users'; const useeffectfetchdata = () => { const [users, setusers] = usestate([]); const getusers = async () => { const response = await fetch(url); const users = await response.json(); setusers(users); }; useeffect(() => { getusers(); // specify [] so we only run useeffect on the first render. }, []); return ( <> <h3>github users</h3> <ul classname='users'> {users.map((user) => { const { id, login, avatar_url, html_url } = user; return ( <li key={id}> <img src={avatar_url} alt={login} /> <div> <h4>{login}</h4> <a href={html_url}>profile</a> </div> </li> ); })} </ul> </> ); }; export default useeffectfetchdata; $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/Conditional Rendering.html",
    "title": "Conditional Rendering",
    "body": " index search search back conditional rendering contents short circuit evlauation ternary operators in the following example we show how we can have react display different elements conditionally: import react, { usestate, useeffect } from 'react'; const url = 'https://api.github.com/users/quincylarson'; const multiplereturns = () => { const [isloading, setisloading] = usestate(true); const [iserror, setiserror] = usestate(false); const [user, setuser] = usestate('default user'); // fetch data useeffect(() => { fetch(url) .then((resp) => { if (resp.status >= 200 && resp.status <= 299) { return resp.json(); } else { // update the control state variables setisloading(false); setiserror(true); throw new error(resp.statustext); } }) .then((user) => { const { login } = user; setuser(login); // update the control state variables setisloading(false); }) .catch((error) => console.log(error)); }, []); // different display depending on the state of the get if (isloading) { return ( <div> <h1>loading...</h1> </div> ); } if (iserror) { return ( <div> <h1>error....</h1> </div> ); } return ( <div> <h1>{user}</h1> </div> ); }; export default multiplereturns; short circuit evlauation now, let's see an example of short circuit evaluation in action: import react, { usestate } from 'react'; const shortcircuit = () => { const [text, settext] = usestate(''); const [iserror, setiserror] = usestate(false); // if text is falsy, then return 'hello world' // else return text // const firstvalue = text || 'hello world'; // if text is true, then return 'hello world' // else return text // const secondvalue = text && 'hello world'; return ( <> {/*if text is false, return h1 with 'john doe value'*/} <h1>{text || 'john doe'}</h1> {/*if text is true, return h1 with 'john doe value'*/} {text && <h1>'john doe'</h1>} </> ); }; export default shortcircuit; ternary operators we can also use ternary operators to render conditionally in react. import react, { usestate } from 'react'; const shortcircuit = () => { const [iserror, setiserror] = usestate(false); return ( <> <button classname='btn' onclick={() => setiserror(!iserror)}> toggle error </button> {/*check the value of iserror, if is error is true, return the first value after the ? else return the second value*/} {iserror ? ( <p>there is an error...</p> ) : ( <div> <h2>there is no error</h2> </div> )} </> ); }; export default shortcircuit; $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/Context API.html",
    "title": "Context API",
    "body": " index search search back context api context api and usecontext allows us to resolve the issue of the prop drilling. the context has two components: the provider: works as a distributer the consumer we use them as follows: import react, { usestate, usecontext } from 'react'; import { data } from '../../../data'; // create context object const personcontext = react.createcontext(); const contextapi = () => { // state saved in the context const [people, setpeople] = usestate(data); // event handler saved in the context const removeperson = (id) => { setpeople((people) => { return people.filter((person) => person.id !== id); }); }; return ( {/*wrap the components in the context provider, so all the nested components have access to the variables defined in the context object*/} <personcontext.provider value={{ removeperson, people }}> <h3>context api / usecontext</h3> <list /> </personcontext.provider> ); }; const list = () => { // obtain data from the context with the usecontext hook const maindata = usecontext(personcontext); return ( <> {maindata.people.map((person) => { return <singleperson key={person.id} {...person} />; })} </> ); }; const singleperson = ({ id, name }) => { // obtain data from the context with the usecontext hook const { removeperson } = usecontext(personcontext); return ( <div classname='item'> <h4>{name}</h4> <button onclick={() => removeperson(id)}>remove</button> </div> ); }; export default contextapi; $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/Start in indexjs.html",
    "title": "Start in index.js",
    "body": " index search search back start in index.js keep in mind, index.js is the entry point: first of all refer to file structure, and then basically remove everything from index.js, and replace it for: import react from 'react'; import reactdom from 'react-dom'; // css import './index.css'; we use the reactdom module to make use of the react dom api, which let's us render components, etc. next we call reactdom.render() to output our html: import react from 'react'; import reactdom from 'react-dom'; // css import './index.css'; function component() { return ( <h4> hi! </h4> ); } reactdom.render( <component/>, document.getelementbyid(\"root\") ) note the function must start with a capital letter the tag that encloses the component must be closed, so either: <component/> or <component></ component> we use document.getelementbyid(\"root\"), this tells react where to place the component inside the html $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/Babel.html",
    "title": "Babel",
    "body": " index search search back babel babel is a javascript compiler that converts es7, es6 to e5 so it can run smoothly in older browsers. this way we can use new features of es7 and es6 while maintaining compatibility. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/Props.html",
    "title": "Props",
    "body": " index search search back props contents spread operator in react to define parameters in our components, we do as follows: import react from 'react' // this are the props const book = (props) => { return ( <article classname='book'> <img src={props.img} alt='' /> <h1>{props.title}</h1> <h4>{props.author}</h4> </article> ); }; export default book another way (more readable), is to spread the object: import react from 'react' // this are the props const book = ({ title, author }) => { return ( <article classname='book'> <h1>{title}</h1> <h4>{author}</h4> </article> ); }; export default book now, to pass these props we do: import react from 'react'; import reactdom from 'react-dom'; // css import './index.css'; import book from './book' reactdom.render( <book title='book title' author='book author'/>, document.getelementbyid('root') ); spread operator let's define an object singlebook that contains all of the book's properties and pass it to the book component: import react from 'react'; import reactdom from 'react-dom'; // css import './index.css'; import book from './book' const singlebook = { title: 'book title', author: 'book author' } reactdom.render( // use the spread operator <book {...singlebook}/>, document.getelementbyid('root') ); $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/Properties Hooks.html",
    "title": "Properties of Hooks",
    "body": " index search search back properties of hooks all the hooks have the following properties: they start with the word use the component where they are created must be named in uppercase they cannot be invoked inside a function/component body. you cannot call hooks conditionally $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/index.html",
    "title": "Web Development",
    "body": " index search search back web development front react back node.js django spring technologies docker graphql db mongodb $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/MongoDB/commands.html",
    "title": "MongoDB Commands",
    "body": " index search search back mongodb commands to log into mongodb with the created user and database: $ mongo -u <your username> -p <your password> \\\\ --authenticationdatabase <your database name> or $ mongo -u <your username> \\\\ --authenticationdatabase <your database name> to connect to the database use the following uri: mongodb://yourusername:yourpasswordhere@127.0.0.1:27017/your-database-name $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/MongoDB/index.html",
    "title": "MongoDB",
    "body": " index search search back mongodb mongodb commands $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Django/django_notes.html",
    "title": "Django Notes",
    "body": " index search search back django notes contents apps models admin urls serializers views actions in this section we lay out some concepts about the django framework. apps models the models can be thought of as objects, in the sense of oop, that have certain attributes. this objects are then mapped by django to the database of choice. to define new models, or modify existing model (e.g. the user model) you need to modify the models.py file in the root folder of every app that is created. alternatively, you can centralize all of your models on the core app. an example of a simple model is the following tag model: class tag(models.model): \"\"\"tag to be used for a book\"\"\" # define the attributes of the table name = models.charfield(max_length=255) # define the relation between the tag and the user user = models.foreignkey( settings.auth_user_model, on_delete=models.cascade, ) # define the string representation of the tag def __str__(self): return self.name once the model is define, it needs to be registered on the admin.py file: admin.site.register(models.tag) specifically when modifying existing models, you will need to extend the classes defined by django (e.g. abstractbaseuser, useradmin). for example: class user(abstractbaseuser, permissionsmixin): \"\"\"custom user model that suppors using email instead of username\"\"\" email = models.emailfield(max_length=255, unique=true) name = models.charfield(max_length=255) is_active = models.booleanfield(default=true) is_staff = models.booleanfield(default=false) objects = usermanager() which has to be registered as follows: admin.site.register(models.user, useradmin) where useradmin is a class define in the admin.py file, that defines the custom user model: class useradmin(baseuseradmin): ordering = ['id'] list_display = ['email', 'name'] # user edit page fields fieldsets = ( (none, {'fields': ('email', 'password')}), (_('personal info'), {'fields': ('name',)}), ( _('permissions'), {'fields': ('is_active', 'is_staff', 'is_superuser')} ), (_('important dates'), {'fields': ('last_login',)}) ) # user create page fields add_fieldsets = ( (none, { 'classes': ('wide',), 'fields': ('email', 'password', 'password2') }), admin this is the feature that allows you to manage your models, let it be create them, modify them or delete them. the functionality of the admin model is defined within the admin.py file on the root folder of every app that is created. in order to create a superuser execute the following command: $ python manage.py createsuperuser on docker: $ docker-compose run app sh -c \"python manage.py createsuperuser\" then, you will be prompted to enter an email and a password. once you have filled said fields, you can start the server with $ docker-compose up and enter to the admin page located on 127.0.0.1:8000/admin, where you can log in with your credentials. urls django allows us to define relative urls on a very modular way. first off, we have the core file when it comes to url definition: app/app/urls.py. here we may have something like this: from django.contrib import admin from django.urls import path, include urlpatterns = [ path('admin/', admin.site.urls), path('api/user/', include('user.urls')), ] this example shows that the urlpatterns variable is a list that holds all of the urls defined in our project. the modularization comes from the way the urls defined on the user’s app are specified. first we specify the endpoint for these urls (namely api/user/), and then we pull all the relative urls from the user’s app, defined on the file app/user/urls.py. which are then concatenated with api/user/. the urls defined on the user app are as follows: app_name = 'user' urlpatterns = [ path('create/', views.createuserview.as_view(), name='create'), ] this the can be used like this: # create user api endpoint dinamically create_user_url = reverse('user:create') serializers this files are defined to specify how to serialize (map to the database) the json objects received, in our case, from http requests. for that we create, for each model, a class that extends serializers.modelserializer. in this class we define an inner class called meta that tells the framework which fields does the object have and so allows the mapping to take place. you can also add extra arguments to this inner class, for example to restrict or exercise a stronger control on the fields. next on, we have a simple example of our user model serializer: from django.contrib.auth import get_user_model from rest_framework import serializers class userserializer(serializers.modelserializer): \"\"\"serializer for the users object\"\"\" class meta: \"\"\"info about how to serialize the user model\"\"\" model = get_user_model() fields = ('email', 'password', 'name') # extra requirements for the user model extra_kwargs = {'password': {'write_only': true, 'min_length': 5}} def create(self, validated_data): \"\"\"create a new user with encrypted password and return it\"\"\" # validation_data: json data passed in the http post return get_user_model().objects.create_user(**validated_data) we can also serialize an object that is not related to a model per se, for example: class authtokenserializer(serializers.serializer): \"\"\"serializer for the user authentication object\"\"\" email = serializers.charfield() password = serializers.charfield( style={'input_type': 'password'}, trim_whitespace=false ) views this is, on simple terms, a python function that takes a web request and returns a web response. in our case, we will mostly use views for our api, so we use pre-make view that allows us to easily make an api that creates, updates, etc an object on the database using the serializer that we specify, for example, the api for creating a user is as follows: class createuserview(generics.createapiview): \"\"\"create a new user in the system\"\"\" serializer_class = userserializer in case of wanting to update an object we extend generics.retrieveupdateapiview instead of generics.createapiview. because this view is private, we need to indicate an authentication mechanism and the level of permissions the user has, in our case the authentication is made via token and the permissions are that the user needs to be logged in. class manageuserview(generics.retrieveupdateapiview): \"\"\"manage the authenticated user\"\"\" serializer_class = userserializer # authentication mechanism by which the authentication happens authentication_classes = (authentication.tokenauthentication,) permission_classes = (permissions.isauthenticated,) def get_object(self): \"\"\"retrieve and return authentication user\"\"\" return self.request.user actions start the server observe that this is executed on the docker-compose configuration file $ python manage.py runserver 0.0.0.0:8000 sync django settings (app/app/settings.py) $ python manage.py migrate on docker: $ docker-compose run app sh -c \"python manage.py migrate\" sync changes made on models $ docker-compose run app sh -c \"python manage.py migrate\" on docker: $ docker-compose run app sh -c \"python manage.py makemigrations\" you can also specify the name off the app that contains the model $ python manage.py makemigrations app_name $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Django/index.html",
    "title": "Django",
    "body": " index search search back django django notes $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/GraphQL/relationships.html",
    "title": "Relationships",
    "body": " index search search back relationships contents one to many one to many we are now going to illustrate the situation where an animal belongs to only one category whilst a category contains several animals: type animal { id: id! category: category! name: string! parameter: string! } type category { id: id! name: string! animals: [animal!]! parameter: string! } where we have stored in our database the id of the category as a foreign key of the animal entity. in order to query for animals from a category we create a new resolver: const resolvers = { query: { animals: () => animals, animal: (parent, args, ctx) => { let animal = animals.find((animal) => { return animal.paramenter === args.id }) return animal } } category: { animals: (parent, args, ctx) => { return animals.filter((animal) >= { return animal.category == parent.id }) } } } so if we query for: { category(parameter: \"mammal\"){ category animals { name } } } we get all the names of the animals that are mammals. the parent object symbolizes the object resulting from category(parameter: \"mammal\"), this object will be a category object and will have an id, that we will use in our resolver to filter the animals. observe that the animals have a attribute called category, which is *not* the same as the type definition we have made for our animal object, this attribute is defined on the database. note that we have created a category resolver that acts as the query resolver but for queries within the category object. we, now, do the same for the animals, meaning we want to get the category object that we specified in the animal object, for that we create a new resolver: animal: { category: (parent, args, ctx) => { return categories.find((category) => { return category.id === parent.category }) } } so what we do is go through all of the categories until we find the one that has the same id. { animal(parameter: \"cat\"){ name category { name } } and with this query we retrieve the name and the category name of a cat. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/GraphQL/updating.html",
    "title": "Mutations",
    "body": " index search search back mutations contents typedef resolvers in order to update, delete or add new data using graphql we use mutations. typedef we create the type definition for the mutation object (which is reserved in graphql to modify/add data, much like the query object). in it, we define all the modifying functions we want, along with the data that must be provided to execute the modification, and also the type of object that is returned. type mutation { addanimal( name: string! description: [string!]! parameter: string! category: string! ): animal removeanimal(id: id!): boolean! } with this we have defined the addanimal method, which creates and animal by specifying the name, description, url parameter and the category. this function will return an animal object. we have also defined the removeanimal method, that only takes an id as a parameter and returns a boolean. resolvers we now define the logic behind both of these methods, so we create a mutation.js file as follows: const { v4 } = require(\"uuid\") const mutation = { addanimal: (parent, { name, description, parameter, category }, { animals }) => { let newanimal = { id: v4(), name, description, parameter, category, } // only because this is an object: here we would create in the database animals.push(newanimal) return newanimal }, removeanimal: (parent, { id }, { animals }) => { // here we would delete in the database let index = animals.findindex((animal) => { return animal.id === id }); animals.splice(index, 1); return true } } module.exports = mutation note that we de-structure the parameters from the args object for readability sake. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/GraphQL/file_structure.html",
    "title": "File Structure",
    "body": " index search search back file structure what is best practice is to separate the type definitions and the resolvers: typedefs: stored in schema.js for example. resolvers: stored in a folder called resolvers, and then for each resolver we create a file, for example for the query resolver: const category = { animals: (parent, args, { animals }) => { return animals.filter(animal => { return animal.category === parent.id }) } } module.exports = category then we create an index.js inside the resolvers folder where we can import and export all of our resolvers together: const query = require('./query') const category = require('./category') const animal = require('./animal') module.exports = { query, category, animal } and we put everything together in our index.js inside the root folder: const { apolloserver } = require('apollo-server'); const { maincards, animals, categories } = require('./db') const typedefs = require('./schema') const { query, category, animal } = require('./resolvers/index') const server = new apolloserver({ typedefs, resolvers: { query, animal, category }, context: { maincards, animals, categories } }); // the `listen` method launches a web server. server.listen().then(({ url }) => { console.log(`🚀 server ready at ${url}`); }); we now use the context object in order to make our \"database\" available to all of the resolvers through ctx. (note that we de-structure the object to the get animal object). $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/GraphQL/terminology.html",
    "title": "Terminology",
    "body": " index search search back terminology contents schema resolver schema it defines the data associated with an entity: type person { id: id! name: string! email: string! age: int! phone: string gender: boolean! } that is to say, it defines the type definitions of the data that conforms a given entity. resolver the data that we get back is dependent on the resolvers. they are functions that return data that follow a certain schema, it does not need to follow the schema, but then when querying it, it may throw and error. people(parent, args, ctx, info){ return[ { id: \"1\", name: \"laith\", email: \"email@email.com\", age: 23, phone: \"623198135\", gender: true } ] } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/GraphQL/fetch.html",
    "title": "Fetch Data",
    "body": " index search search back fetch data contents variables you can start requesting data with usequery. usequery is a react hook that shares graphql data with your ui. so for example to fetch the image and the title of the cards: import { usequery, gql } from '@apollo/client' const fetch_data = gql` { maincards { image title } } ` function mainhero(){ const maindata = usequery(fetch_data) return(<div></div>) } where maincards is one of our resolvers, and we specify that we want to select the image and the title. so now, we can de-structure the different attributes offered by the apolloprovider, namely loading, error and data. and therefore control the flow of our application by using them. import { usequery, gql } from '@apollo/client' const fetch_data = gql` { maincards { image title } } ` function mainhero(){ const { loading, error, data } = usequery(fetch_data) return(<div></div>) } variables in order to make a query by passing parameters we do: const animal_query = gql` query($slug: string!){ animal(slug: $slug){ title image stock description price } } ` where $string is the variable we want to pass in, and we specify its type and the fact that it is required with string!. now to make the query we do: function animalpage() { const { slug } = useparameters() const { loading, data, error } = usequery( variables: { slug: 'cat' } ) } with variables we pass in all of the parameters needed in the query. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/GraphQL/index.html",
    "title": "GraphQL",
    "body": " index search search back graphql backend intro terminoligy graphql server queries, typedefs and resolvers relationships file structure mutations frontend graphql client fetch data mutations $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/GraphQL/intro.html",
    "title": "Intro",
    "body": " index search search back intro contents difference with apis graphql is a query language used to communicate to our api and query for data. difference with apis whenever we use rest apis and we hit specific endpoints, more often than not, we are going to retrieve some data that we have no use for. this is what is called overfetching. for example when you access https://my-rest-api/animals you get an object with a list of animal objects, and you may not need all of the information of every animal. graphql solves this problem by: only having one endpoint. from this endpoint we use the graph query language to select whatever data that we want. for example, to retrieve the same information stated above: query{ animals{ title ratings img price } } which gets only the specified attributes for each animal. graphql also solves underfetching, which is the situation where you cannot get enough data with a call to only one endpoint, forcing you to call a second endpoint. for example, if you want information about the animals and the categories you have to access https://my-rest-api/animals, and https://my-rest-api/categories, however with graphql: query{ animals{ title ratings img price } categories{ id title img } } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/GraphQL/mutations_client.html",
    "title": "Mutations",
    "body": " index search search back mutations in order to execute a mutation from the client side we create a mutation request: const add_animal_mutation = gql` mutation( $name: string!, $description: [string!] $parameter: string!, $category: string! ) { addanimal( name: $name, description: $description, parameter: $parameter, category: $category ) } ` and now we use the usemutation hook to obtain the function that will be called in order to update our animal: import { usemutation, gql } from '@apollo/client' function animal(){ const [addanimal] = usemutation(add_animal_mutation) return( <div> <button onclick={() => addanimal({ variables: { name: 'cat', description: ['this is a description'], parameter: 'cat', category: 'mammal' } } )}/> </div> ) } with this we get the function addanimal with the usemutation hook and we use it in our button, so when it is clicked we add a cat to our animal collection. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/GraphQL/client.html",
    "title": "Client",
    "body": " index search search back client as well as with the server there are several clients for graphql within different languages and frameworks, visit the official page to check them out. we are going to use apollo client so for that we need to install apollo and graphql on the client side of our application: $ npm install @apollo/client graphql in our case we are going to connect our client to react (reference). so, first we import the necessary modules. import react from 'react'; import { render } from 'react-dom'; import { apolloclient, inmemorycache, apolloprovider, usequery, gql } from \"@apollo/client\"; const client = new apolloclient({ uri: 'http://localhost:4000', cache: new inmemorycache() }); function app() { return ( <div> <h2>my first apollo app 🚀</h2> </div> ); } render( <apolloprovider client={client}> <app /> </apolloprovider>, document.getelementbyid('root'), ); we tell apollo that our graphql server is listening for request on our localhost on the port 4000. where apollo allows us to cache our queries, with the inmemorycache module. that way we do not need to make the same request twice, because the data is cached in memory. and then, we wrap our app with the apolloprovider, so all of our components have access to our client. note that we pass our client as a prop. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/GraphQL/server.html",
    "title": "GraphQL Server",
    "body": " index search search back graphql server graphql supports several languages, and has several servers that do mainly the same. consult the official page for the one that suits your needs. we are going to use apollo-server to demonstrate how to use graphql in a node.js application: so, first, we install the apollo-server along with graphql dependency with npm: $ npm install apollo-server graphql now we use graphql to define our type definitions: const { apolloserver, gql } = require('apollo-server'); const typedefs = gql` type book { title: string author: string } type query { books: [book] } and we also create our resolvers: const resolvers = { query: { books: () => books, } } where books is an already defined array of books. finally we create the actual server: const server = new apolloserver({typedefs, resolvers}); server.listen().then(({ url }) => { console.log(`🚀 server ready at ${url}`); }); $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/GraphQL/qtr.html",
    "title": "Queries TypeDefs and Resolvers",
    "body": " index search search back queries typedefs and resolvers contents data specification queries typedefs: define how the data should look. resolvers: resolve what the actual data is going to be. here we could introduce some logic, like calling the database or applying validation. query: defines how we can query our data type query{ books: [book] } so the book resolver would return an array of books. data specification arrays: to define an array on typedefs or queries you use []. type book { author: [string] } non nullable field: to specify that an attribute cannot be null you use !. type book { author: string! author: [string]! // the array must not be null author: [string!]! // the elements of the array and the array must not be null } queries parameters: on the query object you add an argument between brackets (the ! specifies the argument must be provided). type animal { id: id! name: string! description: [string!]! } type query { animals: [animal!]! animal(id: string!): animal } on the resolver we use the arg parameter to retrieve the parameter passed: const resolvers = { query: { animals: () => animals, animal: (parent, args, ctx) => { let animal = animals.find((animal) => { retunr animal.id === args.id }) return animal } } } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Docker/engine.html",
    "title": "Docker Engine",
    "body": " index search search back docker engine contents containerization cgroups when you install docker on your linux system you are installing: docker daemon: this is the background process that manages docker objects (i.e. images, containers, volumes and networks). rest api: it is the interface programs can access to provide instructions to the daemon. docker cli: command line interface to manage our docker objects. this uses the rest api to interact with the docker daemon. note that the docker cli can be run from a remote machine, that is to say the rest api and the docker daemon are running on a different machine. so, in order to interact with the api we use the -h flag, indicating the ip where the api and the daemon reside with the 2375 port. $ docker -h=10.123.2.1:2375 <docker-command> $ docker -h=10.123.2.1:2375 run nginx containerization as we have seen all of our containers run on top of the same operative system, so it is a given that the processes will be handled by the same kernel. this means that the processes of our containers are run along with the rest of processes in the host machine, in other words the pids of all the processes must be different. what docker does to isolate these processes is the container is using namespaces and maps the process id to another process id within the container, and that is visible only on this container. cgroups because all docker containers share the hosts resources it could be possible that a container takes up all of the machine's resources. so, to restrict the amount of resources used by a container docker uses cgroups. you can specify the amount of cpu or ram that the container is allowed to have: $ docker run --cpus=.5 ubuntu $ docker run --memory=100m ubuntu $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Docker/environmentvar.html",
    "title": "Environment Variables",
    "body": " index search search back environment variables in order to pass an environment variables to our container we run: $ docker run -e env_var=value <image_name> this way we set up and environment variable within the container. if you inspect a running container, you will be able to see the environment variables defined, inside the \"env\" object: $ docker inspect <image_name> { . . \"config\": { \"hostname\": \"51049352a8ee\", \"domainname\": \"\", \"user\": \"\", \"attachstdin\": false, \"attachstdout\": false, \"attachstderr\": false, \"exposedports\": { \"3456/tcp\": {}, \"80/tcp\": {} }, \"tty\": false, \"openstdin\": false, \"stdinonce\": false, \"env\": [ \"path=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\", \"nginx_version=1.19.10\", \"njs_version=0.5.3\", \"pkg_release=1\" ], \"cmd\": [ \"nginx\", \"-g\", \"daemon off;\" ] . . . } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Docker/registry.html",
    "title": "Docker Registry",
    "body": " index search search back docker registry contents public registry private registry deploy private registry public registry in the following example you are pulling the nginx image, which in reality is stored as nginx/nginx where the first nginx corresponds to the user name, and the second to the image name. image: nginx this is a public image so it is stored in a public registry, usually in docker.io which is the default registry. so a more verbose configuration file would be: image: docker.io/nginx/nginx private registry when you have applications that should no be made available to the public private registries are used. to pull or use an image from a private registry: register into the private registry: $ docker login private-registry.io run the image indicating the registry: $ docker run private-registry.io/apps/internal-app deploy private registry a private registry is in itself a docker image, so first you have to have your registry image running: $ docker run -p 5000:5000 --name registry registry:2 so now you have your registry running on port 5000. the next step is to assign a tag to your image as follows: $ docker image tag my-image localhost:5000/my-image where my-image is the name of the image and localhost:5000/my-image is the tag assigned. finally you push your image to your registry $ docker push localhost:5000/my-image now you can pull your image: $ docker pull localhost:5000/my-image $ docker pull 192.168.56.100:5000/my-image $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Docker/kubernetes.html",
    "title": "Kubernetes",
    "body": " index search search back kubernetes contents architecture components some of its functionalities are: running several instances of a service. scaling up or down the number of instances. rolling updates. rolling back from updates. supports many different network and storage renderers. provides autoscaling. helps you test new features of your application by only upgrading a percentage of the instances, which allows for doing ab testing. architecture a kubernetes cluster consists of several nodes, the worker nodes are where containers will be launched, so even if one node fails the application is still available. kubernetes clusters are managed by the master, which is a node that watches over worker nodes and is responsible of the orchestration of containers in the worker nodes. components when you install kubernetes in your system you are actually installing: api server: acts as the front-end for kubernetes, so all of the programs talk to this server to interact with the kubernetes server. etcd: it is the distributed reliable key value store to store all data to manage the cluster. scheduler: responsible for distributing work. controller: responsible for noticing/responding to nodes/containers going down. container runtime: underline software used to run containers (e.g. docker). kubelet: is the agent that runs in each node in the cluster, and is responsible of making sure the containers are running on the nodes as expected. one of the command line utilities used by kubernetes is kubectl, that is the kubernetes cli and is used to deploy and manage applications on a kubernetes cluster. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Docker/compose_networks.html",
    "title": "Docker Compose Networks",
    "body": " index search search back docker compose networks let's start with an example application, which is made up of five services: voting-app: a front-end application for the user to vote. redis: and in-memory database to store the vote. worker: application in the back-end that processes the vote and stores it in the database. db: database in which the vote is stored. result-app: front-end application that shows the voting results. in this architecture we have two networks: front-end: voting-app and result-app back-end: all the services. therefore it is desirable to define two networks in our docker-compose and attach the networks to the services: version: 2 services: redis: image: redis networks: - back-end db: image: postgres networks: - front-end vote: image: voting-app networks: - front-end - back-end result: image: result networks: - front-end - back-end worker: image: worker networks: - front-end - back-end networks: - front-end: - back-end: as you can see we define two networks: front-end and back-end (note that we have omitted the configuration of the networks) and then for each service we specify the network to which the service has access (also, observe that the configuration of the services has been trimmed down for readability purposes). $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Docker/swarm.html",
    "title": "Docker Swarm",
    "body": " index search search back docker swarm contents docker service you can combine multiple docker machines together into a single cluster and docker swarm will take care of managing your services. you need to have different hosts with docker installed on them. you must designate one to be the manager, so the rest are the workers. run the docker swarm init command on the manager and that will initialize the manager. on the workers run docker swarm join <token> where <token> is specified in the output of docker swarm init. now you can deploy your services in your cluster, and will be run on the nodes (i.e. workers). docker service docker services are one or more instances of application or services that run along the nodes in the swarm cluster. $ docker services create --replicas=3 <image-name> this creates three instances of my image and runs them in the nodes of the cluster. this command must be run on the manager node, not on the worker nodes. it is similar to the docker run command in terms of the options to pass (networks, ports, interactive mode, etc.) $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Docker/storage.html",
    "title": "Storage",
    "body": " index search search back storage contents layers image and container layers copy-on-write volumes volume mounting bind mounting mount storage administration the data pertaining docker is stored within the folder /var/lib/docker/. this includes containers, images, volumes created, etc. layers because of docker's layered architecture when creating very similar images that share a lot of instructions, it uses the cached layers and is, therefore more efficient by not building each image from scratch. for example, when you update your application's source code, only the instructions after the copy instruction, this one included, from your dockerfile is run. image and container layers the layers created from each instruction on the dockerfile constitute the image layers and are all read-only files. when you run your image a new layer is created, denoted by container layer which is a writable file which is a writable file. however, when the container is destroyed, this layer is removed. this is the reason why we use volumes for permanent storage. this is needed because all the containers use the same image, so the changes made in the image by the different containers should not affect the image. copy-on-write also, the changes made on files stored in the image are not made on the original file. the file is copied to the container layer and the changes are made onto this copy. volumes as we have said, we need volumes to store permanent data. so, first we create the volume: $ docker volume <volume_name> which is stored in /var/lib/docker/volumes volume mounting once we have created the volume, we specify that we want to mount this volume within our container: $ docker run -v <volume_name>:/var/lib/mysql mysql if you run this same command, without creating the volume first, docker will automatically create the volume for you. bind mounting if you want to mount another directory that is not inside /var/lib/docker/volumes, then you have to specify the whole directory's (may be an absolute or relative path). $ docker run -v /data/mysql:/var/lib/mysql mysql mount this is the new way to mount: $ docker run --mount type=bind,source=/data/mysql,target=/var/lib/mysql which is preferred as it is more verbose. storage administration the responsible for all of these operations that happen under the hood are the storage drivers, which are chosen depending on the hosts' os: aufs zfs btrfs device mapper overlay overlay2 $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Docker/cmd_vs_entrypoint.html",
    "title": "CMD vs ENTRYPOINT",
    "body": " index search search back cmd vs entrypoint contents cmd entrypoint difference cmd a command allows us to append to the command executed when the container start of the base image. for example, ubuntu's cmd is bash, so if we append sleep 5 our container will sleep for 5 seconds when started and then exit. from ubuntu cmd sleep 5 the command can also be specified as cmd [\"sleep\", \"5\"]. entrypoint this other instruction also adds to the base image starting command, but this lets us add arguments from the command line, for example, if we define the following dockerfile: from ubuntu entrypoint [\"sleep\"] we build the image $ docker build dockerfile -t ubuntu-sleeper and then we running with 10 as and argument: $ docker run ubuntu-sleeper 10 our container will sleep for 10 seconds and then exit. to define a default value for sleep, when no argument is passed from the command line, we use both entrypoint and cmd from ubuntu entrypoint [\"sleep\"] cmd [\"5\"] to override the entrypoint command specified in the dockerfile we use the flag --entrypoint: $ docker run --entrypoint sleep2.0 ubuntu-sleeper 10 difference when using cmd when running: $ docker run ubuntu-sleeper sleep 10 the argument sleep 10 replaces entirely the starting command. however with entrypoint if we run: $ docker run ubuntu-sleeper 10 the argument 10 is passed and appended to the entrypoint command. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Docker/windows_mac.html",
    "title": "Docker on Windows and Mac",
    "body": " index search search back docker on windows and mac contents windows containers base images on these systems we have two options: docker toolbox (usually for older pc's): installs docker along with virtualbox to create a linux system on which docker is run. hypervirtualization: installs docker and uses hyper-v (comes with windows server or professional edition) or hyperkit on mac. this allows docker to create a linux machine under the hood and run docker in it. windows containers the options just discussed will only work for linux applications and containers. in 2016 microsoft announced support for windows containers, there are two types: windows server container: the containers share the kernel, as regular linux containers do. hyper-v isolation: each container is run within a highly optimized virtual machine, so complete kernel isolation between the containers and the underline host is guaranteed. base images where in linux we had the debian, ubuntu or alpine base images in windows we have two options: windows server core nano server: this is a headless deploy of the windows server, that is, the lightweight option. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Docker/images_commands.html",
    "title": "Image",
    "body": " index search search back image contents list remove download create your own image dockerfile layered architecture list lists downloaded images: $ docker images or alternatively: $ docker image ls remove remove an image $ docker rmi nginx you must stop and remove all the containers that are instances of the image before removing said image. download to only download an image and not also run a container: $ docker pull nginx create your own image first create a dockerfile specifying all of the steps required to set up your application: from ubuntu run apt-get update run apt-get install python run pip install flask run pip install flask-mysql copy . /opt/source-code entrypoint flask_app=/opt/source-code/app.py flask run then build your image, to store locally: $ docker build dockerfile -t mycustomapp here we specify our dockerfile as input for building the image and the tag of the image with the flag -t. to make it available on the dockerhub: $ docker push mycustomapp dockerfile this is configuration file that follows a certain syntax and tells docker how to build the image. the syntax is the following: instruction argument in the previous example we have: from: defines the base image, which can be an os or another image (every image have to be based off another image). run: run a particular command on the base image. copy: copies files from the host system onto the docker image. entrypoint: specifies the command that will be run when the container is started. layered architecture docker follows a layered architecture so each instruction represents a different layer, which contains only the changes from the layer before, and may serve as a snapshot from which to start the build from a particular layer. also, docker caches the layers, so if there is an error, the build would start from the last layer that did not produce a failure. also, if you were to add additional steps, docker would not start the build from scratch. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Docker/index.html",
    "title": "Docker",
    "body": " index search search back docker intro set up container image environment variables cmd vs entrypoint networking storage docker compose docker compose networks docker registry docker engine docker on windows and mac container orchestration docker swarm kubernetes $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Docker/nerworking.html",
    "title": "Networking",
    "body": " index search search back networking contents bridge host none user defined networks inspect network embedded dns when you install docker it creates three networks automatically: bridge: default network the container get attached to. $ docker run ubuntu none: $ docker run ubuntu --network=none host $ docker run ubuntu --network=host bridge this is a private internal network created by docker on the host. all containers can access each other using their internal ip (usually subnets of 172.17.0.3). to access from outside you have to map a port of the container to a port of the host. host another way to configure the network is to associate the container to the host's network, removing all kind of network isolation between the docker host and the docker container. this way when you run a server on port 5000 it would automatically accessible from the host on the port 5000 without needing to map it to a host's port. this prevents you from using the same ports for different applications. none the containers are not attached to any network and are, therefore, isolated from any other containers so they do not have any access to the external network or other containers. user defined networks because with the default internal network, the containers can access each other, it is sometimes desirable to create new internal networks: $ docker network create --drive bridge --subnet 172.18.0.0/16 <network_name> to list the created networks: $ docker network ls inspect network in order to see the network configuration use inspect and head to the networks section: $ docker inspect ( container_name | container_id ) . . . \"macaddress\": \"aa:bb:cc:dd:ee:ff\", \"networks\": { \"bridge\": { \"ipamconfig\": null, \"links\": null, \"aliases\": null, \"networkid\": \"24af0d...\", \"endpointid\": \"3449a29...\", \"gateway\": \"172.17.0.1\", \"ipaddress\": \"172.17.0.3\", \"ipprefixlen\": 16, \"ipv6gateway\": \"\", \"globalipv6address\": \"\", \"globalipv6prefixlen\": 0, \"macaddress\": \"02:42:ac:11:00:03\", \"driveropts\": null } } . . . embedded dns when containers in the same subnet may want to access each other, for that you could hard code the internal ip assigned to the containers. however this is not advisable, as this ip may change when the container is started in another occasion in the future. because of that all containers in a docker host can resolve each other using their names. this is possible has a built-in dns server for this purpose that runs at 172.0.0.11. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Docker/compose.html",
    "title": "Docker Compose",
    "body": " index search search back docker compose contents build versions version 2 it is used to set up a complex application running multiple services. docker commands map to docker compose as follows: to start the application we run: $ docker-compose up build if we would like to tell docker compose to build a docker build instead of pulling an image we use the build keyword inside a service instead of the image keyword. and we specify the location of the directory which contains the application code and a dockerfile. vote: build: ./vote ports: - 5000:80 links: - redis versions different docker compose versions have different formats and functionality. version 2 from version 2 on, you must specify the docker compose version by adding to the top of the file: version: 2 also, all of the different containers should be listed under a sevices section. and now, links are no longer needed as docker creates a virtual network and attaches all of the services to this network with the name of the service. finally, a depends_on keyword is introduced to force a order of startup. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Docker/intro.html",
    "title": "Intro",
    "body": " index search search back intro contents what are containers sharing the kernel containers vs virtual machines container vs image what are containers they are completely isolated environments, they have their own processes, network interfaces, etc. however they share the same os kernel. docker uses lxc containers, which are very low lever, so docker provides a high level tool that allows us to manage our containers easily. sharing the kernel as we have said, docker uses the system's kernel, so it is capable of running any distributions whose underlying kernel is linux (e.g. docker running on ubuntu can run a container based on debian, fedora, etc.) containers vs virtual machines containers: application 1 application 2 ------------- ------------- libs/dependencies 1 libs/dependencies 2 container 1 container 2 docker   os   hardware   virtual machines: application 1 application 2 ------------- ------------- libs/dependencies 1 libs/dependencies 2 os 1 os 2 virtual machine 1 virtual machine 2 hypervisor   hardware   the main differences are the use of hypervisors in virtual machines and how on these, each instance has its own os. which results in needing more hardware resources. also virtual machines have total isolation, as they use their own os, which does not happen with containers, because these do share the same kernel. however the key is combining both technologies, so each virtual machine runs several applications hosted in different containers. container vs image an image can be thought as a package or a template that is used to create one or more containers. that is to say, containers are running instances of images that are isolated and have their own environment. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Docker/setup.html",
    "title": "Set Up",
    "body": " index search search back set up contents install docker docker engine install using static binaries official repo configure docker running as normal user install docker compose in this first step, we will present how to install the necessary tools to use docker and docker compose in arch linux. install docker in the current section we will lay out the steps to carry out in order to get docker up and running on an arch linux machine. docker engine before installing anything we will update the system as follows $ sudo pacman -syu when it is done updating we will proceed rebooting the system, and then we enable the loop module: $ sudo tee /etc/modules-load.d/loop.conf <<< \"loop\" $ sudo modprobe loop install using static binaries for reference go to the official documentation on docker's website. firstly we will download the static binary archive on https://download.docker.com/linux/static/stable/. once the file is downloaded extract it executing the following command, and substituting our docker-20.10.8 for your package's version. $ tar xzvf docker-20.10.8.tgz copy the binaries to your executable path (/usr/bin or /bin). this is optional. $ sudo cp docker/* /usr/bin/ start docker's daemon: $ sudo dockerd finally run to check that the installation was correct (it will download an example image that outputs a message informing the user that the installation was successful, among other things). $ sudo docker run hello-world official repo this other approach will allows to have a docker service so we do not have to always run sudo dockerd & to start docker's daemon. we install docker using pacman: $ sudo pacman -s docker afterwards, we enable the docker service executing: $ sudo systemctl start docker.service $ sudo systemctl enable docker.service finally run to check that the installation was correct (it will download an example image that outputs a message informing the user that the installation was successful, among other things). $ sudo docker run hello-world configure docker running as normal user in order to use docker as a normal user we need to add said user to the docker group. add the docker group $ sudo groupadd docker add your user to the docker group $ sudo usermod -ag docker $user log out, log in and verify that it runs properly $ docker run hello-world install docker compose download the current stable release of docker compose. mind you, this command downloads the 1.29.2 version, check the official page for new releases. $ sudo curl -l \"https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose make the binary executable $ sudo chmod +x /usr/local/bin/docker-compose test the installation $ docker-compose --version docker-compose version 1.29.2, build 5becea4c $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Docker/orchestration.html",
    "title": "Container Orchestration",
    "body": " index search search back container orchestration when in production, it is often needed that several instances of containers are run (because of a heavy load on the application for example). so in these cases you need to monitor the instances as well as the host itself in case any of them crash. for that we use container orchestration that offers a set of tools and scripts that allow us to manage the hosts and containers. the typical approach is to create several instances of containers in different hosts, so if one fails the application can still offer the service. for example: $ docker service create --replicas=100 nodejs some solutions let us automatically scale the number of containers depending on the demand. others can help in automatically adding new hosts to support the user load. they also provide complex networking between the containers as well as load balancing user requests across different hosts or sharing storage between the hosts, configuration management or security. there are several solutions: docker swarm from docker kubernetes from google mesos from apache. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Docker/containers.html",
    "title": "Container",
    "body": " index search search back container contents run basics port mapping volume mapping linking information of a container logs list stop remove execute commands run basics run a container from an image, the attached way, (i.e. it is not run on the background). $ docker run nginx if the image is not present on the host it will be downloaded from docker hub. when it is downloaded it runs and exits right away, because there is not application running in the container. to run the container in the detach mode, so it run on the background: $ docker run -d nginx to bring the container to the foreground: $ docker attach ( container_id | container_name ) run a container with a specific tag: $ docker run redis:4.0 this way we run the redis image where redis's version is 4.0. run a container listening to the standard input (because by default docker does not listen for input): $ docker run -i <image_name> this way we are running our container in interactive mode. in order to attach a terminal: $ docker run -it <image_name> port mapping each container is assigned a port (e.g. 5000) and an internal ip by default (e.g. 127.17.0.2) but this ip is only accessible from the host. so to access it from outside, we would use our host's ip (e.g. 192.168.1.5), however we still need to map our container's port to a free port in our host. so to map, for example, the port 5000 of our docker container to the port 80 of our host: $ docker run -p 80:5000 <image_name> and now, we can access the service running in our docker container by heading to 192.168.1.5:80. this way all traffic in this specific url will be routed to the port 5000 in our docker container. volume mapping our container has its own file system, so the changes made to data stored in it are only made in the container. if you want certain data to persist (because when removing the docker container the files stored within are also removed) you use the flag -v to map a certain file/folder in the container to a certain file/folder in our host: $ docker run -v /opt/datadir:/var/lib/mysql mysql in this particular example we store the data we saved in our mysql database in a directory in our container (/var/lib/mysql), and we map this directory to a directory in our host (/opt/datadir) this way docker mounts implicitly the folder in our host to the folder in the container. linking if we have a web application that connects to a redis instance, we need to tell the web app's container which redis instance to wait for (because there may be multiple). so, first we start the redis container: $ docker run -d --name=redis redis and now we start our web app's container and we link it with the redis container: $ docker run -d --name=vote -p 5000:80 --link redis:redis voting-app the redis before the colon is the name of our redis container, and the redis after the name is the name used in the web app container. this option is soon to be deprecated because new concepts are technologies are being introduced. information of a container in order to get more detailed information about a certain container: $ docker inspect ( container_name | container_id ) logs to see the logs of a container (usually printed to the stdout): $ docker log ( container_name | container_id ) list lists all running containers and some information about it. $ docker ps to see all containers, even if they are not currently running: $ docker ps -a stop stop running a container who matches the id or the name provided: docker stop ( container_id | container_name ) remove removes a container permanently docker rm ( container_id | container_name ) execute commands to execute a command after creating a new container: $ docker run ubuntu sleep 5 this commands starts the container and run the command sleep 5 and then exits. to execute a command in a currently running container: $ docker exec ( container_id | container_name ) cat /etc/hosts $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Other/Rices/arch_install.html",
    "title": "Arch Linux Installation",
    "body": " index search search back arch linux installation contents set up install set up set the keyboard layout: $ loadkeys es augment the size of the iso image: $ mount -o remount,size=1g /run/archiso/cowspace download git: $ pacman -syy && pacman -s git configure git to store the credentials: $ git config --global credential.helper store clone the repository: git clone https://github.com/albamr09/archinstaller.git now, you are good to go to start the installation process. install place yourself inside the root of the repository: cd archinstaller check out the configuration file, in case some values do not make sense to you: cat install_scripts/config.sh if you are satisfied with the configuration, simply execute: cd install_scripts && ./install.sh this will cause the installation to begin. it is mostly automatic, but sometimes you will have to enter a password here and there. so do not just let it execute by itself, because there are timeouts that will cause the installation to hault with an error. once this finished, reboot your computer. when the computer is up and running again, you will be met with a very minimal login interface. log in with you user, and execute the following: cd /install_scripts && ./post_install this script prompts you to connect to a wifi access point. it also sets up some needed services (like lightdm!) and removes all the installation files used from you system so it is nice an clean. well, now your arch linux is ready to go! $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Other/VimWiki/index.html",
    "title": "Vim Wiki",
    "body": " index search search back vim wiki key bindings convert current file to html: ,wh see html file in browser: ,whh more info on vimwiki latex inline \\(a = 1\\) equation \\begin{align} a \\end{align} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Other/index.html",
    "title": "Other",
    "body": " index search search back other rices arch linux installation misc vimwiki macos vm $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Other/MacOS/index.html",
    "title": "Mac OS VM",
    "body": " index search search back mac os vm source initial setup ubuntu/debian: $ sudo apt-get install qemu uml-utilities virt-manager git \\ wget libguestfs-tools p7zip-full make dmg2img -y fedora: $ sudo dnf install @virutalization start libvirt service: $ sudo systemctl start libvirt $ sudo systemctl enable libvirt add user to the kvm and libvirt groups (might be needed). $ sudo usermod -ag kvm $(whoami) $ sudo usermod -ag libvirt $(whoami) $ sudo usermod -ag input $(whoami) note: re-login after executing this command. now edit /etc/libvirt/qemu.conf and set user and group to your user. clone this repository on your qemu system. files from this repository are used in the following steps. $ cd ~ $ git clone --depth 1 --recursive https://github.com/kholia/osx-kvm.git $ cd osx-kvm note: with this you are installing your vm on $home. fetch macos installer. $ ./fetch-macos-v2.py on this step select monterey. convert the downloaded basesystem.dmg file into the basesystem.img file. $ dmg2img -i basesystem.dmg basesystem.img create a virtual hdd image where macos will be installed. if you change the name of the disk image from mac_hdd_ng.img to something else, the boot scripts will need to be updated to point to the new image name. $ qemu-img create -f qcow2 mac_hdd_ng.img 128g be aware that the machine can easily reach that amount of memory. installation cli method (primary). just run the opencore-boot.sh script to start the installation process. $ ./opencore-boot.sh before installing go to disk utility inside the machine and erase the partition we are going to use for the virtual machine (the one that is roughly 128gb). for that click on erase and select mac os extended (journaled). once the erasing procedure is done, you can start the installation normally. edit macos-libvirt-catalina.xml file and change the various file paths (search for changeme strings in that file). the following command should do the trick usually. $ sed \"s/changeme/$user/g\" macos-libvirt-catalina.xml > macos.xml $ virt-xml-validate macos.xml create a vm on virt-manager by running the following command. $ virsh --connect qemu:///system define macos.xml launch virt-manager and start the macos virtual machine. post-installation open virt-manager, select macos and edit cpus and memory so the virtual machine does not lag incredibly. permissions bug (might only happen in fedora) if you get an error when starting the machine related to permissions, they are solved with: $ sudo setenforce permissive if they are related with selinux. if that is the case, refer to. undo the previous command with: $ sudo setenforce enforcing on your $home directory try to fix with: $ sudo chcon -r -u system_u -r object_r -t svirt_image_t osx-kvm/ screen resolution execute the virtual machine and press esc inmmediately. select device management option and change ovmf to 1920x1080p resolution. enter the virtual machine, once it has been booted open a terminal and write: $ diskutil list select the disk where the efi partition is location $ sudo diskutil mount disk1s1 $ vi /volumes/efi/efi/oc/config.plist and edit the entry under resolution to be 1920x1080@32. reboot the machine. once rebooted go to system preferences > displays and check show all resolutions and select 1920x1080. connect to physical iphone open virtual manager, and enter the configuration of the machine. click on add hardware and select usb host, now edit the xml entry just created and substitue the content with: <hostdev mode=\"subsystem\" type=\"usb\" managed=\"yes\"> <source> <vendor id=\"0x05ac\"/> <product id=\"0x12a8\"/> </source> <address type=\"usb\" bus=\"0\" port=\"1\"/> </hostdev> where vendor id and product id is obtained through lsusb on the host machine: $ lsusb ... bus 001 device 004: id 05ac:12a8 apple, inc. iphone 5/5c/5s/6/se ... keyboard is locked if the keyboard seems to be captured when the machine starts, remove the entry on the machine hardware configuration that has this content or similar (this is my keyboard's smart card, may not apply to your case.) <hostdev mode=\"subsystem\" type=\"usb\" managed=\"yes\"> <source> <vendor id=\"0x04f2\"/> <product id=\"0x1469\"/> </source> <address type=\"usb\" bus=\"0\" port=\"2\"/> </hostdev> optimization source only the following are actually important: add more video memory open virtual manager, select macos machine and open the configuration. locate vga and change the xml entry so that vgamem has the value 65536. skip the gui login screen (at your own risk!) $ defaults write com.apple.loginwindow autologinuser -bool true disable spotlight indexing on macos to heavily speed up virtual instances. $ sudo mdutil -i off -a enable performance mode # check if enabled (should contain `serverperfmode=1`) $ nvram boot-args # turn on $ sudo nvram boot-args=\"serverperfmode=1 $(nvram boot-args 2>/dev/null | cut -f 2-)\" disable heavy login screen wallpaper $ sudo defaults write /library/preferences/com.apple.loginwindow desktoppicture \"\" reduce motion & transparency (could be faulty) defaults write com.apple.accessibility differentiatewithoutcolor -int 1 defaults write com.apple.accessibility reducemotionenabled -int 1 defaults write com.apple.universalaccess reducemotion -int 1 defaults write com.apple.universalaccess reducetransparency -int 1 defaults write com.apple.accessibility reducemotionenabled -int 1 to undo any of this changes refer to the reference material. gpu passthrough to be continued $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/10_02.html",
    "title": "The Law of Cosines and Area Formulas",
    "body": " index search search back the law of cosines and area formulas contents triangle side length restriction derivation of the law of cosines how to resolve oblique triangles area formulas heron s area formula other area formula triangle side length restriction in any triangle, the sum of the lengths of any two sides must be greater than the length of the remaining side. derivation of the law of cosines let \\(abc\\) be any oblique triangle. let \\(b\\) be a vertex at the origin and the side \\(bc\\) be along the positive x-axis (figure 10). let \\((x, y)\\) be the coordinates of vertex \\(a\\), then: \\begin{align} \\sin b = \\frac{y}{c} \\end{align} and \\begin{align} \\cos b = \\frac{x}{c} \\end{align} such that: \\begin{align} y = c \\sin b \\end{align} and \\begin{align} x = c \\cos b \\end{align} so the coordiantes for \\(a\\) become \\((c \\cos b, c \\sin b)\\). point \\(c\\) has coordinates \\((a, 0)\\) and \\(ac\\) has length \\(b\\). so if we apply the distance formula we obtain: \\begin{align} b = \\sqrt{(c \\cos b - a)^2 + (c \\sin b - 0)^2} \\end{align} \\begin{align} b^2 = (c \\cos b - a)^2 + (c \\sin b - 0)^2 \\end{align} \\begin{align} b^2 = c^2 \\cos^2 b + a^2 - 2ac\\cos b + c^2 \\sin^2 b \\end{align} \\begin{align} b^2 = c^2 (\\cos^2 b + \\sin^2 b) + a^2 - 2ac\\cos b \\end{align} \\begin{align} b^2 = c^2 (1) + a^2 - 2ac\\cos b \\end{align} \\begin{align} b^2 = c^2 + a^2 - 2ac\\cos b \\end{align} if we place \\(a\\) or \\(c\\) at the origin we obtain: \\begin{align} a^2 = b^2 + c^2 - 2bc\\cos b \\end{align} \\begin{align} c^2 = a^2 + b^2 - 2ab\\cos b \\end{align} how to resolve oblique triangles four cases can occur in solving an oblique triangle: case 1: one side and two angles are known use the angle sum formula (\\(a + b + c = 180º\\))to find the remaining angle use the law of sines to find the remaining sides case 2: two sides and one angle (not in-between) are known (ambiguous case, there may be no triangle, one triangle or two triangles) use the law of sines to find an angle use the angle sum formula to find the remaining angle use the law of sines to find the remaining side if two triangles exist, repeat step 2 and 3 case 3: two sides and the included angle are known use the law of cosines to find the third side use the law of sines to find the smaller of the two remaining angle use the angle sum formula to find the remaining angle case 4: three sides are known use the law of cosines to find the largest angle use the law of sines to find either of the two remaining angles use the angle sum formula to find the remaining angle area formulas heron's area formula given a triangle with sides of length \\(a\\), \\(b\\) and \\(c\\), its semiperimeter is: \\begin{align} s = \\frac{1}{2}(a + b + c) \\end{align} and the area of the triangle is: \\begin{align} \\mathcal{a} = \\sqrt{s(s-a)(s - b)(s - c)} \\end{align} other area formula if we know the measures of two sides and the angle between them, we can find the area of the triangle. we know: \\begin{align} \\mathcal{a} = \\frac{1}{2} bh \\end{align} where \\(b\\) is the base and \\(h\\) is the height, that can be computed as follows: \\begin{align} \\sin a = \\frac{h}{c} \\leftrightarrow h = c \\sin a \\end{align} therefore: \\begin{align} \\mathcal{a} = \\frac{1}{2}bh = \\frac{1}{2}bc \\sin a \\end{align} since the labels for the vertices in triangle abc could be rearranged, other area formulas can be written: \\begin{align} \\mathcal{a} = \\frac{1}{2}ab \\sin c \\end{align} \\begin{align} \\mathcal{a} = \\frac{1}{2}ac \\sin b \\end{align} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/07_03.html",
    "title": "The Conic Sections and Nonlinear Systems",
    "body": " index search search back the conic sections and nonlinear systems contents characteristics eccentricity parabola ellipse circle hyperbola nonlinear systems characteristics the conic sections in this chapter have equations that can be written in the form: \\begin{align} ax^2 + dx + cy^2 + ey + f = 0 \\end{align} where either \\(a\\) or \\(c\\) must be nonzero. the special characteristics of each conic section are summarizeed in the following table. the chart summarizes our work with conic sections: eccentricity a conic is the set of all points \\(p(x, y)\\) in a plane such that the ratio of the distance from \\(p\\) to a fixed point and the distance from \\(p\\) to a fixed line is constant. the constant ratio is called the ecccentricity of the conic, written \\(e\\). parabola if the conic is a parabola, then by definition, the distances \\(d(p, f)\\) and \\(d(p, d)\\) are equal, thus every parabola has eccentricity \\(1\\). ellipse for an ellipse, eccentricity is a measure of its \"roundness\". the constant ratio in the definition is \\(e = \\frac{c}{a}\\), where \\(c\\) is the distance from the center of the figure to a focus and \\(a\\) is the distance from the center to a vertex. by the definition of an ellipse, \\(a^2 > b^2\\) and \\(c = \\sqrt{a^2 - b^2}\\). thus, for the ellipse: \\begin{align} 0 < c < a \\end{align} divide by \\(a\\): \\begin{align} 0 < \\frac{c}{a} < 1 \\end{align} where \\(e = \\frac{c}{a}\\): \\begin{align} 0 < e < 1 \\end{align} circle in the circle the foci coincide with the center such that \\(a = b\\) and \\(c = \\sqrt{a^2 - b^2} = 0\\) and therefore \\(e = \\frac{c}{a} = 0\\). hyperbola the hyperbola also has eccentricity \\(e = \\frac{c}{a}\\). by definition \\(c = \\sqrt{a^2 + b^2} > a\\), so: \\begin{align} 0 < a < c \\end{align} divide by \\(a\\): \\begin{align} 0 < 1 < \\frac{a}{c} \\end{align} \\begin{align} 0 < 1 < e \\end{align} therefore \\(e > 1\\). such that narrow hyperbolas have \\(e\\) near \\(1\\) and wide hyperbolas have a large value of \\(e\\). nonlinear systems a nonlinear system of equations can have any number of solutions. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/09_02.html",
    "title": "Sum and Difference Identities",
    "body": " index search search back sum and difference identities contents cosine sum and difference identities sine and tangent sum and difference identities cosine sum and difference identities let \\(s\\) and \\(q\\) be the points where the terminal sides of angles \\(a\\) and \\(b\\), respectively, intersect the circle. locate point \\(r\\) on the unit circle so that angle \\(por\\) equals the difference \\(a - b\\). see figure 5. we know: \\(q\\) has coordinates \\((\\cos b, \\sin b)\\) \\(s\\) has coordinates \\((\\cos a, \\sin a)\\) \\(r\\) has coordinates \\((\\cos (a - b), \\sin (a - b))\\) angle \\(soq\\) also equals \\(a - b\\). since the central angles \\(soq\\) and \\(por\\) are equal, chords \\(pr\\) and \\(sq\\) are equal. by the distance formula: \\begin{align} \\sqrt{[\\cos (a - b) - 1]^2 + [\\sin(a - b) - 0]^2} = \\sqrt{(\\cos a - \\cos b)^2 + (\\sin a - \\sin b)^2} \\end{align} \\begin{align} [\\cos (a - b) - 1]^2 + [\\sin(a - b) - 0]^2 = (\\cos a - \\cos b)^2 + (\\sin a - \\sin b)^2 \\end{align} \\begin{align} \\cos^2 (a - b)+ 1 - 2\\cos(a - b) + \\sin^2(a - b) = \\cos^2 a + \\cos^2 b - 2\\cos a \\cos b + \\sin^2 a + \\sin^2 b - 2\\sin a \\sin b \\end{align} because \\(\\sin^2 x + \\cos^2 x = 1\\) \\begin{align} 1 + 1 - 2\\cos(a - b) = 1 + 1 - 2\\cos a \\cos b - 2\\sin a \\sin b \\end{align} \\begin{align} -2\\cos(a - b) = - 2\\cos a \\cos b - 2\\sin a \\sin b \\end{align} \\begin{align} \\cos(a - b) = \\cos a \\cos b + \\sin a \\sin b \\end{align} for \\(\\cos (a + b)\\), rewrite \\(a + b\\) as \\(a - (- b)\\), and use the identity for \\(\\cos (a - b)\\): \\begin{align} \\cos(a + b) = \\cos(a - (-b)) = \\cos a \\cos (-b) + \\sin a \\sin (-b) \\end{align} given \\(\\cos (-x) = \\cos x\\) and \\(\\sin -x = - \\sin x\\), then: \\begin{align} = \\cos a \\cos b - \\sin a \\sin b \\end{align} sine and tangent sum and difference identities use the cofunction identity \\(\\sin \\theta = \\cos (\\frac{\\pi}{2} - \\theta)\\) and replace \\(\\theta\\) with \\(a + b\\): \\begin{align} \\sin (a + b) = \\cos \\left[\\frac{\\pi}{2} - (a + b)\\right] \\end{align} \\begin{align} = \\cos \\left[(\\frac{\\pi}{2} - a) - b)\\right] \\end{align} \\begin{align} = \\cos \\left(\\frac{\\pi}{2} - a\\right)\\cos b + \\sin \\left(\\frac{\\pi}{2} - a\\right) \\sin b \\end{align} we apply the cofunction identity again for \\(\\cos \\left(\\frac{\\pi}{2} - a\\right)\\) and \\(\\sin \\left(\\frac{\\pi}{2} - a\\right)\\): \\begin{align} = \\sin a\\cos b + \\cos a \\sin b \\end{align} now we write \\(\\sin (a - b)\\) as \\(\\sin[a + (-b)]\\) and use the identity for \\(\\sin (a + b)\\): \\begin{align} \\sin (a - b) = \\sin (a + (-b)) = \\sin a\\cos (-b) + \\cos a \\sin (-b) \\end{align} given \\(\\cos (-x) = \\cos x\\) and \\(\\sin -x = - \\sin x\\), then: \\begin{align} = \\sin a\\cos b - \\cos a \\sin b \\end{align} to derive the identity for \\(\\tan (a + b)\\), proceed as follows \\begin{align} \\tan (a + b) = \\frac{\\sin (a + b)}{\\cos (a + b)} \\end{align} \\begin{align} = \\frac{\\sin a \\cos b + \\cos a \\sin b}{\\cos a \\cos b - \\sin a \\sin b} \\end{align} we multiply the numerator and denominator by \\(\\frac{1}{\\cos a \\cos b}\\): \\begin{align} = \\frac{\\frac{\\sin a \\cos b + \\cos a \\sin b}{\\cos a \\cos b}}{\\frac{\\cos a \\cos b - \\sin a \\sin b}{\\cos a \\cos b}} \\end{align} \\begin{align} = \\frac{\\frac{\\sin a \\cos b}{\\cos a \\cos b} + \\frac{\\cos a \\sin b}{\\cos a \\cos b}}{\\frac{\\cos a \\cos b}{\\cos a \\cos b} - \\frac{\\sin a \\sin b}{\\cos a \\cos b}} \\end{align} \\begin{align} = \\frac{\\frac{\\sin a}{\\cos a} + \\frac{\\sin b}{\\cos b}}{1 - \\frac{\\sin a \\sin b}{\\cos a \\cos b}} \\end{align} \\begin{align} = \\frac{\\tan a + \\tan b}{1 - \\tan a \\tan b} \\end{align} replacing \\(b\\) with \\(-b\\) and the fact that \\(\\tan (-b) = -\\tan b\\) gives the identity for the tangent of the difference of two numbers: \\begin{align} \\tan (a + b) = \\tan (a + (-b))= \\frac{\\tan a + \\tan (-b)}{1 - \\tan a \\tan (-b)} \\end{align} \\begin{align} = \\frac{\\tan a - \\tan b}{1 + \\tan a \\tan b} \\end{align} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/07_02.html",
    "title": "Ellipses and Hyperbolas",
    "body": " index search search back ellipses and hyperbolas contents ellipse standard forms of equations for ellipses translations of ellipses hyperbola standard forms of equations for hyperbolas translations of hyperbolas ellipse an ellipse is the set of all points in a plane, the sum of whose distances from two fixed points is constant. each fixed point is called a focus (plural, foci) of the ellipse. an ellipse has two axes of symmetry: the major axis (the longer one) and the minor axis (the shorter one). the foci are always located on the major axis. the midpoint of the major axis is the center of the ellipse, and the endpoints of the major axis are the vertices of the ellipse. a chord through a focus and perpendicular to the major axis is called a latus rectum. the graph of an ellipse is not the graph of a function. given an ellipse with center at the origin, foci \\(f(c, 0)\\) and \\(f′(-c, 0)\\), and vertices \\(v(a, 0)\\) and \\(v′(-a, 0)\\). from the previous image we know that the distance from \\(v\\) to \\(f\\) is \\(a - c\\) and the distance from \\(v\\) to \\(f′\\) is \\(a + c\\). the sum of these distances is \\(2a\\). since \\(v\\) is on the ellipse, all othe points must satisfy this distance, such that for any point \\(p(x, y)\\) on the ellipse: \\begin{align} d(p, f) + d(p, f') = 2a \\end{align} \\begin{align} \\sqrt{(x - c)^2 + y^2} + \\sqrt{(x + c)^2 + y^2} = 2a \\end{align} \\begin{align} \\sqrt{(x - c)^2 + y^2} = 2a - \\sqrt{(x + c)^2 + y^2} \\end{align} we now square each side: \\begin{align} (x - c)^2 + y^2 = 4a^2 - 4a\\sqrt{(x + c)^2 + y^2} + (x + c)^2 + y^2 \\end{align} \\begin{align} x^2 + c^2 - 2xc + y^2 = 4a^2 - 4a\\sqrt{(x + c)^2 + y^2} + x^2 + c^2 + 2xc + y^2 \\end{align} \\begin{align} - 4xc = 4a^2 - 4a\\sqrt{(x + c)^2 + y^2} \\end{align} \\begin{align} - xc = a^2 - a\\sqrt{(x + c)^2 + y^2} \\end{align} \\begin{align} xc + a^2 = a\\sqrt{(x + c)^2 + y^2} \\end{align} we square both sides again: \\begin{align} (xc + a^2)^2 = a^2\\left((x + c)^2 + y^2\\right) \\end{align} \\begin{align} x^2c^2 + a^4 + 2xca^2 = a^2\\left(x^2 + c^2 + 2xc + y^2\\right) \\end{align} \\begin{align} x^2c^2 + a^4 + 2xca^2 = a^2x^2 + a^2c^2 + 2xca^2 + a^2y^2 \\end{align} \\begin{align} x^2c^2 + a^4 = a^2x^2 + a^2c^2 + a^2y^2 \\end{align} \\begin{align} x^2c^2 - a^2x^2 - a^2y^2 = - a^4 + a^2c^2 \\end{align} \\begin{align} x^2(c^2 - a^2)- a^2y^2 = a^2 (-a^2 + c^2) \\end{align} we multiply both sides by \\(-1\\): \\begin{align} x^2(a^2 - c^2) + a^2y^2 = a^2 (a^2 - c^2) \\end{align} we divide both sides by \\(a^2(a^2 - c^2)\\): \\begin{align} \\frac{x^2}{a^2} + \\frac{y^2}{(a^2 - c^2)} = 1 \\end{align} which gives us the standard form equation for the ellipse with center on the origin, vertices \\((\\pm a, 0)\\) and foci \\((\\pm c, 0)\\). since \\(b(0, b)\\) is on the ellipse, then: \\begin{align} d(b, f) + d(b + f') = 2a \\end{align} \\begin{align} \\sqrt{(-c)^2 + b^2} + \\sqrt{c^2 + b^2} = 2a \\end{align} \\begin{align} 2\\sqrt{c^2 + b^2} = 2a \\end{align} we square both sides \\begin{align} 4(c^2 + b^2) = 4a^2 \\end{align} \\begin{align} c^2 + b^2 = a^2 \\end{align} \\begin{align} b^2 = a^2 - c^2 \\end{align} therefore, by sustuting on the ellipse formula we obtain: \\begin{align} \\frac{x^2}{a^2} + \\frac{y^2}{b^2} = 1 \\end{align} standard forms of equations for ellipses the ellipse with center at the origin and equation: \\begin{align} \\frac{x^2}{a^2} + \\frac{y^2}{b^2} = 1, (a > b > 0) \\end{align} has vertices \\((\\pm a, 0)\\), endpoints of the minor axis \\((0, \\pm b)\\) and foci \\((\\pm c, 0)\\) where \\(c^2 = a^2 - b^2\\) the ellipse with center at the origin and equation \\begin{align} \\frac{x^2}{b^2} + \\frac{y^2}{a^2} = 1, (a > b > 0) \\end{align} has vertices \\((0, \\pm a)\\), endpoints of the minor axis \\((\\pm b, 0)\\) and foci \\((0, \\pm c)\\) where \\(c^2 = a^2 - b^2\\) translations of ellipses an ellipse with center at \\((h, k)\\) where \\(b^2 = a^2 - c^2\\) with \\(a > b > 0\\) and \\(c > 0\\) satisfies one of the following equations: major axis: horizontal, foci \\((h \\pm c, k)\\) and vertices \\((h \\pm a, k)\\): \\begin{align} \\frac{(x - h)^2}{a^2} + \\frac{(y - k)^2}{b^2} = 1 \\end{align} major axis: vertical, foci \\((h, k \\pm c)\\) and vertices \\((h, k \\pm a)\\): \\begin{align} \\frac{(x - h)^2}{b^2} + \\frac{(y - k)^2}{a^2} = 1 \\end{align} hyperbola a hyperbola is the set of all points in a plane such that the absolute value of the difference of the distances from two fixed points is constant. the two fixed points are called the foci of the hyperbola. suppose a hyperbola has center at the origin and foci at \\(f'(- c, 0)\\) and \\(f(c, 0)\\). the midpoint of the segment \\(f′f\\) is the center of the hyperbola, and the points \\(v'(- a, 0)\\) and \\(v(a, 0)\\) are the vertices of the hyperbola. the line segment v'v is the transverse axis of the hyperbola. a chord through a focus and perpendicular to an extension of the transverse axis is a latus rectum. standard forms of equations for hyperbolas the hyperbola with center at the origin and equation \\begin{align} \\frac{x^2}{a^2} - \\frac{y^2}{b^2} = 1 \\end{align} has vertices \\((\\pm a, 0)\\), asymptotes \\(y = \\pm \\frac{b}{a}x\\) and foci \\((\\pm c, 0)\\) where \\(c^2 = a^2 + b^2\\). the hyperbola with center at the origin and equation \\begin{align} \\frac{y^2}{a^2} - \\frac{x^2}{b^2} = 1 \\end{align} has vertices \\((0, \\pm a)\\), asymptotes \\(y = \\pm \\frac{a}{b}x\\) and foci \\((0, \\pm c)\\) where \\(c^2 = a^2 + b^2\\). to explain the concept of asymptotes, we can start with the first equation for a hyperbola, where the foci are on the x-axis, and solve for \\(y\\): \\begin{align} \\frac{x^2}{a^2} - \\frac{y^2}{b^2} = 1 \\end{align} \\begin{align} \\frac{y^2}{b^2} = \\frac{x^2}{a^2} - 1 \\end{align} \\begin{align} \\frac{y^2}{b^2} = \\frac{x^2 - a^2}{a^2} \\end{align} \\begin{align} \\frac{y}{b} = \\pm \\frac{1}{a} \\sqrt{x^2 - a^2} \\end{align} \\begin{align} y = \\pm \\frac{b}{a} \\sqrt{x^2 - a^2} \\end{align} \\begin{align} y = \\pm \\frac{b}{a} \\frac{x}{x} \\sqrt{x^2 - a^2} \\end{align} \\begin{align} y = \\pm \\frac{b}{a} x \\sqrt{\\frac{x^2 - a^2}{x^2}} \\end{align} \\begin{align} y = \\pm \\frac{b}{a} x \\sqrt{\\frac{x^2}{x^2} - \\frac{a^2}{x^2}} \\end{align} \\begin{align} y = \\pm \\frac{b}{a} x \\sqrt{1 - \\frac{a^2}{x^2}} \\end{align} so when \\(x \\rightarrow \\infty\\) we know that \\(\\frac{a^2}{x^2} \\rightarrow 0\\) and thus: \\begin{align} y = \\pm \\frac{b}{a} x \\sqrt{1} \\end{align} \\begin{align} y = \\pm \\frac{b}{a} x \\end{align} which defines the asymptotes of the hyperbola. the lines are the extended diagonals of the rectangle whose vertices are \\((a, b)\\), \\((- a, b)\\), \\((a, - b)\\), and \\((- a, - b)\\). this rectangle is called the fundamental rectangle of the hyperbola. if the foci are on the y-axis the hyperbola is defined as follows: \\begin{align} y = \\pm \\frac{a}{b} x \\end{align} translations of hyperbolas a hyperbola with center \\((h, k)\\), where \\(c^2 = a^2 + b^2\\) is defined in one of two ways: traverse axis is horizontal, vertices are \\((h \\pm a, k)\\), foci are \\((h \\pm c, k)\\) and asymptotes are \\(y = \\pm \\frac{b}{a}(x - h) + k\\) \\begin{align} \\frac{(x - h)^2}{a^2} - \\frac{(y - k)^2}{b^2} = 1 \\end{align} traverse axis is verticsl, vertices are \\((k, h \\pm a)\\), foci are \\((k, h \\pm c)\\) and asymptotes are \\(y = \\pm \\frac{a}{b}(x - h) + k\\) \\begin{align} \\frac{(y - k)^2}{a^2} - \\frac{(x - h)^2}{b^2} = 1 \\end{align} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/08_05.html",
    "title": "The Circular Functions",
    "body": " index search search back the circular functions contents circular functions in figure 72, we start at the point \\((1, 0)\\) and measure an arc of length \\(s\\). if \\(s > 0\\), then the arc is measured in a counterclockwise direction, and if \\(s < 0\\), then the direction is clockwise. let the endpoint of this arc be at the point \\((x, y)\\). the circle in figure 72 is a unit circle —it has center at the origin and radius \\(1\\) unit. we know that \\(s = r \\theta\\), with \\(r = 1\\) then \\(s = \\theta\\). thus the trigonometric functions of angle \\(\\theta\\) in radians found by choosing a point \\((x, y)\\) on the unit circle can be rewritten as functions of the arc length \\(s\\), they are called circular functions. circular functions for any real number \\(s\\) represented by a directed arc on the unit circle \\(x^2 + y^2 = 1\\), the following definitions hold. \\begin{align} \\sin s = \\frac{y}{r} = y \\end{align} \\begin{align} \\cos s = \\frac{x}{r} = x \\end{align} \\begin{align} \\tan s = \\frac{y}{x}, x \\neq 0 \\end{align} \\begin{align} \\csc s = \\frac{r}{y} = \\frac{1}{y}, y \\neq 0 \\end{align} \\begin{align} \\sec s = \\frac{r}{x} = \\frac{1}{x}, x \\neq 0 \\end{align} \\begin{align} \\cot s = \\frac{x}{y}, y \\neq 0 \\end{align} so circular function values of real numbers are obtained in the same manner as trigonometric function values of angles measured in radians. we can use the following figure to easily obtain exact solutions to some angles: the diagram shown in figure 82 illustrates a correspondence that relates the right triangle ratio definitions of the trigonometric functions and the unit circle interpretation. the arc \\(sr\\) is the first-quadrant portion of the unit circle, and the standard-position angle \\(poq\\) is designated \\(\\theta\\). by definition, the coordinates of \\(p\\) are \\((cos \\theta, sin \\theta)\\). the six trigonometric functions of \\(\\theta\\) can be interpreted as lengths of line segments. for \\(\\cos \\theta\\) and \\(\\sin \\theta\\), use right triangle \\(poq\\) and right-triangle ratios: \\begin{align} \\cos \\theta = \\frac{\\text{adyacent}}{\\text{hypotenuse}} = \\frac{oq}{op} = \\frac{oq}{1} = oq \\end{align} \\begin{align} \\sin \\theta = \\frac{\\text{opposite}}{\\text{hypotenuse}} = \\frac{pq}{op} = \\frac{pq}{1} = pq \\end{align} for \\(\\tan \\theta\\) and \\(\\sec \\theta\\), use right triangle \\(vor\\) and right-triangle ratios: \\begin{align} \\tan \\theta = \\frac{\\text{opposite}}{\\text{adyacent}} = \\frac{vr}{or} = \\frac{vr}{1} = vr \\end{align} \\begin{align} \\sec \\theta = \\frac{\\text{hypotenuse}}{\\text{adyacent}} = \\frac{ov}{or} = \\frac{ov}{1} = ov \\end{align} for \\(\\csc \\theta\\) and \\(\\cot \\theta\\), first note that \\(us\\) and \\(or\\) are parallel. thus angle \\(suo\\) is equal to \\(\\theta\\): \\begin{align} \\csc \\theta = \\frac{\\text{hypotenuse}}{\\text{opposite}} = \\frac{ou}{os} = \\frac{ou}{1} = ou \\end{align} \\begin{align} \\cot \\theta = \\frac{\\text{adjacent}}{\\text{opposite}} = \\frac{us}{os} = \\frac{us}{1} = us \\end{align} figure 83 illustrates the results found above. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/09_03.html",
    "title": "Further Identities",
    "body": " index search search back further identities contents double-number identities product-to-sum identities sum-to-product identities half-number identities double-number identities the double-number identities, or double-angle identities, result from the sum identities when \\(a = b\\) so that \\(a + b = a + a = 2a\\). \\begin{align} \\cos 2a = \\cos(a + a) = \\cos a \\cos a - \\sin a \\sin a \\end{align} \\begin{align} = \\cos^2 a - \\sin^2 a \\end{align} two other common forms of this identity are obtained by substitution: \\begin{align} \\cos 2a = \\cos^2 a - \\sin^2 a = (1 - \\sin^2 a) - \\sin^2 a \\end{align} \\begin{align} 1 - 2\\sin^2 a \\end{align} and \\begin{align} \\cos 2a = \\cos^2 a - \\sin^2 a = \\cos^2 a - (1 - \\cos^2 a) \\end{align} \\begin{align} = 2\\cos^2 a - 1 \\end{align} we find \\(\\sin 2a\\) with the identity for \\(\\sin (a + b)\\) \\begin{align} \\sin 2a = \\sin (a + a) = \\sin a \\cos a + \\sin a \\cos a \\end{align} \\begin{align} = 2\\sin a \\cos a \\end{align} similarly, we use the identity for \\(\\tan (a + b)\\) to find \\(\\tan 2a\\). \\begin{align} \\tan 2a = \\tan (a + a) = \\frac{\\tan a + \\tan a}{1- \\tan a \\tan a} \\end{align} \\begin{align} = \\frac{2 \\tan a}{1 - \\tan^2 a} \\end{align} product-to-sum identities adding the identities for \\(\\cos (a + b)\\) and \\(\\cos (a - b)\\) gives the following: \\begin{align} \\cos (a + b) + \\cos (a - b) = \\cos a \\cos b - \\sin a \\sin b + \\cos a \\cos b + \\sin a \\sin b \\end{align} \\begin{align} = 2\\cos a \\cos b \\end{align} thus: \\begin{align} 2 \\cos a \\cos b = \\left[\\cos(a + b) + \\cos(a - b)\\right] \\end{align} \\begin{align} \\cos a \\cos b = \\frac{1}{2} \\left[\\cos(a + b) + \\cos(a - b)\\right] \\end{align} substracting \\(\\cos(a - b)\\) from \\(\\cos (a + b)\\) gives the following: \\begin{align} \\cos (a + b) - \\cos (a - b) = \\cos a \\cos b - \\sin a \\sin b - \\cos a \\cos b - \\sin a \\sin b \\end{align} \\begin{align} = -2 \\sin a \\sin b \\end{align} thus: \\begin{align} - 2 \\sin a \\sin b = \\left[\\cos(a + b) - \\cos(a - b)\\right] \\end{align} \\begin{align} 2 \\sin a \\sin b = -\\frac{1}{2} \\left[\\cos(a + b) - \\cos(a - b)\\right] \\end{align} \\begin{align} \\sin a \\sin b = \\frac{1}{2} \\left[\\cos(a - b) - \\cos(a + b)\\right] \\end{align} adding the identities for \\(\\sin (a + b)\\) and \\(\\sin (a - b)\\) gives the following: \\begin{align} \\sin(a + b) + \\sin (a - b) = \\sin a \\cos b + \\sin b \\cos a + \\sin a \\cos b - \\sin b \\cos a \\end{align} \\begin{align} = 2 \\sin a \\cos b \\end{align} thus: \\begin{align} 2 \\sin a \\cos b = \\sin (a + b) + \\sin (a - b) \\end{align} \\begin{align} \\sin a \\cos b = \\frac{1}{2} \\left[\\sin (a + b) + \\sin (a - b)\\right] \\end{align} substracting \\(\\sin (a - b)\\) from \\(\\sin (a + b)\\) gives the following: \\begin{align} \\sin(a + b) - \\sin (a - b) = \\sin a \\cos b + \\sin b \\cos a - \\sin a \\cos b + \\sin b \\cos a \\end{align} \\begin{align} = 2 \\sin b \\cos a \\end{align} thus: \\begin{align} 2 \\sin b \\cos a = \\sin (a + b) - \\sin (a - b) \\end{align} \\begin{align} \\sin b \\cos a = \\frac{1}{2} \\left[\\sin (a + b) - \\sin (a - b)\\right] \\end{align} sum-to-product identities from the previous identities we can derive another group of identities. for the sum of sines we have: \\begin{align} \\sin a + \\sin b = \\sin (\\frac{2a}{2} + \\frac{b - b}{2}) + \\sin (\\frac{2b}{2} + \\frac{a - a}{2}) \\end{align} \\begin{align} = \\sin (\\frac{(a + b) + (a - b)}{2}) + \\sin (\\frac{(a + b) - (a - b)}{2}) \\end{align} if \\(x = \\frac{a + b}{2}\\) and \\(y = \\frac{a - b}{2}\\), then \\begin{align} = \\sin (x + y) + \\sin (x - y) \\end{align} by the product to sum identity we have: \\begin{align} = 2 (\\sin x \\cos y) = 2 \\sin(\\frac{a + b}{2}) \\cos(\\frac{a - b}{2}) \\end{align} for the difference of sines we have: \\begin{align} \\sin a - \\sin b = \\sin (\\frac{2a}{2} + \\frac{b - b}{2}) - \\sin (\\frac{2b}{2} + \\frac{a - a}{2}) \\end{align} \\begin{align} = \\sin (\\frac{(a + b) + (a - b)}{2}) - \\sin (\\frac{(a + b) - (a - b)}{2}) \\end{align} if \\(x = \\frac{a + b}{2}\\) and \\(y = \\frac{a - b}{2}\\), then \\begin{align} = \\sin (x + y) - \\sin (x - y) \\end{align} by the product to sum identity we have: \\begin{align} = 2 (\\cos x \\sin y) = 2 \\cos(\\frac{a + b}{2}) \\sin(\\frac{a - b}{2}) \\end{align} for the sum of cosines we have: \\begin{align} \\cos a + \\cos b = \\cos (\\frac{2a}{2} + \\frac{b - b}{2}) + \\cos (\\frac{2b}{2} + \\frac{a - a}{2}) \\end{align} \\begin{align} = \\cos (\\frac{(a + b) + (a - b)}{2}) + \\cos (\\frac{(a + b) - (a - b)}{2}) \\end{align} if \\(x = \\frac{a + b}{2}\\) and \\(y = \\frac{a - b}{2}\\), then \\begin{align} = 2 \\cos (x + y) + \\cos (x - y) \\end{align} by the product to sum identity we have: \\begin{align} = 2 (\\cos x \\cos y) = 2 \\cos(\\frac{a + b}{2}) \\cos(\\frac{a - b}{2}) \\end{align} for the difference of cosines we have: \\begin{align} \\cos a - \\cos b = \\cos (\\frac{2a}{2} + \\frac{b - b}{2}) - \\cos (\\frac{2b}{2} + \\frac{a - a}{2}) \\end{align} \\begin{align} = \\cos (\\frac{(a + b) + (a - b)}{2}) - \\cos (\\frac{(a + b) - (a - b)}{2}) \\end{align} if \\(x = \\frac{a + b}{2}\\) and \\(y = \\frac{a - b}{2}\\), then \\begin{align} = \\cos (x + y) - \\cos (x - y) \\end{align} by the product to sum identity we have: \\begin{align} = -2 (\\sin x \\sin y) = -2 \\sin(\\frac{a + b}{2}) \\sin(\\frac{a - b}{2}) \\end{align} half-number identities we derive identities for \\(\\sin \\frac{a}{2}\\), \\(\\cos \\frac{a}{2}\\) and \\(\\tan \\frac{a}{2}\\). these are known as half-number identities, or half-angle identities. we derive the identity for \\(\\cos \\frac{a}{2}\\) as follows: \\begin{align} \\cos 2x = 2 \\cos^2 x - 1 \\end{align} \\begin{align} \\cos 2x + 1 = 2 \\cos^2 x \\end{align} \\begin{align} \\cos x = \\pm \\sqrt{\\frac{1 + \\cos 2x}{2}} \\end{align} now we replace \\(x\\) with \\(\\frac{a}{2}\\), such that: \\begin{align} \\cos \\frac{a}{2} = \\pm \\sqrt{\\frac{1 + \\cos a}{2}} \\end{align} we derive the identity for \\(\\sin \\frac{a}{2}\\) as follows: \\begin{align} \\cos 2x = 1 - 2 \\sin^2 x \\end{align} \\begin{align} \\frac{1 - \\cos 2x}{2} = \\sin^2 x \\end{align} \\begin{align} \\sin x = \\pm \\sqrt{\\frac{1 - \\cos 2x}{2}} \\end{align} now we replace \\(x\\) with \\(\\frac{a}{2}\\) to obtain: \\begin{align} \\sin \\frac{a}{2} = \\pm \\sqrt{\\frac{1 - \\cos a}{2}} \\end{align} an identity for \\(\\tan \\frac{a}{2}\\) comes from the half-number identities for sine and cosine. \\begin{align} \\tan {\\frac{a}{2}} = \\frac{\\sin \\frac{a}{2}}{\\cos \\frac{a}{2}} \\end{align} \\begin{align} = \\frac{\\pm \\sqrt{\\frac{1 - \\cos a}{2}}}{\\pm \\sqrt{\\frac{1 + \\cos a}{2}}} \\end{align} \\begin{align} = \\pm \\sqrt{\\frac{\\frac{1 - \\cos a}{2}}{\\frac{1 + \\cos a}{2}}} = \\pm \\sqrt{\\frac{1 - \\cos a}{1 + \\cos a}} \\end{align} we derive an alternative identity for \\(\\tan \\frac{a}{2}\\) by using double-number identities. \\begin{align} \\tan \\frac{a}{2} = \\frac{\\sin \\frac{a}{2}}{\\cos \\frac{a}{2}} \\end{align} we multiply by \\(2 \\cos \\frac{a}{2}\\) on both the numerator and the denominator: \\begin{align} = \\frac{2 \\sin \\frac{a}{2} \\cos \\frac{a}{2}}{2 \\cos^2 \\frac{a}{2}} \\end{align} we apply the double-number identity \\(\\sin 2a = 2 \\sin a \\cos a\\) and \\(\\cos 2a = 2 \\cos^2 a - 1\\): \\begin{align} = \\frac{\\sin \\left[2 \\frac{a}{2}\\right]}{1 + \\cos\\left[2 \\frac{a}{2}\\right]} \\end{align} \\begin{align} = \\frac{\\sin a}{1 + \\cos a} \\end{align} if we multiply this identity by \\(\\frac{1 - \\cos a}{1 - \\cos a}\\) we obtain: \\begin{align} = \\frac{(\\sin a)(1 - \\cos a)}{(1 + \\cos a) (1 - \\cos a)} \\end{align} \\begin{align} = \\frac{(\\sin a)(1 - \\cos a)}{1 - \\cos^2 a} \\end{align} given \\(\\cos^2 x + \\sin^2 x = 1\\): \\begin{align} = \\frac{(\\sin a)(1 - \\cos a)}{\\sin^2 a} \\end{align} \\begin{align} = \\frac{1 - \\cos a}{\\sin a} \\end{align} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/06_05.html",
    "title": "Determinants and Cramer's Rule",
    "body": " index search search back determinants and cramer's rule contents [[#determinants of \\(2 \times 2\\) matrices|determinants of \\(2 \times 2\\) matrices]] [[#determinants of \\(3 \times 3\\) matrices|determinants of \\(3 \times 3\\) matrices]] cofactor [[#cramer's rule for \\(2 \times 2\\) systems|cramer's rule for \\(2 \times 2\\) systems]] determinants of \\(2 \\times 2\\) matrices the determinant of a \\(2 \\times 2\\) matrix \\(a\\) is a real number defined as \\(det(a) = a_{11} a_{22}− a_{21} a_{12}\\). determinants of \\(3 \\times 3\\) matrices the determinant of a \\(3 \\times 3\\) matrix \\(a\\) is a real number defined as \\(det(a) = (a_{11}a_{22}a_{33} + a_{12} a_{23} a_{31} + a_{13} a_{21}a_{32}) − (a_{31}a_{22}a_{13} + a_{32} a_{23} a_{11} + a_{33} a_{21}a_{12})\\). cofactor let \\(m_{ij}\\) be the minor for element \\(a_{ij}\\) in an \\(n \\times n\\) matrix. the cofactor of \\(a_{ij}\\), written \\(a_{ij}\\), is defined as follows. \\begin{align} a_{ij} = (-1)^{i + j} \\cdot m_{ij} \\end{align} cramer's rule for \\(2 \\times 2\\) systems the solution of the system: \\begin{align} a_1x + b_1y = c_1 \\end{align} \\begin{align} a_2x + b_2y = c_2 \\end{align} is given by: \\begin{align} x = \\frac{d_x}{d}, y = \\frac{d_y}{d} \\end{align} where: \\begin{align} d_x = det( \\begin{bmatrix} c_1 & b_1 \\\\ c_2 & b_2 \\\\ \\end{bmatrix}) \\end{align} \\begin{align} d_y = det( \\begin{bmatrix} a_1 & c_1 \\\\ a_2 & c_2 \\\\ \\end{bmatrix}) \\end{align} \\begin{align} d = det( \\begin{bmatrix} a_1 & b_1 \\\\ a_2 & b_2 \\\\ \\end{bmatrix}) \\neq 0 \\end{align} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/06_02.html",
    "title": "Solutions of Linear Systems in Three Variables",
    "body": " index search search back solutions of linear systems in three variables we can extend the ideas of systems of equations in two variables to linear equations of the form: \\begin{align} ax + by + cz = d \\end{align} considering the possible intersections of the planes representing three equations in three unknowns shows that the solution set of such a system may be either a single ordered triple \\((x, y, z)\\), an infinite set of ordered triples (dependent equations), or the empty set (an inconsistent system). the following steps can be used to solve a linear system with three variables. eliminate a variable from any two of the equations. eliminate the same variable from a different pair of equations. eliminate a second variable using the resulting two equations in two variables to get an equation with just one variable. find the values of the remaining variables by substitution. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/06_03.html",
    "title": "Solution of Linear Systems by Row Transformations",
    "body": " index search search back solution of linear systems by row transformations contents matrix row transformations row echelon method reduced row echelon method special cases solving linear systems of equations can be streamlined by using matrices. consider a system of three equations and three unknowns. \\begin{align} a_1 x + b_1y + c_1z = d_1 \\end{align} \\begin{align} a_2 x + b_2y + c_2z = d_2 \\end{align} \\begin{align} a_3 x + b_3y + c_3z = d_3 \\end{align} can be written as the following augmented matrix: \\begin{align} \\begin{bmatrix} a_1 & b_1 & c_1 & d_1 \\\\ a_2 & b_2 & c_2 & d_2 \\\\ a_3 & b_3 & c_3 & d_3 \\\\ \\end{bmatrix} \\end{align} matrix row transformations for any augmented matrix of a system of linear equations, the following row transformations will result in the matrix of an equivalent system. any two rows may be interchanged. the elements of any row may be multiplied by a nonzero real number. any row may be changed by adding to its elements a multiple of the corresponding elements of another row. row echelon method the echelon (triangular) form of an augmented matrix has 1s down the diagonal from upper left to lower right and 0s below each 1. once a system of linear equations is in echelon form, back-substitution can be used to find the solution set. the row echelon method uses matrices to solve a system of linear equations. start by obtaining a 1 as the first entry in the first column and then transform all entries below it to a 0. continue through the columns obtaining a 1 as the second entry in the second column (zeros below), the third entry in the third column (zeros below), and so on. repeat this process to row echelon form. the following matrix is an augmented matrix in row echelon form: \\begin{align} \\begin{bmatrix} 1 & 2 & 3 & 4\\\\ 0 & 5 & 6 & 7\\\\ 0 & 0 & 0 & 9\\\\ \\end{bmatrix} \\end{align} reduced row echelon method the reduced row echelon form has 1s along the main diagonal and 0s both below and above. for example \\begin{align} \\begin{bmatrix} 1 & 1 & 1 & 6\\\\ 2 & -1 & 1 & 5\\\\ 3 & 1 & -1 & 9\\\\ \\end{bmatrix} \\end{align} by using row transformations, this augmented matrix can be transformed to \\begin{align} \\begin{bmatrix} 1 & 0 & 0 & 3\\\\ 0 & 1 & 0 & 2\\\\ 0 & 0 & 1 & 1\\\\ \\end{bmatrix} \\end{align} which represents \\(x = 3, y = 2, z = 1\\). there is no need for back-substitution with reduced row echelon form. special cases whenever a row of the augmented matrix is of the form \\begin{align} \\begin{bmatrix} 0 & 0 & \\cdots & a\\\\ \\end{bmatrix} \\end{align} where \\(a \\neq 0\\) the system is inconsistent and there will be no solution. a row of the matrix of a linear system in the form: \\begin{align} \\begin{bmatrix} 0 & 0 & \\cdots & 0\\\\ \\end{bmatrix} \\end{align} indicates that the equations of the system are dependent. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/10_03.html",
    "title": "Vectors and Their Applications",
    "body": " index search search back vectors and their applications contents basic terminology interpretation of vectors properties of parallelograms vector operations vector notation using i and j dot product and the angle between vectors properties of the dot product geometric interpretation of the dot product basic terminology vector quantitites are defined by their magnitude and their direction. they are represented by a directed line segment, called a vector, whose length represents the magnitude. when two letters (i.e. op) name a vector, the first indicates the initial point, while the second one indicates the terminal point. the magnitude of a vector \\(\\textbf{op}\\) is written \\(|\\textbf{op}|\\) two vectors are equal if and only if they both have the same direction and the same magnitude. the sum of two vectors is also a vector. there are two ways to geometrically find the sum of two vectors \\(\\textbf{a}\\) and \\(\\textbf{b}\\). place the initial point of vector \\(\\textbf{b}\\) at the terminal point of vector \\(\\textbf{a}\\) (figure 22). the vector with the same initial point as \\(\\textbf{a}\\) and the same terminal point as \\(\\textbf{b}\\) is the sum \\(\\textbf{a} + \\textbf{b}\\) use the parallelogram rule. place vectors \\(\\textbf{a}\\) and \\(\\textbf{b}\\) so that their initial points coincide (figure 23). then complete the parallelogram. the diagonal of the parallelogram with the same initial point as \\(\\textbf{a}\\) and \\(\\textbf{b}\\) is the sum \\(\\textbf{a} + \\textbf{b}\\). vector addition is commutative. for every vector \\(\\textbf{v}\\) there is a vector \\(-\\textbf{v}\\) that has the same magnitude as \\(\\textbf{v}\\) but opposite direction, and is called the opposite of \\(\\textbf{v}\\) (figure 24). the sum of \\(\\textbf{v}\\) and \\(-\\textbf{v}\\) hsa magnitude \\(0\\) and is called the zero vector. to substract vector \\(\\textbf{b}\\) from vector \\(\\textbf{a}\\) find the vector sum \\(\\textbf{a} + (-\\textbf{b})\\) (figure 25). the product of a scalar \\(k\\) and a vector \\(\\textbf{u}\\) is called scalar multiplication. the vector \\(k\\textbf{u}\\) has magnitude \\(k|\\textbf{u}|\\). the vector \\(k\\textbf{u}\\) has the same direction as \\(\\textbf{u}\\) if \\(k > 0\\) and opposite direction if \\(k < 0\\) (figure 26). interpretation of vectors a vector with its initial point at the origin in a rectrangular coordinate system is called a position vector. the position vector \\(\\textbf{u}\\) with its endpoint at the point \\((a, b)\\) is written \\(\\langle a, b \\rangle\\). every vector in the real plane corresponds to an ordered pair of real numbers. geometrically a vector is a directed line segment and algebraically it is an ordered pair, where \\(a\\) is the horizontal component and \\(b\\) is the vertical component of vector \\(\\textbf{u}\\). figure 27 shows the vector \\(\\textbf{u} = \\langle a, b \\rangle\\). the positive angle between the x-axis and the position vector is called the direction angle of the vector. the maginutde of vector \\(\\textbf{u} = \\langle a, b \\rangle\\) is given by: \\begin{align} |\\textbf{u}| = \\sqrt{a^2 + b^2} \\end{align} the direction angle \\(\\theta\\) satisfies \\(\\tan \\theta = \\frac{b}{a}\\) where \\(a \\neq 0\\). a vector \\(\\textbf{u}\\) with magnitude \\(|\\textbf{u}|\\) and direction angle \\(\\theta\\) has as horizontal component: \\begin{align} a = |\\textbf{u}| \\cos \\theta \\end{align} and as vertical component: \\begin{align} b = |\\textbf{u}| \\sin \\theta \\end{align} therefore \\(\\textbf{u} = \\langle a, b \\rangle = \\langle |\\textbf{u}| \\cos \\theta, |\\textbf{u}| \\sin \\theta \\rangle\\) properties of parallelograms a parallelogram is quadrilateral whose opposite sides are parallel the opposite sides and opposite angles of a parallelogram are equal, and adjacent angles of a parallelogram are supplementary. the diagonals of a parallelogram bisect each other, but do not necessarily bisec the angles of the parallelogram. vector operations let \\(a, b, c, d\\) and \\(k\\) be real numbers: \\begin{align} \\langle a, b \\rangle + \\langle c, d \\rangle = \\langle a + c, b + d \\rangle \\end{align} \\begin{align} k\\langle a, b \\rangle = \\langle ka, kb \\rangle \\end{align} \\begin{align} \\langle a, b \\rangle - \\langle c, d \\rangle= \\langle a, b \\rangle + -\\langle c, d \\rangle = \\langle a - c, b - d \\rangle \\end{align} a unit vector is a vector that has magnitude \\(1\\). two important unit vectors are: \\begin{align} \\textbf{i} = \\langle 1, 0 \\rangle \\end{align} \\begin{align} \\textbf{j} = \\langle 0, 1 \\rangle \\end{align} vector notation using \\(i\\) and \\(j\\) if \\(\\textbf{v} = \\langle a, b \\rangle\\) then \\(\\textbf{v} = a \\textbf{i} + b \\textbf{j}\\) dot product and the angle between vectors the dot product (or inner product) of two vectors \\(\\textbf{u} = \\langle a, b \\rangle\\) and \\(\\textbf{v} = \\langle c, d \\rangle\\) id denoted as \\(\\textbf{u} \\cdot \\textbf{v}\\) and given by the following: \\begin{align} \\textbf{u} \\cdot \\textbf{v} = ac + bd \\end{align} properties of the dot product for all vectors \\(\\textbf{u}\\), \\(\\textbf{v}\\) and \\(\\textbf{w}\\) and real numbers \\(k\\) the following hold: \\(\\textbf{u} \\cdot \\textbf{v} = \\textbf{v} \\cdot \\textbf{u}\\) \\(\\textbf{u} \\cdot (\\textbf{v} + \\textbf{w}) = \\textbf{u} \\cdot \\textbf{v} + \\textbf{u} \\cdot \\textbf{w}\\) \\((\\textbf{u} + \\textbf{v}) \\cdot \\textbf{w} = \\textbf{u} \\cdot \\textbf{w} + \\textbf{v} \\cdot \\textbf{w}\\) \\((k \\textbf{u}) \\cdot \\textbf{v} = k(\\textbf{u} \\cdot \\textbf{v}) = \\textbf{u} \\cdot (k \\textbf{v})\\) \\(0 \\cdot \\textbf{u} = 0\\) \\(\\textbf{u} \\cdot \\textbf{u} = |\\textbf{u}|^2\\) the dot product of two vectors can be positive, \\(0\\) or negative based on the angle between them. if \\(\\textbf{a} \\cdot \\textbf{b} = 0\\) for two nonzero vectors \\(\\textbf{a}\\) and \\(\\textbf{b}\\), then \\(\\cos \\theta = 0\\) and \\(\\theta = 90º\\). thus \\(\\textbf{a}\\) and \\(\\textbf{b}\\) are perpendiular or orthogonal vectors (figure 40). geometric interpretation of the dot product if \\(\\theta\\) is the angle between the two nonzero vectors \\(\\textbf{u}\\) and \\(\\textbf{v}\\), where \\(0º \\leq \\theta \\leq 180º\\) then the following holds: \\begin{align} \\textbf{u} \\cdot \\textbf{v} = |\\textbf{u}||\\textbf{v}| \\cos \\theta \\end{align} or equivalently \\begin{align} \\cos \\theta = \\frac{\\textbf{u}\\textbf{v}}{|\\textbf{u}||\\textbf{v}|} \\end{align} for angles \\(\\theta\\) between \\(0º\\) and \\(180º\\), the following table shows the relationship between \\(\\cos \\theta\\), the dot product and \\(\\theta\\). \\(\\cos \\theta\\) dot product angle \\(\\theta\\) between vectors positive positive acute \\(0\\) \\(0\\) right negative negative obtuse $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/08_03.html",
    "title": "Right Triangles and Evaluating Trigonometric Functions",
    "body": " index search search back right triangles and evaluating trigonometric functions contents right-triangle definitions of the trigonometric functions trigonometric function values of special angles cofunction identities reference angles [[#finding trigonometric function values for a nonquadrantal angle \\(\theta\\)|finding trigonometric function values for a nonquadrantal angle \\(\theta\\)]] right-triangle definitions of the trigonometric functions figure 41 shows an acute angle \\(a\\) in standard position. the side of length \\(y\\) in figure 41 is called the side opposite angle \\(a\\), and the side of length \\(x\\) is called the side adjacent to angle \\(a\\). such that: \\begin{align} \\sin a = \\frac{y}{r} = \\frac{\\text{side opposite}}{\\text{hypotenuse}} \\end{align} \\begin{align} \\cos a = \\frac{x}{r} = \\frac{\\text{side adjacent}}{\\text{hypotenuse}} \\end{align} \\begin{align} \\tan a = \\frac{y}{x} = \\frac{\\text{side opposite}}{\\text{side adjacent}} \\end{align} \\begin{align} \\csc a = \\frac{r}{y} = \\frac{\\text{hypotenuse}}{\\text{side opposite}} \\end{align} \\begin{align} \\sec a = \\frac{r}{x} = \\frac{\\text{hypotenuse}}{\\text{side adjacent}} \\end{align} \\begin{align} \\cot a = \\frac{x}{y} = \\frac{\\text{side adjacent}}{\\text{side opposite}} \\end{align} trigonometric function values of special angles certain special angles, such as \\(30º, 45º\\) and \\(60º\\) occur so often that they deserve special study. see figure 43(a), for convenience the length of the sides is \\(2\\). bisecting one angle of this equilateral triangle leads to two right triangles, each of which has angles of \\(30°, 60°\\), and \\(90°\\), as shown in figure 43(b). let \\(x\\) represent the length of the longer leg: \\begin{align} 2^2 = 1^2 + x^2 \\end{align} \\begin{align} 4 = 1 + x^2 \\end{align} \\begin{align} 3 = x^2 \\end{align} \\begin{align} \\sqrt{3} = x \\end{align} therefore the hypotenuse is \\(2\\), the side opposite is \\(1\\) and the side adjacent is \\(\\sqrt{3}\\). from the definition of the trigonometric functions: \\begin{align} \\sin 30º = \\frac{\\text{side opposite}}{\\text{hypotenuse}} = \\frac{1}{2} \\end{align} \\begin{align} \\cos 30º = \\frac{\\text{side adjacent}}{\\text{hypotenuse}} = \\frac{\\sqrt{3}}{2} \\end{align} \\begin{align} \\tan 30º = \\frac{\\text{side opposite}}{\\text{side adjacent}} = \\frac{\\sqrt{3}}{3} \\end{align} \\begin{align} \\csc 30º = \\frac{\\text{hypotenuse}}{\\text{side opposite}} = \\frac{2}{1} = 2 \\end{align} \\begin{align} \\sec 30º = \\frac{\\text{hypotenuse}}{\\text{side adjacent}} = \\frac{2\\sqrt{3}}{3} \\end{align} \\begin{align} \\cot 30º = \\frac{\\text{side adjacent}}{\\text{side opposite}} = \\frac{\\sqrt{3}}{1} = \\sqrt{3} \\end{align} for \\(60º\\) refer to figure 44, such that hypotenuse is \\(2\\), side opposite is \\(\\sqrt{3}\\) and side adjacent is \\(1\\). therefore from the definition of the trigonometric functions: \\begin{align} \\sin 60º = \\frac{\\text{side opposite}}{\\text{hypotenuse}} = \\frac{\\sqrt{3}}{2} \\end{align} \\begin{align} \\cos 60º = \\frac{\\text{side adjacent}}{\\text{hypotenuse}} = \\frac{1}{2} \\end{align} \\begin{align} \\tan 60º = \\frac{\\text{side opposite}}{\\text{side adjacent}} = \\frac{\\sqrt{3}}{1} = \\sqrt{3} \\end{align} \\begin{align} \\csc 60º = \\frac{\\text{hypotenuse}}{\\text{side opposite}} = \\frac{2\\sqrt{3}}{3} \\end{align} \\begin{align} \\sec 60º = \\frac{\\text{hypotenuse}}{\\text{side adjacent}} = \\frac{2}{1} = 2 \\end{align} \\begin{align} \\cot 60º = \\frac{\\text{side adjacent}}{\\text{side opposite}} = \\frac{\\sqrt{3}}{3} \\end{align} for \\(45º\\) we start with a \\(45º-45º\\) right triangle as shown in figure 45. this triangle has two equal sides whose length is \\(1\\) unit. therefore, by the pythagoread theorem: \\begin{align} 1^2 + 1^2 = r^2 \\end{align} \\begin{align} r = \\sqrt{2} \\end{align} that is the hypotenuse is \\(\\sqrt{2}\\), the side opposite is \\(1\\) and the side adjacent is \\(1\\), so from the definition of the trigonometric functions: \\begin{align} \\sin 45º = \\frac{\\text{side opposite}}{\\text{hypotenuse}} = \\frac{1}{\\sqrt{2}} = \\frac{\\sqrt{2}}{2} \\end{align} \\begin{align} \\cos 45º = \\frac{\\text{side adjacent}}{\\text{hypotenuse}} = \\frac{1}{\\sqrt{2}} = \\frac{\\sqrt{2}}{2} \\end{align} \\begin{align} \\tan 45º = \\frac{\\text{side opposite}}{\\text{side adjacent}} = \\frac{1}{1} = 1 \\end{align} \\begin{align} \\csc 45º = \\frac{\\text{hypotenuse}}{\\text{side opposite}} = \\frac{\\sqrt{2}}{1} = \\sqrt{2} \\end{align} \\begin{align} \\sec 45º = \\frac{\\text{hypotenuse}}{\\text{side adjacent}} = \\frac{\\sqrt{2}}{1} = \\sqrt{2} \\end{align} \\begin{align} \\cot 45º = \\frac{\\text{side adjacent}}{\\text{side opposite}} = \\frac{1}{1} = 1 \\end{align} cofunction identities in a right triangle \\(abc\\) with right angle \\(c\\), the acute angles \\(a\\) and \\(b\\) are complementary. see figure 46. the length of the side opposite angle \\(a\\) is \\(a\\), and the length of the side opposite angle \\(b\\) is \\(b\\). the length of the hypotenuse is \\(c\\). in this triangle, \\(\\sin a = \\frac{a}{c}\\) and \\(\\cos b\\) is also equal to \\(\\frac{a}{c}\\). similar reasoning yields the following. \\begin{align} \\tan a = \\frac{a}{b} = \\cot b \\end{align} \\begin{align} \\sec a = \\frac{c}{b} = \\csc b \\end{align} if these identities follow we say \\(\\sin\\) and \\(\\cos\\) are cofunctions, as well as \\(\\tan\\) and \\(\\cot\\) and \\(\\sec\\) and \\(\\csc\\). since angles \\(a\\) and \\(b\\) are complementary \\(a + b = 90º\\), that is \\(b = 90º - a\\), therefore: \\begin{align} \\sin a = \\cos b = \\cos (90º - a) \\end{align} this is a cofunction identity, the rest are as follows: given an acute angle \\(a\\) in degrees: \\begin{align} \\cos a = \\sin b = \\sin (90º - a) \\end{align} \\begin{align} \\tan a = \\cot b = \\cot (90º - a) \\end{align} \\begin{align} \\csc a = \\sec b = \\sec (90º - a) \\end{align} \\begin{align} \\sec a = \\csc b = \\csc (90º - a) \\end{align} \\begin{align} \\cot a = \\tan b = \\tan (90º - a) \\end{align} given an acute angle \\(a\\) is radians: \\begin{align} \\sin a = \\cos b = \\cos \\left(\\frac{\\pi}{2} - a\\right) \\end{align} \\begin{align} \\cos a = \\sin b = \\sin \\left(\\frac{\\pi}{2} - a\\right) \\end{align} \\begin{align} \\tan a = \\cot b = \\cot \\left(\\frac{\\pi}{2} - a\\right) \\end{align} \\begin{align} \\csc a = \\sec b = \\sec \\left(\\frac{\\pi}{2} - a\\right) \\end{align} \\begin{align} \\sec a = \\csc b = \\csc \\left(\\frac{\\pi}{2} - a\\right) \\end{align} \\begin{align} \\cot a = \\tan b = \\tan \\left(\\frac{\\pi}{2} - a\\right) \\end{align} reference angles a reference angle for an angle \\(\\theta\\), written \\(\\theta'\\), is the positive acute angle made by the terminal side of angle \\(\\theta\\) and the x-axis. if an angle \\(\\theta\\) is negative or has measure greater than \\(360°\\), its reference angle is found by first finding its coterminal angle that is between \\(0°\\) and \\(360°\\). finding trigonometric function values for a nonquadrantal angle \\(\\theta\\) if \\(\\theta > 360°\\), or if \\(\\theta < 0°\\), then find a coterminal angle. find the reference angle \\(\\theta'\\). find the trigonometric function values for reference angle \\(\\theta'\\). determine the correct signs for the values, given by the quadrant of \\(\\theta\\). $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/06_06.html",
    "title": "Solution of Linear Systems by Matrix Inverses",
    "body": " index search search back solution of linear systems by matrix inverses contents multiplicative inverses of square matrices using determinants to find inverses solving linear systems using inverse matrices multiplicative inverses of square matrices in a similar way, if \\(a\\) is an \\(n \\times n\\) matrix, then its multiplicative inverse, written \\(a^{-1}\\), must satisfy both: \\begin{align} aa^{-1} = a^{-1}a = i_n \\end{align} this result means that only a square matrix can have a multiplicative inverse. the inverse matrix of an \\(n \\times n\\) matrix \\(a\\) (if it exists) can be found analytically by first forming the augmented matrix \\([a|i_n]\\) such that \\(ax = i_n\\), thus \\(x = a^{-1}\\). this means you are solving \\(n\\) systems of linear equations of the form \\(ax_i = i_{n_i}\\). this system is solved by performing matrix row operations, until the left side of the augmented matrix becomes the identity matrix. the resulting augmented matrix can be written as \\([i_n|a^{-1}]\\), where the right side of the matrix is \\(a^{-1}\\). if \\(a^{-1}\\) exists, then it is unique. if \\(a^{-1}\\) does not exist, then \\(a\\) is a singular matrix. using determinants to find inverses if \\begin{align} a = \\begin{bmatrix} a & b \\\\ c & d \\end{bmatrix} \\end{align} and \\(det(a) \\neq 0\\) then \\begin{align} a^{-1} = \\frac{1}{det(a)}\\begin{bmatrix} d & -b \\\\ -c & a \\end{bmatrix} \\end{align} if \\(det(a) = 0\\), then \\(a^{−1}\\) does not exist and \\(a\\) is a singular matrix. solving linear systems using inverse matrices to solve the matrix equation \\(ax = b\\), first see if \\(a^{-1}\\) exists. assuming that it does, use the facts that \\(a^{-1}a = i\\) and \\(ix = x\\). \\begin{align} ax = b \\end{align} \\begin{align} a^{-1}(ax) = a^{-1}b \\end{align} \\begin{align} (a^{-1}a)x = a^{-1}b \\end{align} \\begin{align} ix = a^{-1}b \\end{align} \\begin{align} x = a^{-1}b \\end{align} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/08_02.html",
    "title": "Trigonometric Functions and Fundamental Identities",
    "body": " index search search back trigonometric functions and fundamental identities contents trigonometric functions function values of quadrantal angles reciprocal identities signs and ranges of function values pythagorean identities quotient identities trigonometric functions let \\((x, y)\\) be a point other than the origin on the terminal side of an angle \\(\\theta\\) instandard position. the distance from the point to the origin is \\(r = \\sqrt{x^2 + y^2}\\). the six trigonometric functions of \\(\\theta\\) are as follows: \\begin{align} \\sin \\theta = \\frac{y}{r} \\end{align} \\begin{align} \\cos \\theta = \\frac{x}{r} \\end{align} \\begin{align} \\tan \\theta = \\frac{y}{x}, x \\neq 0 \\end{align} \\begin{align} \\csc \\theta = \\frac{r}{y} \\end{align} \\begin{align} \\sec \\theta = \\frac{r}{x} \\end{align} \\begin{align} \\cot \\theta = \\frac{x}{y}, y \\neq 0 \\end{align} \\(\\sin \\theta = \\frac{y}{r}\\) is the same no matter which point is used to find it. refer to figure 28, which shows an angle \\(\\theta\\) and two distinct points on its terminal side. point \\(p\\) has coordinates \\((x, y)\\), and point \\(p'\\) with coordinates \\((x', y')\\). let \\(r\\) be the length of the hypotenuse of triangle \\(opq\\), and let \\(r'\\) be the length of the hypotenuse of triangle \\(op'q'\\). since corresponding sides of similar triangles are in proportion: \\begin{align} \\frac{y}{r} = \\frac{y'}{r'} = \\sin \\theta \\end{align} we can also find the trigonometric function values of an angle if we know the equation of the line coinciding with the terminal ray: \\begin{align} ax + by = 0 \\end{align} by choosing any point on the ray, we can find the trigonometric function values of the angle. in general, it is true that \\(m = \\tan \\theta\\). function values of quadrantal angles conditions for undefined function values if the terminal side of the quadrantal angle lies along the y-axis (\\(x\\) equals zero), then the tangent and secant functions are undefined. if the terminal side of the quadrantal angle lies along the x-axis (\\(y\\) equals zero), then the cotangent and cosecant functions are undefined. reciprocal identities the definitions of the trigonometric functions were written to illustrate that certain function pairs are reciprocals of each other. since: \\begin{align} \\sin \\theta = \\frac{y}{r} \\end{align} and \\begin{align} \\csc \\theta = \\frac{r}{y} \\end{align} then: \\begin{align} \\sin \\theta = \\frac{1}{\\csc \\theta} \\end{align} therefore, the reciprocal identities are listed below: \\begin{align} \\sin \\theta = \\frac{1}{\\csc \\theta} \\end{align} \\begin{align} \\cos \\theta = \\frac{1}{\\sec \\theta} \\end{align} \\begin{align} \\tan \\theta = \\frac{1}{\\cot \\theta} \\end{align} \\begin{align} \\csc \\theta = \\frac{1}{\\sin \\theta} \\end{align} \\begin{align} \\sec \\theta = \\frac{1}{\\cos \\theta} \\end{align} \\begin{align} \\cot \\theta = \\frac{1}{\\tan \\theta} \\end{align} signs and ranges of function values a point \\((x, y)\\) in quadrant ii has \\(x < 0\\) and \\(y > 0\\). this makes the values of sine and cosecant positive for quadrant ii angles, while the other four functions take on negative values. similar results can be obtained for the other quadrants, as summarized here. in figure 37 we can see that as the measure of the angle increases, \\(y\\) increases, but never exceeds \\(r\\), so \\(y \\leq r\\). in a similar way, angles in quadrant iv suggest that \\(-r \\leq y\\). therefore: \\begin{align} -r \\leq y \\leq r \\end{align} \\begin{align} -1 \\leq \\frac{y}{r} \\leq 1 \\end{align} \\begin{align} -1 \\leq \\sin \\theta \\leq 1 \\end{align} similar reasoning leads to the following: \\begin{align} -1 \\leq \\cos \\theta \\leq 1 \\end{align} the tangent of an angle is defined as \\(\\frac{y}{x}\\). it is possible that \\(x < y\\), \\(x = y\\), or \\(x > y\\). for this reason, \\(\\frac{y}{x}\\) can take any value, so \\(\\tan \\theta\\) can be any real number, as can \\(\\cot \\theta\\). the functions \\(\\sec \\theta\\) and \\(\\csc \\theta\\) are reciprocals of the functions \\(\\cos \\theta\\) and \\(\\sin \\theta\\), respectively, making the following true: \\begin{align} \\sec \\theta \\leq -1 \\text{ or } \\sec \\theta \\geq 1 \\end{align} and \\begin{align} \\csc \\theta \\leq -1 \\text{ or } \\csc \\theta \\geq 1 \\end{align} pythagorean identities given \\(x^2 + y^2 = r^2\\), then: \\begin{align} \\frac{x^2}{r^2} + \\frac{y^2}{r^2} = \\frac{r^2}{r^2} \\end{align} \\begin{align} \\left(\\frac{x}{r}\\right)^2 + \\left(\\frac{y}{r}\\right)^2 = 1 \\end{align} \\begin{align} \\left(\\cos \\theta\\right)^2 + \\left(\\sin \\theta\\right)^2 = 1 \\end{align} similarly: \\begin{align} \\frac{x^2}{x^2} + \\frac{y^2}{x^2} = \\frac{r^2}{x^2} \\end{align} \\begin{align} 1 + \\left(\\frac{y}{x}\\right)^2 = \\left(\\frac{r}{x}\\right)^2 \\end{align} \\begin{align} 1 + \\left(\\tan \\theta\\right)^2 = \\left(\\sec \\theta\\right)^2 \\end{align} similarly: \\begin{align} \\frac{x^2}{y^2} + \\frac{y^2}{y^2} = \\frac{r^2}{y^2} \\end{align} \\begin{align} \\left(\\frac{x}{y}\\right)^2 + 1 = \\left(\\frac{r}{y}\\right)^2 \\end{align} \\begin{align} \\left(\\cot \\theta\\right)^2 + 1 = \\left(\\csc \\theta \\right)^2 \\end{align} quotient identities consider the quotient of \\(\\sin \\theta\\) and \\(\\cos \\theta\\): \\begin{align} \\frac{\\sin \\theta}{\\cos \\theta} = \\frac{\\frac{y}{r}}{\\frac{x}{r}} = \\frac{y}{x} = \\tan \\theta \\end{align} where \\(\\cos \\theta \\neq 0\\). similarly: \\begin{align} \\frac{\\cos \\theta}{\\sin \\theta} = \\frac{\\frac{x}{r}}{\\frac{y}{r}} = \\frac{x}{y} = \\cot \\theta \\end{align} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/07_04.html",
    "title": "Parametric Equations",
    "body": " index search search back parametric equations contents graphing a parabola defined parametrically a plane curve is a set of points \\((x, y)\\) such taht \\(x= f(t)\\), \\(y = g(t)\\) and \\(f\\) and \\(g\\) are both continuous on an interval \\(i\\). the equations \\(x = f(t)\\) and \\(y = g(t)\\) are parametric equations with parameter \\(t\\). graphing a parabola defined parametrically graph the plane curve \\(x = t^2, y = 2t + 3\\) for \\(t \\in [-3, 3]\\). make a table of corresponding values of \\(t\\), \\(x\\), and \\(y\\) over the domain of \\(t\\). \\(t\\) \\(x\\) \\(y\\) ---- --- ---- \\(-3\\) \\(9\\) \\(-3\\) \\(-2\\) \\(4\\) \\(-1\\) \\(-1\\) \\(1\\) \\(1\\) \\(0\\) \\(0\\) \\(3\\) \\(1\\) \\(1\\) \\(5\\) \\(2\\) \\(4\\) \\(7\\) \\(3\\) \\(9\\) \\(9\\) then plot the points. to find an equivalent rectangular equation, we eliminate the parameter \\(t\\). \\begin{align} y = 2t + 3 \\end{align} \\begin{align} y - 3 = 2t \\end{align} \\begin{align} \\frac{y - 3}{2} = t \\end{align} now we substitute the result in the first equation \\(x = t^2\\): \\begin{align} x = t^2 = \\left(\\frac{y - 3}{2}\\right)^2 = \\frac{(y - 3)^2}{4} = \\frac{1}{4}(y-3)^2 \\end{align} this is indeed an equation of a horizontal parabola that opens to the right. because \\(t\\) is in \\([3, -3]\\), \\(x\\) is in \\([3, 0]\\), and \\(y\\) is in \\([-3, 9]\\). the rectangular equation must be given with its restricted domain as: \\begin{align} x = \\frac{1}{4}(y-3)^2, \\text{ for } x \\in [0, 9] \\end{align} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/index.html",
    "title": "A Graphical Approach to Algebra and Trigonometry",
    "body": " index search search back a graphical approach to algebra and trigonometry linear functions, equations and inequalities real numbers and the rectangular coordinate system introduction to relations and functions linear functions equations of lines and linear models linear equations and inequalities applications of linear functions analysis of graphs of functions graphs of basic functions and relations: symmetry vertical and horizontal shifts of graphs stretching, shrinking and reflecting graphs absolute value functions piecewise-defined functions opertions and composition polynomial functions complex numbers quadratic functions and graphs quadratic equations and inequalities high-degree polynomial functions and graphs topics in the theory of polynomial functions (i) topics in the theory of polynomial functions (ii) polynomial equations and inequalities; further applications and models rational, power and root functions rational functions and graphs (i) rational functions and graphs (ii) rational equations, inequalities, models and applications functions defined by powers and roots equations, inequalities, and applications involving root functions inverse, exponential and logarithmic functions inverse functions exponential functions logarithms and their properites logarithmic functions exponential and logarithmic equations and inequalities further applications and modeling with exponential and logarithmic functions systems and matrices systems of equations solutions of linear systems in three variables solution of linear systems by row transformations matrix properties and operations determinants and cramer's rule solution of linear systems by matrix inverses systems of inequalities and linear programming partial fractions analytic geometry and nonlinear systems circles and parabolas ellipses and hyperbolas the conic sections and nonlinear systems parametric equations trigonometric functions and applications. angles and their measures trigonometric functions and fundamental identities right triangles and evaluating trigonometric functions applications of right triangles the circular functions graph of the sine and cosine functions graphs of the other circular functions harmonic motion trigonometric identities and equations. trigonometric identities sum and difference identities further identities the inverse circular functions applications of trigonometry and vectors the law of sines the law of cosines and area formulas vectors and their applications trigonometric (polar) form of complex numbers powers and roots of complex numbers polar equations and graphs more parametric equations further topics in algebra sequences and series arithmetric sequences and series geometric sequences and series counting theory the binomial theorem mathematical induction probability appendix b. vectors in space c. polar form of conic sections d. rotation of axes $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/08_06.html",
    "title": "Graphs of the Sine and Cosine Functions",
    "body": " index search search back graphs of the sine and cosine functions contents periodic function graph of the sine function amplitude period guidelines for sketching graphs of the sine and cosine functions translations and transformations further guidelines for sketching graphs of the sine and cosine functions periodic function a periodic function is a function \\(f\\), such that: \\begin{align} f(x) = f(x + np) \\end{align} for every real number \\(x\\) in the domain of \\(f\\), every integer \\(n\\) and some positive real number \\(p\\). the least possible value of \\(p\\) is the period of the function. graph of the sine function see figure 85, and trace along the circle to verify the results shown in the table. this graph is called a sine wave or sinusoid. amplitude the graph of \\(y = a \\sin x\\) or \\(y = a \\cos x\\), with \\(a \\neq 0\\), will have the same shape as the graph of \\(y = \\sin x\\) or \\(y = \\cos x\\), respectively, except with range \\([-|a|, |a|]\\). the amplitude is \\(|a|\\). no matter what the value of the amplitude, the periods of \\(y = a \\sin x\\) and \\(y = a \\cos x\\) are still \\(2\\pi\\). period in general, the graph of a function of the form \\(y = \\sin bx\\) or \\(y = \\cos bx\\), for \\(b > 0\\), will have a period different from \\(2\\pi\\) when \\(b \\neq 1\\). we know that \\(bx\\) ranges from \\(0\\) to \\(2\\pi\\), therefore: \\begin{align} 0 \\leq bx \\leq 2\\pi \\end{align} \\begin{align} 0 \\leq x \\leq \\frac{2\\pi}{b} \\end{align} therefore the period is \\(\\frac{2\\pi}{b}\\). by dividing the interval \\([0, \\frac{2\\pi}{b}]\\) into four equal parts, we obtain the values for which \\(\\sin bx\\) or \\(\\cos bx\\) is \\(-1\\), \\(0\\), or \\(1\\). guidelines for sketching graphs of the sine and cosine functions to graph \\(y = a \\sin bx\\) or \\(y = a \\cos bx\\), with \\(b > 0\\), follow these steps. find the period, \\(\\frac{2\\pi}{b}\\). divide the interval into four equal parts. evaluate the function for each of the five x-values. the points will be maximum points, minimum points, and x-intercepts. plot the points found in step 3, and join them with a sinusoidal curve having amplitude \\(|a|\\). translations and transformations in general, the graph of a function of the form: \\begin{align} y = f(x - d) \\end{align} is translated horizontally compared with the graph of \\(y = f(x)\\). the translation is \\(d\\) units to the right if \\(d > 0\\) and \\(|d|\\) units to the left if \\(d < 0\\). in general, the graph of a function of the form: \\begin{align} y = c + f(x) \\end{align} is translated vertically compared with the graph of \\(y = f(x)\\). the translation is \\(c\\) units up if \\(c > 0\\) and \\(|c|\\) units down if \\(c < 0\\). further guidelines for sketching graphs of the sine and cosine functions a function of the form \\(y = c + a \\sin [b(x − d)]\\) or \\(y = c + a \\cos [b(x − d)]\\) , \\(b > 0\\) can be graphed according to the following guidelines: method 1: find an interval whose length is one period \\(\\frac{2\\pi}{b}\\) by solving the three-part inequality \\(0 \\leq b(x - d) \\leq 2\\pi\\). divide the interval into four equal parts. evaluate the function for each of the five x-values. the points will be maximum points, minimum points, and points that intersect the line \\(y = c\\). plot the points in step 3, and join them with a sinusoidal curve having amplitude \\(|a|\\). method 2: graph \\(y = a \\sin bx\\) or \\(y = a \\cos bx\\). the amplitude of the function is \\(|a|\\), and the period is \\(\\frac{2\\pi}{b}\\). use translations to graph the desired function. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/08_08.html",
    "title": "Harmonic Motion",
    "body": " index search search back harmonic motion contents simple harmonic motion dampled oscillatory motion simple harmonic motion consider figure 119, suppose the point \\(p(x, y)\\) moves around the circle counterclockwise at a uniform angular speed \\(\\omega\\). assume that at time \\(t = 0\\), \\(p\\) is at \\((a, 0)\\). the angle swept out by ray op at time \\(t\\) is given by: \\begin{align} \\theta = \\omega t \\end{align} the coordinates of point \\(p\\) at time \\(t\\) are: \\begin{align} x = a \\cos \\theta = a \\cos \\omega t \\end{align} and \\begin{align} y = a \\sin \\theta = a \\sin \\omega t \\end{align} the number of oscillations, or cycles per unit of time, called the frequency, is the reciprocal o the period. the position of a point oscillating about an equilibrium position at time \\(t\\) is modeled by either: \\begin{align} s(t) = a \\cos \\omega t \\end{align} or \\begin{align} s(t) = a \\sin \\omega t \\end{align} where \\(a\\) and \\(\\omega\\) are constants with \\(\\omega > 0\\). the amplitude of the motion is \\(|a|\\), the period is \\(\\frac{2 \\pi}{\\omega}\\) and the frequency is \\(\\frac{\\omega}{2 \\pi}\\). dampled oscillatory motion up until now we disregarded the effect of friction, which causes the amplitude of the motion to diminish gradually. we say that the motion has been damped by the force of friction. most oscillatory motions are damped, and the decrease in amplitude follows the pattern of exponential decay. an example of damped oscillatory motion is given by the function: \\begin{align} s(t) = e^{-t} \\sin t \\end{align} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/08_04.html",
    "title": "Applications of Right Triangles",
    "body": " index search search back applications of right triangles contents solving triangles angles of elevation or depression bearing the results of physical measurements are only approximately accurate and depend on the precision of the measuring instrument as well as the aptness of the observer. the digits obtained by actual measurement are called significant digits. solving triangles to solve a triangle means to find the measures of all the angles and sides of the triangle. angles of elevation or depression the angle of elevation from point \\(x\\) to point \\(y\\) (above \\(x\\)) is the acute angle formed by ray \\(xy\\) and a horizontal ray with endpoint at \\(x\\) (see figure 61). the angle of depression from point \\(x\\) to point \\(y\\) (below \\(x\\)) is the acute angle formed by ray \\(xy\\) and a horizontal ray with endpoint \\(x\\) (see figure 62). bearing when a single angle is given, such as \\(164°\\), it is understood that the bearing is measured in a clockwise direction from due north (see figure 64). the second method for expressing bearing starts with a north–south line and uses an acute angle to show the direction, either east or west, from this line (see figure 66). $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/08_07.html",
    "title": "Graphs of the Other Circular Functions",
    "body": " index search search back graphs of the other circular functions contents graphs of the secant and cosecant functions graphs of the tangent and cotangent functions graphs of the secant and cosecant functions the secant function is undefined for odd multiples of \\(\\frac{\\pi}{2}\\) and has vertical asymptotes for such values. furthermore, since \\(\\sec (-x) = \\sec x\\), the secant function is even and its graph is symmetric with respect to the y-axis. figure 100 shows how the graphs of \\(y = \\cos x\\) and \\(y = \\sec x\\) are related the vertical asymptotes of the cosecant function are at \\(x\\)-values that are integer multiples of \\(\\pi\\). because \\(\\csc (-x) = -\\csc x\\), the cosecant function is odd and its graph is symmetric with respect to the origin. figure 102 shows how the graphs of \\(y = \\sin x\\) and \\(y = \\csc x\\) are related. guidelines for sketching graphs of the secant and cosecant functions to graph \\(y = a \\sec bx\\) or \\(y = a \\csc bx\\), with \\(b > 0\\), follow these steps: graph the reciprocal function as a guide. for \\(y = a \\sec bx\\), graph \\(y = a \\cos bx\\) for \\(y = a \\csc bx\\), graph \\(y = a \\sin bx\\) sketch the vertical asymptotes with equations \\(x = k\\), where \\((k, 0)\\) is an \\(x\\)-intercept of the graph of the guide function. sketch the graph of the desired function by drawing the typical u-shaped branches between the adjacent asymptotes. the branches will be above the graph of the guide function when the guide function values are positive and below the graph of the guide function when the guide function values are negative. graphs of the tangent and cotangent functions the tangent function is undefined for odd multiples of \\(\\frac{\\pi}{2}\\) and has vertical asymptotes for such values. furthermore, since \\(\\tan (-x) = -\\tan x\\), the tangent function is odd and its graph is symmetric with respect to the origin. the tangent function has period \\(\\pi\\). because \\(\\tan x = \\frac{\\sin x}{\\cos x}\\), tangent values are \\(0\\) when sine values are \\(0\\) (\\(x = 0\\)), and undefined when cosine values are \\(0\\) (\\(x = \\frac{\\pi}{2}\\) or \\(x = -\\frac{\\pi}{2}\\)). as x-values go from \\(-\\frac{\\pi}{2}\\) to \\(\\frac{\\pi}{2}\\), tangent values go from \\(- \\infty\\) to \\(\\infty\\). the graph of \\(y = \\tan x\\) is shown in figure 110. the cotangent function's vertical asymptotes are at x-values that are integer multiples of \\(\\pi\\). because \\(\\cot (-x) = -\\cot x\\), the cotangent function is odd and its graph is symmetric with respect to the origin. its graph is plotted on figure 112. the cotangent function also has period \\(\\pi\\). cotangent values are \\(0\\) when cosine values are \\(0\\) (\\(x = \\frac{\\pi}{2}\\)), and undefined when sine values are \\(0\\) (\\(x = 0\\) or \\(x = \\pi\\)). as \\(x\\)-values go from \\(0\\) to \\(\\pi\\), cotangent values go from \\(\\infty\\) to \\(-\\infty\\) and decrease throughout the interval. guidelines for sketching graphs of the tangent and cotangent functions to graph \\(y = a \\tan bx\\) or \\(y = a \\cot bx\\), with \\(b > 0\\), follow these steps: the period is \\(\\frac{\\pi}{b}\\). to locate two adjacent vertical asymptotes, solve the following equations for \\(x\\). for \\(y = a \\tan bx\\): \\(bx = - \\frac{\\pi}{2}\\) and \\(bx = \\frac{\\pi}{2}\\) for \\(y = a \\cot bx\\): \\(bx = 0\\) and \\(bx = \\pi\\) sketch the two vertical asymptotes. divide the interval formed by the vertical asymptotes into four. evaluate the function for the first-quarter point, midpoint, and thirdquarter point. join the points with a smooth curve. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/06_04.html",
    "title": "Matrix Properties and Operations",
    "body": " index search search back matrix properties and operations contents matrix addition multiplication of a matrix by a scalar matrix multiplication in general, a matrix with \\(m\\) rows and \\(n\\) columns has dimension \\(m \\times n\\). the number of rows is always given first certain matrices have special names. an \\(n \\times n\\) matrix is a square matrix of order n. also, a matrix with just one row is a row matrix, and a matrix with just one column is a column matrix. two matrices are equal if they have the same dimension and if corresponding elements, position by position, are equal a matrix containing only zeros as elements is called a zero matrix. matrix addition the sum of two \\(m \\times n\\) matrices \\(a\\) and \\(b\\) is the \\(m \\times n\\) matrix \\(a + b\\) in which each element is the sum of the corresponding elements of \\(a\\) and \\(b\\). only matrices with the same dimension can be added. multiplication of a matrix by a scalar the product of a scalar \\(k\\) and a matrix \\(a\\) is the matrix \\(ka\\), each of whose elements is \\(k\\) times the corresponding element of \\(a\\). matrix multiplication the product \\(ab\\) of an \\(m \\times n\\) matrix \\(a\\) and an \\(n \\times k\\) matrix \\(b\\) is an \\(m \\times k\\) matrix and is found as follows. to find the \\(i\\)th row, \\(j\\)th column element of \\(ab\\), multiply each element in the \\(i\\)th row of \\(a\\) by the corresponding element in the \\(j\\)th column of \\(b\\). the sum of these products gives the element of row \\(i\\), column \\(j\\) of \\(ab\\). \\begin{align} c_{ij} = \\sum_{k=1}^{n} a_{ik}b_{kj} \\end{align} the product ab can be found only if the number of columns of a is the same as the number of rows of b. the final product will have as many rows as a and as many columns as b. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/06_07.html",
    "title": "Systems of Inequalities and Linear Programming",
    "body": " index search search back systems of inequalities and linear programming contents solving linear inequalities graphing a linear inequality two methods for graphing an inequality soliving systems of inequalitites linear programming fundamental theorem of linear programming solving a linear programming problem a line divides a plane into three sets of points: the points of the line itself the points belonging to the two regions determined by the line. each of these two regions is called a half plane. the line is the boundary of each half plane. solving linear inequalities a linear inequality in two variables is an inequality of the form \\begin{align} ax + by \\leq c, \\end{align} where \\(a\\), \\(b\\), and \\(c\\) are real numbers with \\(a\\) and \\(b\\) not both equal to \\(0\\). (the symbol \\(\\leq\\) be replaced with \\(\\geq\\), \\(>\\) or \\(<\\)). graphing a linear inequality graph \\(x + 4y 7 > 4\\). the boundary here is the line \\(x + 4y = 4\\). since the points on this line do not satisfy \\(x + 4y = 4\\), make the line dashed. to decide which half plane represents the solution, solve for \\(y\\). such that \\(y > -\\frac{1}{4}x + 1\\) since \\(y\\) is greater than \\(-\\frac{1}{4}x + 1\\), the graph of the solution set is the half plane above the boundary two methods for graphing an inequality for a function \\(f\\), the graph of \\(y < f(x)\\) consists of all the points that are below the graph of y = ƒ(x). the graph of \\(y > f(x)\\) consists of all the points that are above the graph of \\(y = f(x)\\). if the inequality is not or cannot be solved for \\(y\\), choose a test point not on the boundary. if the test point satisfies the inequality, the graph includes all points on the same side of the boundary as the test point. otherwise, the graph includes all points on the other side of the boundary. soliving systems of inequalitites the solution set of a system of inequalities is the intersection of the solution sets of its members graph the solution set of the system. \\begin{align} x > 6 - 2y \\end{align} \\begin{align} x^2 < 2y \\end{align} the next figures show the graphs for both inequalities as well as the solution set, that is the intersection of the regions that represent the solution set for each inequality. linear programming we use linear programming to find an optimum value. a linear programming problem typically needs the definition of the following concepts: the restrictions of the problem, usually a system of inequalitites, that conform the constraints. an objetive function, which is the function we aim to optimize. the region of feasible solutions that is the set of values for \\(x\\) and \\(y\\) that satisfy all constraints. fundamental theorem of linear programming if the optimal value for a linear programming problem exists, it occurs at a vertex of the region of feasible solutions. solving a linear programming problem write the objective function and all necessary constraints. graph the region of feasible solutions. identify all vertices (corner points). evaluate the objective function at each vertex. the solution is given by the vertex producing the optimal value of the objective function. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/08_01.html",
    "title": "Angles and Their Measures",
    "body": " index search search back angles and their measures contents basic terminology degree measure standard position and coterminal angles radian measure degree to radian conversion arc lengths and areas of sectors linear and angular speed appendix basic terminology two distinct points \\(a\\) and \\(b\\) determine a line called line \\(ab\\). the portion of the line between \\(a\\) and \\(b\\), including points \\(a\\) and \\(b\\), is segment \\(ab\\). the portion of line \\(ab\\) that starts at \\(a\\) and continues through \\(b\\) and on past \\(b\\) is called ray \\(ab\\). point \\(a\\) is the endpoint of the ray. in trigonometry, an angle consists of two rays in a plane with a common endpoint, or two line segments with a common endpoint. these two rays (or segments) are called the sides of the angle and the common endpoint is called the vertex of the angle. associated with an angle is its measure, generated by a rotation about the vertex. this measure is determined by rotating a ray starting at one side of the angle, called the initial side, to the position of the other side, called the terminal side. a counterclockwise rotation generates an angle with positive measure, while a clockwise rotation generates an angle with negative measure. degree measure the most common unit used to measure the size of angles is the degree. we assign \\(360\\) degrees to a complete rotation of a ray. an angle measuring between \\(0\\)° and \\(90\\)° is an acute angle. an angle measuring exactly \\(90\\)° is a right angle. an angle measuring more than \\(90\\)° but less than \\(180\\)° is an obtuse angle, and an angle of exactly \\(180\\)° is a straight angle. if the sum of the measures of two positive angles is \\(90°\\), the angles are called complementary and the angles are complements. two positive angles with measures whose sum is \\(180°\\) are supplementary and the angles are supplements. one minute, written \\(1'\\), is \\(\\frac{1}{60}\\) of a degree and one second, \\(1''\\), is \\(\\frac{1}{60}\\) of a minute.however angles are commonly measured in decimal degrees. standard position and coterminal angles an angle is in standard position if its vertex is at the origin and its initial side is along the positive x-axis. the angles in (a) and (b) are in standard position. an angle in standard position is said to lie in the quadrant in which its terminal side lies, such as angles with measures \\(90°\\), \\(180°\\), \\(270°\\), and so on, are called quadrantal angles. if the terminal side lies along an axis, then the angle does not lie in any quadrant. for example, an acute angle is in quadrant i (a) and an obtuse angle is in quadrant ii (b). the angles whose measures differ by a multiple of \\(360º\\) are called coterminal angles. radian measure an angle with vertex at the center of a circle that intercepts an arc on the circle equal in length to the radius of the circle has measure \\(1\\) radian. an angle \\(\\theta\\) whose vertex is at the center of a circle is called central angle. in general, if \\(\\theta\\) is a central angle in a circle of radius \\(r\\), and \\(\\theta\\) intercepts an arc of lengt \\(s\\), the radian measure of \\(\\theta\\) is \\(\\frac{s}{r}\\). degree to radian conversion we know that the circumference of a circle is given by \\(c = 2\\pi r\\), where \\(r\\) is the radius. this shows that the radius can be laid \\(2\\pi\\) times around the circle. therefore, an angle of \\(360°\\), which corresponds to a complete circle, intercepts an arc equal in length to \\(2\\pi\\) times the radius of the circle. thus, an angle of \\(360º\\) has measure \\(2\\pi\\). \\begin{align} 360º = 2\\pi \\text{ radians} \\end{align} to convert a degree measure to radians multiply the degree measure by \\(\\frac{2\\pi}{360} = \\frac{\\pi}{180}\\) to convert a radian measure to degrees multiply the radian measure by \\(\\frac{360}{2\\pi} = \\frac{180}{\\pi}\\) arc lengths and areas of sectors in the following figure angle \\(qop\\) has measure \\(1\\) radian and intercepts an arc of length \\(r\\). while angle \\(rot\\) has measure \\(\\theta\\) radians and intercepts an arc of length \\(s\\). since the lengths of the arcs are proportional to the measures of their central angles: \\begin{align} \\frac{s}{r} = \\frac{\\theta}{1} \\end{align} \\begin{align} s = r\\theta \\end{align} a sector of a circle is the portion of the interior of a circle intercepted by a central angle. the interior of a circle can be thought of as a sector intercepted by a central angle of measure \\(2\\pi\\) radians. if a central angle for a sector has measure \\(\\theta\\) radians, then the sector makes up the fraction \\(\\frac{\\theta}{2\\pi}\\) of a complete circle. the area inside a circle with radius \\(r\\) is \\(\\mathcal{a} = \\pi r^2\\), therefore, the area of the sector is given by the product of the fraction \\(\\frac{\\theta}{2\\pi}\\) and the total area: \\begin{align} \\mathcal{a} = \\frac{\\theta}{2\\pi}(\\pi r^2) = \\frac{1}{1}r^2 \\theta, \\theta \\text{ in radians} \\end{align} linear and angular speed suppose that point \\(p\\) moves at a constant speed along a circle of radius \\(r\\) and center \\(o\\). the measure of how fast the position of \\(p\\) is changing is called linear speed. if \\(v\\) represents linear speed, then: \\begin{align} v = \\frac{s}{t} \\end{align} where \\(s\\) is the length of the arc traced by point \\(p\\) in time \\(t\\). (this formula is just a restatement of \\(d = rt\\) with \\(s\\) as distance, \\(v\\) as rate (speed), and \\(t\\) as time.) as point \\(p\\) moves along the circle, ray \\(op\\) rotates around the origin, so the speed at which the measure ofthe angle changes is called angular speed, \\(\\omega\\) and is given by: \\begin{align} \\omega = \\frac{\\theta}{t}, \\theta \\text{ in radians} \\end{align} where \\(\\theta\\) is the measure of angle \\(pob\\). to relate linear and angular speeds we use the result \\(s = r\\theta\\), therefor: \\begin{align} v = \\frac{s}{t} = \\frac{r\\theta}{t} = r \\frac{\\theta}{t} = r \\omega \\end{align} appendix latitude gives the measure of a central angle with vertex at earth's center whose initial side goes through the equator and whose terminal side goes through the given location (basically like north-south orientation). $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/10_01.html",
    "title": "The Law of Sines",
    "body": " index search search back the law of sines contents congruency and oblique triangles derivation of the law of sines ambiguous case congruency and oblique triangles we say two trigangles are congruent if their sides and angles are equal. we list the three congruency axioms: side-angle-side (sas): if two sides and the angle between them of a triangle equal two sides and the angles between them of a second triangle, then the triangles are congruent. angle-side-angle (asa): if two angles and the side between them of a triangle equal two angles and the side between them of a second triangle, then the triangles are congruent. side-side-side (sss): if three sides of a triangles are equal to three sides of a second triangle, then the triangles are congruent. an oblique triangle is a triangle that is not a right triangle. to solve an oblique triangle we need the following data: case 1: one side and two angles are known (saa or asa). case 2: two sides and one angle not included between the two sides are known (ssa). this may lead to zero, one or two triangles. this is called the ambiguous case. case 3: two sides and the angle included between are known (sas). case 4: thre sides are known (sss). cases 1 and 2 require the law of sines. cases 3 and 4 require the law of cosines. derivation of the law of sines given an acute triangle (figure 1(a)) or an obtuse triangle (figure 1(b)). we construct the perpendicular from \\(b\\) to side \\(ac\\). let \\(h\\) be the length of the perpendicular. then: \\begin{align} \\sin a = \\frac{h}{c} \\leftrightarrow h = c \\sin a \\end{align} \\begin{align} \\sin c = \\frac{h}{a} \\leftrightarrow h = a \\sin c \\end{align} since \\(h = c \\sin a = a \\sin c\\), then: \\begin{align} a \\sin c = c \\sin a \\end{align} \\begin{align} \\frac{a}{\\sin a} = \\frac{c}{\\sin c} \\end{align} by constructing perpendicular lines from the other vertices, it can be shown that: \\begin{align} \\frac{a}{\\sin a} = \\frac{b}{\\sin b} \\end{align} \\begin{align} \\frac{b}{\\sin b} = \\frac{c}{\\sin c} \\end{align} therefore: \\begin{align} \\frac{a}{\\sin a} = \\frac{b}{\\sin b} = \\frac{c}{\\sin c} \\end{align} ambiguous case if we are given the length of two sides and the angle opposite to one of them then zero, one or two such triangles could exist. this is what we call the ambiguous case. to solve this type of triangle we make use of the following facts: for any angle \\(\\theta\\) of a triangle, \\(0 < \\sin \\theta \\leq 1\\). given an angle \\(\\theta\\) on the triangle where \\(\\sin \\theta = 1\\), then \\(\\theta = 90º\\) and the triangle is a right triangle. for any angle \\(\\theta\\) it follows \\(\\sin \\theta = \\sin (180º - \\theta)\\) the smallest angle is opposite the shortest side, the largest angle is opposite the longest side and the midle-valued angle is opposite the intermediate side. we know that if \\(a\\) is acute then there are four possible outcomes, whilst if \\(a\\) is obtuse there are two possible outcomes. when \\(a\\) is acute we define the following cases, after applying the law of sines: if \\(\\sin b > 1\\) and \\(a < h< b\\) then there are \\(0\\) possible triangles, as the range of \\(\\sin\\) is \\([-1, 1]\\). if \\(\\sin b = 1\\) and \\(a = b\\) and \\(h < b\\) then there is \\(1\\) possible triangle. if \\(0 < \\sin b < 1\\) and \\(a \\leq b\\) there is \\(1\\) possible triangle. if \\(0 < \\sin b_1 < 1\\), \\(h < a < b\\), there is \\(1\\) possible triangle. note that \\(\\sin b_1 = \\sin (180º - b_1)\\), so if if, \\(a + b_2 < 180º\\) (which means there is a \\(c\\) such that \\(a + b_2 + c = 180º\\)) then there is another possible triangle. when \\(a\\) is obtuse we define the following cases, after applying the law of sines: if \\(\\sin b \\geq 1\\) and \\(a \\leq b\\), then there are zero possible triangles as the range of \\(\\sin\\)is \\([-1, 1]\\). if \\(0 < \\sin b < 1\\) and \\(a > b\\) then there is one possible triangle. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/06_08.html",
    "title": "Partial Fractions",
    "body": " index search search back partial fractions contents decomposition of rational expressions [[#partial fraction decomposition of \\(\frac{f(x)}{g(x)}\\)|partial fraction decomposition of \\(\frac{f(x)}{g(x)}\\)]] techniques for decomposition into partial fractions for linear factors for quadratic factors decomposition of rational expressions partial fraction decomposition of \\(\\frac{f(x)}{g(x)}\\) if \\(\\frac{f(x)}{g(x)}\\) is not a proper fraction (a fraction whose numerator is lesser degree than it denominator) divide \\(f(x)\\) by \\(g(x)\\). for example \\begin{align} \\frac{x^4 - 3x^3 + x^2 + 5x}{x^2 + 3} = x^2 - 3x - 2 + \\frac{14x + 6}{x^2 + 3} \\end{align} then appy the following steps to the remainder. factor the denominator \\(g(x)\\) into factors of the form \\((ax + b)^m\\) or \\((cx^2 + dx + e)^n\\). for each distinct linear factor \\((ax + b)\\), the decomposition must include the term \\frac{a}{ax + b}. for each repeated linear factor \\((ax + b)^m\\), the decomposition must include the terms: \\begin{align} \\frac{a_1}{(ax + b)} + \\frac{a_2}{(ax + b)^2} + \\cdots + \\frac{a_m}{(ax + b)^m} \\end{align} for each distinct quadratic factor \\((cx^2 + dx + e)\\), the decomposition must include the term \\(\\frac{bx + c}{cx2 + dx + e}\\) for each repeated quadratic factor \\((cx^2 + dx + e)^n\\), the decomposition must include the terms: \\begin{align} \\frac{b_1x + c_1}{(cx^2 + dx + e)} + \\frac{b_2x + c_2}{(cx^2 + dx + e)^2} + \\cdots + \\frac{b_nx + c_n}{(cx^2 + dx + e)^n} \\end{align} use algebraic techniques to solve for the constants in the numerators of the decomposition. techniques for decomposition into partial fractions for linear factors multiply each side of the resulting rational equation by the common denominator. substitute the zero of each factor into the resulting equation. for repeated linear factors, substitute as many other numbers as is necessary to find all the constants in the numerators. the number of substitutions required will equal the number of constants \\(a, b, \\cdots\\). for example: \\begin{align} \\frac{f(x)}{(x-1)(x-2)} = \\frac{a}{(x-1)} + \\frac{b}{(x - 2)} = \\frac{a(x-2) + b(x-1)}{(x-2)(x-1)} \\end{align} multiply both sides by \\((x-1)(x-2)\\): \\begin{align} f(x) = a(x-2) + b(x-1) \\end{align} solve for \\(x = 2\\): \\begin{align} f(2) = a(0) + b(1) \\end{align} and then solve for \\(x = 1\\): \\begin{align} f(1) = a(-1) + b(0) \\end{align} for quadratic factors multiply each side of the resulting rational equation by the common denominator. collect terms on the right side of the equation. equate the coefficients of like terms to get a system of equations. solve the system to find the constants in the numerators. for example: \\begin{align} \\frac{x^2 + 3x - 1}{(x + 1)(x^2 + 2)} = \\frac{a}{(x + 1)} + \\frac{bx + c}{(x^2 + 2)} \\end{align} multiply each side by \\((x + 1)(x^2 + 2)\\): \\begin{align} x^2 + 3x - 1 = a(x^2 + 2) + (bx + c)(x + 1) \\end{align} collect the terms on each side of the equation: \\begin{align} x^2 + 3x - 1 = ax^2 + a2 + bx^2 + bx + cx + c = x^2 (a + b) + x (b + c) + 2a + c \\end{align} equate the coefficients of like terms to get a system of equations: \\begin{align} (a + b) = 1 \\end{align} \\begin{align} (b + c) = 3 \\end{align} \\begin{align} 2a + c = -1 \\end{align} solving this system for \\(a\\), \\(b\\), and \\(c\\) would give the partial fraction decomposition. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/09_01.html",
    "title": "Trigonometric Identities",
    "body": " index search search back trigonometric identities contents fundamental identities reciprocal identities quotient identities pythagorean identities negative-number identities hits for verifying identities the unit circle is shown in figure 1. the arc length is given by \\(s = r\\theta\\) and the radius of the unit circle is \\(1\\), an angle \\(\\theta\\) (in radians) determines an arc of length \\(s = \\theta\\). the arc terminates at a point \\((x, y)\\). angle \\(\\theta\\) determines a corresponding arc of equal length terminating at the point \\((x, -y)\\). therefore: \\begin{align} \\sin \\theta = \\frac{y}{1} = y \\end{align} and \\begin{align} \\sin(-\\theta) = \\frac{-y}{1} = -y \\end{align} thus: \\begin{align} \\sin(-\\theta) = -\\sin \\theta \\end{align} also, by definition: \\begin{align} \\cos(-\\theta) = \\cos \\theta \\end{align} and: \\begin{align} \\tan(-\\theta) = \\frac{\\sin(-\\theta)}{\\cos(-\\theta)} = \\frac{-\\sin(\\theta)}{\\cos(\\theta)} = -\\frac{\\sin(\\theta)}{\\cos(\\theta)} \\end{align} so: \\begin{align} \\tan(-\\theta) = -\\tan \\theta \\end{align} fundamental identities reciprocal identities \\begin{align} \\cot(\\theta) = \\frac{1}{\\tan \\theta} \\end{align} \\begin{align} \\sec(\\theta) = \\frac{1}{\\cos \\theta} \\end{align} \\begin{align} \\csc(\\theta) = \\frac{1}{\\sin \\theta} \\end{align} quotient identities \\begin{align} \\tan(\\theta) = \\frac{\\sin \\theta}{\\cos \\theta} \\end{align} \\begin{align} \\cot(\\theta) = \\frac{\\cos \\theta}{\\sin \\theta} \\end{align} pythagorean identities \\begin{align} \\sin^2 \\theta + \\cos^2 \\theta = 1 \\end{align} \\begin{align} 1 + \\tan^2 \\theta = \\sec^2 \\theta \\end{align} \\begin{align} 1 + \\cot^2 \\theta = \\csc^2 \\theta \\end{align} negative-number identities \\begin{align} \\sin (-\\theta) = - \\sin \\theta \\end{align} \\begin{align} \\cos (-\\theta) = \\cos \\theta \\end{align} \\begin{align} \\tan (-\\theta) = -\\tan \\theta \\end{align} \\begin{align} \\csc (-\\theta) = -\\csc \\theta \\end{align} \\begin{align} \\sec (-\\theta) = \\sec \\theta \\end{align} \\begin{align} \\cot (-\\theta) = -\\cot \\theta \\end{align} hits for verifying identities learn the fundamental identities. try to rewrite the more complicated side of the equation. it is sometimes helpful to express all trigonometric functions in the equation in terms of sine and cosine. usually, any factoring, division involving complex fractions, or indicated algebraic operations should be performed. as you select substitutions, keep in mind the side you are not changing, because it represents your goal. if a fractional expression contains \\(1 + \\sin x\\), multiplying both numerator and denominator by \\(1 - \\sin x\\) would give \\(1 - \\sin^2 x\\), which could be replaced with \\(\\cos^2 x\\). note that verifying identities is not the same as solving equations. one strategy is to work with only one side and rewrite it to match the other side. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/07_01.html",
    "title": "Circles and Parabolas",
    "body": " index search search back circles and parabolas contents conic sections circle general form of the equation of a circle parabola parabola with a horizontal axis and vertex 0 0 equation forms for translated parabolas conic sections parabolas, circles, ellipses, and hyperbolas form a group of curves known as the conic sections, because they are the result of intersecting a cone with a plane. circle a circle is a set of points in a plane that are equidistant from a fixed point. the distance is called the radius of the circle, and the fixed point is called the center. suppose a circle has center \\((h, k)\\) and radius \\(r > 0\\). then the distance between the center \\((h, k)\\) and any point \\((x, y)\\) on the circle must equal \\(r\\). thus, an equation of the circle is as follows: \\begin{align} \\sqrt{(x - h)^2 + (y - k)^2} = r \\end{align} \\begin{align} (x - h)^2 + (y - k)^2 = r^2 \\end{align} therefore the center–radius form of the equation of a circle with center \\((h, k)\\) and radius \\(r\\) is: \\begin{align} (x - h)^2 + (y - k)^2 = r^2 \\end{align} notice that a circle is the graph of a relation that is not a function. a circle with center \\((0, 0)\\) and radius \\(r\\) has equation: \\begin{align} x^2 + y^2 = r^2 \\end{align} general form of the equation of a circle for real numbers \\(c\\), \\(d\\), and \\(e\\), the equation: \\begin{align} x^2 + y^2 + cx + dy + e = 0 \\end{align} can have a graph that is a circle, that is a point, or that is empty (contains no points.) starting with an equation in this general form, we can work in reverse by completing the square to get an equation of the form: \\begin{align} (x - h)^2 + (y - k)^2 = m \\text{ for some } m \\end{align} there are three possibilities for the graph, based on the value of \\(m\\): if \\(m > 0\\), then \\(r^2 = m\\), and the equation represents a circle with radius \\(\\sqrt{m}\\). if \\(m = 0\\), the equation represents the single point \\((h, k)\\). if \\(m < 0\\), no points satisfy the equation and the graph is empty. parabola a parabola is a set of points in a plane equidistant from a fixed point and a fixed line. the fixed point is called the focus, and the fixed line the directrix, of the parabola. we can find an equation of a parabola from the preceding definition. let the directrix be the line \\(y = -c\\) and the focus be the point \\(f\\) with coordinates \\((0, c)\\). given a point \\(p\\) on the parabola, with coordinates \\((x, y)\\), using the distance formula gives the following result: \\begin{align} d(p, f) = d(p, d) \\end{align} \\begin{align} \\sqrt{(x - 0)^2 + (y - c)^2} = \\sqrt{(x - x)^2 + [y - (-c)]^2} \\end{align} \\begin{align} x^2 + (y - c)^2 = [y +c]^2 \\end{align} \\begin{align} x^2 + (y - c)^2 = (y + c)^2 \\end{align} \\begin{align} x^2 + y^2 + c^2 - 2cy = y^2 + c^2 + 2cy \\end{align} \\begin{align} x^2 = 4cy \\end{align} the focal chord through the focus and perpendicular to the axis of symmetry of a parabola is called the latus rectum, and has length \\(|4c|\\). to see this, note in the previous image that the endpoints of the chord are \\((-x, c)\\) and \\((x, c)\\). let \\(y = c\\) in the equation of the parabola and solve for \\(x\\). \\begin{align} x^2 = 4cy \\end{align} \\begin{align} x^2 = 4c^2 \\end{align} \\begin{align} x = |2c| \\end{align} the length of half the focal chord is |2c| (from x = 0 to x = 2c or x = -2c) , so its full length is |4c|. parabola with a horizontal axis and vertex \\((0, 0)\\) the parabola with focus \\((c, 0)\\) and directrix \\(x = -c\\) has equation: \\begin{align} y^2 = 4cx \\end{align} the parabola has vertex \\((0, 0)\\), horizontal axis \\(y = 0\\), and opens to the right if \\(c > 0\\) or to the left if \\(c < 0\\). notice that the graph of a parabola with a horizontal axis is not a function. equation forms for translated parabolas a parabola with vertex \\((h, k)\\) has an equation of the form: vertical axis: \\begin{align} (x - h)^2 = 4c(y - k) \\end{align} horizontal axis: \\begin{align} (y - k)^2 = 4c(x - h) \\end{align} where the focus is a distance \\(|c|\\) from the vertex: $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/09_04.html",
    "title": "The Inverse Circular Functions",
    "body": " index search search back the inverse circular functions contents inverse sine function inverse cosine function inverse tangent function other inverse trigonometric functions inverse sine function applying the horizontal line test, we see that \\(y = \\sin x\\) does not define a one-to-one function. if we restrict the domain to the interval \\([-\\frac{\\pi}{2}, \\frac{\\pi}{2}]\\) the function is one-to-one and has an inverse function. see figure 16: \\(y = \\sin^{-1} x\\) or \\(y = \\arcsin x\\) means that \\(x = \\sin y\\), for \\(-\\frac{\\pi}{2} \\leq y \\leq \\frac{\\pi}{2}\\) inverse cosine function the function \\(y = \\cos^{-1} x\\) (or \\(y = \\arccos x\\)) is defined by restricting the domain of the function to the interval \\([0, \\pi]\\), as in figure 19. the graph of \\(y = \\cos^{-1} x\\) is shown in figure 20. \\(y = \\cos^{-1} x\\) or \\(y = \\arccos x\\) means that \\(x = \\cos y\\), for \\(0 \\leq y \\leq \\pi\\). inverse tangent function restricting the domain of the function \\(y = \\tan x\\) to the open interval \\((-\\frac{\\pi}{2}, \\frac{\\pi}{2})\\) yields a one-to-one function. figure 23 shows the graph of the restricted tangent function. figure 24 gives the graph of \\(y = \\tan^{-1} x\\). \\(y = \\tan^{-1} x\\) or \\(y = \\arctan x\\) means \\(x = \\tan y\\), for \\(-\\frac{\\pi}{2} < y < \\frac{\\pi}{2}\\) other inverse trigonometric functions \\(y = \\cot^{-1} x\\) or \\(y = arc\\cot x\\) means that \\(x = \\cot y\\), for \\(0 < y < \\pi\\). \\(y = \\sec^{-1} x\\) or \\(y = arc\\sec x\\) means that \\(x = \\sec y\\), for \\(0 \\leq y \\leq \\pi, y \\neq \\frac{\\pi}{2}\\). \\(y = \\csc^{-1} x\\) or \\(y = arc\\csc x\\) means that \\(x = \\csc y\\), for \\(-\\frac{\\pi}{2} \\leq y \\leq \\frac{\\pi}{2}, y \\neq 0\\) finding \\(\\cot^{-1} x\\), \\(\\sec^{-1} x\\), and \\(\\csc^{-1} x\\) can be achieved by expressing these functions in terms of \\(\\tan^{-1} x\\), \\(\\cos{-1} x\\) and \\(\\sin^{-1} x\\). if \\(y = \\sec^{-1} x\\), then \\(\\sec y = x\\), so it follows: \\begin{align} \\sec y = \\frac{1}{\\cos y} = x \\end{align} \\begin{align} \\cos y = \\frac{1}{x} \\end{align} therefore: \\begin{align} y = \\cos^{-1}\\left(\\frac{1}{x}\\right) \\end{align} for the cosecant function: \\begin{align} \\csc y = \\frac{1}{\\sin y} = x \\end{align} \\begin{align} \\sin y = \\frac{1}{x} \\end{align} therefore: \\begin{align} y = \\sin^{-1}\\left(\\frac{1}{x}\\right) \\end{align} finally the inverse cotangent function can be evaluated as \\(90º - \\tan^{-1}x\\). $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/index.html",
    "title": "Math",
    "body": " index search search back math pre-calculus a graphical approach to algebra and trigonometry calculus calculus ealy transcendentals $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Study/Development.html",
    "title": "Development",
    "body": " index search search back development ordered by priority, one choose one at a time backend dev projects do the back end dev course from freecodecamp (max a week) continue the bookish project (add graphql) learn c++ tutorialspoints course (max a week) learn how to use cmake search for projects, some are: data structure data analysis with python course from freecodecamp data visualization course from freecodecamp to search for more project go to project ideas, there are project listings for a lot of languages, frameworks. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Study/index.html",
    "title": "Study",
    "body": " index search search back study study guides math cs development $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Study/CS/Computer Architecture.html",
    "title": "Computer Architecture",
    "body": " index search search back computer architecture contents resources computer systems a programmer s perspective nand2tetris resources computer systems: a programmer's perspective most courses go from chapter 1 to 6. do this course nand2tetris each chapter involves building a small piece of the overall system, from writing elementary logic gates in hdl, through a cpu and assembler, all the way to an application the size of a tetris game. the elements of computing systems (nand2tetris) $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Study/CS/Operating Systems.html",
    "title": "Operating Systems",
    "body": " index search search back operating systems books operating systems: three easy pieces labs: xv6 labs $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Study/CS/Mathematics for Computer Science.html",
    "title": "Mathematics for Computer Science",
    "body": " index search search back mathematics for computer science books mit lecture notes video lectures mit video lectures $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Study/CS/Algorithms and Data Structures.html",
    "title": "Algorithms and Data Structures",
    "body": " index search search back algorithms and data structures books the algorithm design manual video lectures skiena's or tim's on coursera practice: leetcode problem solving book after the manual: how to solve it $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Study/CS/index.html",
    "title": "Computer Science",
    "body": " index search search back computer science source programming computer architecture algorithms and data structures mathematics for computer science operating systems computer networking databases languages and compilers distributed systems ai and machine learning ai and machine learning check the source. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Study/CS/Computer Networking.html",
    "title": "Computer Networking",
    "body": " index search search back computer networking books computer networking: a top-down approach video lectures standford: introduction to computer networking course labs: wireshark labs $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Study/CS/Programming.html",
    "title": "Programming",
    "body": " index search search back programming contents notes alternatives books structure and interpretation of computer programs video lectures brian harvey’s sicp lectures resources for the berkley course code online on scheme scheme on arch (download mit/gnu scheme) plan 1 notes notes we recommend working through at least the first three chapters of sicp and doing the exercises. for additional practice, work through a set of small programming problems like those on exercism. alternatives same course but with python instead of scheme (stk) books: composing programs lectures: 61a taught by john denero at berkley. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Study/CS/Databases.html",
    "title": "Databases",
    "body": " index search search back databases contents data modelling start with the recording and the go through the book (paper compilation) video lectures cs186b berkley book readings in database systems data modelling book: data and reality: a timeless perspective on perceiving and managing information in our imprecise world. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Study/CS/Distributed Systems.html",
    "title": "Distributed Systems",
    "body": " index search search back distributed systems books practice oriented: designing data-intensive applications more traditional: distributed systems, 3rd edition $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Study/CS/Languages and Compilers.html",
    "title": "Languages and Compilers",
    "body": " index search search back languages and compilers contents notes books introductory: crafting interpreters as supplementary reference for video lectures: compilers: principles, techniques & tools video lecutres alex aiken’s, on edx notes for introductory book: we suggest taking the time to work through the whole thing, attempting whichever of the \"challenges\" sustain your interest. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Study/Math.html",
    "title": "Math",
    "body": " index search search back math contents first year first semester second semester second year first semester second semester third year first semester second semester fourth year first semester second semester first year first semester dicrete maths discrete mathematics with applications, 2nd edition by susanna s. epp discrete mathematics structures, 4th edition by kolman, busby and ross proof writing (very advanced, do not expect to master anything in these books) mathematical proofs: a transition to advanced mathematics by gary chartrand et. al (this one is better than the next one) an introduction to abstract mathematics by robert j. bond and wiliam j. keane second semester pre-algebra (refresh really basic math) ags pre-algebra (has solutions) fearon's pre-algebra (this one is better) college algebra (after the pre-algebra one, if the pre-algebra books are too easy skip onto these ones) college algebra by kaufmann (more begginer friendly) college algebra by blitzer second year first semester pre-calculus (once you are done with college algebra. if you know some basic algebra you can skip the college algebra and start in this section) a graphical approach to algebra and trigonometry by hornsby, lial, and rockswold. 6th edition (get the instructor's edition) second semester calculus calculus by james stewart, 5th edition (very famous book, to learn basic calculus. it has a lot of problems. used to teach calculus i, ii and iii) calculus by michael spivak, 3rd edition (it has less material but it is more advanced) third year first semester differential equations a first course in differential equations by zill ordinary differential equations with applications by andrews (it is easier, good for beginners) linear algebra (try to learn as much as possible) elementary linear algebra by howard anton (beginner friendly, with exercises) linear algebra by friedgber, insel, and spence (it is harder and more difficult to read. it is proof based) second semester statistics mathematical statistics by wackerly, mendenhall, and scheaffer a first course in probability by ross complex analysis (calculus with complex numbers. both are pretty much the same, very good beginner books) fundamentals of complex analysis by saff and snider, 3rd edition complex variables and applications by brown and churchill, 7th edition fourth year first semester real analysis (one of the hardest subjects) analysis 1 and analysis 2 by terrance tao (easier to read, but the other two are standard) advanced calculus by fitzpatrick principles of mathematical analysis by rudin elements ofanalysis by ross (expends a lot of time for proofs) abstract algebra (study of groups, rings and fields. very proof based) abstract algebra by saracino (very good for beginners) contemporary abstract algebra by gallian (also good for beginners) second semester topology (optional) introduction to topology by gamelin and greene (it has full solutions for all of the problems) combinatorics (optional) applied combinatorics by tucker naive set theory (optional) naive set theory by halmos functional analysis (optional) functional analysis by kreyszig graph theory (optional) graph theory by gould $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/index.html",
    "title": "Registry Index",
    "body": " index search search registry index notes study $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/10_04.html",
    "title": "Trigonometric (Polar) Form of Complex Numbers",
    "body": " index search search back trigonometric (polar) form of complex numbers contents the complex plane and vector representation trigonometric polar form converting from rectangular to trigonometric form produc theorem quotient theorem the complex plane and vector representation to graph a complex number we modify the rectangular coordinate system by calling the horizontal axis the real axis and the vertical axis the imaginary axis, such that we obtain the complex plane (figure 46). each complex number \\(a + bi\\) determines a unique position vector \\(\\textbf{op}\\) with initial point \\((0, 0)\\) and terminal point \\((a, b)\\). trigonometric (polar) form the next figure shows the complex number \\(x + yi\\) that corresponds to a vector \\(\\textbf{op}\\) with direction angle \\(\\theta\\) and magnitude \\(r\\), such that: \\begin{align} x = r \\cos \\theta \\end{align} \\begin{align} y = r \\sin \\theta \\end{align} \\begin{align} r = \\sqrt{x^2 + y^2} \\end{align} \\begin{align} \\tan \\theta = \\frac{y}{x}, x \\neq 0 \\end{align} if we substitute \\(x = r \\cos \\theta\\) and \\(y = r \\sin \\theta\\) into \\(x + yi\\) it gives: \\begin{align} x + yi = r \\cos \\theta + r \\sin \\theta i \\end{align} \\begin{align} = r (\\cos \\theta + i \\sin \\theta) \\end{align} this is called the trigonometric form (or polar form) of the complex number \\(x + yi\\). the expression \\(\\cos \\theta + i \\sin \\theta\\) is sometimes abbreviated \\(\\text{cis} \\theta\\), therefore \\(r(\\cos \\theta + i \\sin \\theta) = r \\text{cis} \\theta\\) the number \\(r\\) is the modulus or absolute value of \\(x + yi\\) and \\(\\theta\\) is the argument of \\(x + yi\\). converting from rectangular to trigonometric form sketch a graph of the number \\(x + yi\\) in the complex plane. find \\(r\\) by using the equation \\(r = \\sqrt{x^2 + y^2}\\). find \\(\\theta\\) by using th equation \\(\\tan \\theta = \\frac{y}{x}, x \\neq 0\\) choosing the quadrant indicated in (1). a fractal is a geometric figure with an endless self-similarity property. a fractal image repeats itself infinitely with ever decreasing dimensions. produc theorem given two complex number \\(x + yi\\) and \\(a + bi\\) such that their trigonometric form is given by: \\begin{align} x + yi = r(\\cos \\theta + i \\sin \\theta) \\end{align} and \\begin{align} a + bi = n(\\cos \\phi + i \\sin \\phi) \\end{align} if we multiply their trigonometric forms we obtain: \\begin{align} [r(\\cos \\theta + i \\sin \\theta)][n(\\cos \\phi + i \\sin \\phi)] \\end{align} \\begin{align} = r \\cdot n (\\cos \\theta + i \\sin \\theta)(\\cos \\phi + i \\sin \\phi) \\end{align} \\begin{align} = r \\cdot n (\\cos \\theta \\cdot \\cos \\phi + i \\sin \\theta \\cdot \\cos \\phi + \\cos \\theta \\cdot i \\sin \\phi + i^2 \\sin \\theta \\cdot \\sin \\phi) \\end{align} we know that \\(i^2 = -1\\), and we factor out \\(i\\). \\begin{align} = r \\cdot n (\\cos \\theta \\cdot \\cos \\phi + (-1) \\sin \\theta \\cdot \\sin \\phi + i (\\sin \\theta \\cdot \\cos \\phi + \\cos \\theta \\cdot \\sin \\phi)) \\end{align} \\begin{align} = r \\cdot n (\\cos \\theta \\cdot \\cos \\phi - \\sin \\theta \\cdot \\sin \\phi + i (\\sin \\theta \\cdot \\cos \\phi + \\cos \\theta \\cdot \\sin \\phi)) \\end{align} given \\(\\cos \\theta \\cdot \\cos \\phi - \\sin \\theta \\cdot \\sin \\phi = \\cos (\\theta + \\phi)\\) and \\(\\sin \\theta \\cdot \\cos \\phi + \\cos \\theta \\cdot \\sin \\phi = \\sin (\\theta + \\phi)\\) \\begin{align} = r \\cdot n (\\cos (\\theta + \\phi) + i \\sin (\\theta + \\phi)) \\end{align} in compact form this is written: \\begin{align} = r \\cdot n \\text{cis} (\\theta + \\phi) \\end{align} quotient theorem given two complex number \\(x + yi\\) and \\(a + bi\\) such that their trigonometric form is given by: \\begin{align} x + yi = r(\\cos \\theta + i \\sin \\theta) \\end{align} and \\begin{align} a + bi = n(\\cos \\phi + i \\sin \\phi) \\end{align} if we divide them we obtain: \\begin{align} \\frac{x + yi}{a + bi} = \\frac{(x + yi)(a - bi)}{(a + bi)(a - bi)} \\end{align} \\begin{align} = \\frac{ax + ayi - bxi -ybi^2}{a^2 - b^2i^2} = \\frac{ax + ayi - bxi + yb}{a^2 + b^2} \\end{align} \\begin{align} = \\frac{a(x + yi) + b(y - xi)}{a^2 + b^2} \\end{align} if we substitute their trigonometric forms, knowing that \\(a = n \\cdot \\cos \\phi\\), \\(b = n \\cdot \\sin \\phi\\), \\(x = r \\cdot \\cos \\theta\\) and \\(y = r \\cdot \\sin \\theta\\), then \\begin{align} = \\frac{(n \\cdot \\cos \\phi)(r \\cdot \\cos \\theta + i \\cdot r \\cdot \\sin \\theta) + (n \\cdot \\sin \\phi)(r \\cdot \\sin \\theta - i \\cdot r \\cdot \\cos \\theta)}{(n \\cdot \\cos \\phi)^2 + (n \\cdot \\sin \\phi)^2} \\end{align} we extract \\(n\\) and \\(r\\) as common factors and we expand the denominator: \\begin{align} = \\frac{n \\cdot r [\\cos \\phi \\cdot (\\cos \\theta + i \\cdot \\sin \\theta) + \\sin \\phi \\cdot (\\sin \\theta - i \\cdot \\cos \\theta)]}{n^2 (\\cos^2 \\phi + \\sin^2 \\phi)} \\end{align} we know that \\(\\cos^2 x + \\sin^2 x = 1\\). we multiply the elements on the numerator: \\begin{align} = \\frac{n \\cdot r (\\cos \\phi \\cdot \\cos \\theta + i \\cdot \\cos \\phi \\cdot \\sin \\theta + \\sin \\phi \\cdot \\sin \\theta - i \\sin \\phi \\cdot \\cos \\theta)}{n^2} \\end{align} we rearrange the elements on the numerator and extract \\(i\\) as a common factor: \\begin{align} = \\frac{n \\cdot r [\\cos \\theta \\cdot \\cos \\phi + \\sin \\theta \\cdot \\sin \\phi + i \\cdot (\\sin \\theta \\cdot \\cos \\phi - \\sin \\phi \\cdot \\cos \\theta)]}{n^2} \\end{align} given that \\(\\cos \\theta \\cdot \\cos \\theta + \\sin \\theta \\cdot \\sin \\phi = \\cos (\\theta - \\phi)\\) and \\(\\sin \\theta \\cdot \\cos \\phi - \\sin \\phi \\cdot \\cos \\theta = \\sin (\\theta - \\phi)\\): \\begin{align} = \\frac{n \\cdot r (\\cos (\\theta - \\phi) + i \\cdot \\sin (\\theta - \\phi))}{n^2} \\end{align} \\begin{align} = \\frac{r}{n} (\\cos (\\theta - \\phi) + i \\cdot \\sin (\\theta - \\phi)) \\end{align} in compact form this is written: \\begin{align} = \\frac{r}{n} \\text{cis} (\\theta - \\phi) \\end{align} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/10_05.html",
    "title": "Power and Roots of Complex Numbers",
    "body": " index search search back power and roots of complex numbers contents powers of complex numbers de moivre s theorem roots of complex numbers finding the roots of complex numbers powers of complex numbers (de moivre’s theorem) consider the following: \\begin{align} r(\\cos \\theta + i \\sin \\theta)^2 = [r(cos \\theta + i \\sin \\theta)][r(cos \\theta + i \\sin \\theta)] \\end{align} by the complex number product theorem: \\begin{align} = r^2 [cos (\\theta + \\theta) + i \\sin (\\theta + \\theta)] \\end{align} \\begin{align} = r^2 (\\cos 2\\theta + i \\sin 2 \\theta) \\end{align} so by de moivre's theorem: if \\(r(\\cos \\theta + i \\sin \\theta)\\) is a complex number and \\(n\\) is any positive integer, then the following holds: \\begin{align} [r(\\cos \\theta + i \\sin \\theta)]^n = r^n (\\cos n\\theta + i \\sin n\\theta) \\end{align} in compact form: \\begin{align} [r\\text{ cis} \\theta]^n = r^n \\text{ cis } n\\theta \\end{align} roots of complex numbers for a positive integer \\(n\\), the complex number \\(a + bi\\) an \\(n\\)th root of the complex number \\(x + yi\\) if the following holds: \\begin{align} (a + bi)^n = x + yi \\end{align} finding the roots of complex numbers to find the three complex cube roots of \\(8(\\cos 135º + i \\sin 135º)\\) we look for a comple number, \\(r(\\cos \\alpha + i \\sin \\alpha)\\) that satisfies: \\begin{align} [r (\\cos \\alpha + i \\sin \\alpha)]^3 = 8(\\cos 135º + i \\sin 135º) \\end{align} using de moivre's theorem the expression becomes: \\(r^3(\\cos 3\\alpha + i \\sin 3\\alpha) = 8(\\cos 135º + i \\sin 135º)\\) the first condition implies: \\begin{align} r^3 = 8 \\leftrightarrow r = 2 \\end{align} the second condition implies: \\begin{align} \\cos 3\\alpha = \\cos 135º \\end{align} \\begin{align} \\sin 3\\alpha = \\sin 135º \\end{align} such that \\(3\\alpha\\) must represent an angle that is coterminal with \\(135º\\), therefore: \\begin{align} 3 \\alpha = 135º + 360º k, k \\in \\mathbb{z} \\end{align} \\begin{align} \\alpha = \\frac{135º + 360º k}{3}, k \\in \\mathbb{z} \\end{align} if we let \\(k\\) take on integer values \\(0\\), \\(1\\) and \\(2\\): \\begin{align} \\text{if } k = 0 \\text{, then } \\alpha = 45º \\end{align} \\begin{align} \\text{if } k = 1 \\text{, then } \\alpha = 165º \\end{align} \\begin{align} \\text{if } k = 2 \\text{, then } \\alpha = 285º \\end{align} for \\(k > 2\\) we obtain angles bigger than \\(365º\\) that are coterminal with the identified solution. for example, for \\(k = 4\\) we obtain \\(\\alpha = 405º\\) that is coterminal with \\(45º\\). this previous example represents the \\(n\\)th root theorem that says: if \\(n\\) is a positive integer, \\(r\\) is a positive real number and \\(\\theta\\) is in degrees, then the nonzero complex number \\(r (\\cos \\theta + i \\sin \\theta)\\) has exactly \\(n\\) distinct \\(n\\)th roots, given by: \\begin{align} \\sqrt[n]{r} (\\cos \\alpha + i \\sin \\alpha) \\end{align} \\begin{align} \\sqrt[n]{r} \\text{ cis } \\alpha \\end{align} where: \\begin{align} \\alpha = \\frac{\\theta + 360º \\cdot k}{n}, k = 0, 1, \\cdots, n - 1 \\end{align} if \\(\\theta\\) is in radians then: \\begin{align} \\alpha = \\frac{\\theta + 2 \\pi \\cdot k}{n}, k = 0, 1, \\cdots, n - 1 \\end{align} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/10_06.html",
    "title": "Polar Equations and Graphs",
    "body": " index search search back polar equations and graphs contents polar coordinate system relationships between rectangular and polar coordinates graph of polar equations classifying polar equations circles lemniscates lima ons rose curves polar coordinate system the polar coordinate system is based on a point, called the pole, and a ray, called the polar axis. the polar axis is usually drawn in the direction of the positive x-axis. see figure 56. in figure 57, the pole has been placed at the origin of a rectangular coordinate system. the point \\(p\\) has rectangular coordinates \\((x, y)\\), directed angle \\(\\theta\\) and directed distance \\(r\\). the ordered pair \\((r, \\theta)\\) gives us the polar coordinates. figure 58 shows the rectangular axes over a polar coordinate grid. relationships between rectangular and polar coordinates if a point has rectangular coordinates \\((x, y)\\) and polar coordinates \\((r, \\theta)\\) then: \\begin{align} x = r \\cos \\theta \\end{align} \\begin{align} y = r \\sin \\theta \\end{align} \\begin{align} r^2 = x^2 + y^2 \\end{align} \\begin{align} \\tan \\theta = \\frac{y}{x}, x \\neq 0 \\end{align} note that a point in the plane can only have one pair of rectangular coordinates, however this same point can have infinitely many pairs of polar coordinates. for example \\((2, 30º) = (2, 390º) = (2, -330º) = (-2, 210º) = \\cdots\\) (see figure 62). graph of polar equations equations in \\(x\\) and \\(y\\) are called rectangluar (or cartesian) equations, so equations in \\(r\\) and \\(\\theta\\) are called polar equations. \\begin{align} r = 3 \\sin \\theta \\end{align} the rectangular forms of lines and circles can also be defined in terms of polar coordinates, usually obtained by solving for \\(r\\). for a line: \\begin{align} ax + by = c \\end{align} \\begin{align} a(r \\cos \\theta) + b(r \\sin \\theta) = c \\end{align} \\begin{align} r(a \\cos \\theta + b \\sin \\theta) = c \\end{align} \\begin{align} r = \\frac{c}{a \\cos \\theta + b \\sin \\theta} \\end{align} for a circle: \\begin{align} x^2 + y^2 = a^2 \\end{align} \\begin{align} r^2 = a^2 \\end{align} \\begin{align} r = \\pm \\sqrt{a^2} = \\pm a \\end{align} classifying polar equations the table summarizes common polar graphs and forms of their equations. circles \\begin{align} r = a \\cos \\theta \\end{align} \\begin{align} r = a \\sin \\theta \\end{align} lemniscates \\begin{align} r^2 = a^2 \\sin 2 \\theta \\end{align} \\begin{align} r^2 = a^2 \\cos 2 \\theta \\end{align} limaçons \\begin{align} r = a \\pm b \\sin \\theta \\end{align} \\begin{align} r = a \\pm b \\cos \\theta \\end{align} rose curves $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/10_07.html",
    "title": "More Parametric Equations",
    "body": " index search search back more parametric equations contents parametric equations with trigonometric functions the cycloid applications of parametric equations parametric equations with trigonometric functions if we use trigonometric functions in parametric equations, many interesting curves can be drawn as shown in the following figure: the cycloid the path traced by a fixed point on the circumference of a circle rolling along a line is called a cycloid. a cycloid is defined by: \\begin{align} x = at - a \\sin t \\end{align} \\begin{align} y = a - a \\cos t \\end{align} for \\(t\\) in \\((-\\infty, \\infty)\\). it has an interesting physical property. if a flexible cord goes through points \\(p\\) and \\(q\\), due to the force of gravity, a bead slides without friction along this path from \\(p\\) to \\(q\\). the path that requires least time takes the shape of an inverted cycloid. applications of parametric equations parametric equations are used to simulate motion. if a ball is thrown with an initial velocidy of \\(v_0\\) at an angle \\(\\theta\\) with the horizontal, it position \\((x, y)\\) can be modeled by the parametric equations: \\begin{align} x = (v_0 \\cos \\theta)t \\end{align} \\begin{align} y = (v_0 \\sin \\theta)t - 16t^2 + h \\end{align} where \\(t\\) is in seconds and \\(h\\) is the ball's initial height above the ground. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/11_01.html",
    "title": "Sequences and Series",
    "body": " index search search back sequences and series contents sequences series summation properties summation rules sequences a sequence is a function that has a set of natural numbers as its domain. instead of using a funcion notation to indicate a sequence \\(f\\), we use \\(a_n\\), where \\(a_n = f(n)\\). the elements in the range of a sequence are called the terms of the sequence, and they are ordered. the general term of the \\(n\\)th term of the sequence is \\(a_n\\). a sequence is a finite sequence if the domain is a finite set \\(\\{1, 2, 3, 4, \\cdots, n\\}\\), where \\(n\\) is a natural number. an infinite sequence has the set of a ll natural numbers as its domain. if the terms of an infinite sequence get closer to some real number, the sequence is said to be convergent and to converge to that real number (see figure 3). a sequence that does not converte to some number is divergent. some sequences are defined by a recursive definition, a definition in which each term is defined as an expression involving the previous term or terms. series the sum of the terms of a sequence is called a series. a finite series is an expression of the form: \\begin{align} s_n = a_1 + a_2 + a_3 + \\cdots + a_n = \\sum_{i=1}^n a_i \\end{align} an infinite series is an expression of the form: \\begin{align} s_{\\infty} = a_1 + a_2 + a_3 + \\cdots + a_n + \\cdots = \\sum_{i=1}^{\\infty} a_i \\end{align} summation properties if \\(a_1, a_2, a_3, \\cdots, a_n\\) and \\(b_1, b_2, b_3, \\cdots, b_n\\) are two sequences, and \\(c\\) is a constante, then for every positive integer \\(n\\), the following hold: \\begin{align} \\sum_{i=1}^n c = n c \\end{align} \\begin{align} \\sum_{i=1}^n ca_i = c \\sum_{i=1}^n a_i \\end{align} \\begin{align} \\sum_{i=1}^n (a_i + b_i) = \\sum_{i=1}^n a_i + \\sum_{i=1}^n b_i \\end{align} \\begin{align} \\sum_{i=1}^n (a_i - b_i) = \\sum_{i=1}^n a_i - \\sum_{i=1}^n b_i \\end{align} summation rules \\begin{align} \\sum_{i=1}^n i = 1 + 2 + \\cdots + n = \\frac{n(n + 1)}{2} \\end{align} \\begin{align} \\sum_{i=1}^n i^2 = 1^2 + 2^2 + \\cdots + n^2 = \\frac{n(n + 1)(2n + 1)}{6} \\end{align} \\begin{align} \\sum_{i=1}^n i^3 = 1^3 + 2^3 + \\cdots + n^3 = \\frac{n^2(n + 1)^2}{4} \\end{align} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/11_02.html",
    "title": "Arithmetic Sequences and Series",
    "body": " index search search back arithmetic sequences and series contents arithmetic sequences arithmetic series arithmetic sequences a sequence in which each term after the first is obtained by adding a fixed number, the common difference \\(d\\), to a previous term is an arithmetic sequence (or arithmetic progression). the common difference is obtained as: \\begin{align} d = a_{n + 1} - a_n \\end{align} in an arithmetic sequence with first term \\(a_1\\) and common difference \\(d\\), the \\(n\\)th term is: \\begin{align} a_n = a_1 + (n - 1)d \\end{align} to obtain the graph for that sequence: \\begin{align} a_n = a_1 + (n - 1)d \\end{align} \\begin{align} = a_1 + dn - d \\end{align} \\begin{align} = dn + (a_1 - d) \\end{align} \\begin{align} = dn + c \\end{align} where \\(c = a_1 - d\\). such that the points on the graph of an arithmetic sequence \\(f\\) are defined by \\(f(n) = dn + c\\). the following image shows such a graph: arithmetic series the sum of the terms of an arithmetic sequence is an arithmetic series. to obtain the general formula for the arithmetic series we first write the sum of the first \\(n\\) terms as: \\begin{align} s_n = a_1 + (a_1 + d) + (a_1 + 2d) + \\cdots + (a_1 + (n - 1)d) \\end{align} now we write the same sum in reverse order, beginnin with \\(a_n\\) and substracting \\(d\\): \\begin{align} s_n = a_n + (a_n - d) + (a_n - 2d) + \\cdots + (a_n - (n - 1)d) \\end{align} now we add both expressions: \\begin{align} 2 s_n = (a_1 + a_n) + (a_1 + a_n) + \\cdots + (a_1 + a_n) \\end{align} \\begin{align} 2 s_n = n(a_1 + a_n) \\end{align} \\begin{align} s_n = \\frac{n}{2}(a_1 + a_n) \\end{align} \\begin{align} s_n = \\frac{n}{2}(a_1 + a_1 + (n-1)d) \\end{align} \\begin{align} s_n = \\frac{n}{2}(2a_1 + (n-1)d) \\end{align} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/CG/RTGW/04/01_transformations.html",
    "title": "Transformations",
    "body": " index search search back transformations contents vertex transformations homogeneous coordinates transformations translation matrices scaling matrices rotation matrices cumulating transformations transposing transformation or projection matrices vertex transformations each transformation is encoded by a \\(4\\)x\\(4\\) matrix. we multiply vertices that have three components, \\((x, y, z)\\), by this \\(4\\)x\\(4\\) matrix by adding a fourth component to each vertex called the homogeneous coordinate. this article has a great visualization for each space: world space camera space clip space homogeneous coordinates until now, we only considered 3d vertices as a \\((x,y,z)\\) triplet. let’s introduce \\(w\\). homogeneous coordinates make it possible to represent affine transformations (such as rotation, scaling, shear, and translation) and projective transformations as \\(4\\)x\\(4\\) matrices. in homogeneous coordinates, vertices have four components: \\(x, y, z\\), and \\(w\\). the first three components are the vertex coordinates in euclidian space. the fourth is the perspective component. so \\((x, y, z, w)\\) take us to a new space: the projective space. this will be more clear soon, but for now, just remember this: if \\(w == 1\\), then the vector \\((x,y,z,1)\\) is a position in space. if \\(w == 0\\), then the vector \\((x,y,z,0)\\) is a direction. what difference does this make? well, for a rotation, it doesn’t change anything. when you rotate a point or a direction, you get the same result. however, for a translation (when you move the point in a certain direction), things are different. what could mean “translate a direction”? not much. homogeneous coordinates allow us to use a single mathematical formula to deal with these two cases. homogeneous coordinates make it possible to solve a system of linear equations where each equation represents a line that is parallel with all the others in the system. remember that in euclidian space, a system like that does not have solutions, because there are no intersections. however, in projective space, this system has a solution—the lines will intersect at infinity. this fact is represented by the perspective component having a value of \\(0\\). it's easy to convert from homogeneous coordinates to non-homogeneous, old-fashioned, euclidean coordinates by dividing each coordinate by \\(w\\): \\begin{align} h(x, y, z, w) = v(\\frac{x}{w}, \\frac{y}{w}, \\frac{z}{w}) \\end{align} consequently, if you want to go from euclidean to projective space, you add the fourth component, \\(w\\), and make it \\(1\\): \\begin{align} v(x, y, z) = h(x, y, z, 1) \\end{align} in fact, this is what we've been doing throughout the first three chapters: #version 300 es precision mediump float; uniform mat4 umodelviewmatrix; uniform mat4 uprojectionmatrix; uniform mat4 unormalmatrix; in vec3 avertexposition; void main(void) { gl_position = uprojectionmatrix * umodelviewmatrix * vec4(avertexposition, 1.0); } there is one more thing to note about homogeneous coordinates: while vertices have a homogeneous coordinate, \\(w = 1\\), vectors have a homogeneous coordinate, \\(w = 0\\). this is because in the phong vertex shader, the line that processes the normals looks like this: vvertexnormal = vec3(unormalmatrix * vec4(avertexnormal, 0.0)); transformations translation matrices these are the most simple tranformation matrices to understand. a translation matrix look like this: \\begin{align} \\begin{bmatrix} 1 & 0 & 0 & x \\\\ 0 & 1 & 0 & y \\\\ 0 & 0 & 1 & z \\\\ 0 & 0 & 0 & 1 \\\\ \\end{bmatrix} \\end{align} where \\(x,y,z\\) are the values that you want to add to your position. so if we want to translate the vector \\((10,10,10,1)\\) of \\(10\\) units in the x direction, we get: \\begin{align} \\begin{bmatrix} 1 & 0 & 0 & 10 \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 1 \\\\ \\end{bmatrix} * \\begin{bmatrix} 10 \\\\ 10 \\\\ 10 \\\\ 1 \\\\ \\end{bmatrix} = \\begin{bmatrix} 1 * 10 + 0 * 10 + 0 * 10 + 10 * 1 \\\\ 0 * 10 + 1 * 10 + 0 * 10 + 0 * 1 \\\\ 0 * 10 + 0 * 10 + 1 * 10 + 0 * 1 \\\\ 0 * 10 + 0 * 10 + 0 * 10 + 1 * 1 \\\\ \\end{bmatrix} = \\begin{bmatrix} 20 \\\\ 10 \\\\ 10 \\\\ 1 \\\\ \\end{bmatrix} \\end{align} and we get a \\((20,10,10,1)\\) homogeneous vector! remember, the \\(1\\) means that it is a position, not a direction. so our transformation didn’t change the fact that we were dealing with a position, which is good. scaling matrices scaling matrices are quite easy too: \\begin{align} \\begin{bmatrix} x & 0 & 0 & 0 \\\\ 0 & y & 0 & 0 \\\\ 0 & 0 & z & 0 \\\\ 0 & 0 & 0 & 1 \\\\ \\end{bmatrix} \\end{align} so if you want to scale a vector (position or direction, it doesn’t matter) by \\(2.0\\) in all directions: \\begin{align} \\begin{bmatrix} 2 & 0 & 0 & 0 \\\\ 0 & 2 & 0 & 0 \\\\ 0 & 0 & 2 & 0 \\\\ 0 & 0 & 0 & 1 \\\\ \\end{bmatrix} * \\begin{bmatrix} x \\\\ y \\\\ z \\\\ w \\\\ \\end{bmatrix} = \\begin{bmatrix} 2 * x + 0 * y + 0 * z + 0 * w \\\\ 0 * x + 2 * y + 0 * z + 0 * w \\\\ 0 * x + 0 * y + 2 * z + 0 * w \\\\ 0 * x + 0 * y + 0 * z + 1 * w \\\\ \\end{bmatrix} = \\begin{bmatrix} 2x \\\\ 2y \\\\ 2z \\\\ w \\\\ \\end{bmatrix} \\end{align} rotation matrices tbc cumulating transformations so now we know how to rotate, translate, and scale our vectors. it would be great to combine these transformations. this is done by multiplying the matrices together: transformedvector = translationmatrix * rotationmatrix * scalematrix * originalvector; this actually performs the scaling first, and then the rotation, and then the translation. this is how matrix multiplication works. transposing transformation or projection matrices it can be confusing to determine whether you should transpose your matrix before passing it to the graphics pipeline. according to the webgl specifications, matrices are conventionally written in column-major order. row-major order is what is conventionally used on mathematics to define matrices, and throughout all this chapter we define the matrices on row-major order, therefore to avoid this before passing them to webgl we need to transpose them, either we do it manually, or we can use: gl.uniformmatrix4fv( umodelviewmatrix, true, modelviewmatrix.tofloatarray() ); where the second argument determines whether we want to transpose the matrix or not. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/CG/RTGW/04/02_01_perspective.html",
    "title": "Perspective Matrix",
    "body": " index search search back perspective matrix contents fundamentals derivation projected x projected y projected z the field of view and image aspect ratio computing the coordinates note references in all opengl books and references, the perspective projection matrix used in opengl is defined as: \\begin{align} \\begin{bmatrix} \\frac{2n}{r - l} & 0 & \\frac{r + l}{r - l} & 0 \\\\ 0 & \\frac{2n}{t - b} & \\frac{t + b}{t - b} & 0 \\\\ 0 & 0 & -\\frac{f + n}{f - n} & -\\frac{2fn}{f - n} \\\\ 0 & 0 & -1 & 0 \\end{bmatrix} \\end{align} when we multiply a homogeneous point with this matrix, the point's \\(w\\) coordinate is multiplied by this element, and the value of \\(w\\) ends up being the projected point's \\(z\\) coordinate: \\begin{align} \\begin{bmatrix} \\frac{2n}{r - l} & 0 & \\frac{r + l}{r - l} & 0 \\\\ 0 & \\frac{2n}{t - b} & \\frac{t + b}{t - b} & 0 \\\\ 0 & 0 & -\\frac{f + n}{f - n} & -\\frac{2fn}{f - n} \\\\ 0 & 0 & -1 & 0 \\end{bmatrix} \\cdot \\begin{bmatrix} x \\\\ y \\\\ z \\\\ w = 1 \\end{bmatrix} = \\begin{bmatrix} \\frac{2n}{r - l} \\cdot x + \\frac{r + l}{r - l} \\cdot y \\\\ \\frac{2n}{t - b} \\cdot y + \\frac{t + b}{t - b} \\cdot z \\\\ -\\frac{f + n}{f - n} \\cdot z + -\\frac{2fn}{f - n} \\cdot w \\\\ -1 \\cdot z \\end{bmatrix} \\end{align} in summary, we understand that the matrix is correctly set up for the z-divide. fundamentals let's now examine how points are projected in opengl (or webgl). a line is drawn from the camera's origin to the point \\(p\\) that we want to project, and the intersection of this line with the image plane determines the position of the projected point \\(p_s\\). it's important to note that in opengl, the image plane is situated on the near clipping plane. the triangles \\(\\delta abc\\) and \\(\\delta def\\) are similar. thus, we can express: \\begin{align} \\frac{ab}{de} = \\frac{bc}{ef} \\end{align} by substituting \\(ab\\) with \\(n\\) (the near clipping plane), \\(de\\) with \\(p_z\\) (the z-coordinate of \\(p\\)), and \\(ef\\) with \\(p_y\\) (the y-coordinate of \\(p\\)), we can rewrite this equation as: \\begin{align} \\frac{n}{-p_z} = \\frac{bc}{p_y} \\end{align} and solving for \\(bc\\) we obtain: \\begin{align} bc = p_{sy} \\frac{n \\cdot p_y}{-p_z} \\end{align} note that since the camera is oriented along the negative z-axis, \\(p_z\\) is negative, so, to maintain the sign of the y-coordinate, we negate \\(p_z\\). following the same logic, we derive the x-coordinate of the projected point with the following equation: \\begin{align} p_{s_x} = \\frac{n \\cdot p_x}{-p_z} \\end{align} following the same reasoning for \\(p_y\\), we obtain: \\begin{align} p_{s_y} = \\frac{n \\cdot p_y}{-p_z} \\end{align} derivation we need to figure out how \\(p_{sx}\\) and \\(p_{sy}\\) correlate with the webgl perspective matrix. the purpose of a projection matrix is to remap the values projected onto the image plane to a unit cube (defined by minimum \\((-1, -1, -1)\\) and maximum \\((1, 1, 1)\\)). projected x once the point \\(p\\) is projected onto the image plane (near clipping plane), is considered visible if its and coordinates fall within the range \\([left, right]\\) for \\(x\\) and \\([bottom, top]\\) for \\(y\\), as depicted in figure 2. such that: \\begin{align} l \\leq p_{sx} \\leq r \\end{align} where \\(l\\) and \\(r\\) are the left and right coordinates respectively. our objective is to remap so that its final value resides within the range \\([-1, 1]\\): \\begin{align} 0 \\leq p_{sx} - l \\leq r - l \\end{align} normalizing by dividing by \\(r - l\\) gives: \\begin{align} 0 \\leq \\frac{p_{sx} - l}{r - l} \\leq 1 \\end{align} multiplying all terms by \\(2\\): \\begin{align} 0 \\leq 2 \\frac{p_{sx} - l}{r - l} \\leq 2 \\end{align} substracting \\(1\\) from all terms results in: \\begin{align} -1 \\leq 2 \\frac{p_{sx} - l}{r - l} - 1 \\leq 1 \\end{align} now the central term on the inequality is defined to exist on the range \\([-1, 1]\\), which is what we wanted. with some further rearrangement: \\begin{align} -1 \\leq 2 \\frac{p_{sx} - l}{r - l} - \\frac{r - l}{r - l} \\leq 1 \\end{align} \\begin{align} -1 \\leq \\frac{2p_{sx} - 2l - r + l}{r - l}\\leq 1 \\end{align} \\begin{align} -1 \\leq \\frac{2p_{sx} - r - l}{r - l}\\leq 1 \\end{align} \\begin{align} -1 \\leq \\frac{2p_{sx}}{r - l} - \\frac{r + l}{r - l}\\leq 1 \\end{align} the two central terms are quite similar to the first two terms of the first row in the webgl perspective projection matrix. if we replace \\(p_{sx}\\) from the previous equation with \\begin{align} p_{sx} = \\frac{n p_x}{-p_z} \\end{align} we get: \\begin{align} -1 \\leq \\frac{2np_x}{-p_z(r - l)} - \\frac{r + l}{r - l}\\leq 1 \\end{align} we can encode this equation in matrix form if we replace the first and third coefficients of the matrix's first row with the first and second term of this formula: \\begin{align} \\begin{bmatrix} \\frac{2n}{r - l} & 0 & \\frac{r + l}{r - l} & 0 \\\\ \\cdots & \\cdots & \\cdots & \\cdots \\\\ \\cdots & \\cdots & \\cdots & \\cdots \\\\ 0 & 0 & -1 & 0 \\end{bmatrix} \\end{align} so computing \\(p_{sx}\\) yields: \\begin{align} \\begin{bmatrix} \\frac{2n}{r - l} & 0 & \\frac{r + l}{r - l} & 0 \\\\ \\cdots & \\cdots & \\cdots & \\cdots \\\\ \\cdots & \\cdots & \\cdots & \\cdots \\\\ 0 & 0 & -1 & 0 \\end{bmatrix} \\cdot \\begin{bmatrix} p_x \\\\ p_y \\\\ p_z \\\\ p_w \\\\ \\end{bmatrix} \\end{align} such that: \\begin{align} p_{sx} = \\frac{2n}{r - l} p_x + \\frac{r + l}{r - l} p_z \\end{align} and since \\(p_{sx}\\) will be divided at the end of the process by \\(-p_z\\) when we convert from homogeneous to cartesian coordinates, we get: \\begin{align} p_{sx} = \\frac{\\frac{2n}{r - l} p_x}{-p_z} + \\frac{\\frac{r + l}{r - l} p_z}{-p_z} = \\frac{2np_x}{-p_z(r - l)} - \\frac{r + l}{r - l} \\end{align} this is the first coordinate of the projected point \\(p_{s}\\) computed using the webgl perspective matrix. projected y the derivation for \\(p_{sy}\\) is analogous, replacing \\(l\\) and \\(r\\) with and \\(b\\) and \\(t\\), such that: \\begin{align} b \\leq p_{s_y} \\leq t \\end{align} \\begin{align} 0 \\leq p_{s_y} - b \\leq t - b \\end{align} \\begin{align} 0 \\leq \\frac{p_{s_y} - b}{t - b} \\leq 1 \\end{align} we multiply by \\(2\\): \\begin{align} 0 \\leq 2\\frac{p_{s_y} - b}{t - b} \\leq 2 \\end{align} and we substract \\(1\\): \\begin{align} -1 \\leq 2\\frac{p_{s_y} - b}{t - b} - 1 \\leq 1 \\end{align} \\begin{align} -1 \\leq 2\\frac{p_{s_y} - b}{t - b} - \\frac{t - b}{t - b} \\leq 1 \\end{align} \\begin{align} -1 \\leq \\frac{2p_{s_y} - 2b - t + b}{t - b} \\leq 1 \\end{align} \\begin{align} -1 \\leq \\frac{2p_{s_y} - b - t}{t - b} \\leq 1 \\end{align} \\begin{align} -1 \\leq \\frac{2p_{s_y}}{t - b} - \\frac{t + b}{t - b} \\leq 1 \\end{align} given we know that: \\begin{align} p_{s_y} = \\frac{n p_y}{-p_z} \\end{align} then: \\begin{align} -1 \\leq \\frac{2n p_y}{-p_z(t - b)} - \\frac{t + b}{t - b} \\leq 1 \\end{align} therefore, now our projection matrix has the following shape: \\begin{align} \\begin{bmatrix} \\frac{2n}{r - l} & 0 & \\frac{r + l}{r - l} & 0 \\\\ 0 & \\frac{2n}{t - b} & \\frac{t + b}{t - b} & 0 \\\\ \\cdots & \\cdots & \\cdots & \\cdots \\\\ 0 & 0 & -1 & 0 \\end{bmatrix} \\end{align} computing \\(p_{s_y}\\) using this matrix gives: \\begin{align} \\begin{bmatrix} \\frac{2n}{r - l} & 0 & \\frac{r + l}{r - l} & 0 \\\\ 0 & \\frac{2n}{t - b} & \\frac{t + b}{t - b} & 0 \\\\ \\cdots & \\cdots & \\cdots & \\cdots \\\\ 0 & 0 & -1 & 0 \\end{bmatrix} \\cdot \\begin{bmatrix} x \\\\ y \\\\ w \\\\ z \\\\ \\end{bmatrix} \\end{align} \\begin{align} p_{s_y} = 0 \\cdot x + \\frac{2n}{t - b} p_y + \\frac{t + b}{t - b}p_z + 0 \\end{align} and after the divsion by \\(-p_z\\): \\begin{align} p_{s_y} = \\frac{\\frac{2n}{t - b}p_y}{-p_z} + \\frac{\\frac{t + b}{t - b}p_z}{-p_z} \\end{align} \\begin{align} = \\frac{2n p_y}{-p_z(t - b)} - \\frac{t + b}{t - b} \\end{align} projected z all that's left to do to complete it is find a way to remap the z-coordinate of the projected points to the range \\([-1,1]\\) we know that the \\(x\\) and \\(y\\) coordinates of \\(p\\) don't contribute to the calculation of the projected point's z-coordinate. thus, the first and second coefficients of the matrix's third row are necessarily zero. we are left with the following matrix: \\begin{align} \\begin{bmatrix} \\frac{2n}{r - l} & 0 & \\frac{r + l}{r - l} & 0 \\\\ 0 & \\frac{2n}{t - b} & \\frac{t + b}{t - b} & 0 \\\\ 0 & 0 & a & b \\\\ 0 & 0 & -1 & 0 \\end{bmatrix} \\end{align} if we write the equation to compute \\(p_{s_z}\\) using this matrix, we get: \\begin{align} p_{s_z} = \\frac{0 \\cdot p_x + 0 \\cdot p_y + a \\cdot p_z + b \\cdot p_w}{p_{s_w} = - p_z} \\end{align} \\begin{align} \\frac{a \\cdot p_z + b}{p_{s_w} = -p_z} \\end{align} note that we are dividing \\(p_{s_z}\\) by \\(p_{s_w}\\) when the point is converted from homogeneous to cartesian coordinates, and that \\(p_w = 1\\). we need to find the values of \\(a\\) and \\(b\\). we know that when \\(p_z\\) is on the near clipping plane, \\(p_{s_z}\\) needs to be remapped to \\(-1\\), and when \\(p_z\\) is on the far clipping plane, \\(p_{s_z}\\)needs to be remapped to \\(1\\). so, when \\(p_z\\) is on the near plane, the previous equation is as follows: \\begin{align} \\frac{a \\cdot (p_z = -n) + b}{(-p_z = -(-n) = n)} = -1 \\end{align} \\begin{align} \\frac{a \\cdot -n + b}{n} = -1 \\end{align} \\begin{align} -na + b = -n \\end{align} and when \\(p_z\\) is on the far plane: \\begin{align} \\frac{a \\cdot (p_z = -f) + b}{(-p_z = -(-f) = f)} = 1 \\end{align} \\begin{align} \\frac{a \\cdot -f + b}{f} = 1 \\end{align} \\begin{align} -fa + b = f \\end{align} these two equations form the following system of equations: \\begin{align} \\begin{cases} -na + b = -n \\\\ -fa + b = f \\end{cases} \\end{align} we solve the first equation for \\(b\\): \\begin{align} b = -n + an \\end{align} and we substitute on the second equation: \\begin{align} -fa + (-n + an) = f \\end{align} \\begin{align} a (n - f) = f + n \\end{align} \\begin{align} a= -\\frac{f + n}{f - n} \\end{align} finding \\(b\\) is straightforward. we just replace \\(a\\) in the first equation: \\begin{align} b = -n + (-\\frac{f + n}{f - n})n \\end{align} \\begin{align} b = -n(1 + \\frac{f + n}{f - n}) \\end{align} \\begin{align} b = -n(\\frac{f + n + f - n}{f - n}) \\end{align} \\begin{align} b = -n(\\frac{2f}{f - n}) \\end{align} \\begin{align} b = -\\frac{2fn}{f - n} \\end{align} we can replace the solutions we found for a and b in our matrix, and we finally get: \\begin{align} \\begin{bmatrix} \\frac{2n}{r - l} & 0 & \\frac{r + l}{r - l} & 0 \\\\ 0 & \\frac{2n}{t - b} & \\frac{t + b}{t - b} & 0 \\\\ 0 & 0 & -\\frac{f + n}{f - n}& -\\frac{2fn}{f - n} \\\\ 0 & 0 & -1 & 0 \\end{bmatrix} \\end{align} the field of view and image aspect ratio the field of view and the image aspect ratio are somehow related to the projection process. the construction of the matrix relies on six parameters: the left, right, bottom, and top coordinates, as well as the near and far clipping planes. the user provides the values for the near and far clipping planes, but how about the left, right, bottom, and top coordinates? what are these, where do they come from, and how do we calculate them? observing the following figure, you can see that these coordinates correspond to the lower-left and upper-right corners of the frustum front face, where the image of the 3d scene is projected: the angle of view can either be defined vertically or horizontally. opengl tends to define the field-of-view as vertical (hence the y in fovy). computing the coordinates to compute the top coordinate, we look at the right-angled triangle \\(abc\\) on the following image. the angle between by \\(ab\\) and \\(ac\\) is half the fov. also, the adjacent side of the triangle is the value for the near-clipping plane. using trigonometry, we can express this as: \\begin{align} \\tan(\\frac{fovy}{2}) = \\frac{opposite}{adyacent} = \\frac{bc}{ab} = \\frac{top}{near} \\end{align} therefore: \\begin{align} top = \\tan(\\frac{fovy}{2}) \\cdot near \\end{align} and since the bottom half of the camera is symmetrical to the upper half, we can state that: \\begin{align} bottom = -top \\end{align} in figure 5, two scenarios are considered: the image can either be square or rectangular. for a square camera, it's straightforward: the left and bottom coordinates are the same, the right and top coordinates are also the same. therefore: \\begin{align} top = \\tan(\\frac{fovy}{2}) \\cdot near \\end{align} \\begin{align} left = bottom = -top \\end{align} \\begin{align} right = top \\end{align} for a non-square camera, as shown in the right inside of figure 5, the bottom and top coordinates remain the same, but the left and right coordinates are scaled by the aspect ratio, defined as the image width over the image height. the general formulas for computing the left, right, and bottom coordinates are: \\begin{align} aspect ratio = \\frac{width}{heigth} \\end{align} \\begin{align} top = \\tan(\\frac{fovy}{2}) \\cdot near \\end{align} \\begin{align} bottom = -top \\end{align} \\begin{align} right = top \\cdot aspect ratio \\end{align} \\begin{align} left = bottom \\cdot aspect ratio \\end{align} note this section is kinda important, up until now we have define this projection matrix on what we call row-major order. however, webgl expects us to use matrices defined on column-major order. see transposing transformation or projection matrices on how to correctly defined these matrices. references the perspective projection matrix $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/CG/RTGW/04/02_model_view.html",
    "title": "Model, View and Projection Transform",
    "body": " index search search back model, view and projection transform contents the model matrix the view matrix the model-view matrix spatial encoding of the world rotation matrix translation vector the mysterious fourth row the projection matrix perspective or orthogonal projection perspective matrix orthographic matrix clipping recap references the model, view and projection matrices are a handy tool to separate transformations cleanly. the model matrix a model is defined by a set of vertices. the \\(x,y,z\\) coordinates of these vertices are defined relative to the object’s center: that is, if a vertex is at \\((0,0,0)\\), it is at the center of the object. we'd like to be able to move this model (you just learnt to do so: translation*rotation*scale, and done. you apply this matrix to all your vertices at each frame and everything moves. something that doesn't move will be at the center of the world. your vertices are now in world space. we went from model space (all vertices defined relatively to the center of the model) to world space (all vertices defined relatively to the center of the world). see figure below: the view matrix it you want to view a moutain from another angle, you can either move the camera... or move the mountain. so initially your camera is at the origin of the world space. in order to move the world, you simply introduce another matrix. let’s say you want to move your camera of \\(3\\) units to the right (\\(+x\\)). this is equivalent to moving your whole world \\(3\\) units to the left (\\(-x\\)). we went from world space (all vertices defined relatively to the center of the world, as we made so in the previous section) to camera space (all vertices defined relatively to the camera). the figure below shows how we go from model/object coordinates to world coordinates and finally to camera coordinates. the model-view matrix the model-view matrix allows us to perform affine transformations in our scene. affine is a mathematical name that describes transformations that do not change the structure of the object undergoing such transformations. in our 3d world scene, such transformations are rotation, scaling, reflection shearing, and translation. let's take a look at how the model-view matrix is constructed. spatial encoding of the world by default, when you render a scene, you are looking at it from the origin of the world in the negative direction of the z-axis. as shown in the following diagram, the z-axis is coming out of the screen: rotation matrix the intersection of the first three rows with the first three columns defines the 3x3 rotation matrix. this matrix contains information about rotations around the standard axis. \\begin{align} \\begin{bmatrix} m_1 & m_2 & m_3 \\\\ m_5 & m_6 & m_7 \\\\ m_9 & m_{10} & m_{11} \\end{bmatrix} \\end{align} translation vector the intersection of the first three rows with the last column defines a three-component translation vector. \\begin{align} \\begin{bmatrix} m_{13} & m_{14} & m_{15} \\end{bmatrix} \\end{align} the mysterious fourth row the fourth row does not have any special meaning. the \\(m_4\\), \\(m_8\\), and \\(m_{12}\\) elements are always \\(0\\). the \\(m_{16}\\) element (the homogeneous coordinate) will always be \\(1\\). the projection matrix projection matrices are specialized \\(4\\)x\\(4\\) matrices designed to transform a 3d point in camera space into its projected counterpart on the canvas. essentially, when you multiply a 3d point by a projection matrix, you determine its 2d coordinates on the canvas within ndc (normalized device coordinates) space (we'll see what these are later). points in ndc space fall within the range \\([-1, 1]\\). it's crucial to remember that projection matrices are intended for transforming vertices or 3d points, not vectors. the workaround involves treating points as \\(1\\times 4\\) vectors, enabling their multiplication by a \\(4\\times 4\\) matrix. the result is another \\(1\\times 4\\) matrix, or 4d points with homogeneous coordinates. these coordinates are only directly applicable as 3d points if their fourth component is \\(1\\), allowing the first three components to represent a standard 3d cartesian point. this operation determines how much of the view space will be rendered and how it will be mapped onto the computer screen. this region is known as the frustum and it is defined by six planes (near, far, top, bottom, right, and left planes), as shown in the following diagram: these six planes are encoded in the projection matrix. any vertices lying outside the frustum after applying the transformation are clipped out and discarded from further processing. therefore, the frustum defines clipping coordinates, and the projection matrix that encodes the frustum produces clipping coordinates. if the far and near planes have the same dimensions, the frustum will then determine an orthographic projection. otherwise, it will be a perspective projection. we went from camera space (all vertices defined relatively to the camera) to homogeneous space (all vertices defined in a small cube. everything inside the cube is onscreen). before projection, we’ve got our blue objects, in camera space, and the red shape represents the frustum of the camera: the part of the scene that the camera is actually able to see. multiplying everything by the projection matrix has the following effect: perspective or orthogonal projection a perspective projection assigns more space to details that are closer to the camera than details that are farther away. in other words, the geometry that is close to the camera will appear larger than the geometry that is farther from it. in contrast, an orthogonal projection uses parallel lines; this means that lines will appear to be the same size, regardless of their distance to the camera. perspective matrix the projection matrix determines the field of view (fov) of the camera. which is how much of the 3d space will be captured by the camera. it is a measure given in degrees, and the term is used interchangeably with the term angle of view. perspective matrix orthographic matrix orthographic matrix clipping up to this point, we are still working with homogeneous coordinates. projection matrices actually transform points from the camera space to the homogeneous clip space, not to ndc (normalized device coordinate) space. because webgl doesn't know anything about the coordinate space it requires that when all of the transformations are done, things should be in normalized device coordinates. normalized device coordinates are obtained by dividing the clipping coordinates by the \\(w\\) component. this is why this step is known as perspective division. in the ndc space, the \\(x\\) and \\(y\\) coordinates represent the location of your vertices on a normalized 2d screen, while the z-coordinate encodes depth information, which is the relative location of the objects with respect to the near and far planes. basically the homogeneous coordinates have four components: \\(x\\), \\(y\\), \\(z\\), and \\(w\\). the clipping is done by comparing the \\(x\\), \\(y\\), and \\(z\\) components against the homogeneous coordinate, \\(w\\). if any of them is more than, \\(+w\\), or less than, \\(-w\\), then that vertex lies outside the frustum and is discarded. the clipping coordinates now range from \\(-1\\) to \\(+1\\) on each axis, regardless of the shape or size of the actual screen. the bottom left corner will be at \\((-1, -1)\\), and the top right corner will be at (1, 1). webgl will then map these coordinates onto the viewport that was configured with glviewport. recap the following diagram shows the theory we have learned so far, along with the relationships between the steps in the theory and the implementation in webgl. the five transformations that we apply to object coordinates to obtain viewport coordinates are: the model-view matrix that groups the model and view transform in one single matrix. when we multiply our vertices by this matrix, we end up in the camera space with homogeneous coordinates. the projection matrix as a result, we end up in the homogeneous clip space. clipping: transforms the homogeneous coordinates on cartesian coordinates by leaving out all vertices ouside of the range \\([-w, w]\\). this leaves us on the clip space. perspective division: after we apply perspective division, so now our coordinates are on the ndc space. gl viewport: internal transform to move to the raster space. an extra transformation matrix is defined specially for the normals. this is the normal matrix, which is obtained by inverting and transposing the model-view matrix. this matrix is applied to normal vectors to ensure that they continue to be perpendicular to the surface. references model view projection projection matrices $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/CG/RTGW/04/03_normal_transform.html",
    "title": "Normal Transform",
    "body": " index search search back normal transform contents calculating the normal matrix whenever vertices are transformed, normal vectors should also be transformed so that they point in the right direction. we could consider using the model-view matrix that transforms vertices to do this, but this approach is problematic: the model-view matrix will not always keep the perpendicularity of normals: this problem occurs if there is a unidirectional (one axis) scaling transformation or a shearing transformation in the model-view matrix. calculating the normal matrix two vectors are perpendicular if their dot product is \\(0\\). in our example \\begin{align} <n, s> = 0 \\end{align} here, \\(s\\) is the surface vector and can be calculated as the difference of two vertices. let \\(m\\) be the model-view matrix. we can use \\(m\\) to transform \\(s\\) as follows: \\begin{align} s' = ms \\end{align} we want to find a matrix, \\(k\\), that allows us to transform normals in a similar way. for the \\(n\\) normal, we want the following: \\begin{align} n' = kn \\end{align} for the scene to be consistent after obtaining \\(n'\\) and \\(s'\\), these two need to keep the perpendicularity that the original vectors \\(n\\) and \\(s\\) had. \\begin{align} <n', s'> = 0 \\end{align} substituting \\(n'\\) and \\(s'\\): \\begin{align} <kn, ms> = 0 \\end{align} \\begin{align} (kn)^t(ms) = 0 \\end{align} \\begin{align} n^tk^tms = 0 \\end{align} \\begin{align} n^t(k^tm)s = 0 \\end{align} now, remember that \\(<n, s> = 0\\) so \\(n^ts = 0\\). this means that in the previous equation, \\((k^tm)\\) needs to be the identity matrix, \\(i\\), so the original condition of n and s being perpendicular holds: \\begin{align} k^tm = i \\end{align} \\begin{align} k^tmm^{-1} = im^{-1} = m^{-1} \\end{align} \\begin{align} k^t = m^{-1} \\end{align} \\begin{align} (k^t)^t = (m^{-1})^t \\end{align} \\begin{align} k = (m^{-1})^t \\end{align} \\(k\\) is obtained by transposing the inverse of the model-view matrix (\\(m\\), in this example). we need to use \\(k\\) to multiply the normal vectors so that they keep being perpendicular to the surface when transformed. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/CG/RTGW/04/04_camera.html",
    "title": "Camera Marix",
    "body": " index search search back camera marix contents camera translation interpreting transformations using the model-view matrix basic camera types the camera model let's assume that our camera is located at the origin of the world and that it's oriented so that it's looking toward the negative z-axis direction. we already know what transformation represents such a configuration in webgl (identity matrix of rank four). camera translation let's move the camera to \\([0, 0, 4]\\) in world coordinates. this means four units from the origin on the positive z-axis. if we applied: mat4.translate(modelviewmatrix, modelviewmatrix, [0, 0, 4]); in such a case, the world would be translated 4 units on the positive z-axis, and since the camera position has not been changed, it would be located at \\([0, 0, -4]\\), which is exactly the opposite of what we want. now, say that we applied the translation in the opposite direction: mat4.translate(modelviewmatrix, modelviewmatrix, [0, 0, -4]); in such a case, the world would be moved 4 units on the negative z-axis and then the camera would be located at \\([0, 0, 4]\\) in the new world-coordinate system. the camera matrix transformation is the inverse of the model-view matrix transformation. interpreting transformations using the model-view matrix as we've just seen, understanding the rotation matrix (the \\(3 \\times 3\\) upper-left corner of the model-view matrix) is simple: the first \\(3\\) columns always tell us where the axis is. basic camera types so far, we've learned how to generate rotations and translations in either world or camera coordinates. in both cases, however, we are always generating the rotations around the center of the world. this may be ideal when we're orbiting around a 3d object. we will refer to this type of camera as an orbiting camera. if we are able to look left and right (rotations) and then move in the direction in which our camera is pointing (translation), then this camera type can be designated as a first-person camera and it is generally known as a tracking camera. when applying transformation the order of the operations affects the result. it is not the same to rotate around the origin and then translate away from it (orbiting camera), as compared to translating the origin and then rotating around it (tracking camera). with an orbiting camera, the camera will always look toward the center of the world. therefore, we will always use the z-axis to move to and from the object we are examining. however, with a tracking camera, since the rotation occurs at the camera location, we can end up looking to any position in the world. thus, we need to know the direction in which the camera is pointing in world coordinates (camera axis). the camera model just like the model-view matrix, the camera matrix encodes information about the camera orientation. as we can see in the following diagram, the upper-left \\(3 \\times 3\\) matrix corresponds to the camera axes: the first column corresponds to the x-axis of the camera. we will call it rightvector. the second column is the y-axis of the camera. this will be upvector. the third column determines the vector in which the camera can move back and forth. this is the z-axis of the camera and we will call it cameraaxis. because the camera matrix is the inverse of the model-view matrix, the upper-left \\(3 \\times 3\\) rotation matrix contained in the camera matrix gives us the orientation of the camera axes in world space. this means that we can tell the orientation of our camera in world space just by looking at the columns of this \\(3 \\times 3\\) rotation matrix. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/CG/RTGW/04/index.html",
    "title": "Camera",
    "body": " index search search back camera even though we have a camera within our 3d application, there is no camera object in the webgl api—only matrices. that is because having matrices instead of a camera object gives webgl the flexibility to represent complex projections and animations. webgl does not have cameras webgl does not have a camera object that you can manipulate. however, we can assume that what we render in the canvas is what our camera captures. every time we move our camera around, we need to update the objects according to the new camera position. so, we need to transform each vertex. similarly, we need to make sure that the object normals and light directions are still consistent after the camera has moved. in summary, we need to analyze two different types of transformations: vertex (points) and normal (vectors) content transformations the model, view and projection matrices normal transform camera $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/CG/RTGW/04/02_02_orthographic.html",
    "title": "Orthographic Matrix",
    "body": " index search search back orthographic matrix contents intro derivation projection of x projection of y projection of z note references intro in this chapter, we will explore how to construct a matrix that projects a point from camera space onto the image plane of an orthographic camera. the aim of the orthographic projection matrix is to remap all coordinates within a specific 3d space bounding box to the canonical viewing volume. for that we need to know the scene's bounding box, that is the bounding box that encompasses all the objects on the scene. the orthographic matrix then aims to remap this box to a canonical view volume, defined by minimum and maximum extents of \\((-1, -1, -1)\\) and \\((1, 1, 1)\\). once we have computed the scene bounding box, we need to project the minimum and maximum extents of this bounding box onto the image plane of the camera. the \\(x\\)- and \\(y\\)-coordinates of any point expressed in camera space and the \\(x\\)- and \\(y\\)-coordinates of the same points projected onto the image plane remain identical. it may be necessary to adjust the projection of the bounding box's minimum and maximum extents onto the screen to ensure the screen window is either square or maintains the same aspect ratio as the image. derivation we will refer to these screen coordinates as \\(l\\), \\(r\\), \\(t\\), and \\(b\\), which stand for left, right, top, and bottom, respectively. projection of \\(x\\) now, we need to remap the left and right screen coordinates \\((l, r)\\) to \\(-1\\) and \\(1\\), and apply the same remapping to the top and bottom coordinates \\((t, b)\\). assuming \\(x\\) is any point within the range \\([l ,r]\\), we can state: \\begin{align} l \\leq x \\leq r \\end{align} \\begin{align} 0 \\leq x - l \\leq r - l \\end{align} \\begin{align} 0 \\leq \\frac{x - l}{r - l} \\leq 1 \\end{align} \\begin{align} 0 \\leq 2\\frac{x - l}{r - l} \\leq 2 \\end{align} \\begin{align} -1 \\leq 2\\frac{x - l}{r - l} -1 \\leq 1 \\end{align} now, the middle term falls within the range \\([-1, 1]\\), successfully remapping it. to further develop this formula: \\begin{align} -1 \\leq \\frac{2x - 2l - r + l}{r - l} \\leq 1 \\end{align} \\begin{align} -1 \\leq \\frac{2x - l - r}{r - l} \\leq 1 \\end{align} \\begin{align} -1 \\leq \\frac{2x}{r - l} - \\frac{r + l}{r - l} \\leq 1 \\end{align} this yields the transformation formula for \\(x\\): \\begin{align} x' = \\frac{2x}{r - l} - \\frac{r + l}{r - l} \\end{align} to represent this transformation in matrix form: \\begin{align} \\begin{bmatrix} \\frac{2}{r - l} & 0 & 0 & -\\frac{r + l}{r - l} \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 1 \\\\ \\end{bmatrix} \\end{align} so: \\begin{align} \\begin{bmatrix} \\frac{2}{r - l} & 0 & 0 & -\\frac{r + l}{r - l} \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 1 \\\\ \\end{bmatrix} \\cdot \\begin{bmatrix} x \\\\ y \\\\ z \\\\ 1 \\\\ \\end{bmatrix} = \\begin{bmatrix} \\frac{2x}{r - l} - \\frac{r + l}{r - l} \\\\ y \\\\ z \\\\ 1 \\\\ \\end{bmatrix} \\end{align} projection of \\(y\\) the process for the y-coordinate is the same. you just need to replace \\(r\\) and \\(l\\) with \\(t\\) and \\(b\\) (top and bottom). \\begin{align} b \\leq y \\leq t \\end{align} \\begin{align} 0 \\leq y - b \\leq t - b \\end{align} \\begin{align} 0 \\leq \\frac{y - b}{t - b} \\leq 1 \\end{align} \\begin{align} 0 \\leq 2\\frac{y - b}{t - b} \\leq 2 \\end{align} \\begin{align} -1 \\leq 2\\frac{y - b}{t - b} - 1 \\leq 1 \\end{align} \\begin{align} -1 \\leq \\frac{2y - 2b - t + b}{t - b} \\leq 1 \\end{align} \\begin{align} -1 \\leq \\frac{2y - b - t}{t - b} \\leq 1 \\end{align} \\begin{align} -1 \\leq \\frac{2y}{t - b} - \\frac{t + b}{t - b} \\leq 1 \\end{align} so the transformation formula for \\(y\\) is as follows: \\begin{align} y' = \\frac{2y}{t - b} - \\frac{t + b}{t - b} \\end{align} which yields the following transformation matrix: \\begin{align} \\begin{bmatrix} \\frac{2}{r - l} & 0 & 0 & -\\frac{r + l}{r - l} \\\\ 0 & \\frac{2}{t - b} & 0 & -\\frac{t + b}{t - b} \\\\ 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 1 \\\\ \\end{bmatrix} \\end{align} so: \\begin{align} \\begin{bmatrix} \\frac{2}{r - l} & 0 & 0 & -\\frac{r + l}{r - l} \\\\ 0 & \\frac{2}{t - b} & 0 & -\\frac{t + b}{t - b} \\\\ 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 1 \\\\ \\end{bmatrix} \\cdot \\begin{bmatrix} x \\\\ y \\\\ z \\\\ 1 \\\\ \\end{bmatrix} = \\begin{bmatrix} \\frac{2x}{r - l} - \\frac{r + l}{r - l} \\\\ \\frac{2y}{t - b} - \\frac{t + b}{t - b} \\\\ z \\\\ 1 \\\\ \\end{bmatrix} \\end{align} projection of \\(z\\) and finally, to complete our orthographic projection matrix, we need to remap the z-coordinates from \\(-1\\) to \\(1\\). we start with the following condition: \\begin{align} n \\leq -z \\leq f \\end{align} don't forget that the \\(z\\)-coordinates of all points visible to the camera are negative, which is why we use \\(-z\\) instead of \\(z\\). \\begin{align} 0 \\leq -z - n\\leq f - n \\end{align} \\begin{align} 0 \\leq \\frac{-z - n}{f - n} \\leq 1 \\end{align} \\begin{align} 0 \\leq 2\\frac{-z - n}{f - n} \\leq 2 \\end{align} \\begin{align} -1 \\leq 2\\frac{-z - n}{f - n} - 1 \\leq 1 \\end{align} \\begin{align} -1 \\leq \\frac{-2z - 2n -f + n}{f - n} \\leq 1 \\end{align} \\begin{align} -1 \\leq \\frac{-2z - n - f}{f - n} \\leq 1 \\end{align} \\begin{align} -1 \\leq \\frac{-2z}{f - n} - \\frac{n + f}{n - f}{f - n} \\leq 1 \\end{align} now we add this to the matrix: \\begin{align} \\begin{bmatrix} \\frac{2}{r - l} & 0 & 0 & -\\frac{r + l}{r - l} \\\\ 0 & \\frac{2}{t - b} & 0 & -\\frac{t + b}{t - b} \\\\ 0 & 0 & -\\frac{2}{f - n} & -\\frac{n + f}{n - f} \\\\ 0 & 0 & 0 & 1 \\\\ \\end{bmatrix} \\end{align} so: \\begin{align} \\begin{bmatrix} \\frac{2}{r - l} & 0 & 0 & -\\frac{r + l}{r - l} \\\\ 0 & \\frac{2}{t - b} & 0 & -\\frac{t + b}{t - b} \\\\ 0 & 0 & -\\frac{2}{f - n} & -\\frac{n + f}{n - f} \\\\ 0 & 0 & 0 & 1 \\\\ \\end{bmatrix} \\cdot \\begin{bmatrix} x \\\\ y \\\\ z \\\\ 1 \\\\ \\end{bmatrix} = \\begin{bmatrix} \\frac{2x}{r - l} - \\frac{r + l}{r - l} \\\\ \\frac{2y}{t - b} - \\frac{t + b}{t - b} \\\\ \\frac{-2z}{f - n} - \\frac{f + n}{f - n} \\\\ 1 \\\\ \\end{bmatrix} \\end{align} note this section is kinda important, up until now we have define this projection matrix on what we call row-major order. however, webgl expects us to use matrices defined on column-major order. see transposing transformation or projection matrices on how to correctly defined these matrices. references orthographic matrix $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/11_03.html",
    "title": "Geometric Sequences and Series",
    "body": " index search search back geometric sequences and series contents geometric sequences geometric series infinite geometric series geometric sequences a geometric sequence (or geometric progression) is a sequence in which each term after the first is obtained by multiplying the preceding term by a constant non-zero real number, called the common ratio \\(r\\). that is: \\begin{align} r = \\frac{a_{n+1}}{a_n} \\end{align} in a geometric sequence with first term \\(a_1\\) and common ratio \\(r\\), where neither of them are zero, then the \\(n\\)th term is: \\begin{align} a_n = a_1 r^{n-1} \\end{align} geometric series a geometric series is the sum of the terms of a geometric sequence. to find a formula of the sum \\(s_n\\) first we write the sum as follows: \\begin{align} s_n = a_1 + a_2 + \\cdots + a_n \\end{align} \\begin{align} = a_1 + a_1 r + \\cdots + a_1 r^{n-1} \\end{align} we multiply each side of the equation by \\(r\\) \\begin{align} rs_n = a_1r + a_1 r^2 + \\cdots + a_1 r^{n} \\end{align} and now we substract these two equations: \\begin{align} s_n - rs_n = a_1 + (a_1r - a_1r) + (a_1 r^2 - a_1 r^2) + \\cdots + (a_1 r^{n-1} - a_1 r^{n-1}) - a_1 r^{n} \\end{align} \\begin{align} s_n - rs_n = a_1 - a_1 r^{n} \\end{align} \\begin{align} s_n (1 - r) = a_1 - a_1 r^{n} \\end{align} \\begin{align} s_n = \\frac{a_1 - a_1 r^{n}}{1 - r}, r \\neq 1 \\end{align} infinite geometric series if a geometric sequence has first term \\(a_1\\) and common ratio \\(r\\), then: \\begin{align} s_n = \\frac{a_1 - a_1 r^{n}}{1 - r}, r \\neq 1 \\end{align} \\begin{align} s_n = \\frac{a_1(1 - r^{n})}{1 - r}, r \\neq 1 \\end{align} if \\(|r| < 1\\), then \\(\\lim_{n \\rightarrow \\infty}r^n = 0\\) and \\begin{align} \\lim_{n \\rightarrow \\infty} s_n = \\frac{a_1(1 - 0)}{1 - r} = \\frac{a_1}{1 - r} \\end{align} the quotient \\(\\frac{a_1}{1 - r}\\) is called the sum of the term of an infinite geometric sequence. the limit \\(\\lim_{n \\rightarrow \\infty} s_n\\) can be expressed as \\(s_{\\infty}\\) or \\(\\sum_{i=1}^{\\infty} a_i\\). $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/01_01.html",
    "title": "Real Numbers and the Rectangular System",
    "body": " index search search back real numbers and the rectangular system contents sets of real numbers the rectangular coordinate system pythagorean theorem distance formula midpoint formula sets of real numbers several important sets of numbers are used in mathematics. some of these sets are listed in the following table set description natural numbers \\(\\{1, 2, 3, \\cdots\\}\\) whole numbers \\(\\{0, 1, 2, 3, \\cdots\\}\\) integers \\(\\{\\cdots, -1, 0, 1, 2, 3, \\cdots\\}\\) rational numbers \\(\\{\\frac{p}{q} \\shortmid p \\text{ and } q \\text{ are integers, } q \\neq 0\\}\\) irrational numbers \\(\\{x \\shortmid x \\text { is not rational}\\}\\) real numbers \\(\\{x \\shortmid x \\text { is a decimal number}\\}\\) the rectangular coordinate system if we place two number lines at right angles, intersecting at their origins, we obtain a two-dimensional rectangular coordinate system. this rectangular coordinate system is also called the cartesian coordinate system. pythagorean theorem in a right triangle, the sum of the squares of the lengths of the legs is equal to the square of the length of the hypotenuse. \\begin{align} a^2 + b^2 = c^2 \\end{align} distance formula suppose that \\(p(x_1, y_1)\\) and \\(r(x_2, y_2)\\) are two points in a coordinate plane. then the distance between \\(p\\) and \\(r\\), written \\(d(p, r)\\), is given by the distance formula. \\begin{align} d(p, r) = \\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2} \\end{align} midpoint formula the midpoint \\(m\\) of the line segment with endpoints \\((x_1, y_1)\\) and \\((x_2, y_2)\\) has the following coordinates. \\begin{align} m = \\left(\\frac{x_1 + x_2}{2}, \\frac{y_1 + y_2}{2}\\right) \\end{align} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/01_02.html",
    "title": "Introduction to Relations and Functions",
    "body": " index search search back introduction to relations and functions contents set-builder notation and interval notation relations domain and range functions vertical line test function notation set-builder notation and interval notation the following chart summarizes set-builder notation, interval notation, and graphs of intervals of real numbers. it is assumed that \\(a < b\\). relations, domain, and range a relation is a set of ordered pairs. if we denote the ordered pairs of a relation by \\((x, y)\\), then the set of all \\(x\\)-values is called the domain of the relation and the set of all \\(y\\)-values is called the range of the relation. a relation can be represented by any of the following: a graph, as illustrated in figure 17 and figure 18 a table of \\(xy\\)-values, as shown in figure 18(a) an equation, such as \\(y = 2x\\) in figure 18(b) a mapping or diagram, as illustrated in figure 19 functions a function is a relation in which each element in the domain corresponds to exactly one element in the range. in a function, each \\(x\\)-value must correspond to exactly one \\(y\\)-value vertical line test if every vertical line intersects a graph in no more than one point, then the graph is the graph of a function. function notation to say that \\(y\\) is a function of \\(x\\) means that for each value of \\(x\\) from the domain of the function, there is exactly one value of \\(y\\). to emphasize that \\(y\\) is a function of \\(x\\), or that \\(y\\) depends on \\(x\\), it is common to write \\begin{align} y = f(x) \\end{align} with \\(f(x)\\) read \"f of x.\" this notation is called function notation. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/01_03.html",
    "title": "Linear Functions",
    "body": " index search search back linear functions contents linear function intercepts constant function slope of a line geometric orientation based on slope vertical line slope intercept form of the equation of a line linear function a function \\(f\\) defined by \\(f(x) = ax + b\\), where \\(a\\) and \\(b\\) are real numbers, is called a linear function. graphing linear equations by hand involves plotting points whose coordinates are solutions of the equation and then connecting them with a straight line. from geometry, we know that two distinct points determine a line. therefore, if we know the coordinates of two points, we can graph the line. unless otherwise specified, the domain of a linear function is the set of all real numbers. the range of a nonconstant linear function is also the set of all real numbers. intercepts to find the \\(x\\)-intercept of the graph of \\(y = ax + b\\), let \\(y = 0\\) and solve for \\(x\\) (assuming that \\(a \\neq 0\\)). to find the \\(y\\)-intercept, let \\(x = 0\\) and solve for \\(y\\). let \\(ƒ\\) be a function. then any number \\(c\\) for which \\(f(c) = 0\\) is called a zero of the function \\(ƒ\\). the point \\((c, 0)\\) is an \\(x\\)-intercept of the graph of \\(f\\). constant function a function \\(f(x) = b\\), where \\(b\\) is a real number, is called a constant function. its graph is a horizontal line with \\(y\\)-intercept \\((0, b)\\). for \\(b \\neq 0\\), it has no \\(x\\)-intercept. (every constant function is also linear.) slope of a line the slope \\(m\\) of the line passing through the points \\((x_1, y_1)\\) and \\((x_2, y_2)\\) is: \\begin{align} m = \\frac{\\delta y}{\\delta x} = \\frac{y_2 - y_1}{x_2 - x_1} \\end{align} where \\(\\delta x = x_2 - x_1 \\neq 0\\) geometric orientation based on slope for a line with slope \\(m\\), if \\(m > 0\\) (i.e., slope is positive), the line rises from left to right. if \\(m < 0\\) (i.e., slope is negative), the line falls from left to right. if \\(m = 0\\) (i.e., slope is \\(0\\)), the line is horizontal. vertical line a vertical line with \\(x\\)-intercept \\((k, 0)\\) has an equation of the form \\(x = k\\). its slope is undefined. slope–intercept form of the equation of a line in general, if \\(f(x) = ax + b\\), then the slope of the graph of \\(f(x)\\) is \\(a\\) and the \\(y\\)-coordinate of the \\(y\\)-intercept is b. to verify this fact, notice that \\(f(0) = a(0) + b = b\\). because the slope of the graph of \\(f(x) = ax + b\\) is \\(a\\), it is often convenient to use \\(m\\) rather than \\(a\\) in the general form of the equation. therefore, we can write either \\begin{align} f(x) = mx + b \\end{align} or \\begin{align} y = mx + b \\end{align} this equation for \\(f(x)\\) is generally called the slope–intercept form of the equation of a line. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/CG/RTGW/05.html",
    "title": "Animations",
    "body": " index search search back animations contents webgl matrix naming conventions scene graph matrix stacks animating a 3d scene the requestanimationframe function parametric curves optimizing batch performance interpolation linear interpolation polynomial interpolation b-splines webgl matrix naming conventions before we go any further, let's take a moment to quickly summarize some of the conventions around matrix-naming: world matrix: sometimes referred to as the model matrix, this is a matrix that takes the vertices of a model and moves them to world space. *camera matri*x: this matrix positions the camera in the world. you can also think of it as the world matrix for the camera. view matrix: this matrix moves everything else in the world in front of the camera. as we've seen, this is the inverse of the camera matrix. projection matrix: this is the matrix that converts a frustum of space into clip space. you can also think of it as the matrix returned by your matrix math library's perspective or orthographic function. local matrix: the matrix is used in scene graphs, where the matrix, at any particular node on the graph, is used before multiplying with any other nodes. scene graph this is a data structure, commonly used by vector-based graphics-editing applications and modern computer games, that arranges the logical and often spatial representation of a graphical scene. a scene graph is a collection of nodes in a graph or tree structure. matrix stacks a matrix stack provides a way to apply local transforms to individual objects in our scene while preserving global transforms. the matrix stack works at each rendering cycle, it requires calculating the scene matrices to react to camera movements. the update is done in the following steps: global transform: update the model-view matrix for each object and push it to the stack. this allows us to recover the original matrix once we’ve applied local transforms. local transform: update model-view matrix for each object in the scene by multiplying the original model-view matrix by a matrix that represents the rotation, translation, and/or scaling of each object in the scene. recover the original matrix for the stack. repeat the process for each object on the scene. the following diagram shows this procedure for one object: animating a 3d scene animating a scene is nothing more than applying the appropriate local transformations to the objects in the scene. for instance, if we want to move a cone and a sphere, each one of them will have a corresponding local transformation that will describe its location, orientation, and scale. we should address when to apply these transforms. if we calculate the position to apply to the cone and sphere in our example every time we call the render function, this would imply that the animation rate would depend on the speed of our rendering cycle. a slow rendering cycle would produce choppy animations and too fast a rendering cycle would create the illusion of objects jumping from one side to the other without smooth transitions. the requestanimationframe function one of the advantages of leveraging this function is that it is designed to call the rendering function (whatever function we indicate) only when the browser/tab window is in focus. parametric curves there are many situations where we don't know the exact position of an object at a given time, but we do know an equation that describes its movement. these equations are known as parametric curves. the following diagram shows the parametric equation that describes the free-fall motion: \\[ h = h_0 + v_0t - \\frac{1}{2}gt^2 \\] where \\(g\\) is the gravity at \\(9.8 m/s\\), \\(v_0\\) is the initial velocity, \\(h_0\\) is the initial position, \\(t\\) is the time and \\(h\\) is the position at \\(t\\). optimizing batch performance webgl 2 adds some interesting features, such as geometry-instancing. this feature allows us to render the same instance of a single mesh with differing shader attributes using instancing and only one render call. though instancing is limited, as it’s based on the same mesh only, it’s still a great way to improve performance if you have to draw the same meshes multiple times, especially if combined with shaders. interpolation interpolation greatly simplifies a 3d objects’ animation. unlike parametric curves, it is not necessary to define the position of the object as a function of time. when interpolation is used, we only need to define control points or knots. the set of control points describes the path that a particular animate object will follow. linear interpolation this method requires that we define the starting and ending points of the location of our object, along with the number of interpolating steps. the object will move on the line determined by the starting and ending point: polynomial interpolation this method allows us to determine as many control points as we want. the object will move from the starting point to the ending point and will pass through each one of the control points in between while using polynomials, an increasing number of control points can produce undesired oscillations on the object's path described by this technique. this is known as runge's phenomenon. b-splines this method is similar to polynomial interpolation with the difference that the control points are outside of the object's path. in other words, the object does not pass through the control points as it moves. b-splines also respond better to runge's phenomenon: $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/01_04.html",
    "title": "Equations of Lines and Linear Models",
    "body": " index search search back equations of lines and linear models contents point slope form standard form of the equation of a line parallel and perpendicular lines linear models and regression point slope form figure 51 shows a line passing through the fixed point \\((x_1, y_1)\\) with slope \\(m\\). let \\((x, y)\\) be any other point on the line. by the slope formula: \\begin{align} m = \\frac{y - y_1}{x - x_1} \\end{align} \\begin{align} y - y_1 = m(x - x_1) \\end{align} this result is called the point–slope form of the equation of a line. standard form of the equation of a line a linear equation written in the form: \\begin{align} ax + by = c \\end{align} where \\(a\\), \\(b\\), and \\(c\\) are real numbers (\\(a\\) and \\(b\\) not both \\(0\\)), is said to be in standard form. parallel and perpendicular lines two distinct nonvertical lines are parallel if and only if they have the same slope. two lines, neither of which is vertical, are perpendicular if and only if their slopes have product \\(-1\\). linear models and regression when data points are plotted in the \\(xy\\)-plane, the resulting graph is sometimes called a scatter diagram. scatter diagrams are often helpful for analyzing trends in data graphing calculators are capable of finding the line of \"best fit,\" for the data called the least-squares regression line, by using a technique taught in statistics courses known as least-squares regression. one common measure of the strength of the linear relationship in a data set is called the correlation coefficient, denoted \\(r\\), where \\(-1 \\leq r \\leq 1\\). $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/01_05.html",
    "title": "Linear Equations and Inequalities",
    "body": " index search search back linear equations and inequalities contents solving linear equations in one variable identities and contradictions analytic approach graphical approaches to solving linear equations intersection-of-graphs method of graphical solution x-intercept method of graphical solution solving linear inequalities in one variable graphical approaches to solving linear inequalities intersection-of-graphs method of solution of a linear inequality x-intercept method of solution of a linear inequality solving linear equations in one variable a linear equation in the variable \\(x\\) is an equation that can be written in the form: \\begin{align} ax + b = 0, a \\neq 0 \\end{align} we use two distinct approaches to solving equations. the analytic approach, in which we use paper and pencil to transform complicated equations into simpler ones. the graphical approach, in which we often support our analytic solutions by using graphs or tables. the words root, solution, and zero all refer to the same basic concept. identities and contradictions a contradiction is an equation that has no solution. an identity is an equation that is true for all values in the domain of its variables. analytic approach one way to solve a given equation analytically is to rewrite it as a series of simpler equivalent equations, each of which has the same solution set as the given one. equivalent equations are obtained by using the properties of equality. graphical approaches to solving linear equations in general, if \\(f\\) and \\(g\\) are linear functions, then their graphs are lines that intersect at a single point, no point, or infinitely many points, as illustrated in figure 67. intersection-of-graphs method of graphical solution to solve the equation \\(f(x) = g(x)\\) graphically, graph \\begin{align} y_1 = f(x) \\end{align} and \\begin{align} y_2 = g(x) \\end{align} the \\(x\\)-coordinate of any point of intersection of the two graphs is a solution of the equation. x-intercept method of graphical solution to solve the equation \\(f(x) = g(x)\\) graphically, graph \\begin{align} y = f(x) - g(x) = f(x) \\end{align} the \\(x\\)-coordinate of any \\(x\\)-intercept of the graph of \\(y = f(x)\\) (or zero of the function \\(f\\)) is a solution of the equation. solving linear inequalities in one variable an inequality says that one expression is greater than, greater than or equal to, less than, or less than or equal to another. two inequalities with the same solution set are equivalent inequalities. inequalities are solved using the properties of inequality: for real numbers \\(a\\), \\(b\\), and \\(c\\): \\(a < b\\) and \\(a + c < b + c\\) are equivalent if \\(c > 0\\), then \\(a < b\\) and \\(ac < bc\\) are equivalent if \\(c < 0\\), then \\(a < b\\) and \\(ac > bc\\) are equivalent similar properties exist for \\(>, \\leq\\) and \\(\\geq\\). a linear inequality in the variable \\(x\\) is an inequality that can be written in one of the following forms, where \\(a \\neq 0\\). \\begin{align} ax + b > 0 \\end{align} \\begin{align} ax + b < 0 \\end{align} \\begin{align} ax + b \\geq 0 \\end{align} \\begin{align} ax + b \\leq 0 \\end{align} the solution set of a linear inequality is typically an interval of the real number line and can be expressed in interval notation. graphical approaches to solving linear inequalities intersection-of-graphs method of solution of a linear inequality suppose that \\(f\\) and \\(g\\) are linear functions. the solution set of \\(f(x) > g(x)\\) is the set of all real numbers \\(x\\) such that the graph of \\(f\\) is above the graph of \\(g\\). x-intercept method of solution of a linear inequality to solve \\(ƒ(x) > g(x)\\), we can rewrite the inequality as \\(ƒ(x) - g(x) > 0\\) or \\(f(x) > 0\\). such that the solution set of \\(f(x) > 0\\) is the set of all real numbers \\(x\\) such that the graph of \\(f\\) is above the \\(x\\)-axis. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/01_06.html",
    "title": "Applications of Linear Functions",
    "body": " index search search back applications of linear functions contents problem-solving strategies direct variation problem-solving strategies these steps may be helpful in solving application problems. read the problem and make sure you understand it. assign a variable to what you are being asked to find. write an equation that relates the quantities described in the problem. solve the equation and determine the solution to the posed question look back and check your solution. direct variation a common application involving linear functions deals with quantities that vary directly (or are in direct proportion). a number \\(y\\) varies directly with \\(x\\) if there exists a nonzero number \\(k\\) such that: \\begin{align} y = kx \\end{align} the number k is called the constant of variation. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/02_01.html",
    "title": "Graphs of Basic Functions and Relations: Symmetry",
    "body": " index search search back graphs of basic functions and relations: symmetry contents increasing decreasing and constant functions symmetry with respect to the y -axis symmetry with respect to the origin symmetry with respect to the x -axis even and odd functions the absolute value function increasing, decreasing, and constant functions suppose that a function \\(f\\) is defined over an open interval \\(i\\). \\(f\\) increases on \\(i\\) if, whenever \\(x_1 < x_2\\), \\(f(x_1) < ƒ(x_2)\\) \\(f\\) decreases on \\(i\\) if, whenever \\(x_1 < x_2\\), \\(f(x_1) > ƒ(x_2)\\) \\(f\\) is constant on \\(i\\) if for every \\(x_1\\), \\(x_2\\), \\(f(x_1) = ƒ(x_2)\\) symmetry with respect to the \\(y\\)-axis if a function \\(f\\) is defined so that: \\begin{align} f(-x) = f(x) \\end{align} for all \\(x\\) in its domain, then the graph of \\(f\\) is symmetric with respect to the \\(y\\)-axis. symmetry with respect to the origin if a function \\(f\\) is defined so that: \\begin{align} f(-x) = -f(x) \\end{align} for all \\(x\\) in its domain, then the graph of \\(f\\) is symmetric with respect to the origin. symmetry with respect to the \\(x\\)-axis if replacing \\(y\\) with \\(-y\\) in an equation results in the same equation, then the graph is symmetric with respect to the \\(x\\)-axis. even and odd functions a function \\(f\\) is called an even function if \\(f(-x) = f(x)\\) for all \\(x\\) in the domain of \\(f\\). (its graph is symmetric with respect to the y-axis.) a function \\(f\\) is called an odd function if \\(f(-x) = -f(x)\\) for all \\(x\\) in the domain of \\(f\\). (its graph is symmetric with respect to the origin.) the absolute value function on a number line, the absolute value of a real number x, denoted \\(|x|\\), represents its undirected distance from the origin, \\(0\\). the absolute value function, \\(f(x) = |x|\\), pairs every real number with its absolute value and is defined as follows: \\begin{align} f(x) = |x| = \\begin{cases} x & \\text{ if } x \\geq 0 \\\\ -x & \\text{ if } x < 0 \\\\ \\end{cases} \\end{align} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/02_02.html",
    "title": "Vertical and Horizontal Shifts of Graphs",
    "body": " index search search back vertical and horizontal shifts of graphs contents vertical shifts horizontal shifts vertical shifts if \\(c > 0\\), then the graph of \\(y = f(x) + c\\) is obtained by shifting the graph of \\(y = f(x)\\) upward a distance of \\(c\\) units. the graph of \\(y = f(x) - c\\) is obtained by shifting the graph of \\(y = f(x)\\) downward a distance of \\(c\\) units. horizontal shifts if \\(c > 0\\), then the graph of \\(y = f(x - c)\\) is obtained by shifting the graph of \\(y = f(x)\\) to the right a distance of \\(c\\) units. the graph of \\(y = f(x + c)\\) is obtained by shifting the graph of \\(y = f(x)\\) to the left a distance of \\(c\\) units. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/02_03.html",
    "title": "Vertical and Horizontal Shifts of GraphsStretching, Shrinking and Reflecting Graphs",
    "body": " index search search back vertical and horizontal shifts of graphsstretching, shrinking and reflecting graphs contents vertical stretching vertical shrinking horizontal stretching and shrinking reflecting across an axis combining transformations of graphs vertical stretching if \\(c > 1\\), then the graph of \\(y = cf(x)\\) is a vertical stretching of the graph of \\(y = f(x)\\) by applying a factor of \\(c\\). in figure 25, we graphically interpret the preceding statement. notice that the graphs have the same \\(x\\)-intercepts vertical shrinking if \\(0 < c < 1\\), then the graph of \\(y = cf(x)\\) is a vertical shrinking of the graph of \\(y = f(x)\\) by applying a factor of \\(c\\). figure 27 shows a vertical shrink graphically. vertical stretching or shrinking does not change the \\(x\\)-intercepts of the graph but it can change the \\(y\\)-intercept. horizontal stretching and shrinking if \\(0 < c < 1\\), then the graph of \\(y = f(cx)\\) is a horizontal stretching of the graph of \\(y = f(x)\\). if \\(c > 1\\), then the graph of \\(y = f(cx)\\) is a horizontal shrinking of the graph of \\(y = f(x)\\). notice in figure 32 that horizontal stretching or shrinking can change the \\(x\\)-intercepts, but not the \\(y\\)-intercept. reflecting across an axis for a function \\(y = f(x)\\), the following are true. the graph of \\(y = −f(x)\\) is a reflection of the graph of \\(f\\) across the \\(x\\)-axis. the graph of \\(y = f(−x)\\) is a reflection of the graph of \\(f\\) across the \\(y\\)-axis. combining transformations of graphs we can create infinitely many functions from a basic function by stretching or shrinking, shifting upward, downward, left, or right, and reflecting across an axis. to determine the order in which the transformations are made, follow the conventional order of operations as they would be applied to a particular \\(x\\)-value. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/02_04.html",
    "title": "Absolute Value Functions",
    "body": " index search search back absolute value functions contents the graph of y f x properties of absolute value equations and inequalities involving absolute value the graph of \\(y = ∣f(x)∣\\) the domain of \\(y = |f(x)|\\) is the same as the domain of \\(f\\), while the range of \\(y = |f(x)|\\) will be a subset of \\([0, \\infty)\\). properties of absolute value for all real numbers \\(a\\) and \\(b\\): \\(|ab| = |a| |b|\\) \\(|\\frac{a}{b}| = \\frac{|a|}{|b|}\\) \\(|a| = |-a|\\) \\(|a| + |b| \\geq |a + b|\\) equations and inequalities involving absolute value let \\(k\\) be a positive number. to solve \\(|ax + b| = k\\), solve: \\begin{align} a x + b = k, \\text{ or } ax + b = -k \\end{align} to solve \\(|ax + b| > k\\), solve: \\begin{align} a x + b > k, \\text{ or } ax + b < -k \\end{align} to solve \\(|ax + b| < k\\), solve: \\begin{align} a x + b < k, \\text{ or } ax + b > -k \\end{align} inequalities involving \\(\\leq\\) or \\(\\geq\\) are solved similarly. if two quantities have the same absolute value, they must either be equal to each other or be negatives of each other. this fact allows us to solve absolute value equations (and related inequalities) of the form \\(|ax + b| = |cx + d|\\) by solving: \\begin{align} ax + b = cx + d, \\text{ or } ax + b = -(cx + d) \\end{align} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/11_04.html",
    "title": "Counting Theory",
    "body": " index search search back counting theory contents fundamental principle of counting n-factorial permutations combinations fundamental principle of counting two events are independent events if neither influences the outcome of the other. if \\(n\\) independent events take place, with: \\begin{align} \\begin{matrix} m_1 \\text{ ways for event } 1 \\text{ to occur}, \\\\ m_2 \\text{ ways for event } 2 \\text{ to occur}, \\\\ \\cdot \\\\ \\cdot \\\\ \\cdot \\\\ m_n \\text{ ways for event } n \\text{ to occur}, \\\\ \\end{matrix} \\end{align} then there are: \\begin{align} m_1 \\times m_2 \\times \\cdots \\times m_n \\end{align} different ways for all \\(n\\) events to occur. n-factorial for any positive integer \\(n\\): \\begin{align} n! = n(n-1)(n-2)\\cdots (3)(2)(1) \\end{align} by definition \\(0! = 1\\). permutations a permutation of \\(n\\) elements taken \\(r\\) at a time if one of the possible orderings of \\(r\\) elements from a set of \\(n\\) elements. the number of permutations of \\(r\\) elements on a set of \\(n\\) elements its denoted by \\(p(n, r)\\) and is calculated as follows: \\begin{align} p(n, r) = n(n - 1)(n - 2)(n - r + 1) \\end{align} \\begin{align} = \\frac{n(n - 1)(n - 2)(n - r + 1)(n - r)(n - r - 1) \\cdots (2)(1)}{(n - r)(n - r - 1)\\cdots (2)(1)} \\end{align} \\begin{align} = \\frac{n!}{(n - r)!} \\end{align} altenative notations for \\(p(n, r)\\) are \\(p^n_r\\) and \\(_{n}p_{r}\\). combinations a subset of items selected without regard to order is called a combination. to evaluate \\(c(n, r)\\), we start with the number of permutations, given by \\(p(n, r)\\). to get rid of the repeat orderings we divide by \\(r!\\) (the number of ways to oder the subset of \\(r\\) elements). such that the number of combinations of \\(n\\) elements taken \\(r\\) at a time is obtained as: \\begin{align} c(n, r) = \\frac{p(n, r)}{r!} \\end{align} \\begin{align} = \\frac{n!}{(n - r)!r!} \\end{align} altenative notations for \\(c(n, r)\\) are \\(c^n_r\\) and \\(_{n}c_{r}\\). $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/02_05.html",
    "title": "Piecewise-Defined Functions",
    "body": " index search search back piecewise-defined functions contents graphing piecewise-defined functions graphing piecewise-defined functions the absolute value function is a simple example of a function defined by different rules (formulas) over different subsets of its domain. such a function is called a piecewise-defined function. see figure 55. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/02_06.html",
    "title": "Operations and Composition",
    "body": " index search search back operations and composition contents operations on functions the difference quotient composition of functions operations on functions given two functions \\(ƒ\\) and \\(g\\), for all values of \\(x\\) for which both \\(f(x)\\) and \\(g(x)\\) are defined: \\begin{align} (f + g)(x) = f(x) + g(x) \\end{align} \\begin{align} (f - g)(x) = f(x) - g(x) \\end{align} \\begin{align} (fg)(x) = f(x)g(x) \\end{align} \\begin{align} \\left(\\frac{f}{g}\\right)(x) = \\frac{f(x)}{g(x)}, g(x) \\neq 0 \\end{align} the domains of \\(f + g\\), \\(f - g\\), and \\(fg\\) include all real numbers in the intersection of the domains of \\(f\\) and \\(g\\), while the domain of \\(\\frac{f}{g}\\) includes those real numbers in the intersection of the domains of \\(f\\) and \\(g\\) for which \\(g(x) \\neq 0\\). the difference quotient suppose that the point \\(p\\) lies on the graph of \\(y = f(x)\\) as in figure 68, and suppose that \\(h\\) is a positive number. if we let \\((x, f(x))\\) denote the coordinates of \\(p\\) and \\((x + h, f(x + h))\\) denote the coordinates of \\(q\\), then the line joining \\(p\\) and \\(q\\) has slope: \\begin{align} m = \\frac{f(x + h) - f(x)}{(x + h) - x} = \\frac{f(x + h) - f(x)}{h} \\end{align} this expression, called the difference quotient. figure 68 shows the graph of the line pq (called a secant line. this slope is equal to the average rate of change of \\(f\\) from \\(x\\) to \\(x + h\\). composition of functions the diagram in figure 69 shows a function \\(ƒ\\) that assigns, to each \\(x\\) in its domain, a value \\(ƒ(x)\\). then another function \\(g\\) assigns, to each \\(f(x)\\) in the domain of \\(g\\), a value \\(g(f(x))\\). this two-step process takes an element \\(x\\) and outputs an element \\(g(f(x))\\). the function with \\(y\\)-values \\(g(f(x))\\) is called the composition of function \\(g\\) and \\(f\\), written \\(g \\circ f\\) and read \"\\(g\\) of \\(f\\)\". $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/03_01.html",
    "title": "Complex Numbers",
    "body": " index search search back complex numbers contents the imaginary unit i complex numbers simplifying powers of i complex conjugates the imaginary unit i the imaginary unit is defined as: \\begin{align} i = \\sqrt{-1} \\end{align} and therefore \\begin{align} i^2 = -1 \\end{align} complex numbers numbers of the form \\(a + bi\\), where \\(a\\) and \\(b\\) are real numbers, are called complex numbers. in the complex number \\(a + bi\\), \\(a\\) is the real part and \\(b\\) is the imaginary part. two complex numbers \\(a + bi\\) and \\(c + di\\) are equal provided that their real parts are equal and their imaginary parts are equal. for a complex number \\(a + bi\\), if \\(b = 0\\), then \\(a + bi =\\) a, which is a real number. if \\(a = 0\\) and \\(b \\neq 0\\), the complex number is a pure imaginary number. simplifying powers of i by definition, \\(i^1 = i\\) and \\(i^2 = -1\\). now, observe the following pattern. \\begin{align} i^1 = i \\end{align} \\begin{align} i^2 = -1 \\end{align} \\begin{align} i^3 = i^2 i^1 = -i \\end{align} \\begin{align} i^4 = i^2 i^2 = 1 \\end{align} such that: \\begin{align} (i^4)^n = 1 \\end{align} we can then simplify powers of \\(i\\) by considering the other factor. for example, \\begin{align} i^53 = i^52 i^1 = (i^4)^13 i^1 = i \\end{align} complex conjugates the conjugate of the complex number \\(a + bi\\) is \\(a - bi\\). their product is the sum of the squares of their real and imaginary parts. to find the quotient of two complex numbers in standard form, we multiply numerator and denominator by the conjugate of the denominator. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/03_02.html",
    "title": "Quadratic Functions and Graphs",
    "body": " index search search back quadratic functions and graphs contents quadratic function completing the square graphs of quadratic functions vertex formula extreme values quadratic function the function: \\begin{align} p(x) = ax^2 + bx + c \\end{align} where \\(a\\), \\(b\\), and \\(c\\) are real numbers, with \\(a \\neq 0\\), is called a quadratic function. quadratic functions, as well as linear functions, are examples of polynomial functions. completing the square to transform the quadratic function \\(p(x) = ax^2 + bx + c\\) into the form \\(p(x) = a(x - h)^2 + k\\), follow these steps. divide each side of the equation by \\(a\\) so the coefficient of \\(x^2\\) is \\(1\\). \\begin{align} \\frac{p(x)}{a} = x^2 + \\frac{b}{a}x + \\frac{c}{a} \\end{align} add \\(-\\frac{c}{a}\\) to each side \\begin{align} \\frac{p(x)}{a} - \\frac{c}{a} = x^2 + \\frac{b}{a}x \\end{align} completing the squares: add to each side the square of hald the coefficient of \\(x\\): \\(\\left(\\frac{b}{2a}\\right)^2\\) \\begin{align} \\frac{p(x)}{a} - \\frac{c}{a} + \\left(\\frac{b}{2a}\\right)^2 = x^2 + \\frac{b}{a}x + \\left(\\frac{b}{2a}\\right)^2 \\end{align} factor the right side as the square of a binomial and combine terms on the left. \\begin{align} \\frac{p(x)}{a} - \\frac{c}{a} + \\left(\\frac{b}{2a}\\right)^2 = (x + \\frac{b}{a})^2 \\end{align} isolate the term involving \\(p(x)\\) on the left. \\begin{align} \\frac{p(x)}{a} = (x + \\frac{b}{a})^2 + \\frac{c}{a} - \\left(\\frac{b}{2a}\\right)^2 \\end{align} \\begin{align} = (x + \\frac{b}{a})^2 + \\frac{c}{a} - \\frac{b^2}{4a^2} \\end{align} multiply each side by \\(a\\). \\begin{align} p(x) = a(x + \\frac{b}{a})^2 + c - \\frac{b^2}{4a} \\end{align} \\begin{align} = a(x + \\frac{b}{a})^2 + \\frac{4ac - b^2}{4a} \\end{align} graphs of quadratic functions recall from intercepts that the \\(y\\)-intercept of the graph of an equation is the point that has \\(x\\)-coordinate 0. for a parabola given in the form \\(p(x) = ax^2 + bx + c\\), the \\(y\\)-value of the \\(y\\)-intercept is \\(p(0) = c\\). consider the graph of \\(p(x) = a(x - h)^2 + k (a \\neq 0)\\), then: the graph is a parabola with vertex \\((h, k)\\) and vertical line \\(x = h\\) as its axis of symmetry. the graph opens upward if \\(a > 0\\) and downward if \\(a < 0\\). the graph is wider than the graph of \\(y = x^2\\) if \\(0 < |a| < 1\\) and narrower if \\(|a| > 1\\). vertex formula we can determine the coordinates of the vertex of the graph of a quadratic function by completing the square, as shown earlier. given the standard form of the quadratic function \\(p(x) = ax^2 + bx + c, where a \\neq 0\\), then: \\begin{align} p(x) = a\\left(x - \\left(-\\frac{b}{a}\\right)\\right)^2 + + \\frac{4ac - b^2}{4a} \\end{align} this equation shows that the vertex \\((h, k)\\) can be expressed in terms of \\(a, b\\) and \\(c\\), such that: \\begin{align} h = \\left(-\\frac{b}{a}\\right) \\end{align} and \\begin{align} k = \\frac{4ac - b^2}{4a} \\end{align} extreme values the vertex of the graph of \\begin{align} p(x) = ax^2 + bx + c \\end{align} is the lowest point on the graph of the function if \\(a > 0\\) and the highest point if \\(a < 0\\). such points are called extreme points (also extrema; singular, extremum). if \\(a > 0\\) then the vertex \\((h, k)\\) is called the minimum point of the graph. the minimum value of the function is \\(p(h) = k\\). if \\(a < 0\\) then the vertex \\((h, k)\\) is called the maximum point of the graph. the maximum value of the function is \\(p(h) = k\\). figure 14 illustrates these ideas. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/11_05.html",
    "title": "The Binomial Theorem",
    "body": " index search search back the binomial theorem contents binomial coefficient pascal s triangle the binomial theorem rth term of a binomial expansion binomial coefficient generalizing, we find that the coefficient for the term of the expansion of \\((x + y)^n\\) in which the variable part is \\(x^ry^{n -r}\\), where \\(r \\leq n\\) is: \\begin{align} \\binom{n}{r} = \\frac{n!}{r!(n - r)!} \\end{align} which is equivalent to \\(c(n ,r)\\). this number is called the binomial coefficient and is often written as \\(\\binom{n}{r}\\). pascal's triangle if we only write the coffiencients for the expansion of \\((x + y)^n\\) we obtain the following pattern: such that each number in the triangle is the sum of the two numbers directly above it. this triangular array of numbers is called pascal's triangle. the binomial theorem our observations about the expansion of \\((x + y)^n\\) are summarized as follows: there are \\(n + 1\\) terms in the expansion. the first term is \\(x^n\\) and the last term is \\(y^n\\) in each term, the exponent on \\(x\\) decreases by \\(1\\), and the exponent on \\(y\\) increases by \\(1\\). the sum of the exponents on \\(x\\) and \\(y\\) in any term is \\(n\\) the coefficient of the term with \\(x^ry^{n - r}\\) o \\(x^{n - r}y^r\\) is \\(\\binom{n}{r}\\) from these observations the binomial theorem is derived: for any positive integer \\(n\\): \\begin{align} (x + y)^n = x^n + \\binom{n}{1} x^{n-1}y + \\binom{n}{2}x^{n-2}y^2 + \\cdots + \\binom{n}{r}x^{n - r}y^r + \\cdots + \\binom{n}{n - 1}xy^{n - 1} + y^n \\end{align} \\begin{align} (x + y)^n = \\sum_{r=0}^n \\binom{n}{r}x^{n - r}y^r \\end{align} rth term of a binomial expansion the \\(r\\)th term of the binomial expansion of \\((x + y)^n\\), where \\(n \\geq r - 1\\) is: \\begin{align} \\binom{n}{r - 1} x^{n - (r - 1)} y^{r - 1} \\end{align} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/03_03.html",
    "title": "Quadratic Equations and Inequalities",
    "body": " index search search back quadratic equations and inequalities contents quadratic equation in one variable square root property quadratic formula and the discriminant solving quadratic inequalities quadratic equation in one variable an equation that can be written in the form: \\begin{align} ax^2 + bx + c = 0 \\end{align} where \\(a\\) and \\(b\\) are real numbers, with \\(a \\neq 0\\) is a quadratic equation in standard form. figure 25 shows possible numbers of \\(x\\)-intercepts of the graph of a quadratic function that opens upward similarly, figure 26 shows possible numbers of x-intercepts of the graph of a quadratic function that opens downward. thus, a quadratic equation can have zero, one, or two real solutions. square root property the solution set of \\(x^2 = k\\) is one of the following \\(\\{\\pm \\sqrt{k}\\}\\) if \\(k > 0\\) \\(\\{0\\}\\) if \\(k = 0\\) \\(\\{\\pm i\\sqrt{|k|}\\}\\) if \\(k < 0\\) quadratic formula and the discriminant there is a formula that can be used to solve any quadratic equation. to find it, we complete the square on the standard form of \\(ax^2 + bx + c = 0\\). \\begin{align} ax^2 + bx + c = 0 \\end{align} \\begin{align} x^2 + \\frac{b}{a}x + \\frac{c}{a} = 0 \\end{align} \\begin{align} x^2 + \\frac{b}{a}x = -\\frac{c}{a} \\end{align} \\begin{align} x^2 + \\frac{b}{a}x + \\left(\\frac{b}{2a}\\right)^2= -\\frac{c}{a} + \\left(\\frac{b}{2a}\\right)^2 \\end{align} \\begin{align} (x + \\frac{b}{2a})^2 = -\\frac{c}{a} + \\frac{b^2}{4a^2} \\end{align} \\begin{align} x + \\frac{b}{2a} = \\sqrt{-\\frac{c}{a} + \\frac{b^2}{4a^2}} \\end{align} \\begin{align} x + \\frac{b}{2a} = \\pm \\sqrt{\\frac{b^2 - 4ac}{4a^2}} \\end{align} \\begin{align} x + \\frac{b}{2a} = \\pm \\frac{\\sqrt{b^2 - 4ac}}{2a} \\end{align} \\begin{align} x = - \\frac{b}{2a} \\pm \\frac{\\sqrt{b^2 - 4ac}}{2a} \\end{align} \\begin{align} x = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} \\end{align} the expression \\(b^2 − 4ac\\) under the radical in the quadratic formula is called the discriminant. if \\(b^2 - 4ac > 0\\) then there are two real solutions. if \\(b^2 - 4ac = 0\\) then there is one real solutions. if \\(b^2 - 4ac < 0\\) then there are two non-real complex solutions. solving quadratic inequalities a quadratic inequality is an inequality that can be written in the form: \\begin{align} ax^2 + bx + c < 0 \\end{align} where \\(a\\), \\(b\\) and \\(c\\) are real numbers with \\(a \\neq 0\\). we can solve a quadratic inequality graphically, using the ideas shown in the following table. to solve a quadratic inequality analytically, follow these steps. solve the corresponding quadratic equation. identify the intervals determined by the solutions of the equation use a test value from each interval to determine which intervals form the solution set. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/03_05.html",
    "title": "High-Degree Polynomial Functions and Graphs",
    "body": " index search search back high-degree polynomial functions and graphs contents polynomial function cubic functions quartic functions extrema number of turning points end behaviour x-intercepts real zeros comprehensive graphs polynomial function a polynomial function of degree \\(n\\) in the variable \\(x\\) is a function of the form: \\begin{align} p(x) = a_nx^n + a_{n-1}x^{n-1} + \\cdots + a_1 x + a_0 \\end{align} where each \\(a_1\\) is a real number, \\(a_n \\neq 0\\) and \\(n\\) is a whole number. the behavior of the graph of a polynomial function is due largely to the value of the coefficient \\(a_n\\) and the parity of the exponent \\(n\\) on the term of greatest degree. for this reason, we will refer to \\(a_n\\) as the leading coefficient and to \\(a_n x_n\\) as the dominating term. the term \\(a_0\\) is the constant term of the polynomial function, and since \\(p(0) = a_0\\), it is the \\(y\\)-value of the \\(y\\)-intercept of the graph. cubic functions a polynomial function of the form: \\begin{align} p(x) = ax^3 + bx^2 + cx + d, a \\neq 0 \\end{align} is a cubic function. quartic functions a polynomial function of the form: \\begin{align} p(x) = ax^4 + bx^3 + cx^2 + dx + e, a \\neq 0 \\end{align} is a quartic function. extrema the graphs for polynomial may have turning points where the function changes from increasing to decreasing or vice versa. let \\(c\\) be in the domain of \\(p\\), then the following hold: \\(p(c)\\) is an absolute maximum if \\(p(c) \\geq p(x)\\) for all \\(x\\) in the domain of \\(p\\) \\(p(c)\\) is an absolute minimum if \\(p(c) \\leq p(x)\\) for all \\(x\\) in the domain of \\(p\\) \\(p(c)\\) is an local maximum if \\(p(c) \\geq p(x)\\) when \\(x\\) is near \\(c\\) \\(p(c)\\) is an local minimum if \\(p(c) \\leq p(x)\\) when \\(x\\) is near \\(c\\) number of turning points the number of turning points of the graph of a polynomial function of degree \\(n \\geq 1\\) is at most \\(n - 1\\). end behaviour suppose that \\(ax^n\\) is the dominating term of a polynomial function \\(p\\) of odd degree. if \\(a > 0\\), then as \\(x \\rightarrow \\infty\\), \\(p(x) \\rightarrow \\infty\\), and as \\(x \\rightarrow -\\infty\\), \\(p(x) \\rightarrow -\\infty\\). therefore, the end behavior of the graph is of the type shown in figure 52(a). if \\(a < 0\\), then as \\(x \\rightarrow \\infty\\), \\(p(x) \\rightarrow -\\infty\\), and as \\(x \\rightarrow -\\infty\\), \\(p(x) \\rightarrow \\infty\\). therefore, the end behavior of the graph is of the type shown in figure 52(b). suppose that \\(ax^n\\) is the dominating term of a polynomial function \\(p\\) of even degree. if \\(a > 0\\), then as \\(|x| \\rightarrow \\infty\\), \\(p(x) \\rightarrow \\infty\\). therefore, the end behavior of the graph is of the type shown in figure 53(a). if \\(a < 0\\), then as \\(|x| \\rightarrow \\infty\\), \\(p(x) \\rightarrow -\\infty\\). therefore, the end behavior of the graph is of the type shown in figure 53(b). x-intercepts (real zeros) the graph of a polynomial function of degree \\(n\\) will have at most \\(n\\) \\(x\\)-intercepts (real zeros). comprehensive graphs the most important features of the graph of a polynomial function are its intercepts, extrema, and end behavior. for this reason, a comprehensive graph of a polynomial function will exhibit the following features. all \\(x\\)-intercepts (if any) the \\(y\\)-intercept all extreme points (if any) enough of the graph to reveal the correct end behavior $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/11_06.html",
    "title": "Mathematical Induction",
    "body": " index search search back mathematical induction contents principle of mathematical induction method of proof by mathematical induction generalized principle of mathematical induction proof of the binomial theorem principle of mathematical induction let \\(s_n\\) be a statement concerning the positive integer \\(n\\). suppose that both of the following hold: \\(s_1\\) is true. for any positive integer \\(k\\), \\(k \\leq n\\) if \\(s_k\\) is true, then \\(s_{k+1}\\) is also true. then \\(s_n\\) is true for every positive integer \\(n\\). method of proof by mathematical induction prove that the statement is true for \\(n = 1\\). show that for any positive integer \\(k\\), if \\(s_k\\) is true then \\(s_{k+1}\\) is also true. generalized principle of mathematical induction let \\(s_n\\) be a statement concerning the positive integer \\(n\\). let \\(j\\) be a fixed positive integer. suppose that both of the following hold. \\(s_j\\) is true. for any positive integer \\(k\\), \\(k \\geq j\\), \\(s_k\\) implies \\(s_{k+1}\\) then \\(s_n\\) is true for all positive integers \\(n\\), where \\(n \\geq j\\). proof of the binomial theorem the binomial theorem can be proved by mathematical induction. that is, for any positive integer \\(n\\) and any numbers \\(x\\) and \\(y\\), \\begin{align} (x + y)^n = x^n + \\binom{n}{1} x^{n-1}y + \\binom{n}{2} x^{n-2}y^2 + \\cdots + \\binom{n}{r} x^{n - r}y^r + \\cdots + \\binom{n}{n-1}xy^{n-1} + y^n \\end{align} proof let \\(s_n\\) be the previous statement. begin by verifying \\(s_n\\) for \\(n = 1\\). \\begin{align} (x + y)^{n=1} = x + y = \\binom{1}{0}x^1y^0 + \\binom{1}{1} x^0y^1 \\end{align} now we assume \\(s_k\\), such that: \\begin{align} (x + y)^k = x^k + \\frac{k!}{1!(k - 1)!} x^{k-1}y + \\frac{k!}{2!(k - 2)!} x^{k-2}y^2 + \\cdots + \\frac{k!}{r!(k - r)!} x^{k - r}y^r + \\cdots + \\frac{k!}{(k - 1)!1!}xy^{k-1} + y^k \\end{align} we multiply the left side by \\((x + y)\\): \\begin{align} (x + y)(x + y)^k = x(x + y)^k + y(x + y)^k \\end{align} and we apply \\(s_k\\) \\begin{align} x(x + y)^k + y(x + y)^k = x\\left[x^k + \\frac{k!}{1!(k - 1)!} x^{k-1}y + \\frac{k!}{2!(k - 2)!} x^{k-2}y^2 + \\cdots + \\frac{k!}{r!(k - r)!} x^{k - r}y^r + \\cdots + \\frac{k!}{(k - 1)!1!}xy^{k-1} + y^k\\right] + y \\left[x^k + \\frac{k!}{1!(k - 1)!} x^{k-1}y + \\frac{k!}{2!(k - 2)!} x^{k-2}y^2 + \\cdots + \\frac{k!}{r!(k - r)!} x^{k - r}y^r + \\cdots + \\frac{k!}{(k - 1)!1!}xy^{k-1} + y^k\\right] \\end{align} \\begin{align} = \\left[x^{k + 1} + \\frac{k!}{1!(k - 1)!} x^{k}y + \\frac{k!}{2!(k - 2)!} x^{k-1}y^2 + \\cdots + \\frac{k!}{r!(k - r)!} x^{k - r + 1}y^r + \\cdots + \\frac{k!}{(k - 1)!1!}x^2y^{k-1} + xy^k\\right] + \\left[yx^k + \\frac{k!}{1!(k - 1)!} x^{k-1}y^2 + \\frac{k!}{2!(k - 2)!} x^{k-2}y^3 + \\cdots + \\frac{k!}{r!(k - r)!} x^{k - r}y^{r + 1} + \\cdots + \\frac{k!}{(k - 1)!1!}xy^{k} + y^{k+1}\\right] \\end{align} now we group the elements with the same terms: \\begin{align} = x^{k+1} + \\left[\\frac{k!}{1!(k - 1)!} x^{k}y + \\frac{k!}{0!k!} yx^k \\right] + \\left[\\frac{k!}{2!(k - 2)!} x^{k-1}y^2 + \\frac{k!}{1!(k - 1)!} x^{k-1}y^2 \\right] + \\cdots + \\left[\\frac{k!}{r!(k - r)!} x^{(k - r) + 1}y^r + \\frac{k!}{(r - 1)!(k - (r - 1))!}x^{(k - r) + 1}y^{r} \\right] + \\cdots + y^{k + 1} \\end{align} we first show that: \\begin{align} \\frac{k!}{r!(k - r)!} + \\frac{k!}{(r + 1)!(k - (r + 1))!} = \\binom{k + 1}{r + 1} \\end{align} by the definition of the factorial of a number: \\begin{align} = \\frac{k (k - 1) (k - 2) \\cdots (k - r) \\cdots 1}{(r + 1)!(k - r - 1)!} + \\frac{k (k - 1) (k - 2) \\cdots (k - r + 1) \\cdots 1}{r!(k - r)!} \\end{align} \\begin{align} = \\frac{k (k - 1) (k - 2) \\cdots (k - r)}{(r + 1)!} + \\frac{k (k - 1) (k - 2) \\cdots (k - r - 1)}{r!} \\end{align} \\begin{align} = \\frac{k (k - 1) (k - 2) \\cdots (k - r)}{(r + 1)!} + (r + 1)\\frac{k (k - 1) (k - 2) \\cdots (k - r + 1)}{(r + 1)!} \\end{align} \\begin{align} = \\frac{k(k - 1)(k - 2) \\cdots (k - r - 1) \\left[(k - r) + (r + 1)\\right]}{(r + 1)!} \\end{align} \\begin{align} = \\frac{k(k - 1)(k - 2) \\cdots (k - r - 1) \\left[k + 1\\right]}{(r + 1)!} \\end{align} \\begin{align} = \\frac{(k + 1)k(k - 1)(k - 2) \\cdots (k - r - 1)}{(r + 1)!} \\end{align} \\begin{align} = \\frac{(k + 1)k(k - 1)(k - 2) \\cdots (k - r - 1) \\cdots 1}{(r + 1)!(k - r)!} \\end{align} \\begin{align} = \\frac{(k + 1)!}{(r + 1)!((k + 1) - (r + 1))!} \\end{align} \\begin{align} = \\binom{k + 1}{r + 1} \\end{align} so now: \\begin{align} = x^{k+1} + \\left[\\frac{k!}{1!(k - 1)!} + \\frac{k!}{0!k!}\\right] x^{k}y + \\left[\\frac{k!}{2!(k - 2)!} + \\frac{k!}{1!(k - 1)!} \\right] x^{k-1}y^2 + \\cdots + \\left[\\frac{k!}{r!(k - r)!} + \\frac{k!}{(r - 1)!(k - (r - 1))!} \\right] x^{(k - r) + 1} y^r + \\cdots + y^{k + 1} \\end{align} by the previous proof \\(\\frac{k!}{r!(k - r)!} + \\frac{k!}{(r + 1)!(k - (r + 1))!} = \\binom{k + 1}{r + 1}\\), therefore: \\begin{align} = x^{k+1} + \\binom{k + 1}{1} x^{k}y + \\binom{k + 1}{2} x^{k-1}y^2 + \\cdots + \\binom{k + 1}{r!} x^{(k - r) + 1} y^r + \\cdots + y^{k + 1} \\end{align} \\begin{align} = x^{k+1} + \\binom{k + 1}{1} x^{(k + 1) - 1}y + \\binom{k + 1}{2} x^{(k + 1) - 2}y^2 + \\cdots + \\binom{k + 1}{r} x^{(k + 1) - r} y^r + \\cdots + y^{k + 1} \\end{align} \\begin{align} = \\sum_{r = 0}^{k + 1} \\binom{k + 1}{r}x^{(k + 1) - r}y^r \\end{align} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/03_06.html",
    "title": "Topics in the Theory of Polynomial Functions (I)",
    "body": " index search search back topics in the theory of polynomial functions (i) contents intermediate value theorem division of polynomials by x k and synthetic division remainder theorem factor theorem division of any two polynomials intermediate value theorem if \\(p(x)\\) defines a polynomial function with only real coefficients, and if, for real numbers \\(a\\) and \\(b\\), the values \\(p(a)\\) and \\(p(b)\\) are opposite in sign, then there exists at least one real zero between \\(a\\) and \\(b\\). division of polynomials by x − k and synthetic division we can use long division to determine whether one whole number is a factor of another. if the degree \\(n\\) polynomial \\(p(x)\\) (where \\(n \\geq 1\\)) is divided by \\(x - k\\), then the quotient polynomial, \\(q(x)\\), has degree \\(n - 1\\). the remainder \\(r\\) is a constant (and may be \\(0\\)). the complete quotient for \\(\\frac{p(x)}{x - k}\\) may be written as: \\begin{align} \\frac{p(x)}{x - k} = q(x) + \\frac{r}{x - k} \\end{align} long division of a polynomial by a binomial of the form \\(x - k\\) can be condensed on the right, exactly the same division is shown without the variables. all the numbers in color on the right are repetitions of the numbers directly above them, so they can be omitted, as shown below on the left. since the coefficient of \\(x\\) in the divisor is always \\(1\\), it can be omitted, too the numbers in color on the left are again repetitions of the numbers directly above them. they may be omitted, as shown on the right. now the problem can be condensed. if the 3 in the dividend is brought down to the beginning of the bottom row, the top row can be omitted, since it duplicates the bottom row to simplify the arithmetic, we replace subtraction in the second row by addition and compensate by changing the \\(-3\\) at the upper left to its additive inverse, \\(3\\). remainder theorem if a polynomial \\(p(x)\\) is divided by \\(x - k\\), the remainder is equal to \\(p(k)\\). by the division algorithm for polynomials: \\begin{align} p(x) = q(x)(x-k) + r \\end{align} \\begin{align} p(k) = q(k)(k-k) + r = r \\end{align} factor theorem a polynomial \\(p(x)\\) has a factor \\(x - k\\) if and only if \\(p(k) = 0\\). by the remainder theorem: \\begin{align} p(k) = r \\end{align} where \\(r\\) is the remainder, which is necessarily \\(0\\). division of any two polynomials let \\(p(x)\\) and \\(d(x)\\) be two polynomials, with the degree of \\(d(x)\\) greater than zero and less than the degree of \\(p(x)\\). then there exist unique polynomials \\(q(x)\\) and \\(r(x)\\) such that: \\begin{align} \\frac{p(x)}{d(x)} = q(x) + \\frac{r(x)}{d(x)} \\end{align} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/03_07.html",
    "title": "Topics in the Theory of Polynomial Functions (II)",
    "body": " index search search back topics in the theory of polynomial functions (ii) contents conjugate zeros theorem fundamental theorem of algebra number of zeros theorem multiplicity rational zeros theorem descartes rule of signs boundedness theorem conjugate zeros theorem if \\(p(x)\\) is a polynomial function having only real coefficients, and if \\(a + bi\\) is a zero of \\(p(x)\\), then the conjugate \\(a - bi\\) is also a zero of \\(p(x)\\). fundamental theorem of algebra every function defined by a polynomial of degree \\(1\\) or more has at least one complex zero. number of zeros theorem a function defined by a polynomial of degree \\(n\\) has at most \\(n\\) distinct (unique) complex zeros. multiplicity the number of times a zero appears is referred to as the multiplicity of the zero. a zero \\(k\\) of a polynomial function has as multiplicity the exponent of the factor \\(x - k\\). if the zero has multiplicity one, the graph crosses the \\(x\\)-axis at the corresponding \\(x\\)-intercept as seen in figure 74(a) on the next page. if the zero has even multiplicity, the graph is tangent to the \\(x\\)-axis at the corresponding \\(x\\)-intercept (see figure 74(b)). if the zero has odd multiplicity greater than one, the graph crosses the \\(x\\)-axis and is tangent to the \\(x\\)-axis at the corresponding \\(x\\)-intercept. (see figure 74(c)). rational zeros theorem let \\(p(x) = a_nx^n + a_{n-1}x^{n - 1} + \\cdots + a_1x + a_0\\), where \\(a_n \\neq 0\\) and \\(a_0 \\neq 0\\), be a polynomial function with integer coefficients. if \\(\\frac{p}{q}\\) is a rational number written in lowest terms, and if \\(\\frac{p}{q}\\) is a zero of \\(p(x)\\), then \\(p\\) is a factor of the constant term \\(a_0\\), and \\(q\\) is a factor of the leading coefficient \\(a_n\\). proof \\(p(\\frac{p}{q}) = 0\\) since \\(\\frac{p}{q}\\) is a zero of \\(p(x)\\): we substitute \\(x\\) by \\(\\frac{p}{q}\\) \\begin{align} a_n \\left(\\frac{p}{q}\\right)^n + a_{n-1} \\left(\\frac{p}{q}\\right)^{n - 1} + \\cdots + a_{1} \\left(\\frac{p}{q}\\right) + a_0 = 0 \\end{align} \\begin{align} a_n \\left(\\frac{p^n}{q^n}\\right) + a_{n-1} \\left(\\frac{p^{n-1}}{q^{n-1}}\\right) + \\cdots + a_{1} \\left(\\frac{p}{q}\\right) + a_0 = 0 \\end{align} we multiply by \\(q^n\\) and we add \\(-a_0q^n\\) \\begin{align} a_n p^n + a_{n-1} p^{n-1}q + \\cdots + a_{1} p q^{n-1} = -a_0 + q^{n} \\end{align} we factor out \\(p\\) \\begin{align} p(a_n p^{n-1} + a_{n-1} p^{n-2}q + \\cdots + a_{1} q^{n-1}) = -a_0 + q^{n} \\end{align} thus, \\(-a_0q^n\\) equals the product of the two factors, \\(p\\) and \\((a_np^{n-1} + \\cdots + a_1q^{n-1})\\). for this reason, \\(p\\) must be a factor of \\(-a_0q^n\\). since it was assumed that \\(\\frac{p}{q}\\) is written in lowest terms, \\(p\\) and \\(q\\) have no common factor other than \\(1\\), so \\(p\\) is not a factor of \\(q^n\\). thus, \\(p\\) must be a factor of \\(a_0\\). descartes' rule of signs let \\(p(x)\\) be a polynomial function with real coefficients and a nonzero constant term, with terms in descending powers of \\(x\\). the number of positive real zeros either equals the number of variations in sign occurring in the coefficients of \\(p(x)\\) or is less than the number of variations by a positive even integer. the number of negative real zeros either equals the number of variations in sign occurring in the coefficients of \\(p(-x)\\) or is less than the number of variations by a positive even integer. boundedness theorem let \\(p(x)\\) be a polynomial function of degree \\(n \\geq 1\\) with real coefficients and with a positive leading coefficient. suppose \\(p(x)\\) is divided synthetically by \\(x - c\\). if \\(c > 0\\) and all numbers in the bottom row of the synthetic division are nonnegative, then \\(p(x)\\) has no zero greater than \\(c\\). if \\(c < 0\\) and the numbers in the bottom row of the synthetic division alternate in sign (with \\(0\\) considered positive or negative, as needed), then \\(p(x)\\) has no zero less than \\(c\\). $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/03_08.html",
    "title": "Polynomial Equations and Inequalities; Further Applications and Models",
    "body": " index search search back polynomial equations and inequalities; further applications and models contents complex nth roots complex nth roots theorem complex nth roots if \\(n\\) is a positive integer and \\(k\\) is a nonzero complex number, then a solution of \\(x^n = k\\) is called an \\(n\\)th root of \\(k\\). complex nth roots theorem if \\(n\\) is a positive integer and \\(k\\) is a nonzero complex number, then the equation \\(x^n = k\\) has exactly \\(n\\) complex roots. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/04_01.html",
    "title": "Rational Functions and Graphs (I)",
    "body": " index search search back rational functions and graphs (i) contents rational function the reciprocal function rational function a function \\(f\\) of the form: \\begin{align} f(x) = \\frac{p(x)}{q(x)} \\end{align} where \\(p(x)\\) and \\(q(x)\\) are polynomials, with \\(q(x) \\neq 0\\), is called a rational function. the reciprocal function the simplest rational function with a variable denominator is the reciprocal function, defined as: \\begin{align} f(x) = \\frac{1}{x} \\end{align} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/04_02.html",
    "title": "Rational Functions and Graphs (II)",
    "body": " index search search back rational functions and graphs (ii) contents vertical and horizontal asymptotes graphic a rational function behavior of graphs of rational functions near vertical asymptotes behavior of graphs of rational functions near x-intercepts graphs with points of discontinuity vertical and horizontal asymptotes let \\(p(x)\\) and \\(q(x)\\) be polynomials. for the rational function \\(f(x) = \\frac{p(x)}{q(x)}\\), written in lowest terms, and for real numbers \\(a\\) and \\(b\\), if \\(|f(x)| \\rightarrow \\infty\\) as \\(x \\rightarrow a\\), then the line \\(x = a\\) is a vertical asymptote if \\(|f(x)| \\rightarrow b\\) as \\(x \\rightarrow \\infty\\), then the line \\(y = b\\) is a horizontal asymptote to find asymptotes of a rational function defined by a rational expression in lowest terms, use the following procedures: vertical asymptotes are found by determining the values of \\(x\\) that make the denominator, but not the numerator, equal to \\(0\\). other asymptotes: if the numerator has lesser degree than the denominator, then there is a horizontal asymptote \\(y = 0\\) . if the numerator and denominator have the same degree and the function is of the form: \\begin{align} f(x) = \\frac{a_nx^n + \\cdots + a_0}{b_nx^n + \\cdots + b_0}, \\text{ where } b_n \\neq 0 \\end{align} then dividing by \\(x_n\\) in the numberator and denominator produces de horizontal asymptote \\(y = \\frac{a_n}{b_n}\\). if the numerator is of degree exactly one greater than the denominator, then there may be an oblique (or slant) asymptote. to find it, divide the numerator by the denominator and disregard any remainder. set the (linear) polynomial portion of the quotient equal to \\(y\\) to find the equation of the asymptote. graphic a rational function let \\(f(x) = \\frac{p(x)}{q(x)}\\) be a function with the rational expression in lowest terms. to sketch its graph, follow these steps. find the domain and all vertical asymptotes. find any horizontal or oblique asymptote. find the \\(y\\)-intercept, if possible, by evaluating \\(f(0)\\) find the \\(x\\)-intercepts, if any, by solving \\(f(x) = 0\\). determine whether the graph will intersect its nonvertical asymptote \\(y = b\\) by solving \\(f(x) = b\\), where \\(b\\) is the \\(y\\)-value of the horizontal asymptote, or by solving \\(f(x) = mx + b\\), where \\(y = mx + b\\) is the equation of the oblique asymptote. plot selected points as necessary. behavior of graphs of rational functions near vertical asymptotes suppose that \\(f(x)\\) is a rational expression in lowest terms. if \\(n\\) is the largest positive integer such that \\((x - a)^n\\) is a factor of the denominator of \\(f(x)\\), the graph will behave in the manner illustrated near \\(a\\). behavior of graphs of rational functions near x-intercepts suppose that \\(f(x)\\) is a rational expression in lowest terms. if \\(n\\) is the largest positive integer such that \\((x - c)^n\\) is a factor of the numerator of \\(f(x)\\), the graph will behave in the manner illustrated near \\(c\\). graphs with points of discontinuity a rational function that has a common variable factor in the numerator and denominator is not in lowest terms. its graph usually has a hole, or point of discontinuity. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/04_03.html",
    "title": "Rational Equations, Inequalities, Models and Applications",
    "body": " index search search back rational equations, inequalities, models and applications contents solving rational equations and inequalities solving rational equations solving rational inequalities inverse variation joint variation solving rational equations and inequalities a rational equation (or rational inequality) is an equation (or inequality) with at least one term having a variable expression in a denominator or at least one term having a variable expression raised to a negative integer power. solving rational equations determine all values for which the rational equation has undefined expressions. to clear fractions, multiply each side of the equation by the least common denominator of all rational expressions in the equation. solve the resulting equation. reject any values found in step 1. solving rational inequalities rewrite the inequality, if necessary, so that \\(0\\) is on one side and there is a single rational expression on the other side. determine the values that will cause either the numerator or the denominator of the rational expression to equal \\(0\\). these values determine the intervals on the number line to consider. use a test value from each interval to determine which intervals form the solution set. inverse variation when two quantities vary inversely, an increase in one quantity results in a decrease in the other. let \\(x\\) and \\(y\\) denote two quantities and \\(n\\) be a positive number. then \\(y\\) is inversely proportional to the nth power of \\(x\\), or \\(y\\) varies inversely with the nth power of \\(x\\), if there exists a nonzero number \\(k\\) such that: \\begin{align} y = \\frac{k}{x^n} \\end{align} if \\(y = \\frac{k}{x}\\), then \\(y\\) is inversely proportional to \\(x\\), or \\(y\\) varies inversely with \\(x\\). joint variation let \\(m\\) and \\(n\\) be real numbers. then \\(z\\) varies jointly with the \\(n\\)th power of \\(x\\) and the \\(m\\)th power of \\(y\\) if a nonzero real number \\(k\\) exists such that \\begin{align} z = kx^ny^m \\end{align} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/04_04.html",
    "title": "Functions Defined by Powers and Roots",
    "body": " index search search back functions defined by powers and roots contents power and root functions [[#graphs of \\(f(x) = \\sqrt[n]{ax + b}\\)]] power and root functions a function \\(f\\) of the form: \\begin{align} f(x) = x^b \\end{align} where \\(b\\) is a constant, is a power function. if \\(b = \\frac{1}{m}\\), for some integer \\(n \\geq 2\\), then \\(f\\) is a root function frequently, the domain of a power function \\(f\\) is restricted to nonnegative numbers. suppose the rational number \\(\\frac{p}{q}\\) is written in lowest terms. then the domain of \\(f(x) = x^{\\frac{p}{q}}\\) is all real numbers whenever \\(q\\) is odd and all nonnegative real numbers whenever \\(q\\) is even. if \\(b\\) is a positive irrational number, the domain of \\(f(x) = x^b\\) is all nonnegative real number. graphs of \\(f(x) = \\sqrt[n]{ax + b}\\) when \\(n\\) is even, the graph of the root function \\(f(x) = \\sqrt[n]{x}\\) resembles the graph of the square root function. when \\(n\\) is odd, the graph of the root function \\(f(x) = \\sqrt[n]{x}\\) resembles the graph of the cube root function. to determine the domain of a root function of the form: \\begin{align} f(x) = \\sqrt[n]{ax + b} \\end{align} we must note the parity of \\(n\\): if \\(n\\) is even in \\(\\sqrt[n]{ax + b}\\), then \\(ax + b\\) must be greater than or equal to \\(0\\). if \\(n\\) is odd in \\(\\sqrt[n]{ax + b}\\), then \\(ax + b\\) can be any real number. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/04_05.html",
    "title": "Equations, Inequalities, and Applications Involving Root Functions",
    "body": " index search search back equations, inequalities, and applications involving root functions contents equations and inequalities power property equations and inequalities power property if \\(p\\) and \\(q\\) are algebraic expressions, then every solution of the equation \\(p = q\\) is among the solutions of the equation \\(p^n = q^n\\), for any positive integer \\(n\\). when the power property is used to solve equations, the new equation may have more solutions than the original equation. we call these proposed solutions of the original equation. after applying the power property on equations that contain radicals or rational exponents, it is essential to check all proposed solutions in the original equation. to solve equations involving roots, follow these steps. isolate a term involving a root on one side of the equation raise each side of the equation to a positive integer power that will eliminate the radical or rational exponent. solve the resulting equation. (if a root is still present after step 2, repeat steps 1 and 2.) check each proposed solution in the original equation $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/05_01.html",
    "title": "Inverse Functions",
    "body": " index search search back inverse functions contents one-to-one functions horizontal line test inverse function finding the equation of the inverse of y ƒ x geometric relationship between the graphs of f and f -1 important facts about inverses one-to-one functions a function \\(f\\) is a one-to-one function if, for elements \\(a\\) and \\(b\\) from the domain of \\(f\\): \\begin{align} a \\neq b \\end{align} implies \\begin{align} f(a) \\neq f(b) \\end{align} and by the contrapositive: \\begin{align} f(a) = f(b) \\end{align} implies \\begin{align} a = b \\end{align} a function that is either always increasing or always decreasing on its domain must be one-to-one. horizontal line test a function is one-to-one if every horizontal line intersects the graph of the function at most once. inverse function let \\(f\\) be a one-to-one function. then \\(g\\) is the inverse function of \\(f\\) and \\(f\\) is the inverse function of \\(g\\) if: \\begin{align} (f \\circ g)(x) = x \\text{ for every } x \\text{ in the domain of } g \\end{align} and \\begin{align} (g \\circ x)(x) = x \\text{ for every } x \\text{ in the domain of } f \\end{align} a special notation is often used for inverse functions. if \\(g\\) is the inverse function of \\(ƒ\\), then \\(g\\) can be written as \\(f^{-1}\\) (read \"f-inverse\"). by the definition of an inverse function, the domain of \\(f\\) equals the range of \\(f^{-1}\\), and the range of \\(f\\) equals the domain of \\(f^{-1}\\). finding the equation of the inverse of y = ƒ(x) for a one-to-one function \\(f\\) defined by an equation \\(y = f(x)\\), find the defining equation of the inverse as follows. (you may need to replace \\(f(x)\\) with \\(y\\) first. any restrictions on \\(x\\) and \\(y\\) should be considered.) interchange \\(x\\) and \\(y\\). solve for \\(y\\). replace \\(y\\) with \\(f^{-1}\\). geometric relationship between the graphs of \\(f\\) and \\(f^{-1}\\) if a function \\(f\\) is one-to-one, then the graph of its inverse \\(f^{-1}\\) is a reflection of the graph of \\(f\\) across the line \\(y = x\\). important facts about inverses if \\(f\\) is one-to-one, then \\(f^{-1}\\) exists the domain of \\(f\\) is equal to the range of \\(f^{-1}\\), and the range of \\(f\\) is equal to the domain of \\(f^{-1}\\). if the point \\((a, b)\\) lies on the graph of \\(f\\), then \\((b, a)\\) lies on the graph of \\(f^{-1}\\). the graphs of \\(f\\) and \\(f^{-1}\\) are reflections of each other across the line \\(y = x\\). $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/05_02.html",
    "title": "Exponential Functions",
    "body": " index search search back exponential functions contents real-number exponents graphs of exponential functions exponential equations type 1 real-number exponents for any real number \\(a > 0\\), \\(a \\neq 1\\), the following statements are true: \\(a^{x}\\) is a unique real number for each real number \\(x\\). \\(a^b = a^c\\) if and only if \\(b = c\\). if \\(a > 1\\) and \\(m < n\\), then \\(a^m > a^n\\). graphs of exponential functions if \\(a > 0\\) and \\(a \\neq 1\\), then: \\begin{align} f(x) = a^x \\end{align} is the exponential function with base \\(a\\). the behavior of the graph of an exponential function depends, in general, on the magnitude of \\(a\\). as a becomes larger (\\(a > 1\\)), the graph becomes steeper moving to the right of the \\(y\\)-axis. (see figure 16(a)). if the base \\(a\\) is between \\(0\\) and \\(1\\), as a gets closer to \\(0\\), the graph becomes steeper moving to the left of the \\(y\\)-axis. (see figure 16(b)). exponential equations (type 1) on the equation \\(25^x = 125\\) the variable appears in the exponent, we refer to such an equation as a type 1 exponential equation (this is not any type of standard naming, it is just used on this manual). $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/05_03.html",
    "title": "Logarithms and Their Properties",
    "body": " index search search back logarithms and their properties contents logarithm common logarithm natural logarithm properties of logarithms proofs change-of-base rule logarithm for all positive numbers \\(a\\), where \\(a \\neq 1\\), \\begin{align} a^y = x \\end{align} is equivalent to \\begin{align} y = \\log_a x \\end{align} the expression \\(\\log_a x\\) represents the exponent to which the base \\(a\\) must be raised in order to obtain \\(x\\). the number \\(a\\) is called the base of the logarithm, and \\(x\\) is called the argument of the expression. the argument of a logarithm must be a positive number. common logarithm base \\(10\\) logarithms are called common logarithms. the common logarithm of \\(x\\) is written \\(log x\\), where the base is understood to be \\(10\\). natural logarithm logarithms with base \\(e\\) are called natural logarithms. the natural logarithm of a positive number \\(x\\) is written \\(\\ln x\\). properties of logarithms for \\(a > 0\\), \\(a \\neq q\\), and any real number \\(k\\), the following hold. \\(log_a 1 = 0\\) \\(log_a a^k = k\\) \\(a^{\\log_a k} = k ,k > 0\\) product rule \\(\\log_a xy = \\log_a x + \\log_a y\\) quotient rule \\(\\log_a \\frac{x}{y} = \\log_a x - \\log_a y\\) power rule \\(\\log_a x^r = r\\log_a x\\) proofs property \\(1\\) is true because \\(a^0 = 1\\) for any nonzero value of \\(a\\). property \\(2\\) is verified by writing the equation in exponential form. by the definition of the logarithm, if \\(\\log_a a^k = k\\), then \\(a^k = a^k\\), which is true. property \\(3\\) is justified by the fact that \\(\\log_a k\\) is the value we have to raise \\(a\\) to obtain \\(k\\). if we raise \\(a\\) by \\(\\log_a k\\), then by the definition of the logarithm we obtain \\(k\\). the proof of property \\(4\\), the product rule, is as follows: let \\(m = \\log_a x\\) and \\(n = \\log_a y\\), then \\(a^m = x\\) and \\(a^n = y\\) by the definiton of a logarithm. if we multiply them: \\begin{align} a^m a^n = xy \\end{align} \\begin{align} a^{m + n} = xy \\end{align} by the definition of the logarithm: \\begin{align} \\log_a xy = m + n \\end{align} substituting \\(m = \\log_a x\\) and \\(n = \\log_a y\\) \\begin{align} \\log_a xy = \\log_a x + \\log_a y \\end{align} properties \\(5\\) and \\(6\\), the quotient and power rules, are proved in a similar way change-of-base rule for any positive real numbers \\(x\\), \\(a\\), and \\(b\\), where \\(a \\neq 1\\) and \\(b \\neq 1\\) \\begin{align} \\log_a x = \\frac{\\log_b x}{\\log_b a} \\end{align} let \\begin{align} y = \\log_a x \\end{align} by the definition of the logarithm: \\begin{align} a^y = x \\end{align} we apply the logarithm on both sides: \\begin{align} \\log_b a^y = \\log_b x \\end{align} by the power rule: \\begin{align} y \\log_b a = \\log_b x \\end{align} \\begin{align} y = \\frac{\\log_b x}{\\log_b a} \\end{align} substituting \\(y = \\log_a x\\) \\begin{align} \\log_a x = \\frac{\\log_b x}{\\log_b a} \\end{align} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/05_04.html",
    "title": "Logarithms Functions",
    "body": " index search search back logarithms functions contents logarithmic function graphs of logarithmic functions logarithmic function if \\(a > 0\\), \\(a \\neq 1\\), and \\(x > 0\\), then \\begin{align} f(x) = \\log_a x \\end{align} is the logarithmic function with base \\(a\\). the exponential function \\(f(x) = a^x\\), \\(a > 1\\), is increasing on its domain. if \\(0< a <1\\), the function is decreasing on its domain. thus, for all allowable bases \\(a\\), function \\(f\\) is one-to-one and has an inverse. we can find the rule for \\(f^{-1}\\) analytically: \\begin{align} f(x) = a^x \\end{align} \\begin{align} y = a^x \\end{align} \\begin{align} x = a^y \\end{align} by the definition of the logarithm: \\begin{align} y = \\log_a x \\end{align} \\begin{align} f^{-1}(x) = \\log_a x \\end{align} to confirm this, use properties of logarithms to show that \\((f \\circ f^{-1})(x) = x\\) and \\((f^{-1} \\circ f)(x) = x\\). \\begin{align} (f \\circ f^{-1})(x) = f(f^{-1}(x)) = a^{\\log_a x} = x \\end{align} \\begin{align} (f^{-1} \\circ f)(x) = f^{-1}(f(x)) = \\log_a a^x = x \\end{align} thus, the functions \\(f(x) = a^x\\) and \\(g(x) = log_a x\\) are inverse functions. graphs of logarithmic functions $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/05_05.html",
    "title": "Exponential and Logarithmic Equations and Inequalities",
    "body": " index search search back exponential and logarithmic equations and inequalities contents properties of logarithmic and exponential functions exponential equations and inequalities type 2 solving exponential and logarithmic equations properties of logarithmic and exponential functions for \\(b > 0\\) and \\(b \\neq 1\\): \\(b^x = b^y\\) if and only if \\(x = y\\). if \\(x > 0\\) and \\(y > 0\\), then \\(log_b x = log_b y\\) if and only if \\(x = y\\) exponential equations and inequalities (type 2) unlike a type 1 exponential equation (or inequality) a type 2 exponential equation (or inequality) is one in which the exponential expressions cannot easily be written as powers of the same base. for example: \\begin{align} 7^x = 12 \\end{align} solving exponential and logarithmic equations an exponential or logarithmic equation can be solved by changing the equation into one of the following forms, where \\(a\\) and \\(b\\) are real numbers, \\(a > 0\\), and \\(a \\neq 1\\). \\(a^{f(x)} = b\\): solve by taking a logarithm of each side. \\(\\log_a f(x) = \\log_a g(x)\\): the equation is satisfied when \\(f(x) = g(x)\\) \\(\\log_a f(x) = b\\): solve by changing to exponential form \\(f(x) = a^b\\) $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/05_06.html",
    "title": "Further Applications and Modeling with Exponential and Logarithmic Functions",
    "body": " index search search back further applications and modeling with exponential and logarithmic functions contents physical science applications physical science applications a function of the form: \\begin{align} a(t) = a_0 e^{kt} \\end{align} where \\(a_0\\) represent the initial quantity present, \\(t\\) represents the time elapsed, \\(k > 0\\) represents the growth constant is called an exponential growth function. a function of the form: \\begin{align} a(t) = a_0 e^{-kt} \\end{align} is an exponential decay function. if a quantity decays exponentially, the amount of time that it takes to reach onehalf its original amount is called the half-life. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/06_01.html",
    "title": "Systems of Equations",
    "body": " index search search back systems of equations contents linear systems substitution method substitution method nonlinear systems linear systems any equation of the form: \\begin{align} a_1 x_1 + a_2 x_2 + \\cdots + a_n x_n = b \\end{align} for real numbers \\(a_1, a_2, \\cdots, a_n\\) (not all zero) and \\(b\\) is a linear equation or a first-degree equation in \\(n\\) unknowns. a set of equations is called a system of equations. the solutions of a system of equations must satisfy every equation in the system. if all the equations in a system are linear, the system is a system of linear equations, or a linear system. there are three possible outcomes for the graph of a system of two linear equations in two variables: the graphs intersect at exactly one point, which gives the (single) ordered-pair solution of the system. the system is consistent and the equations are independent. (figure 1a) the graphs are parallel lines, so there is no solution and the solution set is \\(\\emptyset\\). the system is inconsistent and the equations are independent. see figure 1(b). the graphs are the same line, and there are infinitely many solutions. the system is consistent and the equations are dependent. see figure 1(c). substitution method in a system of two equations with two variables, the substitution method involves using one equation to find an expression for one variable in terms of the other, and then substituting this expression into the other equation of the system. substitution method another way to solve a system of two equations, the elimination method, uses multiplication and addition to eliminate a variable from one equation. systems that have the same solution set are called equivalent systems. the three transformations allowed are the following: interchange any two equations of the system. multiply or divide any equation of the system by a nonzero real number. replace any equation of the system by the sum of that equation and a multiple of another equation in the system. nonlinear systems a nonlinear system of equations is a system in which at least one of the equations is not a linear equation. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/11_07.html",
    "title": "Probability",
    "body": " index search search back probability contents basic concepts probability of event e complements and venn diagrams odds union of two events properties of probability binomial probability basic concepts given an experiment that has one or more outcomes that are equally likely to occur. then the set \\(s\\) of all possible outcomes of a given experiment is called the sample space for the experiment. for example, the sample space for the experiment of tossing a consists of the outcomes \\(h\\) (heads) and \\(t\\) (tails). this can be written in set notation as: \\begin{align} s = \\{h, t\\} \\end{align} any subset of the sample space is called an event. to represent the number of outcomes that belong to event \\(e\\) we use the notation \\(n(e)\\). the notation \\(p(e)\\) is used for the probability of an event \\(e\\). probability of event e in a sample space with equally likely outcomes, the probability of an event \\(e\\), written \\(p(e)\\) is given by: \\begin{align} p(e) = \\frac{n(e)}{n(s)} \\end{align} where \\(n(e)\\) is the number of outcomes in sample space \\(s\\) that belong to event \\(e\\), and \\(n(s)\\) is the total number of outcomes in sample space \\(s\\). complements and venn diagrams the set of all outcomes in the sample space that do not belong to event \\(e\\) is called the complement of \\(e\\), written \\(e'\\). by definition: \\begin{align} e \\cup e' = s \\end{align} \\begin{align} e \\cap e' = \\emptyset \\end{align} probability concepts can be illustrated using venn diagrams, as shown in figure 23. odds the odds in favor of an event \\(e\\) are expressed as the ratio of \\(p(e)\\) to \\(p(e')\\), or as the fraction \\(\\frac{p(e)}{p(e')}\\). if the odds favoring event \\(e\\) are \\(m\\) to \\(n\\), then: \\begin{align} p(e) = \\frac{m}{m + n} \\end{align} and \\begin{align} p(e') = \\frac{n}{m + n} \\end{align} union of two events two events \\(h\\) and \\(k\\) that cannot occur simultaneously are said to be mutually exclusive, therefore \\(h \\cap k = \\emptyset\\) is always true. this suggests the following proprety: for any events \\(e\\) and \\(f\\): \\begin{align} p(e \\text{ or } f) = p(e \\cup f) = p(e) + p(f) - p(e \\cap f) \\end{align} properties of probability for any events \\(e\\) and \\(f\\) the following hold: \\(0 \\leq p(e) \\leq 1\\) \\(p(\\text{a certain event}) = 1\\) \\(p(\\text{an impossible event}) = 0\\) \\(p(e') = 1 - p(e)\\) \\(p(e \\text{ or } f) = p(e \\cup f) = p(e) + p(f) - p(e \\cap f)\\) binomial probability an experiment that consists of repeated independent trials, which only has two outcomes (success and failure) is called a binomial experiment. let the probability of success in one trial be \\(p\\), such that the probability of failure becomes \\(1 - p\\). then the probability of \\(r\\) successes in \\(n\\) trials is: \\begin{align} \\binom{n}{r} p^r (1 - p)^r \\end{align} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/B.html",
    "title": "Vectors in Space",
    "body": " index search search back vectors in space contents rectangular coordinates in space distance formula vectors in space vector definitions and operations angle between two vectors direction angles in space rectangular coordinates in space on a three dimensional space, we associate each point with an ordered triple \\((x, y, z)\\) (see figure 1). the region of three-dimensional space where are coordinates are positive is called the first octant. there are eight octants in all. distance formula if \\(p_1(x_1, y_1, z_1)\\) and \\(p_2(x_2, y_2, z_2)\\) are two points in a three-dimensional coordinate system, then the distance between \\(p_1\\) and \\(p_2\\) is given by: \\begin{align} d(p_1, p_2) = \\sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2 + (z_2 - z_1)^2} \\end{align} vectors in space we denote a vector \\(\\textbf{v}\\) in space with initial point \\(o\\) at the origin as: \\begin{align} \\textbf{v} = \\langle a, b, c \\rangle \\end{align} using the unit vectors \\(\\textbf{i} = \\langle 1, 0, 0 \\rangle\\), \\(\\textbf{j} = \\langle 0, 1, 0 \\rangle\\) and \\(\\textbf{k} = \\langle 0, 0, 1 \\rangle\\), we can represent \\(\\textbf{v}\\) as: \\begin{align} \\textbf{v} = a\\textbf{i} + b \\textbf{j} + c \\textbf{k} \\end{align} where the scalars \\(a\\), \\(b\\) and \\(c\\) are the components of vector \\(\\textbf{v}\\). not all vectors are position vectors, and they are computed differently. for example, the component form of vector \\(\\textbf{pq}\\) is represented as follows: \\begin{align} \\textbf{pq} = \\langle x_2 - x_1, y_2 - y_1, z_2 - z_1 \\rangle \\end{align} as figure 2 suggests, \\(\\textbf{pq}\\) is equal to the following position vector: \\begin{align} \\textbf{or} = (x_2 - x_1)\\textbf{i} + (y_2 - y_1)\\textbf{j} + (z_2 - z_1)\\textbf{k} \\end{align} vector definitions and operations if \\(\\textbf{v} = a\\textbf{i} + b\\textbf{j} + c\\textbf{k}\\) and \\(\\textbf{w} = d\\textbf{i} + e \\textbf{j} + f\\textbf{k}\\) are vectors and \\(g\\) is a scalar, the following hold. \\(\\textbf{v} = \\textbf{w}\\) if and only if \\(a = d\\), \\(b = e\\) and \\(c = f\\). \\(\\textbf{v} + \\textbf{w} = (a + d)\\textbf{i} + (b + e)\\textbf{j} + (c + f)\\textbf{k}\\) \\(\\textbf{v} - \\textbf{w} = (a - d)\\textbf{i} + (b - e)\\textbf{j} + (c - f)\\textbf{k}\\) \\(g\\textbf{v} = ga \\textbf{i} + gb \\textbf{j} + gc \\textbf{k}\\) \\(|\\textbf{v}| = \\sqrt{a^2 + b^2 + c^2}\\) \\(\\textbf{v} \\cdot \\textbf{w} = ad + be + cf\\) angle between two vectors if \\(\\theta\\) is the angle between two nonzero vectors \\(\\textbf{v}\\) and \\(\\textbf{w}\\), where \\(0º \\leq \\theta \\leq 180º\\), then: \\begin{align} \\cos \\theta = \\frac{\\textbf{v} \\cdot \\textbf{w}}{|\\textbf{v}||\\textbf{w}|} \\end{align} direction angles in space in three dimensions, a vector is determined by its magnitude and three direction angles. as shown in figure 3: \\(\\alpha\\) is the direction angle between \\(\\textbf{v}\\) and the positive \\(x\\)-axis \\(\\beta\\) is the direction angle between \\(\\textbf{v}\\) and the positive \\(y\\)-axis \\(\\gamma\\) is the direction angle between \\(\\textbf{v}\\) and the positive \\(z\\)-axis we can evaluate these angles using the expression for the cosine of the angle between two vectors. note that \\(\\textbf{i} = \\langle 1, 0, 0 \\rangle\\), \\(\\textbf{j} = \\langle 0, 1, 0 \\rangle\\) and \\(\\textbf{k} = \\langle 0, 0, 1 \\rangle\\), where each one has magnitude \\(1\\). for \\(\\textbf{v} = a\\textbf{i} + b \\textbf{j} + c\\textbf{k}\\): \\begin{align} \\cos \\alpha = \\frac{\\textbf{v} \\cdot \\textbf{i}}{|\\textbf{v}||\\textbf{i}|} = \\frac{a}{|\\textbf{v}|} \\end{align} \\begin{align} \\cos \\beta = \\frac{\\textbf{v} \\cdot \\textbf{j}}{|\\textbf{v}||\\textbf{j}|} = \\frac{b}{|\\textbf{v}|} \\end{align} \\begin{align} \\cos \\gamma = \\frac{\\textbf{v} \\cdot \\textbf{k}}{|\\textbf{v}||\\textbf{k}|} = \\frac{c}{|\\textbf{v}|} \\end{align} these quantities, \\(\\cos \\alpha\\), \\(\\cos \\beta\\) and \\(\\cos \\gamma\\) are called direction cosines. and they satisfy: \\begin{align} \\cos^2 \\alpha + \\cos^2 \\beta + \\cos^2 \\gamma = 1 \\end{align} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/C.html",
    "title": "Polar Form of Conic Sections",
    "body": " index search search back polar form of conic sections contents polar forms of conic sections polar forms of conic sections a polar equation of the form: \\begin{align} r = \\frac{ep}{1 \\pm e \\cos \\theta} \\end{align} or \\begin{align} r = \\frac{ep}{1 \\pm e \\sin \\theta} \\end{align} has a conic section as its graph. the eccentricity is \\(e\\) (where \\(e > 0\\)), and \\(|p|\\) is the distance between the pole (focus) and the directrix. we can verify that those equations satisfy the definition of a conic section. consider figure 1, where the directrix is vertical and \\(p > 0\\) units to the right of the focus \\(f(0, 0º)\\). let \\(p(r, \\theta)\\) be a point on the graph, then the distance between \\(p\\) and the directrix is obtained as: \\begin{align} pp' = |p - x| \\end{align} \\begin{align} = |p - r \\cos \\theta| \\end{align} we substitute \\(r\\) by \\(\\frac{ep}{1 \\pm e \\cos \\theta}\\). \\begin{align} = |p - \\left(\\frac{ep}{1 \\pm e \\cos \\theta} \\right) \\cos \\theta| \\end{align} \\begin{align} = |\\frac{(1 + e \\cos \\theta) - ep\\cos \\theta}{1 \\pm e \\cos \\theta} | \\end{align} \\begin{align} = |\\frac{p + ep \\cos \\theta - ep\\cos \\theta}{1 \\pm e \\cos \\theta}| \\end{align} \\begin{align} = |\\frac{p}{1 \\pm e \\cos \\theta}| \\end{align} given: \\begin{align} r = \\frac{ep}{1 \\pm e \\cos \\theta} \\end{align} then we can multiply each side by \\(\\frac{1}{e}\\) \\begin{align} \\frac{r}{e} = \\frac{p}{1 \\pm e \\cos \\theta} \\end{align} we substitute this expression for \\(\\frac{r}{e}\\): \\begin{align} pp' = |\\frac{p}{1 \\pm e \\cos \\theta}| = |\\frac{r}{e}| = \\frac{|r|}{|e|} = \\frac{|r|}{e} \\end{align} note that \\(e > 0\\), therefore \\(|e| = e\\). the distance between the pole and \\(p\\) is \\(pf = |r|\\), so the ratio of \\(pf\\) to \\(pp'\\) is: \\begin{align} \\frac{pf}{pp'} = \\frac{|r|}{\\frac{|r|}{e}} = e \\end{align} thus, by definition, the graph has eccentricity \\(e\\) and must be a conic. in the previous discussion, we assumed a vertical directrix to the right of the pole. there a re three other possible situations: equation directrix \\(r = \\frac{ep}{1 + e \\cos \\theta}\\) vertical, \\(p\\) units to the right of the pole \\(r = \\frac{ep}{1 - e \\cos \\theta}\\) vertical, \\(p\\) units to the left of the pole \\(r = \\frac{ep}{1 + e \\sin \\theta}\\) horizontal, \\(p\\) units above the pole \\(r = \\frac{ep}{1 - e \\sin \\theta}\\) horizontal, \\(p\\) units below the pole $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Music/index.html",
    "title": "Music",
    "body": " index search search back music basic adult piano course $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/D.html",
    "title": "Rotation of Axes",
    "body": " index search search back rotation of axes contents derivation of rotation equations angle of rotation equations of conics with xy-term derivation of rotation equations given a \\(xy\\)-coordinate system having origin \\(o\\). if we rotate the axes about \\(o\\) through an angle \\(\\theta\\), the new coordinate system is called a rotation of the \\(xy\\)-system. let \\(p\\) be any point other than the origin, with coordinates \\((x, y)\\) in the \\(xy\\)-system and \\((x', y')\\) in the \\(x'y'\\)-system (see figure 1). let \\(op = r\\) and \\(\\alpha\\) be the angle made by \\(op\\) and the \\(x'\\) axis. then the following holds: \\begin{align} \\cos (\\theta + \\alpha) = \\frac{oa}{r} = \\frac{x}{r} \\end{align} \\begin{align} \\sin (\\theta + \\alpha) = \\frac{ap}{r} = \\frac{y}{r} \\end{align} \\begin{align} \\cos (\\alpha) = \\frac{ob}{r} = \\frac{x'}{r} \\end{align} \\begin{align} \\sin (\\alpha) = \\frac{pb}{r} = \\frac{y'}{r} \\end{align} such that we can rewrite the statements as follows: \\begin{align} x = r \\cos (\\theta + \\alpha) \\end{align} \\begin{align} y = r \\sin (\\theta + \\alpha) \\end{align} \\begin{align} x' = r \\cos \\alpha \\end{align} \\begin{align} y' = r \\sin \\alpha \\end{align} therefore: \\begin{align} x = r \\cos (\\theta + \\alpha) \\end{align} \\begin{align} = r (\\cos\\theta \\cos\\alpha - \\sin\\theta \\sin \\alpha) \\end{align} \\begin{align} = \\cos\\theta (r\\cos\\alpha) - \\sin\\theta (r\\sin \\alpha) \\end{align} \\begin{align} = \\cos\\theta x' - \\sin\\theta y' \\end{align} the same goes for \\(y\\) \\begin{align} y = r \\sin (\\theta + \\alpha) \\end{align} \\begin{align} = r (\\sin\\theta \\cos\\alpha + \\cos\\theta \\sin \\alpha) \\end{align} \\begin{align} = \\sin\\theta (r\\cos\\alpha) + \\cos\\theta (r\\sin \\alpha) \\end{align} \\begin{align} = \\sin\\theta x' + \\cos\\theta y' \\end{align} angle of rotation the \\(xy\\)-term is removed from the standard equation: \\begin{align} ax^2 + bxy + cy^2 + dx + ey + f = 0 \\end{align} by a rotation of the axes through an angle \\(\\theta\\), \\(0º < \\theta < 90º\\), where: \\begin{align} \\cot 2\\theta = \\frac{a - c}{b} \\end{align} equations of conics with xy-term if the standard second-degree equation: \\begin{align} ax^2 + bxy + cy^2 + dx + ey + f = 0 \\end{align} has a graph, it will be one of the following: a circle or an ellipse (or a point) if \\(b^2 - 4ac < 0\\) a parabola (or one line or two parallel lines) if \\(b^2 - 4ac = 0\\) a hyperbola (or two intersecting lines) if \\(b^2 - 4ac > 0\\) a straight line if \\(a = b = c = 0\\) and \\(d \\neq 0\\) or \\(e \\neq 0\\) $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/3C_1C/ICPDM/index.html",
    "title": "Infraestructuras Computacionales para Procesamiento de Datos Masivos",
    "body": " index search search back infraestructuras computacionales para procesamiento de datos masivos módulo 1 tema 1. introducción a big data tema 2. el núcleo de hadoop tema 3. programación mapreduce tema 4. inyección extracción y serialización/deserialización de los datos módulo 2 tema 1. introducción a apache spark tema 2. programación en aplicaciones spark tema 3. librerías/componentes de spark tema 4. configuración, monitorización y optimización de spark módulo 3 tema 1. introducción a las arquitecturas de procesamiento de streams: lambda y kappa tema 2. componentes tecnológicos de adquisición y transmisión/distribución de eventos: kafka tema 3. procesamiento de streams: apache spark streaming $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/CG/RTGW/06.html",
    "title": "Colors, Depth Testing, and Alpha Blending",
    "body": " index search search back colors, depth testing, and alpha blending contents using colors in weblgl using colors in objects constant coloring per-vertex coloring per-fragment coloring use of color in lights scalability problem how many uniforms can we use simplifying the problem using uniform arrays to handle multiple lights directional point lights attenuation factor use of color in the scene transparency updated rendering pipeline depth testing depth function alpha blending the blending function separate blending functions the blend equation webgl alpha-blending api the blend color alpha blending modes additive blending substractive blending multiplicative blending interpolative blending creating transparent objects using colors in weblgl webgl supplies a fourth attribute to the rgb model. this attribute is called the alpha channel. the extended model then is known as the rgba model, where a stands for alpha. the alpha channel contains a value between the range of \\(0.0\\) to \\(1.0\\). a completely opaque color will have an alpha value of \\(1.0\\), whereas a completely transparent color will have an alpha value of \\(0.0\\). this is the general case, but as we will see, we need to take other factors into account when we obtain translucent colors. using colors in objects constant coloring to obtain a constant color, we store the desired color in a uniform that is passed to the fragment shader. this uniform is usually called the object's diffuse material property. we can also combine object normals and light-source information to obtain a lambert coefficient. we can use the lambert coefficient to proportionally change the reflecting color depending on the angle on which the light hits the object. per-vertex coloring to implement per-vertex coloring, we need to define an attribute that stores the color for the vertex in the vertex shader: in vec4 avertexcolor; the next step is to assign the avertexcolor attribute to a varying so that it can be passed to the fragment shader. remember that varyings are automatically interpolated. therefore, each fragment will have a color that is the weighted result of its contributing vertices. if we want our color map to be sensitive to lighting conditions, we can multiply each vertex color by the diffuse component of the light. the result is then assigned to the varying that will transfer the result to the fragment shader. per-fragment coloring we can also assign a random color to each pixel of the object we are rendering. use of color in lights scalability problem given the desire to use more than one light in our scene, we need to define and map the number of appropriate uniforms of the lighting model of choice. if we have four properties per light (ambient, diffuse, specular, and location), we need to define four uniforms for each light. if we want to have three lights, we need to write, use, and map twelve uniforms! we need to resolve this complexity before it gets out of hand. how many uniforms can we use to find out the limit for your webgl implementation, you can query webgl using the gl.getparameter function with these constants: gl.max_vertex_uniform_vectors gl.max_fragment_uniform_vectors simplifying the problem in order to simplify the problem, we can assume that the ambient component is the same for all of the lights. this will reduce the number of uniforms—one fewer uniform for each light. using uniform arrays to handle multiple lights as we've seen, handling light properties with individual uniforms makes the code verbose and difficult to maintain. fortunately, essl provides several mechanisms we can use to solve the problem of handling multiple lights. one of them is uniform arrays. this technique allows us to handle multiple lights by introducing enumerable arrays of vectors in the shaders. this allows us to calculate light contributions by iterating through the light arrays in the shaders. uniform vec3 upositionlight[3]; it’s important to note that essl does not support dynamic initialization of uniform arrays. we could try something such as this, but will not work: uniform int numlights; uniform vec3 upositionlight[numlights]; however, this construct is valid: const int numlights = 3; uniform vec3 upositionlight[numlights]; to map these variables on javascript: const lightposition1 = [0, 7, 3]; const lightposition2 = [2.5, 3, 3]; const lightposition3 = [-2.5, 3, 3]; const location = gl.getuniformlocation(program, 'upositionlight'); // the values are concatenated on a single flat array gl.uniform3fv(location, [...lightposition1, ...lightposition2, ...lightposition3]); directional point lights in this section, we will combine directional and positional lights creating a directional point light, commonly referred to as a spot light. the trick to creating these lights is to subtract the light-direction vector from the normal for each vertex. the resulting vector will create a different lambert coefficient that will reflect into the cone generated by the light source. on the following excerpts we show a practical example of how a sportlight could be implemented. on the first place we have the vertex shader whose responsability it is to compute: the rays, vray, for each light source. this is the vector between the position of the light and the position of the vertex (after is has been transformed by the model view). the \"modified\" normal, vtransformednormals. this stores the normals after the ligth direction vector has been substracted from it. we will use both of these vectors to compute the lambert term on the fragment shader. #version 300 es const int numlights = 3; uniform mat4 umodelviewmatrix; uniform mat4 unormalmatrix; uniform mat4 uprojectionmatrix; uniform vec3 ulightpositions[numlights]; uniform vec3 ulightdirections[numlights]; in vec3 apos; in vec3 anormal; out vec3 vray[numlights]; out vec3 vtransformednormals[numlights]; void main(void) { vec4 vertex = umodelviewmatrix * vec4(apos, 1.0); vec3 normal = vec3(unormalmatrix * vec4(anormal, 1.0)); // iterate over each light for(int i = 0; i < numlights; i++) { // define each ray as the vector berween the light and the vertex vec4 lightposition = umodelviewmatrix * vec4(ulightpositions[i], 1.0); vray[i] = vertex.xyz - lightposition.xyz; // transform the direction of the light vec3 directionlight = vec3(unormalmatrix * vec4(ulightdirections[i], 1.0)); // transform the normal by substracting the direction of each light vtransformednormals[i] = normal - directionlight; } gl_position = uprojectionmatrix * vertex; } here we have the fragment shader where we compute the final color. this color is made up from two main sources: ambient light diffuse light: these light is computed taking into account a number of lights given numlights. for each one we incrementally modify the final diffuse light, id. note that for each of these diffuse lights we apply the lambertian reflection model, where we compute the final color as the product of the color of the light, the color of the material and finally the cosine of the angle between the light source (vray) and the normal of the surface (that is the lamberterm). in this case, instead of the normal of the surface we use our transformed normal, vtransformednormals. #version 300 es precision mediump float; const int numlights = 3; uniform vec4 ulightcolors[numlights]; uniform vec4 umaterialambient; uniform vec4 umaterialdiffuse; uniform vec4 ulightambient; uniform float ulightcutoff; in vec3 vray[numlights]; in vec3 vtransformednormals[numlights]; out vec4 fragcolor; void main(void) { vec4 ia = ulightambient * umaterialambient; vec4 id = vec4(0.0); // iterate over each light for(int i = 0; i < numlights; i++) { // define the normalized transformed normal per each light, as we // have modified the surface normal with the light's direction vec3 n = normalize(vtransformednormals[i]); vec3 l = normalize(vray[i]); // cosine of angle between light and surface float lambertterm = dot(n, -l); // if cosine is bigger than cutoff (the angle is less than an implicit // threhsold imposed but that cutoff) then we update the // sum of the diffuse color if (lambertterm > ulightcutoff) { id += ulightcolors[i] * umaterialdiffuse * lambertterm; } } fragcolor = vec4(vec3(ia + id), 1.0); } one other thing to note is the ulightcutoff. this variable allows us to create a spotlight, it basically defines the minimum value of the cosine of the angle between the light source and the normal. this cosine is maximized when the light is perpendicular to the surface, and minimized when the light is perpendicular. so with the ulightcutoff we are kind of saying what is the maximum angle we allow between the light and the surface. attenuation factor however we can use this threshold as the variable to define an attenuation. for example by computing the final color as follows: if (lambertterm > ulightcutoff) { id += ulightcolors[i] * umaterialdiffuse * pow(lamberterm, 10.0 * ulightcutoff); } so now the effect of lamberterm is not as straight forward, and it does not increasig \"linearly\" but by the means of a power function: \\[ f(x) = \\text{lambert term}^{10 \\text{cutoff}} \\] this is illustrated of the following figure: use of color in the scene transparency the first approach to render transparent objects is to use polygon stippling. this technique consists of discarding some fragments so that you can see through the object. opengl supports polygon stippling through the glpolygonstipple function. this function is not available in webgl. you could try to replicate this functionality by dropping some fragments in the fragment shader using the essl discard command. more commonly, we can use the alpha channel information to obtain translucent objects. however, modifying the alpha values does not produce transparency automatically. creating transparency corresponds to altering the fragments that we’ve already written to the framebuffer. on a scene where there is one translucent object in front of an opaque object (from our camera view) we need to be able to see the opaque object through the translucent object. therefore, the fragments that overlap between the far and near objects need to be combined somehow to create the transparency effect. to properly render transparent surfaces, we need to learn about two important webgl concepts: depth testing and alpha blending. updated rendering pipeline depth testing and alpha blending are two optional stages for fragments once they've been processed by the fragment shader. if the depth test is not activated, all the fragments are automatically available for alpha blending. if the depth test is enabled, those fragments that fail the test will automatically be discarded by the pipeline and will no longer be available for any other operation. this means that discarded fragments will not be rendered. the following diagram shows the order in which depth testing and alpha blending are performed: depth testing each fragment that has been processed by the fragment shader carries an associated depth value. though fragments are two-dimensional since they're rendered on the screen, the depth value keeps the information of how far the fragment is from the camera (screen). depth values are stored in a special webgl buffer named depth buffer or z-buffer. the \\(z\\) comes from the fact that \\(x\\) and \\(y\\) values correspond to the screen coordinates of the fragment, while the \\(z\\) value measures distance perpendicular to the screen. after the fragment has been calculated by the fragment shader, it becomes available for depth testing. this only occurs if the depth test is enabled. gl.enable(gl.depth_test); the depth test takes the depth value of a fragment into consideration and compares it to the depth value for the same fragment coordinates already stored in the depth buffer. the depth test determines whether that fragment is accepted for further processing in the rendering pipeline. in normal circumstances, when the depth test is enabled, only those fragments with a lower depth value than the corresponding fragments present in the depth buffer will be accepted. depth testing is a commutative operation with respect to the rendering order. this means that no matter which object gets rendered first, as long as depth testing is enabled, we will always have a consistent scene. depth function in some applications, we may be interested in changing the default behavior of depth testing, which discards fragments with a higher depth value than those fragments in the depth buffer. for that purpose, webgl provides the gl.depthfunc(function) method. this method has only one parameter, the function to use: parameter description gl.never the depth test always fails. gl.less only fragments with a depth lower than current fragments on the depth buffer will pass the test gl.lequal fragments with a depth less than or equal to corresponding current fragments in the depth buffer will pass the test. gl.equal only fragments with the same depth as current fragments on the depth buffer will pass the test gl.notequal only fragments that do not have the same depth value as fragments on the depth buffer will pass the test. gl.gequal fragments with greater or equal depth value will pass the test. gl.greater only fragments with a greater depth value will pass the test. gl.always the depth test always passes. the depth test is disabled by default in webgl. when enabled, if no depth function is set, the gl.less function is selected by default. alpha blending alpha blending is enabled using the following line of code: gl.enable(gl.blend); for each available fragment, the alpha blending operation reads the color from the framebuffer by the appropriate fragment coordinates and creates a new color based on a linear interpolation between the previously calculated color in the fragment shader and the color from the framebuffer. the blending function with blending enabled, the next step is to define a blending function. this function will determine how fragment colors from the object (source) are combined with the fragment colors present in the framebuffer (destination). we combine source and destination colors as follows: color = s * sw + d * dw; where: s: source color (vec4) d: destination color (vec4) sw: source scaling factor dw: destination scaling factor s.rgb: rgb components of the source color s.a: alpha component of the source color d.rgb: rgb components of the destination color d.a: alpha component of the destination color it's important to note that the rendering order will determine the source and the destination fragments. if a sphere is rendered first, it will then become the destination of the blending operation because the sphere fragments are stored in the framebuffer at the time that the cone is rendered. in other words, alpha blending is a non-commutative operation with respect to rendering order: separate blending functions it is also possible to determine how the rgb channels are going to be combined independently from the alpha channels. for that, we use the gl.blendfuncseparate function. we define two independent functions this way: color = s.rgb * sw.rgb + d.rgb * dw.rgb; alpha = s.a * sw.a + d.a * dw.a; more precisely: s.rgb: rgb components of the source color sw.rgb: is the source scaling factor (only rgb) s.a: alpha component of the source color sw.a: is the source scaling factor for the source alpha value d.rgb: rgb components of the destination color sw.rgb: is the destination scaling factor (only rgb) d.a: alpha component of the destination color sd.a: is the source scaling factor for the destination alpha value then, we could have something such as the following: color = s.rgb * s.a + d.rgb * (1.0 - s.a); alpha = s.a * 1.0 + d.a * 0.0; this would be translated into code as follows: gl.blendfuncseparate(gl.src_alpha, gl.one_minus_src_alpha, gl.one, gl.zero); the blend equation we could have a case where we do not want to interpolate the source and destination fragment colors with scale or add operations. for example, we may want to subtract one from the other. in this case, webgl provides the gl.blendequation function. this function receives one parameter that determines the operation on the scaled source and destination fragment colors. for example, gl.blendequation(gl.func_add) is calculated as such: color = s * sw + d * dw; and, gl.blendequation(gl.func_subtract) corresponds to the following: color = s * sw - d * dw; there is a third option, gl.blendequation(gl.func_reverse_subtract), that corresponds to the following: color = d* dw - s * sw; as expected, you can define the blending equation separately for the rgb channels and for the alpha channel. for that, we use the gl.blendequationseparate function. webgl alpha-blending api webgl function description gl.enable/disable(gl.blend) enable/disable blending gl.blendfunc(sw, dw) specify pixel arithmetic gl.blendfuncseparate(sw_rgb, dw_rgb, sw_a, dw_a) specify pixel arithmetic for rgb and alpha components separately gl.blendequation(mode) specify the equation used for both the rgb blend equation and the alpha blend equation gl.blendequationseparate(modergb, modealpha) set the rgb blend equation and the alpha blend equation separately. gl.blendcolor(red, green, blue, alpha) set the blend color. gl.getparameter(name) just like with other webgl variables, it is possible to query blending parameters using gl.getparameter. the blend color webgl provides the gl.constant_color and gl.one_minus_constant_color scaling factors. these scaling factors can be used with gl.blendfunc and gl.blendfuncseparate. however, we need to first establish the blend color. we do so by invoking gl.blendcolor. alpha blending modes depending on the parameter selection for sw and dw, we can create different blending modes. additive blending additive blending simply adds the colors of the source and destination fragments, creating a lighter image. we obtain additive blending by writing the following: gl.blendfunc(gl.one, gl.one); this assigns the weights for source and destination fragments sw and dw to \\(1\\). the color output will be as follows: color = s * 1.0 + d * 1.0; color = s + d; substractive blending similarly, we can obtain subtractive blending by writing the following: gl.blendequation(gl.func_subtract); gl.blendfunc(gl.one, gl.one); this will change the blending equation to the following: color = s * 1.0 - d * 1.0; color = s - d; multiplicative blending we obtain multiplicative blending by writing the following: gl.blendfunc(gl.dst_color, gl.zero); this will be reflected in the blending equation as the following: color = s * d + d * 0.0; color = s * d; the result will always be a darker blending interpolative blending if we set sw to s.a and dw to 1 - s.a, then we get the following: color = s * s.a + d *(1 - s.a); this will create a linear interpolation between the source and destination color using the source alpha color, s.a, as the scaling factor. in code, this is translated as the following: gl.blendfunc(gl.src_alpha, gl.one_minus_src_alpha); interpolative blending allows us to create a transparency effect as long as the destination fragments have passed the depth test. as expected, this requires that the objects be rendered from back to front. creating transparent objects we've learned that in order to create transparency, we need to: enable alpha blending and select the interpolative blending function render the faces of objects back to front how do we create transparent objects when there is nothing to blend them against? in other words, if there’s only one object, how can we make it transparent? one solution is to use face-culling. face-culling allows us to only render the back or front face of an object. similar to other options in the pipeline, culling is disabled by default. we enable it by calling the following: gl.enable(gl.face_culling); to render only the back faces of an object, we call gl.cullface(gl.front) before we call drawarrays or drawelements. similarly, to render only the front face, we use gl.cullface(gl.back) before the draw call. the following diagram summarizes the steps needed to create a transparent object with alpha blending and face-culling: $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Calculus/CET/01_01.html",
    "title": "Four Ways to Represent a Function",
    "body": " index search search back four ways to represent a function contents representation of functions functions arise whenever one quantity depends on another. a symbol that represents an arbitrary number in the domain of a function \\(f\\) is called an independent variable. a symbol that represents a number in the range of f is called a dependent variable. one way to visualize a function is to think of it as a machine (see figure 2). another way to picture a function is by an arrow diagram as in figure 3. perhaps the most useful method for visualizing a function is its graph (see figure 4). if \\(f\\) is a function with domain \\(d\\), then its graph is the set of ordered pairs \\begin{align} \\{(x, f(x)) | x \\in d\\} \\end{align} representation of functions we consider four different ways to represent a function: verbally: by a description in words. numerically: by a table of values. visually: by a graph. algebraically: by an explicit formula. a function with an explicit formula that approximates the behavior of a given \"true\" function its called a mathematical model. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Calculus/CET/index.html",
    "title": "Calculus Ealy Transcendentals",
    "body": " index search search back calculus ealy transcendentals functions and models four ways to represent a function mathematical models: a catalog of essential functions new functions from old functions exponential functions inverse functions and logarithms limits and derivatives the tangent and velocity problems the limit of a function calculating limits using the limits laws the precise definition of a limit continuity limits at infinity. horizontal asymptotes derivatives and rates of change the derivative as a function $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Calculus/CET/01_02.html",
    "title": "Mathematical Models: A Catalog of Essential Functions",
    "body": " index search search back mathematical models: a catalog of essential functions contents mathematical model algebraic function faimilies of essential functions and their graphs mathematical model a mathematical model is a mathematical description (generally by the means of a function or an equation) of a real-world phenomenon. its purpose is to understan the phenomenon and perhaps make predictions about future behaviour. the process of mathematical modeling is a follows: formulate a mathematical model by identifying the independent and dependent variables and making assumptions that simplify the phenomenon. apply the mathematics that we know to derive mathematical conclusions. take those mathematics conclusions and interpret them as information about the original real-world phenomenon. test our predictions against real-world data. this process is illustrated on the following figure. if there is no physical law or principle to help us formulate a model, we construct an empirical model that is a model that captures the basic trend of the data points. algebraic function a function \\(f\\) is an algebraic function if it can be constructed using algebraic operations (such as addition, substraction, multiplication, division and taking roots). functions that are not algebraic are called transcendental, these include trigonometric, exponential and logarithmic functions. faimilies of essential functions and their graphs on the following table we show a summary of graphs of some families of essential functions. function form graph linear function \\(f(x) = mx + b\\) power function \\(f(x) = x^n\\) root function \\(f(x) = \\sqrt[n]{x}\\) reciprocal function \\(f(x) = \\frac{1}{\\sqrt[n]{x}}\\) exponential function \\(f(x) = b^x\\) logarithmic function \\(f(x) = \\log_b x\\) trigonimetric functions \\(f(x) = \\sin x\\) trigonimetric functions \\(f(x) = \\cos x\\) trigonimetric functions \\(f(x) = \\tan x\\) $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Calculus/CET/01_03.html",
    "title": "New Functions from Old Functions",
    "body": " index search search back new functions from old functions see the following for the theory on function transformations: vertical and horizontal shifts of graphs stretching, shrinking and reflecting graphs and for more information on operations and composition. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Calculus/CET/01_04.html",
    "title": "Exponential Functions",
    "body": " index search search back exponential functions contents the number e the definition of an exponential function. the number e figures 12 and 13 show the tangent lines to the graphs of \\(y = 2^x\\) and \\(y = 3^x\\) at the point \\((0, 1)\\). the slopes for these tangent lines are \\(m \\approx 0.7\\) and \\(m \\approx 1.1\\) respectively. some formulas of calculus will be simplified if we choose the base \\(b\\) so that the slope of the tangent line to \\(y = b^x\\) at \\((0, 1)\\) is exactly \\(1\\) (see figure 14). such a base is denoted by the letter \\(e\\). this notation was chosen by the swiss mathematician leonhard euler in 1727. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Calculus/CET/01_05.html",
    "title": "Inverse Functions and Logarithms",
    "body": " index search search back inverse functions and logarithms contents inverse functions cancellation equations graphing the inverse logarithmic functions natural logarithms inverse trigonometric functions inverse sine function inverse cosine function inverse tangent function other inverse functions inverse functions we know that a function is one-to-one graphically by applying the horizontal line test. any function \\(f\\) has an inverse if and only if \\(f\\) is one-to-one. cancellation equations given a function \\(f: a \\rightarrow b\\) whose inverse \\(f^{-1}\\) exists, then its cancellation equations are defined as follows: \\begin{align} f^{-1}(f(x)) = x, \\forall x \\in a \\end{align} \\begin{align} f(f^{-1}(x)) = x, \\forall x \\in b \\end{align} on the first cancellation equation \\(f^{-1}\\) undoes what \\(f\\) does, and viceversa for the second equation. graphing the inverse the process of finding the inverse gives us a method for obtaining the graph of \\(f^{-1}\\) from the graph of \\(f\\). since \\(f(a) = b\\) if and only if \\(f^{-1}(b) = a\\) then the point \\((a, b)\\) is on the graph of \\(f\\) if and only if the point \\((b, a)\\) is on the graph \\(f^{-1}\\). but we get the point \\((b, a)\\) from \\((a, b)\\) by reflecting about the line \\(y = x\\) (see figure 8). so the graph of \\(f^{-1}\\) is obtained by reflecting the graph of \\(f\\) about the line \\(y = x\\). logarithmic functions if \\(b > 0\\) and \\(b \\neq 1\\) then the exponential function \\(f(x) = b^x\\) is either increasing or decreasing, and so it is one-to-one. therefore its inverse exists and is called the logarithmic function with base \\(b\\): \\begin{align} \\log_b x = y \\leftrightarrow b^y = x \\end{align} if we apply the cancellation equations we obtain: \\begin{align} \\log_b(b^x) = x, \\forall x \\in \\mathbb{r} \\end{align} \\begin{align} b^{\\log_b x} = x, \\forall x > 0 \\end{align} the logarithmic function has domain \\((0, \\infty)\\) and range \\(\\mathbb{r}\\). its graph is the reflection of the graph of \\(y = b^x\\) about the line \\(y = x\\) (see figure 11). natural logarithms the logarithm with base \\(e\\) is called the natural logarithm and is denoted as: \\begin{align} \\log_e x = \\ln x \\end{align} if we apply the cancellation equations we obtain: \\begin{align} \\ln(e^x) = x, x \\in \\mathbb{r} \\end{align} \\begin{align} e^{\\ln x} = x, x > 0 \\end{align} in particular if we set \\(x = 1\\) we get: \\begin{align} \\ln e = 1 \\end{align} therefore: \\begin{align} x^r = \\left(e^{\\ln(x)}\\right)^r = e^{r \\ln(x)} \\end{align} inverse trigonometric functions trigonometric functions are not one-to-one, as their are periodic function. however if their domain to an interval that \"lats\" one period of the function then it is one-to-on. inverse sine function the inverse of the sine function is denoted by \\(\\sin^{-1}\\) or \\(\\arcsin\\), and it is defined as: \\begin{align} \\sin^{-1}(x) = y \\leftrightarrow \\sin y = x, -\\frac{\\pi}{2} \\leq y \\leq \\frac{\\pi}{2} \\end{align} as you can see the domain has been restricted to \\([-\\frac{\\pi}{2}, \\frac{-pi}{2}]\\) (see figure 18). by the cancellation equations we obtain: \\begin{align} \\sin^{-1}(\\sin x) = x, -\\frac{\\pi}{2} \\leq x \\leq \\frac{\\pi}{2} \\end{align} \\begin{align} \\sin(\\sin^{-1} x) = x, -1 \\leq x \\leq 1 \\end{align} the inverse sine function has domain \\([-1, 1]\\) and range \\([-\\frac{\\pi}{2}, \\frac{\\pi}{2}]\\) and its graph is shown on figure 20. inverse cosine function the inverse of the cosine function is denoted by \\(\\cos^{-1}\\) or \\(\\arccos\\), and it is defined as: \\begin{align} \\cos^{-1}(x) = y \\leftrightarrow \\cos y = x, 0 \\leq y \\leq \\pi \\end{align} as you can see the domain has been restricted to \\([0, \\pi]\\) (see figure 21). by the cancellation equations we obtain: \\begin{align} \\cos^{-1}(\\cos x) = x, 0 \\leq x \\leq \\pi \\end{align} \\begin{align} \\cos(\\cos^{-1} x) = x, -1 \\leq x \\leq 1 \\end{align} the inverse cosine function has domain \\([-1, 1]\\) and range \\([0, \\pi]\\) and its graph is shown on figure 22. inverse tangent function the inverse of the tangent function is denoted by \\(\\tan^{-1}\\) or \\(\\arctan\\), and it is defined as: \\begin{align} \\tan^{-1}(x) = y \\leftrightarrow \\tan y = x, -\\frac{\\pi}{2} \\leq y \\leq \\frac{\\pi}{2} \\end{align} as you can see the domain has been restricted to \\([-\\frac{\\pi}{2}, \\frac{\\pi}{2}]\\) (see figure 23). by the cancellation equations we obtain: \\begin{align} \\tan^{-1}(\\tan x) = x, -\\frac{\\pi}{2} \\leq x \\leq \\frac{\\pi}{2} \\end{align} \\begin{align} \\tan(\\tan^{-1} x) = x, -1 \\leq x \\leq 1 \\end{align} the inverse tangent function has domain \\([-1, 1]\\) and range \\([-\\frac{\\pi}{2}, \\frac{\\pi}{2}]\\) and its graph is shown on figure 25. we know that the lines \\(x = \\pm \\frac{\\pi}{2}\\) are vertical asymptotes of the graph of the tangent function. since the graph of \\(\\tan^{-1}\\) is obtained by reflecting the graph of the restricted tangnet function about the line \\(y = x\\), the the lines \\(y = \\frac{\\pi}{2}\\) and \\(y = -\\frac{\\pi}{2}\\) are horizontal asymptotes of the graph of \\(\\tan^{-1}\\). other inverse functions see for information about the remaning inverse trigonometric functions. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Music/ABPCI/01_notation.html",
    "title": "Notation",
    "body": " index search search back notation contents quarter notes and half notes the whole note eighth notes time signature dynamic signs tied notes dotted half note dotted quarter notes the grand staff slur and legato playing incomplete measure the sharp sign the flat sign staccato half step whole step syncopated notes natural sign accent sign overlapping pedal eighth note triplets quarter notes and half notes music is made up of short and long tones, which are writter with notes. a quarter note is written as follows: this note has a count of \\(1\\). a half note is written as follows: this note has a count of \\(2\\). the whole note a whole note is written as follows: this noe has a count of \\(4\\). eighth notes two eighth notes are played in the time of one quarter note. time signature music has numbers at the beginning of a score called the time signature. where the upper \\(4\\) means \\(4\\) beats per measure and the lower \\(4\\) means that a quarter note get one beat. dynamic signs the signs that tell up how loud or soft to play are called dynamic signs. for example: a \\(\\textit{p (piano)}\\) tells us to play soft. a \\(\\textit{mf (mezzoforte)}\\) tells us to moderately loud. a \\(\\textit{f (forte)}\\) tells us to play loud. a \\(\\textit{ff (fortissimo)}\\) tells us to play very loud. a \\(\\textit{mp (mezzopiano)}\\) tells us to play medium soft. tied notes whe notes on the same line of space are joined with a curved line, we call them tied notes. and the key is held down for the duration of both notes. dotted half note a dotted half note gets \\(3\\) counts (\\(2\\) counts for the half note, plus \\(1\\) count for the dot). dotted quarter notes a dotted quarter note is equivalent to a quarter note tied to a eighth note: the grand staff the bass staff and the treble staff, when joined together with a brace, make up the grand staff. slur and legato playing a slur is a curved line over or under notes on different lines or spaces. slurs means play legato (smoothly connected), they often divide the music intro phrases (a musical thougth or sentence). incomplete measure some pieces begin with an incomplete measure, that is it has one missing count: the sharp sign the sharp sign before a note means to play the next key to the right (wether black or white). when a sharp appears before a note, it applies to that note for the rest of measure: the flat sign the flat sign before a note means to play the next key to the left of said note. staccato the dot over or under the notes indicates the staccato touch, which means: make the note very short. half step a half step is the distance between a key and the key directly above or below it (black or white). whole step a whole step is equal to two half steps. syncopated notes notes that are played between the main beats of the measure and are held across the beat are called syncopated notes. natural sign the natural sign cancels a sharp or flat, so a note after a natural sign is always a white key. accent sign an accent sign mean that we have to play a note with special emphasis: overlapping pedal the following sign is used to indicate the overlapping pedal: and this is how you play it: eighth note triplets when three notes are grouped together with a figure \\(3\\) bove of below the notes, the group is called a triplet. the three notes of a eighth-note triplet group equal one quarter note. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Music/ABPCI/02_positions.html",
    "title": "Positions",
    "body": " index search search back positions contents do position right hand do position left hand do position right hand extended do position sol position middle do position do position right hand do position place the right hand on the keyboard so that the 1st finger falls on middle do. the \\(4\\) remaining fingers fall naturally on the next \\(4\\) white keys: the names of the \\(5\\) keys are: do, re, mi, fa, sol. notes for this position are writter on the trebble staff. see the following figure: the treble clef sign is used for right hand notes. we see that middle do is writter on a short line below the staff, which is called a leger line. left hand do position this position is obtained by moving the left hand so that the \\(5\\)th finger falls on the do below the middle do. the remaning \\(4\\) fingers fall naturally on the next \\(4\\) white keys. notes for this position are writter on the bass staff. right hand extended do position this position is similar to the standard do position, but modified as follows: so now the first three fingers are on do, mi and sol, while the last finger is on the next do, an octave higher. sol position until now you have played only in the do position. now you will move to the sol position: middle do position on this position the right hand is on do position, however the left hand is one key down from sol position, like so: so both thumbs are over the middle do. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Music/ABPCI/03_intervals.html",
    "title": "Intervals",
    "body": " index search search back intervals contents melodic interval harmonic interval melodic intervals in do position harmonic intervals in do position melodic intervals in sol position harmonic intervals in sol position 6ths 7ths octave melodic interval distances between tones are measured in intervals, called \\(2\\)nds, \\(3\\)rds, \\(4\\)ths, \\(5\\)ths, etc. notes playes separately make a melody, and we call the intervals between these notes melodic intervals. harmonic interval notes played together make harmony. we call the intervals between these notes harmonic intervals. melodic intervals in do position harmonic intervals in do position melodic intervals in sol position harmonic intervals in sol position 6ths when you skip 4 white keys then the interval is a 6th. 7ths when you skip 5 white keys then the interval is a 7th. octave when you skip 6 white keys then the interval is an octave. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Music/ABPCI/04_chords.html",
    "title": "Chords",
    "body": " index search search back chords contents chords in do position do major sol7 fa major chords in sol position sol major re7 do major in sol position tetrachord major 3rd minor 3rd perfect 5th triads major triads minor triads primary chords primary chords in do major primary chords in sol major primary chords in fa major primary chords in re minor chord progressions arpeggiated progressions a chord is three or more notes played together. chords in do position do major the do major chord is made of three notes: do, mi and sol. the \\(\\textbf{sol}^7\\) chord is made of three notes: si, fa and sol. sol7 fa major the fa major chord is made of three notes: do, fa and la. chords in sol position sol major re7 do major in sol position we know that the do major is composed of the following notes: do, mi, sol. when you play the same notes of a chord in a different order, it’s still the same chord, but in what’s called an inversion. for example: root position of the do major chord: do (root), mi, sol. first inversion: mi, sol, do (mi is the lowest note). second inversion: sol, do, mi (sol is the lowest note). tetrachord a tetrachord is a series of four notes having a pattern of: whole step, whole step, half step major 3rd a major 3rd is an interval between two notes that are four half steps (semitones) apart. this interval gives a bright and happy sound. for example: minor 3rd a minor 3rd is an interval between two notes that are three half steps (semitones) apart. this interval gives a slightly darker or sadder sound. for example: perfect 5th a perfect 5th is a musical interval that spans seven half steps (or semitones) between two notes. for example: triads a triad is a 3-note chord. the three notes of a triad are: root third fifth the root is the note from which the triad gets its name. the root of a do triad is do. triads in root position are triads that have the root at the bottom. major triads major triads consist of a root a major 3rd and a perfect 5th. minor triads major triads consist of a root a minor 3rd and a perfect 5th. any major triad may be changed to a minor triad by lowering the 3rd one half step. primary chords the three most important chords in any key are those built on the 1st, 4th and 5th notes of the scale. these are called the primary chords of the key. the chords are identified by the roman numerals \\(\\textbf{i}\\), \\(\\textbf{iv}\\) and \\(\\textbf{v}\\). the \\(\\textbf{v}\\) chord usually adds the note a \\(7\\)th above the root to make a \\(\\textbf{v}^7\\). primary chords in do major the \\(\\textbf{i}\\) chord is the do major triad. the \\(\\textbf{iv}\\) chord is the fa major triad. the \\(\\textbf{v}\\) chord is the \\(\\text{sol}^7\\) major triad. (sol major triad with an added \\(7\\)th). primary chords in sol major the \\(\\textbf{i}\\) chord is sol major. the \\(\\textbf{iv}\\) chord is the do major in sol position. the \\(\\textbf{v}\\) chord is the re7 major. primary chords in fa major the \\(\\textbf{i}\\) chord is fa major. the \\(\\textbf{iv}\\) chord is the sib major. the \\(\\textbf{v}\\) chord is the do major. primary chords in re minor the \\(\\textbf{i}\\) chord is re minor (rem). the \\(\\textbf{iv}\\) chord is the sol minor (solm). the \\(\\textbf{v}\\) chord is the la7. chord progressions when we change from one chord to another, we call this a chord progression. to make the chord progressions easier to play and sound better, the \\(iv\\) and \\(v^7\\) chords may be played in other positions by moving one or more of the higher chord tones down an octave. for example for the primary chords on do major: and the chord progressions for the primary chords sol major are: arpeggiated progressions when a wavy line appears beside a chord, the chord is said to be arpeggiated, that is broken or rolled. this means that you should play the lower note first, and quickly add the next higher notes one at a time until the chord is complete. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Music/ABPCI/index.html",
    "title": "Alfred Basic Piano Course I",
    "body": " index search search back alfred basic piano course i notation positions intervals chords scales keys tidbits $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Music/ABPCI/05_scales.html",
    "title": "Scales",
    "body": " index search search back scales contents major scales do major scale sol major scale fa major scale harmonic scale minor scales the la harmonic minor scale the re harmonic minor scale the major scale is made of two tetrachords joined by a whole step. major scales do major scale the do major scale is constrcuted as follow: each scale begins and ends on a note of the same name as the scale, called the key note. sol major scale the sol major scale is also made up of two tetrachods, where the second tetrachord begins in re: fa major scale the fa major scale follows the following structure: harmonic scale in the harmonic minor scale, the 7th tone is rained one semitone. you can see on the following image that the seventh tone is flat. this flat is not included in the key signature, but is written each time it occurs. minor scales the la harmonic minor scale this is the most frequently used minor scale. the re harmonic minor scale $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Calculus/CET/02_01.html",
    "title": "The Tangent and Velocity Problems",
    "body": " index search search back the tangent and velocity problems contents the tangent problem the velocity problem the tangent problem we can think of a tangent to a curve as a line that touches the curve an follows the same direction as the curve at the point of contact. let's look at the next example, where we want to find an equation for the tangent line to the parabola \\(y = x^2\\) at point \\(p(1, 1)\\). to do so we only need to know the slope \\(m\\), however to find the slope of the line we need two points on the curve, and as of now we only have \\(p(1, 1)\\). but observe that we can compute an approximation by choosing a nearby point \\(q(x, x^2)\\) (see figure 2) and computing the slope \\(m_{pq}\\) of the secant line \\(pq\\). (a secant line if a line that intersects a curve more than once): \\begin{align} m_{pq} = \\frac{x^2 - 1}{x - 1} \\end{align} on the following tables we see that the closer \\(q\\) is to \\(p\\), that is the closer \\(x\\) is to \\(1\\), then the closer \\(m_{pq}\\) is to \\(2\\). \\(x\\) \\(m_{pq}\\) \\(2\\) \\(3\\) \\(1.5\\) \\(2.5\\) \\(1.1\\) \\(2.1\\) \\(1.01\\) \\(2.01\\) \\(1.001\\) \\(2.001\\) \\(x\\) \\(m_{pq}\\) \\(0\\) \\(1\\) \\(0.5\\) \\(1.5\\) \\(0.9\\) \\(1.9\\) \\(0.99\\) \\(1.99\\) \\(0.999\\) \\(1.999\\) this suggests that the slope of the tangent line is the limit of the slopes of the secant lines: \\begin{align} \\lim_{q \\rightarrow p} m_{pq} = m \\end{align} \\begin{align} \\lim_{x \\rightarrow 1} \\frac{x^2 - 1}{x - 1} = 2 \\end{align} assuming that the slope of the tangent is indeed \\(2\\), we define the equation of the tangent line through \\((1, 1)\\) as: \\begin{align} y - 1 = 2(x - 1) \\end{align} \\begin{align} y = 2x - 1 \\end{align} figure 3 illustrates the process that occurs on this example. as \\(q\\) approaches \\(p\\) the secant lines rotate about \\(p\\) and approach the tangent line \\(\\mathcal{l}\\). another method to approximate the slope of the tangent line at \\(p\\) is to measure the sides of a triangle \\(abc\\) as in figure 5: this gives an estimate of the slope of the tangent line as: \\begin{align} - \\frac{ab}{bc} \\approx -\\frac{8.0 - 5.4}{0.06 - 0.02} = -65.0 \\end{align} the velocity problem the instantaneous velocity is defined to be the limiting value of the average velocities over shorter and shorter time periods. thus there is a close connection between the tangent problem and the velocity problem. if we draw the grapf of the distance function and we consider points \\(p(5, f(5))\\) and \\(q(5 + h, f(5 + h))\\) (see figure 6). then the slope of the secant line \\(pq\\) is: \\begin{align} m_{pq} = \\frac{f(5 + h) - f(5)}{(5 + h) - 5} \\end{align} which is the same as the average velocity over the time interval \\([5, 5 + h]\\). $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Music/ABPCI/06_keys.html",
    "title": "Keys",
    "body": " index search search back keys contents major keys key of sol major key of fa major minor keys relative minor of do major la minor relative minor of fa major re minor most frequently used keys major keys minor keys harmonic minors music based on any particular scale is said to be in the key of that scale. if there are shaprs or flats in the scale, they are shown at the beginning of the score. this is called the key signature. major keys key of sol major a piece based on the sol major scale is in the key of sol major. since fa is sharp in the sol scale, every fa will be sharp in the key of sol major. instead of placing a sharp before every fa in the entire piece, the sharp is indicated at the beginning in the key signature. key of fa major a piece based on the fa major scale has the following key signature: minor keys every major key has a relative minor key that has the same key signature. the relative minor being on the 6th tone of the major scale. relative minor of do major: la minor the relative minor of do major is la minor: because the key of do major and la minor have the same key signature (no sharps and no flats) we say that they are relatives. the minor scale shown above is called the natural minor scale. relative minor of fa major: re minor the re minor is the relative of fa major and both keys have the same signature (1 flat: si). remember the relative minor beings on the 6th tone of the major scale. the minor scale shown above is the natural minor scale. that is, a scale that only uses the notes that are found in the relative major scale. most frequently used keys major keys do major sol major: 1 sharp on fa. fa major: 1 flat on si. minor keys (harmonic minors) la minor: relative of do major. re minor: relative of fa major, 1 flat on si. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Calculus/CET/02_02.html",
    "title": "The Limit of a Function",
    "body": " index search search back the limit of a function contents limits one-sided limits how can a limit fail to exist infinite limits vertical asymptotes vertical asymptotes limits suppose \\(f(x)\\) is defined when \\(x\\) is near the number \\(a\\), then we write: \\begin{align} \\lim_{x \\rightarrow a} f(x) = l \\end{align} if we can make the values of \\(f(x)\\) arbitrarily close to \\(l\\) by restricting \\(x\\) to be sufficiently close to \\(a\\) (on either side of \\(a\\)) but not equal to \\(a\\) (see figure 1). an alternative notation is: \\begin{align} f(x) \\rightarrow l \\text{ as } x \\rightarrow a \\end{align} notice that we never consider \\(x = a\\). in fact, \\(f(x)\\) need not even be defined when \\(x = a\\). the only thing that matters is how \\(f\\) is defined near \\(a\\). one-sided limits the notation \\(t \\rightarrow 0^{-}\\) indicates that we consider only values of \\(t\\) that are less than 0. likewise, \\(t \\rightarrow 0^{+}\\) indicates that we consider only values of \\(t\\) that are greater than 0. we write: \\begin{align} \\lim_{x \\rightarrow a^{-}} f(x) = l \\end{align} and say that the left-hand limit of \\(f(x)\\) as \\(x\\) approaches \\(a\\) is equal to \\(l\\) if we can make the values of \\(f(x)\\) arbitrarily clsoe to \\(l\\) by restricting \\(x\\) to be sufficiently close to \\(a\\) with \\(x\\) less than \\(a\\). we write: \\begin{align} \\lim_{x \\rightarrow a^{+}} f(x) = l \\end{align} and say that the right-hand limit of \\(f(x)\\) as \\(x\\) approaches \\(a\\) is equal to \\(l\\) if we can make the values of \\(f(x)\\) arbitrarily clsoe to \\(l\\) by restricting \\(x\\) to be sufficiently close to \\(a\\) with \\(x\\) greater than \\(a\\). see figure 6 for a graphical representation. by both definitions, we see that the following is true: \\begin{align} \\lim_{x \\rightarrow a} f(x) = l \\leftrightarrow \\lim_{x \\rightarrow a^{-}} f(x) = l \\text{ and } \\lim_{x \\rightarrow a^{+}} f(x) = l \\end{align} how can a limit fail to exist? a limit fails to exist at a number \\(a\\) if the left- and right-hand limits are not equal. when guessing the value of a limit it is easy to guess the wrong value if we use inapproapriate values of \\(x\\). it is also hard to know when to stop calculating value (sometimes calculators and computers give the wrong values due to precission issues). infinite limits: vertical asymptotes another way a limit at a number \\(a\\) can fail to exist is when the function values grow arbitrarily large (in absolute value) as \\(x\\) approaches \\(a\\). let \\(f\\) be a function defined on both sides of \\(a\\), except possible at \\(a\\) itself, then: \\begin{align} \\lim_{x \\rightarrow a} f(x) = \\infty \\end{align} means that the values of \\(f(x)\\) can be arbitrarily large by taking \\(x\\) sufficiently close to \\(a\\), but not equal to \\(a\\) (see figure 10). let \\(f\\) be a function defined on both sides of \\(a\\), except possible at \\(a\\) itself, then: \\begin{align} \\lim_{x \\rightarrow a} f(x) = -\\infty \\end{align} means that the values of \\(f(x)\\) can be arbitrarily large negative by taking \\(x\\) sufficiently close to \\(a\\), but not equal to \\(a\\) (see figure 11). this does not mean that the limit exists, it simply expresses the particular way in which the limit does not exist. similar definitions can be given for one-sided limits: \\begin{align} \\lim_{x \\rightarrow a^{-}} f(x) = \\infty \\end{align} \\begin{align} \\lim_{x \\rightarrow a^{-}} f(x) = -\\infty \\end{align} \\begin{align} \\lim_{x \\rightarrow a^{+}} f(x) = \\infty \\end{align} \\begin{align} \\lim_{x \\rightarrow a^{+}} f(x) = -\\infty \\end{align} these are illustrated on the following figure: vertical asymptotes the vertical line \\(x = a\\) is called a vertical asymptotes of the curve \\(y = f(x)\\) if at least one of the following statements is true: \\begin{align} \\lim_{x \\rightarrow a} f(x) = \\infty \\end{align} \\begin{align} \\lim_{x \\rightarrow a} f(x) = -\\infty \\end{align} \\begin{align} \\lim_{x \\rightarrow a^{-}} f(x) = \\infty \\end{align} \\begin{align} \\lim_{x \\rightarrow a^{-}} f(x) = -\\infty \\end{align} \\begin{align} \\lim_{x \\rightarrow a^{+}} f(x) = \\infty \\end{align} \\begin{align} \\lim_{x \\rightarrow a^{+}} f(x) = -\\infty \\end{align} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Calculus/CET/02_03.html",
    "title": "Calculating Limits Using the Limits Laws",
    "body": " index search search back calculating limits using the limits laws contents properties of limits evaluating limits by direct substitution limit equality using one-sided limits the squeeze theorem properties of limits supporse that \\(c\\) is a constant and the limits: \\begin{align} \\lim_{x \\rightarrow a} f(x) \\end{align} \\begin{align} \\lim_{x \\rightarrow a} g(x) \\end{align} exist. then: sum law \\begin{align} \\lim_{x \\rightarrow a} [f(x) + g(x)] = \\lim_{x \\rightarrow a} f(x) + \\lim_{x \\rightarrow a} g(x) \\end{align} difference law \\begin{align} \\lim_{x \\rightarrow a} [f(x) - g(x)] = \\lim_{x \\rightarrow a} f(x) - \\lim_{x \\rightarrow a} g(x) \\end{align} constant multiple law \\begin{align} \\lim_{x \\rightarrow a} [cf(x)] = c\\lim_{x \\rightarrow a} f(x) \\end{align} product law \\begin{align} \\lim_{x \\rightarrow a} [f(x) g(x)] = \\lim_{x \\rightarrow a} f(x) \\cdot \\lim_{x \\rightarrow a} g(x) \\end{align} quotient law \\begin{align} \\lim_{x \\rightarrow a} [\\frac{f(x)}{g(x)}] = \\frac{\\lim_{x \\rightarrow a} f(x)}{\\lim_{x \\rightarrow a} g(x)} \\end{align} if we use the product law repeteadly with \\(g(x) = f(x)\\), then we arrive at the power law: \\begin{align} \\lim_{x \\rightarrow a} \\left[f(x)\\right]^n = [\\lim_{x \\rightarrow a} f(x)]^n \\end{align} root law \\begin{align} \\lim_{x \\rightarrow a} \\sqrt[n]{f(x)} = \\sqrt[n]{\\lim_{x \\rightarrow a} f(x)} \\end{align} let's now see two special limits: \\begin{align} \\lim_{x \\rightarrow a} c = c \\end{align} \\begin{align} \\lim_{x \\rightarrow a} x = a \\end{align} if we now let \\(f(x) = x\\) on the power law and use \\(\\lim_{x \\rightarrow a} x = a\\), then: \\begin{align} \\lim_{x \\rightarrow a} x^n = [\\lim_{x \\rightarrow a} x]^n = a^n \\end{align} if we now let \\(f(x) = x\\) on the root law and use \\(\\lim_{x \\rightarrow a} x = a\\), then: \\begin{align} \\lim_{x \\rightarrow a} \\sqrt[n]{x} = \\sqrt[n]{\\lim_{x \\rightarrow a} x} = \\sqrt[n]{a} \\end{align} where \\(n\\) is a positive integer. also, if \\(n\\) is even then we assume that \\(a > 0\\). evaluating limits by direct substitution the limit laws prove that direct substitution can be used to obtain the value of a limit for polynomial and rational functions. if \\(f\\) is a polynomial or a rational function and \\(a\\) is in the domain of \\(f\\), then: \\begin{align} \\lim_{x \\rightarrow a} f(x) = f(a) \\end{align} functions that satisfy this property are said to be continuous at \\(a\\). however, not all limits can be evaluated initially by direct substitution. limit equality if \\(f(x) = g(x)\\) when \\(x \\neq a\\), then \\(\\lim_{x \\rightarrow a} f(x) = \\lim_{x \\rightarrow a} g(a)\\) using one-sided limits we say: \\begin{align} \\lim_{x \\rightarrow a} f(x) = l \\end{align} if and only if \\begin{align} \\lim_{x \\rightarrow a^{-}} f(x) = l = \\lim_{x \\rightarrow a^{+}} f(x) \\end{align} the squeeze theorem the following two theorems describe how the limits of functions are related when the values of one function are greater than (or equal to) those of another. if \\(f(x) \\leq g(x)\\) when \\(x\\) is near \\(a\\) (except possibly at \\(a\\)) and the limits of \\(f\\) and \\(g\\) both exist as \\(x\\) approaches \\(a\\), then: \\begin{align} \\lim_{x \\rightarrow a} f(x) \\leq \\lim_{x \\rightarrow a} g(x) \\end{align} the squeeze theorem states: if \\(f(x) \\leq g(x) \\leq h(x)\\) when \\(x\\) is near \\(a\\) (except possibly at \\(a\\)) and: \\begin{align} \\lim_{x \\rightarrow a} f(x) = \\lim_{x \\rightarrow a} h(x) = l \\end{align} then: \\begin{align} \\lim_{x \\rightarrow a} g(x) = l \\end{align} this theorem is illustrated on figure 7. it says that if \\(g(x)\\) is squeezed between \\(f(x)\\) and \\(h(x)\\) near \\(a\\), and if \\(f\\) and \\(h\\) have the same limit \\(l\\) at \\(a\\), then \\(g\\) is forced to have the same limit \\(l\\) at \\(a\\). $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Music/ABPCI/07_tidbits.html",
    "title": "Tidbits of Music",
    "body": " index search search back tidbits of music contents blues blues music cal led blues has long been a part of the of american musical heritage. we find it in the music of many popular song writers, in ballads, boogie and rock. blues follows a basic formula, that is, a standard chord progression: 4 measures of the i chord 2 measures of the iv chord 2 measures of the i chord 1 measure of the \\(v^7\\) chord 2 measures of the iv chord 2 measures of the i chord $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Calculus/CET/02_04.html",
    "title": "The Precise Definition of a Limit",
    "body": " index search search back the precise definition of a limit contents the precise definition of a limit one-sided limits precise definition of left-hand limit precise definition of right-hand limit limit laws proof of the sum law infinite limits the intuitive definition is inadequate for some purpose because of it vagueness. the precise definition of a limit as motivation consier the following function: \\begin{align} f(x) = \\begin{cases} 2x - 1 & \\text{ if } x \\neq 3 \\\\ 6 & \\text{ if } x = 3 \\\\ \\end{cases} \\end{align} think about how close to \\(3\\) does \\(x\\) have to be so that \\(f(x)\\) differs from \\(5\\) less than \\(0.1\\)? we know that the distance from \\(x\\) to \\(3\\) is \\(|x - 3|\\) and the distance from \\(f(x)\\) to \\(5\\) is \\(|f(x) - 5|\\), so out problem becomes: \\begin{align} | f(x) - 5 | < 0.1 \\text{ if } 0 < | x - 3 | < \\delta \\end{align} notice that if: \\begin{align} 0 < |x - 3| < \\frac{0.1}{2} = 0.5 \\end{align} then: \\begin{align} |f(x) - 5| = |(2x - 1) - 5| = |2x - 6| = 2|x - 3| < 2(0.05) = 0.1 \\end{align} that is: \\begin{align} |f(x) - 5| < 0.1 \\text { if } 0 < |x - 3| < 0.05 \\end{align} thus an answer to the proposed problem is given by \\(\\delta = 0.05\\). however, if we change the limit \\(0.1\\) to \\(0.01\\) by using the same method we find that \\(\\delta = 0.005\\), such that: \\begin{align} |f(x) - 5| < 0.01 \\text { if } 0 < |x - 3| < 0.005 \\end{align} and similarly: \\begin{align} |f(x) - 5| < 0.001 \\text { if } 0 < |x - 3| < 0.0005 \\end{align} these values: \\(0.1, 0.01\\) and \\(0.001\\) are what we call error tolerances. but to actually compute the limit we must be able to find a \\(\\delta\\) for any arbitrarily small positive number \\(\\epsilon\\): \\begin{align} |f(x) - 5| < \\epsilon \\text { if } 0 < |x - 3| < \\delta = \\frac{\\epsilon}{2} \\end{align} this is the precise way of saying that \\(f(x)\\) is close to \\(5\\) when \\(x\\) is close to \\(3\\) because the previous statement says that we can make the values of \\(f(x)\\) within an arbitrary distance \\(\\epsilon\\) from \\(5\\) by restricting \\(x\\) to be within a distance \\(\\frac{\\epsilon}{2}\\) from \\(3\\) (see figure 1). the precise definition of a limit is as follows: let \\(f\\) be a function defined on some open interval that contains the number \\(a\\), except possible at \\(a\\) itself. then we say that the limit of \\(f(x)\\) as \\(x\\) approaches \\(a\\) is \\(l\\) and we write: \\begin{align} \\lim_{x \\rightarrow a} f(x) = l \\end{align} if for every number \\(\\epsilon > 0\\) there is a number \\(\\delta > 0\\) such that: \\begin{align} \\text{ if } 0 < |x - a| < \\delta \\text{ then } |f(x) - l| < \\epsilon \\end{align} we can reformulate this definition in terms of intervals: \\begin{align} \\lim_{x \\rightarrow a} f(x) = l \\end{align} means that for every \\(\\epsilon > 0\\) we can find \\(\\delta > 0\\) such that if \\(x \\in (a - \\delta, a + \\delta)\\) and \\(x \\neq a\\), then \\(f(x) \\in (l - \\epsilon, l + \\epsilon)\\) (see figure 3). also we can interpret the definition geometrically in terms of the graph of a function. if \\(\\epsilon > 0\\) is given we draw horizontal lines \\(y = l + \\epsilon\\) and \\(y = l - \\epsilon\\) as well as the graph of \\(f\\) (see figure 4). if \\(\\lim_{x \\rightarrow a} f(x) = l\\) then we can find a number \\(\\delta > 0\\) such that if \\(x \\in (a - \\delta, a + \\delta)\\) and \\(x \\neq a\\), then the curve \\(y = f(x)\\) lies between the lines \\(y = l - \\epsilon\\) and \\(y = l + \\epsilon\\) (see figure 5). once \\(\\delta\\) has been found, then any smaller \\(\\delta\\) will also work. note that this process must work for every positive number \\(\\epsilon\\), no matter how small (see figure 6). one-sided limits precise definition of left-hand limit \\begin{align} \\lim_{x \\rightarrow a^{-}} f(x) = l \\end{align} if for every number \\(\\epsilon > 0\\) there is a number \\(\\delta > 0\\) such that: \\begin{align} \\text{ if } a - \\delta < x < a \\text{ then } |f(x) - l| < \\epsilon \\end{align} that is, \\(x\\) is restricted to lie in the left half of the interval \\((a - \\delta, a + \\delta)\\). precise definition of right-hand limit \\begin{align} \\lim_{x \\rightarrow a^{+}} f(x) = l \\end{align} if for every number \\(\\epsilon > 0\\) there is a number \\(\\delta > 0\\) such that: \\begin{align} \\text{ if } a < x < a + \\delta \\text{ then } |f(x) - l| < \\epsilon \\end{align} that is, \\(x\\) is restricted to lie in the right half of the interval \\((a - \\delta, a + \\delta)\\). limit laws up until now we have used the precise definition of a limit to compute the limit of a given function. however if we were given a more complicated funtion a proof would require a great deal of ingenuity. fortunately we can use the limit laws, which can be proved using the definition of a limit. so the limits of complicated function can be found rigorously from the limit laws without resorting to the definition directly. proof of the sum law the sum law states that if the limits: \\begin{align} \\lim_{x \\rightarrow a} f(x) \\end{align} \\begin{align} \\lim_{x \\rightarrow a} g(x) \\end{align} exist. then: \\begin{align} \\lim_{x \\rightarrow a} [f(x) + g(x)] = \\lim_{x \\rightarrow a} f(x) + \\lim_{x \\rightarrow a} g(x) \\end{align} proof let \\(\\epsilon > 0\\) be given, we must find \\(\\delta > 0\\) such that: \\begin{align} \\text{ if } 0 < |x - a| < \\delta \\text{ then } |f(x) + g(x) - (l + m)| < \\epsilon \\end{align} by the means of the triangle inequality: \\begin{align} | f(x) + g(x) - (l + m) | = | (f(x) - l) + (g(x) - m) | \\leq | f(x) - l | + | g(x) - m | \\end{align} we make \\(|f(x) + g(x) - (l + m)|\\) less that \\(\\epsilon\\) by letting: \\begin{align} | f(x) - l | < \\frac{\\epsilon}{2} \\end{align} and \\begin{align} | g(x) - m | < \\frac{\\epsilon}{2} \\end{align} since \\(\\frac{\\epsilon}{2} > 0\\) and \\(\\lim_{x \\rightarrow a} f(x) = l\\) there exists a number \\(\\delta_1 > 0\\) such that: \\begin{align} \\text{ if } 0 < |x - a| < \\delta_1 \\text{ then } |f(x) - l| < \\frac{\\epsilon}{2} \\end{align} similarly, since \\(\\frac{\\epsilon}{2} > 0\\) and \\(\\lim_{x \\rightarrow a} g(x) = m\\) there exists a number \\(\\delta_2 > 0\\) such that: \\begin{align} \\text{ if } 0 < |x - a| < \\delta_2 \\text{ then } |g(x) - m| < \\frac{\\epsilon}{2} \\end{align} let \\(\\delta = \\min\\{\\delta_1, \\delta_2\\}\\), notice: \\begin{align} \\text{ if } 0 < |x - a| < \\delta \\text{ then } 0 < |x - a| < \\delta_1 \\text{ and } 0 < |x - a| < \\delta_2 \\end{align} and also: \\begin{align} | f(x) - l | < \\frac{\\epsilon}{2} \\text{ and } | g(x) - m | < \\frac{\\epsilon}{2} \\end{align} and, therefore by the triangle inequality we showed before: \\begin{align} |f(x) + g(x) - (l + m)| \\leq | f(x) - l | + | g(x) - m | < \\frac{\\epsilon}{2} + \\frac{\\epsilon}{2} = \\epsilon \\end{align} thus, by the definition of a limit: \\begin{align} \\lim_{x \\rightarrow a} [f(x) + g(x)] = l + m \\end{align} infinite limits let \\(f\\) be a function defined on some open interval that contains the number \\(a\\), except possibly at \\(a\\) itself. then: \\begin{align} \\lim_{x \\rightarrow a} f(x) = \\infty \\end{align} means that for every postive number \\(m\\) there is a positive number \\(\\delta\\) such that: \\begin{align} \\text{ if } 0 < |x - a| < \\delta \\text{ then } f(x) > m \\end{align} this says that the values of \\(f(x)\\) ca be made arbitrarily large (larger than any given number \\(m\\)) by requiring \\(x\\) to be close enough to \\(a\\) (see figure 10). let \\(f\\) be a function defined on some open interval that contains the number \\(a\\), except possibly at \\(a\\) itself. then: \\begin{align} \\lim_{x \\rightarrow a} f(x) = -\\infty \\end{align} means that for every postive number \\(n\\) there is a positive number \\(\\delta\\) such that: \\begin{align} \\text{ if } 0 < |x - a| < \\delta \\text{ then } f(x) < n \\end{align} see figure 11. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/CG/RTGW/07.html",
    "title": "Textures",
    "body": " index search search back textures contents creating and uploading a texture using texture coordinates polygon mesh texture coordinates using textures in a shader texture filter modes nearest linear mipmapping generating mipmaps texture wrapping clamp to edge repeat mirrored repeat using multiple textures cube maps creating and uploading a texture unlike traditional native opengl applications, browsers load textures \"upside down\". as a result, many webgl applications set textures to be loaded with the \\(y\\) coordinate flipped by: gl.pixelstorei(gl.unpack_flip_y_webgl, true); creating textures follows the same pattern as using buffers: create a new texture const texture = gl.createtexture(); bind it to make it the current texture. the first parameter indicates the type of texture we're binding. gl.bindtexture(gl.texture_2d, texture); pass the texture contents // from dom const image = document.getelementbyid('texture-image'); gl.teximage2d(gl.texture_2d, 0, gl.rgba, gl.rgba, gl.unsigned_byte, image); // from image const texture = gl.createtexture(); const image = new image(); image.src = 'texture-file.png'; image.onload = () => { gl.bindtexture(gl.texture_2d, texture); gl.teximage2d(gl.texture_2d, 0, gl.rgba, gl.rgba, gl.unsigned_byte, image); gl.texparameteri(gl.texture_2d, gl.texture_mag_filter, gl.nearest); gl.texparameteri(gl.texture_2d, gl.texture_min_filter, gl.nearest); gl.bindtexture(gl.texture_2d, null); }; set the filter mode or other texture parameters. we'll see what filters are later on, the simplest ones are the following: gl.texparameteri(gl.texture_2d, gl.texture_mag_filter, gl.nearest); gl.texparameteri(gl.texture_2d, gl.texture_min_filter, gl.nearest); unbind the texture gl.bindtexture(gl.texture_2d, null); when we no longer need the texture we can remove it and free up the associated memory as follows: gl.deletetexture(texture); using texture coordinates before we apply our texture to our surface, we need to figure out which part of the texture maps onto which part of the surface. we do this through another vertex attribute known as texture coordinates. webgl forces all of the texture coordinates into a \\(0\\) to \\(1\\) range, where \\((0, 0)\\) represents the top left-hand side corner of the texture and \\((1, 1)\\) represents the bottom right-hand side corner. this comes in handy because if the texture coordinates were defined in terms of pixels, then the mapping would be dependent on the resolution of the image. the process of laying out textures and generating texture coordinates is called unwrapping. polygon mesh a polygon mesh is a collection of vertices, edges, and faces that defines the shape of a polyhedral object in 3d computer graphics and solid texture coordinates texture coordinates also have a common symbolic representation. unfortunately, it's not consistent across all 3d software applications. opengl and webgl refer to these coordinates as \\(s\\) and \\(t\\) for the \\(x\\) and \\(y\\) components, respectively. however, directx and many popular modeling packages refer to them as \\(u\\) and \\(v\\) (so they are usually referred to as \"uvs\"). using textures in a shader we'll want to include a two-element vector attribute in our vertex shader that will map to our texture coordinates: in vec2 avertextexturecoords; we need to add a new uniform to the fragment shader that uses a type we haven't seen before: sampler2d. the sampler2d uniform is what allows us to access the texture data in the shader: uniform sampler2d usampler; the following code shows how to associate a texture with a specific sampler uniform: gl.activetexture(gl.texture0); gl.bindtexture(gl.texture_2d, texture); gl.uniform1i(program.usampler, 0); first off, we are changing the active texture with gl.activetexture. next, we bind the texture we wish to use, which associates it with the currently active texture, texture0. finally, we tell the sampler uniform which texture it should be associated with. here, we give it \\(0\\) to indicate that the sampler should use texture0. to use our texture in the fragment shader by return the value of the texture as the fragment color: texture(usampler, vtexturecoord); texture takes in the sampler uniform we wish to query and the coordinates to lookup, and returns the color of the texture image at those coordinates as vec4. if the image has no alpha channel, vec4 will still be returned with the alpha component always set to \\(1\\). texture filter modes if you were to zoom in on a texture you would see that it begins to alias, where we can see that jagged edges develop around the webgl logo. why do we see these artifacts in the first place? in the fragment shader the texture coordinates provided by the vertex shader are interpolated (as they are varying variables). in a perfect situation, the texture would display at a 1:1 ratio on screen, meaning each pixel of the texture would take up exactly one pixel on screen. in this scenario, there would be no artifacts: the reality of 3d applications, however, is that textures are almost never displayed at their native resolution. we refer to these scenarios as magnification and minification. when a texture is magnified or minified, there can be some ambiguity about what color the texture sampler should return, for example: texture filtering allows us to control how textures are sampled and achieve the look we want. we change the currently bound texture's filter mode by: gl.texparameteri(gl.texture_2d, gl.texture_mag_filter, gl.nearest); gl.texparameteri(gl.texture_2d, gl.texture_min_filter, gl.nearest); note that different textures can have different filters. nearest textures using the nearest filter always return the color of the texel whose center is nearest to the sample point. with this mode, textures will look pixilated up close: linear returns the weighted average of the four pixels whose centers are nearest to the sample point. also known as bilinear filtering. the graphics hardware has to read four times as many pixels per fragment, so it is slower. mipmapping a problem arises when sampling minified textures. in cases where we use linear filtering and the sample points are so far apart, we can completely miss some details of the texture. to avoid this, graphics cards can utilize a mipmap chain. mipmaps are scaled-down copies of a texture, with each copy being exactly half the size of the previous one. with these chains, graphics hardware can choose the copy of the texture that most closely matches the size of the texture on screen. nearest_mipmap_nearest: select the mipmap that most closely matches the size of the texture on screen and samples from it using the nearest algorithm. linear_mipmap_nearest: selects the mipmap that most closely matches the size of the texture on screen and samples from it using the linear algorithm. nearest_mipmap_linear: selects two mipmaps that most closely match the size of the texture on screen and samples from both of them by using the nearest algorithm. the color returned is a weighted average of those two samples. linear_mipmap_linear: selects two mipmaps that most closely match the size of the texture on screen and samples from both of them using the linear algorithm. the color returned is a weighted average of those two samples (also known as trilinear filtering). generating mipmaps we have to create mipamps for every texture: gl.generatemipmap(gl.texture_2d); this insttruction has to be called after the texture has been populated with the image. to provide the mipmaps manually we use: gl.teximage2d(gl.texture_2d, 1, gl.rgba, gl.rgba, gl.unsigned_byte, mipmapimage); by passing a number other than 0 as the second parameter we are creating the first mipmap level. in order to use mipmaps with a texture in webgl 1, mipmaps need to satisfy some dimension restrictions. namely, the texture width and height must both be powers of two (pot). this does not apply for webgl 2. texture wrapping texture wrapping describes the behavior of the sampler when the texture coordinates fall outside the range of \\(0\\) and \\(1\\). the wrapping mode can be set independently for both the s and t coordinates: gl.texparameteri(gl.texture_2d, gl.texture_wrap_s, gl.clamp_to_edge); gl.texparameteri(gl.texture_2d, gl.texture_wrap_t, gl.clamp_to_edge); clamp_to_edge this wrap mode rounds any texture coordinates greater than \\(1\\) down to \\(1\\); any coordinates lower than \\(0\\) are rounded up to \\(0\\), clamping the values to the \\((0, 1)\\) range. visually, this has the effect of repeating the texture's border pixels indefinitely once the coordinates go out of the \\((0, 1)\\) range. repeat this is the default wrap mode. it ignores the integer part of the texture coordinate. this creates the visual effect of the texture repeating as you move outside of the \\((0, 1)\\) range. mirrored_repeat if the coordinate's integer portion is even, the texture coordinates will be the same as they were with repeat. if the integer portion of the coordinate is odd, the resulting coordinate is \\(1\\) minus the fractional portion of the coordinate. this results in a texture that \"flip-flops\" as it repeats. using multiple textures there are times when we may want to have multiple textures contribute to a fragment. in such cases, we can use webgl's ability to access multiple textures in a single draw call, commonly referred to as multi-texturing. when talking about exposing a texture to a shader as a sampler uniform, we used the following code: gl.activetexture(gl.texture0); gl.bindtexture(gl.texture_2d, texture); we use it to tell the webgl state machine which texture we're going to use in subsequent texture functions. if we want to attach a different texture to the second texture unit, we would use gl.texture1 instead. it may be more convenient to specify the texture unit programmatically or find a need to refer to a texture unit above \\(31\\). in such situations, you can always substitute gl.texture0 + i for gl.texturei, as in the following example: gl.texture0 + 2 === gl.texture2; accessing multiple textures in a shader is as simple as declaring multiple samplers: uniform sampler2d usampler; uniform sampler2d uothersamp when setting up your draw call, tell the shader which texture is associated with which sampler by providing the texture unit to gl.uniform1i. // bind the first texture gl.activetexture(gl.texture0); gl.bindtexture(gl.texture_2d, texture); gl.uniform1i(program.usampler, 0); // bind the second texture gl.activetexture(gl.texture1); gl.bindtexture(gl.texture_2d, othertexture); gl.uniform1i(program.uothersampler, 1); cube maps a cube map is a cube of textures. six individual textures are created, each assigned to a different face of the cube. the graphics hardware can sample them as a single entity, by using a 3d texture coordinate. the faces of the cube are identified by the axis they face and whether they are on the positive or negative side of that axis: cube mapping introduces a few new texture targets that indicate we are working with cube maps. these targets also indicate which face of the cube map we're manipulating: texture_cube_map texture_cube_map_positive_x texture_cube_map_negative_x texture_cube_map_positive_y texture_cube_map_negative_y texture_cube_map_positive_z texture_cube_map_negative_z cube maps are created like a normal texture, but binding and property manipulation happen with the texture_cube_map target: const cubetexture = gl.createtexture(); gl.bindtexture(gl.texture_cube_map, cubetexture); gl.texparameteri(gl.texture_cube_map, gl.texture_mag_filter, gl.linear); gl.texparameteri(gl.texture_cube_map, gl.texture_min_filter, gl.linear); when uploading the image data for the texture, you need to specify the side that you are manipulating: gl.teximage2d(gl.texture_cube_map_positive_x, 0, gl.rgba, gl.rgba, gl.unsigned_byte, positiveximage); gl.teximage2d(gl.texture_cube_map_negative_x, 0, gl.rgba, gl.rgba, gl.unsigned_byte, negativeximage); gl.teximage2d(gl.texture_cube_map_positive_y, 0, gl.rgba, gl.rgba, gl.unsigned_byte, positiveyimage); exposing the cube map texture to the shader is done in the same way as a normal texture, just with the cube map target: gl.activetexture(gl.texture0); gl.bindtexture(gl.texture_cube_map, cubetexture); gl.uniform1i(program.ucubesampler, 0); however, the uniform type within the shader is specific to cube maps: uniform samplercube ucubesampler; when sampling from the cube map, you also use a cube map-specific function: texture(ucubesampler, vcubetexturecoords); the 3d coordinates you provide are normalized by the graphics hardware into a unit vector, which specifies a direction from the center of the \"cube.\" a ray is traced along that vector, and where it intersects the cube face is where the texture is sampled: $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/PR/CC/01.html",
    "title": "Meaningful Names",
    "body": " index search search back meaningful names use intention revealing names: the name of a variable, function or class should answer why it exists, what it does and how it is used. let's avoid: list<int> list1; make meaningful distinctions: if variable names are different then they must mean something different, and that difference has to be easily understood. let's avoid: char[] a1; char[] a2; use pronounceable names: use common words for names, instead of gibberish. let's avoid: class dtarcrd102 { private date genymdhms; } use searchable names: if a variable is used on several places on your code it should be easy to seach, so avoid numbers and single letter variables. class names: should be nouns or noun-like words. method names: should have verb or verb phrases as names. pick one word per concept: avoid having different namings for something that is fundamentally the same. for example, avoid having fetch, retrieve and get as different method names that do the \"same\". use solution domain names: use algorithm names, pattern names, math names and so forth. use problem domain names: if no solution domain name is suitable, go ahead and use the name from the problem domain. add meaninful context: few names are meaningul in and of themselves, so it is always helpful when they are declared under well named classes, methods, namespaces, etc. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/PR/CC/index.html",
    "title": "Clean Code",
    "body": " index search search back clean code meaningful names functions comments formatting objects and data structures error handling boundaries unit tests classes systems emergence concurrency $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/PR/CC/02.html",
    "title": "Functions",
    "body": " index search search back functions contents how functions should be defined switch statements how functions should be defined lets consider the following code: public static string testablehtml( pagedata pagedata, boolean includesuitesetup ) throws exception { wikipage wikipage = pagedata.getwikipage(); stringbuffer buffer = new stringbuffer(); if (pagedata.hasattribute(\"test\")) { if (includesuitesetup) { wikipage suitesetup = pagecrawlerimpl.getinheritedpage( suiteresponder.suite_setup_name, wikipage ); if (suitesetup != null) { wikipagepath pagepath = suitesetup.getpagecrawler().getfullpath(suitesetup); string pagepathname = pathparser.render(pagepath); buffer.append(\"!include -setup .\") .append(pagepathname) .append(\"\\n\"); } } wikipage setup = pagecrawlerimpl.getinheritedpage(\"setup\", wikipage); if (setup != null) { wikipagepath setuppath = wikipage.getpagecrawler().getfullpath(setup); string setuppathname = pathparser.render(setuppath); buffer.append(\"!include -setup .\") .append(setuppathname) .append(\"\\n\"); } } buffer.append(pagedata.getcontent()); if (pagedata.hasattribute(\"test\")) { wikipage teardown = pagecrawlerimpl.getinheritedpage(\"teardown\", wikipage); if (teardown != null) { wikipagepath teardownpath = wikipage.getpagecrawler().getfullpath(teardown); string teardownpathname = pathparser.render(teardownpath); buffer.append(\"\\n\") .append(\"!include -teardown .\") .append(teardownpathname) .append(\"\\n\"); } if (includesuitesetup) { wikipage suiteteardown = pagecrawlerimpl.getinheritedpage( suiteresponder.suite_teardown_name, wikipage ); if (suiteteardown != null) { wikipagepath pagepath = suiteteardown.getpagecrawler().getfullpath (suiteteardown); string pagepathname = pathparser.render(pagepath); buffer.append(\"!include -teardown .\") .append(pagepathname) .append(\"\\n\"); } } } pagedata.setcontent(buffer.tostring()); return pagedata.gethtml(); } this is quite a convoluted function from which we can extract a few keypoints of things we should enforce when defining functions. the first rule of functions is that they should be small. the indent level should not be greater than 1 or 2. a function should do one thing and one thing only. we say the function does one thing by abstracting all of the inner steps. the statements within a function should be all on the same level of abstraction. every function should be defined so the program can be read from top to bottom. that is: 1 to print a string i have to create the string, show the string on the screen. 1.1 to create a string i have to create an array of characters and append each character 1.1.1 to create an array of characters i have to allocate memory 1.1.2 to append a character i have to find on memory the place i want to save it to and save its ascii 1.2. to show a string on the screen i have to show each character on the screen 1.2.1. to show a character on the screen i need to know its bitmap and print it on the screen ... use descriptive names that say exactly what the function does. a function should have zero arguments. they take a lot of conceptual power as they are on a different level of abstraction and they also make testing harder. output arguments are harder to understand than input arguments as we usually do not expect arguments to be modified, so it is best to steer clear of them. if your function must change the state of something, have it change the state of its owning object. avoid flag arguments as these booleans make the function do one thing if they are true and another if they are false. that is now our function does two things. use the keyword form of a function name, where we encode the names of the arguments into the function name. for example instead of assertequals we define assertexpectedequalsactual. avoid having side effects, where the function seems to do one thing but is also does some other hidden thing (e.g. updating an instance variable). apply the command query separation: functions should either change the state of an object, or it should return some information about that object. doing both often leads to confusion. prefer returning exceptions to error codes: when you return an error code, you create the problem that the caller must deal with the error immediately. try/catch blocks confuse the structure of the code and mix error processing with normal processing. functions should do one thing. error handing is one thing. so it is better to extract the bodies of the try and catch blocks out into functions of their own. public void delete(page page) { try { deletepageandallreferences(page); } catch (exception e) { logerror(e); } } private void deletepageandallreferences(page page) throws exception { deletepage(page); registry.deletereference(page.name); configkeys.deletekey(page.name.makekey()); } switch statements switch statements it violates our previous rule about functions doing only one thing, most usually swith function do as many things as clauses it has. also they may grow whenever a new case is added. in order to avoid this it is recommended swith statements be buried low on the abstraction hierarchy. for example, instead of creating a function that computes the pay with regards of the type of employee: public money calculatepay(employee e) throws invalidemployeetype { switch (e.type) { case commissioned: return calculatecommissionedpay(e); case hourly: return calculatehourlypay(e); case salaried: return calculatesalariedpay(e); default: throw new invalidemployeetype(e.type); } } we, instead, define an abstract factory that creates one type of employee or another, and where each type of employee decides how calculatepay is computed with polymorphism. public abstract class employee { public abstract boolean ispayday(); public abstract money calculatepay(); public abstract void deliverpay(money pay); } ----------------- public interface employeefactory { public employee makeemployee(employeerecord r) throws invalidemployeetype; } ----------------- public class employeefactoryimpl implements employeefactory { public employee makeemployee(employeerecord r) throws invalidemployeetype { switch (r.type) { case commissioned: return new commissionedemployee(r) ; case hourly: return new hourlyemployee(r); case salaried: return new salariedemploye(r); default: throw new invalidemployeetype(r.type); } } } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/PR/CC/03.html",
    "title": "Comments",
    "body": " index search search back comments contents good comments bad comments the proper use of comments is to compensate for our failure to express ourself in code. most often that not, comments also lie. the older a comment is, and the farther away it is from the code it describes, the more likely it is to be just plain wrong. therefore, though comments are sometimes necessary, we will expend significant energy to minimize them. good comments legal comments: for example, copyright and authorship statements are necessary and reasonable things to put into a comment at the start of each source file. informative comments: they are sometimes useful, but it is better to use the name of the function to convey the information where possible // format matched kk:mm:ss eee, mmm dd, yyyy pattern timematcher = pattern.compile( \"\\\\d*:\\\\d*:\\\\d* \\\\w*, \\\\w* \\\\d*, \\\\d*\"); explanation of intent: comments that provide the intent behind a decision. //this is our best attempt to get a race condition //by creating large number of threads. for (int i = 0; i < 25000; i++) { widgetbuilderthread widgetbuilderthread = new widgetbuilderthread(widgetbuilder, text, parent, failflag); thread thread = new thread(widgetbuilderthread); thread.start(); } clarification: in general it is better to find a way to make that argument or return value clear in its own right; but when its part of the standard library, or in code that you cannot alter, then a helpful clarifying comment can be useful. warning of consequences: sometimes it is useful to warn other programmers about certain consequences. // don't run unless you // have some time to kill. public void _testwithreallybigfile() { ... } todo comments\">todo comments\">todo comments: still, you don’t want your code to be littered with todos. amplification: used to amplify the importance of something that may otherwise seem inconsequential. string listitemcontent = match.group(3).trim(); // the trim is real important. it removes the starting // spaces that could cause the item to be recognized // as another list. docs in public apis: if you are writing a public api, then you should certainly write good javadocs for it. bad comments redundant comments: comments that are not more informative than the code itself. misleading comments: that say half truths and may confuse future maintainers. mandated comments: it is just plain silly to have a rule that says that every function must have a javadoc, or every variable must have a comment. journal comments: sometimes people add a comment to the start of a module every time they edit it. they are no longer necessary as we already have version control. position markers: a banner is startling and obvious if you don’t see banners very often. so use them very sparingly, and only when the benefit is significant. if you overuse banners, they’ll fall into the background noise and be ignored. // actions ////////////////////////////////// closing brace comments: sometimes programmers will put special comments on closing braces. it serves only to clutter the kind of small and encapsulated functions that we prefer. attributions and bylines: source code control systems are very good at remembering who added what, when. /* added by rick */ commented-out code: others who see that commented-out code won’t have the courage to delete it. they’ll think it is there for a reason and is too important to delete. nonlocal information: if you must write a comment, then make sure it describes the code it appears near. don’t offer systemwide information in the context of a local comment. too much information: don’t put interesting historical discussions or irrelevant descriptions of details into your comments. inobvious connection: the connection between a comment and the code it describes should be obvious. function headers: short functions don’t need much description. a well-chosen name for a small function that does one thing is usually better than a comment header. api docs in nonpublic code: generating javadoc pages for the classes and functions inside a system is not generally useful. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Calculus/CET/02_05.html",
    "title": "Continuity",
    "body": " index search search back continuity contents continuity of a function properties of continuous functions continuity of polynomial and rational functions continuous functions continuity of composite functions the intermediate value theorem continuity of a function a function \\(f\\) is continuous at a number \\(a\\) if: \\begin{align} \\lim_{x\\rightarrow a} f(x) = f(a) \\end{align} this definition implicitly requires: \\(f(a)\\) is defined \\(\\lim_{x\\rightarrow a} f(x)\\) exists \\(\\lim_{x\\rightarrow a} f(x) = f(a)\\) this definition says that \\(f\\) is continuous at \\(a\\) if \\(f(x)\\) approaches \\(f(a)\\) as \\(x\\) approaches \\(a\\). and we say that \\(f\\) is discontinuous at \\(a\\) if \\(f\\) is not continuous at \\(a\\). we distinguish three cases of discontinuity: removable discontinuity infinite discontinuity jump discontinuity a function \\(f\\) continuous from the right at a number \\(a\\) if: \\begin{align} \\lim_{x\\rightarrow a^{+}} f(x) = f(a) \\end{align} a function \\(f\\) continuous from the left at a number \\(a\\) if: \\begin{align} \\lim_{x\\rightarrow a^{-}} f(x) = f(a) \\end{align} a function \\(f\\) is continuous on an interval if it is continuous at every number on the interval. properties of continuous functions if \\(f\\) and \\(g\\) are continuous at a number \\(a\\) and \\(c\\) is constant, then the following functions are also continuous at \\(a\\): \\(f + g\\) \\(f - g\\) \\(cf\\) \\(f\\cdot g\\) \\(\\frac{f}{g}, g(a) \\neq 0\\) proof since \\(f\\) and \\(g\\) are continuous at \\(a\\) we have that: \\begin{align} \\lim_{x \\rightarrow a} f(x) = f(a) \\end{align} and \\begin{align} \\lim_{x \\rightarrow a} g(x) = g(a) \\end{align} by the properties of limits: \\begin{align} \\lim_{x \\rightarrow a} [f(x) + g(x)] = [\\lim_{x \\rightarrow a} f(x)] + [\\lim_{x \\rightarrow a} g(x)] \\end{align} \\begin{align} = f(a) + g(a) = (f + g)(a) \\end{align} and thus, \\(f + g\\) is continuous at \\(a\\). continuity of polynomial and rational functions any polynomial functions is continuous on \\(\\mathbb{r}\\). proof a polynomial is a function of the form: \\begin{align} p(x) = c_nx^n + c_{n-1}x^{n-1} + \\cdots + c_1x + c_0 \\end{align} where \\(c_i \\in \\mathbb{r}\\), we know that: \\begin{align} \\lim_{x \\rightarrow a} c_0 = c_0 \\end{align} and \\begin{align} \\lim_{x \\rightarrow a} x^m = a^m, m = 1, 2, \\cdots, n \\end{align} therefore: \\begin{align} \\lim_{x \\rightarrow a} p(x) = \\lim_{x \\rightarrow a} c_nx^n + c_{n-1}x^{n-1} + \\cdots + c_1x + c_0 \\end{align} by the properties of limits: \\begin{align} \\lim_{x \\rightarrow a} p(x) = \\sum_{i = 0}^n \\lim_{x \\rightarrow a} c_i x^{i} \\end{align} \\begin{align} = \\left(\\sum_{i = 1}^n \\lim_{x \\rightarrow a} c_i x^{i}\\right) + \\lim_{x \\rightarrow} c_0 \\end{align} \\begin{align} = \\left(\\sum_{i = 1}^n c_i a^i\\right) + c_0 \\end{align} \\begin{align} = p(a) \\end{align} thus \\(p\\) is continuous at \\(a\\), where \\(a \\in \\mathbb{r}\\). any ration function is continuous whenever it is defined, that is, it is continuous on its domain. proof a rational function is a function of the form: \\begin{align} f(x) = \\frac{p(x)}{q(x)} \\end{align} where \\(p\\) and \\(q\\) are polynomials. the domain of \\(f\\) is \\(d = \\{x \\in \\mathbb{r} | q(x) \\neq 0\\}\\). so we now, by the previous proof, that \\(p\\) and \\(q\\) are continuous everywhere. thus by the properties of continuous functions \\(f\\) is continuous at every number in \\(d\\) (its domain). continuous functions the following types of functions are continuous on their domains: polynomial functions rational functions root functions trigonometric functions inverse trigonometric functions exponential functions logarithmic functions note that the inverse of a continuous one-to-one function is also continuous. our geometric intuitions makes it seem plausible: we know that the graph of \\(f^{-1}\\) is obtained by reflecting the graph of \\(f\\) on the line \\(y = x\\). so if the graph of \\(f\\) has no break in it (the function is continuous), then the graph of \\(f^{-1}\\) also has no break in it. continuity of composite functions if \\(f\\) is continuous at \\(b\\) and \\(\\lim_{x \\rightarrow a} g(x) = b\\), then \\(\\lim_{x \\rightarrow a} f(g(x)) = b\\), that is: \\begin{align} \\lim_{x \\rightarrow a} f(g(x)) = f\\left(\\lim_{x \\rightarrow a} g(x)\\right) \\end{align} if \\(g\\) is continuous at \\(a\\) and \\(f\\) is continuous at \\(g(a)\\), then the composite function \\(f \\circ g\\), given by \\((f \\circ g)(x) = f(g(x))\\) is continuous at \\(a\\) proof since \\(g\\) is continuous at \\(a\\) we have that: \\begin{align} \\lim_{x \\rightarrow a} g(x) = g(a) \\end{align} since \\(f\\) is continuous at \\(b = g(a)\\) we have that: \\begin{align} \\lim_{x \\rightarrow a} f(g(x)) = f(b) = f(g(a)) \\end{align} thus \\(f \\circ g\\) is continuous at \\(a\\). the intermediate value theorem suppose that \\(f\\) is continuous at the closed interval \\([a, b]\\) and let \\(n\\) be any number between \\(f(a)\\) and \\(f(b)\\), where \\(f(a) \\neq f(b)\\). there there exists a number \\(c \\in (a, b)\\), such that \\(f(c) = n\\). the intermediate value theorem states that a continuous functions takes on every intermediate value between the function values \\(f(a)\\) and \\(f(b)\\) (see figure 8). $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/PR/CC/04.html",
    "title": "Formatting",
    "body": " index search search back formatting contents the purpose of formatting vertical formatting the newspaper metaphor vertical openness between concepts vertical density vertical distance vertical ordering horizontal formatting horizontal openness and density horizontal alignment indentantion team rules the purpose of formatting the coding style and readability set precedents that continue to affect maintainability and extensibility long after the original code has been changed beyond recognition. vertical formatting how big should a source file be? small files are usually easier to understand than large files are. the newspaper metaphor we would like a source file to be like a newspaper article. the name should be simple but explanatory. detail should increase as we move downward. vertical openness between concepts each blank line is a visual cue that identifies a new and separate concept package fitnesse.wikitext.widgets; import java.util.regex.*; public class boldwidget extends parentwidget { public static final string regexp = \"'''.+?'''\"; private static final pattern pattern = pattern.compile(\"'''(.+?)'''\", pattern.multiline + pattern.dotall ); public boldwidget(parentwidget parent, string text) throws exception { super(parent); matcher match = pattern.matcher(text); match.find(); addchildwidgets(match.group(1)); } public string render() throws exception { stringbuffer html = new stringbuffer(\"<b>\"); html.append(childhtml()).append(\"</b>\"); return html.tostring(); } } vertical density vertical density implies close association. so lines of code that are tightly related should appear vertically dense. vertical distance concepts that are closely related should be kept vertically close to each other to avoid forcing our readers to hop around through our source files and classes. variable declarations: variables should be declared as close to their usage as possible. instance variables: should all be declared in one well-known place (e.g. at the top of the class, at then end of the class). dependent functions: if one function calls another, they should be vertically close, and the caller should be above the callee, if at all possible. vertical ordering in general we want function call dependencies to point in the downward direction. that is, a function that is called should be below a function that does the calling. also, we expect the most important concepts to come first. horizontal formatting programmers clearly prefer short lines (80 to 120 characters). horizontal openness and density we use horizontal white space to associate things that are strongly related and disassociate things that are more weakly related. horizontal alignment using horizontal alignment to accentuate certain structures is not useful: public class fitnesseexpediter implements responsesender { private socket socket; private inputstream input; private outputstream output; private request request; private response response; private fitnessecontext context; protected long requestparsingtimelimit; private long requestprogress; private long requestparsingdeadline; private boolean haserror; indentantion a source file is a hierarchy rather like an outline. each level of this hierarchy is a scope into which names can be declared and in which declarations and executable statements are interpreted. and each level of hierarchy is differentiated using indentantion. this allows readers to quickly hop over scopes. breaking indentation: it is sometimes tempting to break the indentation rule for short if statements, short while loops, or short functions. however it is preferable to expand and indent those scopes. team rules a team of developers should agree upon a single formatting style. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/PR/CC/05.html",
    "title": "Objects and Data Structures",
    "body": " index search search back objects and data structures contents data abstraction data object anti-symmetry the law of demeter hybrids data transfer objects active record conclusion data abstraction hiding implementation is not just a matter of putting a layer of functions between the variables. hiding implementation is about abstractions! for example on the following excerpt we do not know how the point is defined, if by rectangular coordinates or by polar coordintes. public interface point { double getx(); double gety(); void setcartesian(double x, double y); double getr(); double gettheta(); void setpolar(double r, double theta); } data/object anti-symmetry objects hide their data behind abstractions and expose functions that operate on that data. data structure expose their data and have no meaningful functions. they are virtual opposites. procedural shape public class square { public point topleft; public double side; } public class rectangle { public point topleft; public double height; public double width; } public class circle { public point center; public double radius; } public class geometry { public final double pi = 3.141592653589793; public double area(object shape) throws nosuchshapeexception { if (shape instanceof square) { square s = (square)shape; return s.side * s.side; } else if (shape instanceof rectangle) { rectangle r = (rectangle)shape; return r.height * r.width; } else if (shape instanceof circle) { circle c = (circle)shape; return pi * c.radius * c.radius; } throw new nosuchshapeexception(); } } polymorphic shapes public class square implements shape { private point topleft; private double side; public double area() { return side*side; } } public class rectangle implements shape { private point topleft; private double height; private double width; public double area() { return height * width; } } public class circle implements shape { private point center; private double radius; public final double pi = 3.141592653589793; public double area() { return pi * radius * radius; } } this exposes the fundamental dichotomy between objects and data structures: procedural code (code using data structures) makes it easy to add new functions without changing the existing data structures. oo code, on the other hand, makes it easy to add new classes without changing existing functions. in any complex system there are going to be times when we want to add new data types rather than new functions. for these cases objects and oo are most appropriate. on the other hand, there will also be times when we’ll want to add new functions as opposed to data types. in that case procedural code and data structures will be more appropriate. the law of demeter the law of demeter says a module should not know about the innards of the objects it manipulates. more precisely, the law of demeter says that a method f of a class c should only call the methods of these: c an objects created by f an object passed as an argument to f an object held in an instance variable of c that is, the method should not invoke methods on objects that are returned by any of the allowed functions. hybrids the are structures that are hybrid structures which are half object and half data structure. they have functions that do significant things, and they also have either public variables or public accessors and mutators that make the private variables public. such hybrids make it hard to add new functions but also make it hard to add new data structures. data transfer objects the quintessential form of a data structure is a class with public variables and no functions. this is sometimes called a data transfer object, or dto. they are useful when communicating with databases or parsing messages from sockets, and so on and one should avoid adding business logic to these type of objects. active record active records are special forms of dtos. they are data structures with public variables; but they typically have navigational methods like save and find. typically these active records are direct translations from database tables, or other data sources. we should treat the active record as a data structure and to create separate objects that contain the business rules and that hide their internal data. conclusion objects expose behavior and hide data. this makes it easy to add new kinds of objects without changing existing behaviors. it also makes it hard to add new behaviors to existing objects. data structures expose data and have no significant behavior. this makes it easy to add new behaviors to existing data structures but makes it hard to add new data structures to existing functions. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/PR/CC/06.html",
    "title": "Error Handling",
    "body": " index search search back error handling contents use exceptions rather than return codes write your try-catch-finally statement first use unchecked exceptions provide context with exceptions define exception classes in terms of a caller s needs don t return null don t pass null conclusion error handling is important, but if it obscures logic, it’s wrong. use exceptions rather than return codes the problem with using return codes is that they clutter the caller. the caller must check for errors immediately after the call. unfortunately, it’s easy to forget. for this reason it is better to throw an exception. the code is better because two concerns that were tangled, the algorithm for device shutdown and error handling, are now separated. write your try-catch-finally statement first one of the most interesting things about exceptions is that they define a scope within your program. your catch has to leave your program in a consistent state, no matter what happens in the try. for this reason it is good practice to start with a try-catch-finally statement when you are writing code that could throw exceptions. this helps you define what the user of that code should expect. use unchecked exceptions with unchecked exceptions the signature of every method would list all of the exceptions that it could pass to its caller. these exceptions were part of the type of the method. your code wouldn't compile if the signature didn’t match what your code could do. the price of checked exceptions is an open/closed principle1 violation. if you throw a checked exception from a method in your code and the catch is three levels above, you must declare that exception in the signature of each method between you and the catch. this means that a change at a low level of the software can force signature changes on many higher levels. in general application development the dependency costs outweigh the benefits. provide context with exceptions each exception that you throw should provide enough context to determine the source and location of an error by using informative error messages. define exception classes in terms of a caller's needs wrapping third-party apis is a best practice. when you wrap a third-party api, you minimize you dependencies upon it. wrapping also makes it easier to mock out third-party calls when you are testing your own code. one final advantage of wrapping is that you aren’t tied to a particular vendor's api design choices. don't return null if you are tempted to return null from a method, consider throwing an exception or returning a special case object instead. if you are calling a null-returning method from a third-party api, consider wrapping that method with a method that either throws an exception or returns a special case object. you will minimize the chance of nullpointerexceptions and your code will be cleaner. don't pass null you should avoid passing null in your code whenever possible. in most programming languages there is no good way to deal with a null that is passed by a caller accidentally. because this is the case, the rational approach is to forbid passing null by default. conclusion clean code is readable, but it must also be robust. these are not conflicting goals. we can write robust clean code if we see error handling as a separate concern, something that is viewable independently of our main logic. to the degree that we are able to do that, we can reason about it independently, and we can make great strides in the maintainability of our code. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/3C_1C/ICPDM/M01/01_intro.html",
    "title": "Introducción a Big Data",
    "body": " index search search back introducción a big data contents origen e historia diferencias entre big data machine learning e inteligencia artificial las cinco v del big data desaf os del big data aplicaciones y casos de uso beneficios del big data el big data son conjuntos de datos cuya principal característica es que su tamaño es tal que no podemos utilizar el software de procesamiento convencional. estos conjuntos de datos pueden ser estructurados, semiestructurados o no estructurados. origen e historia los orígenes de los datos masivos se remontan a los años 60 y 70, cuando estábamos apenas comenzando con los primeros centros de datos y las bases de datos relacionales. en el 2005, la gente se dio cuenta de la cantidad de datos que estábamos generando en plataformas online. fue entonces cuando salió a la luz hadoop, un sistema diseñado para guardar y analizar grandes cantidades de datos. también en esa época, las bases de datos nosql (no solo sql) hicieron sus primeras apariciones. los frameworks de código abierto como hadoop (y más recientemente, spark) provocaron que manejar y guardar esta cantidad de datos fuese más sencillo y barato. desde entonces la cantidad de datos sigue creciendo, con la diferencia de que ahora no sólo somos nosotros mismos los que generamos los datos si no que también las máquinas toman parte. con la llegada del internet de las cosas (iot), hay cada vez más objetos conectados a la red recopilando datos sobre cómo usamos las cosas y el rendimiento de los productos. y no podemos olvidar el auge del aprendizaje automático, que está generando aún más datos. la magia del cloud computing ha ampliado las posibilidades del big data. en la nube, los desarrolladores pueden escalar cosas de forma ágil y rápida. además, las bases de datos de gráficos son cada vez más populares e importantes, mostrando toneladas de datos de forma rápida y completa. diferencias entre big data, machine learning e inteligencia artificial el machine learning está dentro de la inteligencia artificial, sin embargo, no toda inteligencia artifical es machine learning. de la misma forma podemos ver cómo el concepto de big data no está dentro de la inteligencia artificial, sino que tiene otras características. aquella parte donde confluyen machine learning y big data recibe el nombre de big data analytics, un concepto relacionado con el dato puesto al servicio del entrenamiento de modelos con el fin de analizar patrones en los datos, predecir comportamientos, etc. big data analytics proporciona los datos que la ia y el ml necesitan para aprender y mejorar. la ia y el ml pueden utilizarse para analizar grandes conjuntos de datos y encontrar patrones y conocimiento oculto. este conocimiento puede utilizarse para mejorar los procesos de negocio, desarrollar nuevos productos y servicios y tomar mejores decisiones. por ejemplo: análisis de clientes: para comprender mejor sus necesidades y preferencias. detección de fraude: al analizar las transacciones, se pueden extraer diferentes métricas y detectar así actividades fraudulentas. desarrollo de nuevos productos: podemos identificar las distintas necesidades de los clientes y crear nuevos productos que las satisfagan. las cinco \"v\" del big data el concepto de las v's del big data ha evolucionado con el tiempo, comenzando con 3 v's: volumen, velocidad y variedad y ampliándose a 5 con valor y veracidad y, en algunos casos, hasta 7 v's: variabilidad y visualización. volumen: se refiere a la enorme cantidad de datos generados y recopilados. variedad: hace referencia a la diversidad de tipos de datos (datos estructurados y datos no estructurados). velocidad: se refiere a la velocidad a la que se generan, procesan y analizan los datos. veracidad: relacionada con la calidad y la confiabilidad de los datos. valor: capacidad para convertir los datos en valor significativo para la toma de decisiones y la obtención de información. desafíos del big data infraestructuras para los datos: la gestión y el almacenamiento de los datos pueden ser costosos y complicados. es necesario crear infraestructuras robustas y escalables. velocidad de procesamiento: el análisis en tiempo real y la capacidad de procesar datos rápidamente son fundamentales en muchos casos. veracidad de los datos: los datos deben proceder de fuentes confiables que aseguren una toma de decisiones correcta. privacidad y seguridad: con la creciente adquisición de los datos la privacidad de los usuarios y la seguridad de la información pueden estar amenazadas. esto deriva en la implantación de leyes y normas que regulen la privacidad y seguridad de los datos. elevados costos: implementar y mantener infraestructuras y tecnologías de big data puede conllevar una importante inversión. profesionales especializados: existe una demanda creciente de profesionales con habilidades en el manejo, limpieza y análisis de datos masivos. la escaseza de los mismos puede suponer un desafío. interoperabilidad: la integración de diferentes sistemas y tecnologías puede resultar difícil y ser un verdadero desafío especialmente cuando se trabaja con conjuntos de datos provenientes de diversas fuentes y en diferentes formatos. gobernanza: gestionar y gobernar los datos de forma eficaz es un reto importante para las empresas que gestionan conjuntos masivos de datos. aplicaciones y casos de uso salud: poder mejorar la atención al paciente, desarrollar nuevos medicamentos y tratamientos, y prevenir enfermedades con antelación. finanzas: la detección del fraude, gestionar los riesgos de la concesión de créditos y blanqueo de capitales y tomar decisiones de inversión. marketing: comprender el comportamiento de los clientes, personalizar las recomendaciones y mejorar las campañas de marketing. transporte: la optimización de rutas, mejorar la seguridad y reducir el tráfico. gobierno: las campañas electorales, creación de planes de fidelización político-social. beneficios del big data toma de decisiones: las empresas pueden tomar mejores decisiones al proporcionarles más información mediante la explotación de los datos. mejora de la eficiencia: la eficiencia de los procesos de automatización pueden llevar a mejorar la productividad y reducir costos. innovación: para la innovación de las estrategias o en la creación de nuevos productos el big data puede proporcionar nuevas ideas y perspectivas. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/3C_1C/ICPDM/M01/02_hadoop.html",
    "title": "El Núcleo de Hadoop",
    "body": " index search search back el núcleo de hadoop contents fundamentos y herramientas del ecosistema de hadoop la evoluci n de hadoop caracter sticas de hadoop c digo abierto distribuido escalable tolerante a fallos estructura de hadoop sistema de ficheros distribuidos qu es hadoop distributed file system hdfs sistema distribuido escalabilidad horizontal estructura jer rquica arquitectura y componentes namenode datanode escritura en hdfs lectura en hdfs comandos de hdfs listar ficheros leer y escribir ficheros cargar y descargar ficheros gesti n de ficheros gesti n de permisos gesti n de administraci n yarn gesti n de recursos por qu surge yarn arquitectura y componentes resource manager node manager application master secuencia de trabajo en hadoop yarn federaci n en hadoop yarn fundamentos y herramientas del ecosistema de hadoop la naturaleza de los datos masivos hace que la utilización de sistemas de almacenamiento y procesamiento tradicionales, como las bases de datos relaciones, sea inviable. el ecosistema de hadoop es un entorno software que permite alamcenar, procesar y analizar este tipo de datos de forma eficiente. la evolución de hadoop a principio de los 2000 e inspirado por las innovaciones en sistemas distribuidos de google (google file system y el modelo de programación mapreduce), doug cutting desarrolla una alternativa en código abierto a estas tecnologías. inicialmente se crearon dos partes: hadoop distributed file system (hdfs): una manera de almacenar grandes cantidades de datos. mapreduce: un sistema para procesar estes datos distribuidos. tras el éxito de hadoop surgieron otros proyectos como hive, pig y sparkk que ampliaron lo que se podía hacer con hadoop. en la actualidad hadoop es un estándar en el big data y es utilizado en muchas industrias diferentes. características de hadoop código abierto el código fuente de hadoop se encuentra disposible públicamente, lo cual fomenta innovación ya que distintos desarrolladores pueden trabajar en mejorar el software. distribuido se trata de una plataforma de computación distribuida que ha sido diseñada para poder manejar grandes volúmenes de datos en múltiples nodos de un clúster de servidores. de tal manera que hadoop puede distribuir la carga de trabajo y los datos entre varios nodos. esto permite procesamiento en paralelo y escalable. escalable la escalabilidad de hadoop se puede entender en dos dimensiones: escalabilidad horizontal: se añaden más nodos al clúster para aumentar la capacidad de almacenamiento y de procesamiento cuando la demanda así lo requiere. escalabilidad vertical: se puede aumentar la capacidad de cpu, memoria y almacenamiento de nodos individuales para majera tareas más grandes o complejas. tolerante a fallos se ha diseñado hadoop de tal manera que se mantiene la disponibilidad del servicio y la integridad de los datos incluso cuando ocurren fallos en el hardware o en el software del sistema. esta tolerancia se obtiene mediante: la replicación de datos. la autorecuperación. la monitorización constante del estado del clúster. estructura de hadoop en 2006 se ceden los dos componentes que formaban hadoop a apache software foundation. en 2012 se publica la versión 1.0 y seguidamente en 2013 se publica la versión 2.0 en la cual se introduce yarn como gestor de recursos y se desacoplan los módulos hdf y mapreduce. finalmente en 2017 se publica la versión 3.0. actualmente hadoop se conforma de los siguientes componentes principales: hadoop distributed system (hdf): sistema distribuido de almacenamiento primario de datos. este divide los datos en bloques y los distribuye en varios nodos del clúster para garantizar la tolerancia a fallos y la escalabilidad. mapreduce: proporciona un modelo de programación y procesamiento distribuido para realizar operaciones en conjuntos de datos distribuidos almacenados en hdf. este divide las tareas en dos fases: map: los datos se procesan y se filtran en tareas más pequeñas que se ejecutan de forma paralela en diferentes nodos del clúster. reduce: los resultados intermedios de las tareas de combinan y se procesan para producir el resultado final. yet another resource negotiator (yarn): es el administrados e recursos del clúster. se encarga de gestionar recursos de procesamiento (cpu, memoria). también permite la programación dinámica de tareas y la adminitración eficiente de recursos. sistema de ficheros distribuidos ¿qué es hadoop distributed file system (hdfs)? hadoop crea una capa de abstracción en forma de sistema de ficheros único. tal que se encarga de almacenar los datos en varios nodos manteniendo sus metadatos. sistema distribuido en este sistema de ficheros los ficheros de dividen en bloques de un mismo tamaño (normalmente 128mb, pero es configurable) y se distribuyen en los nodos del clúster. cada uno de los bloques se replicará en varios nodos para que el sistema sea tolerante a fallos. para este tipo de sistemas no es óptimo que los ficheros tengan un tamaño pequeño. por ejemplo, si tenemos un fichero de 800mb, lo dividiríamos en siete bloques. seis serán de 128mb y el último será de 32mb escalabilidad horizontal la escalabilidad horizontal se implementa aumentando el espacio por medio de discos duros o añadiendo más nodos al sistema. este tipo de escalabilidad es más sencilla que la escalabilidad vertical ya que consiste en añadir hardware básico. estructura jerárquica decimos que hdfs es jerárquico, ya que existe una jerarquía de directorios y ficheros. arquitectura y componentes sigue una arquitectura maestro-esclavo con dos componentes principales: namenodes y datanodes. namenode almacena los metadatos de hdfs, incluyendo información acerca de la estructura de directorios, los permisos en los archivos y la ubicación física de los bloques de datos. en un clúster hdfs sólo hay un namenode, y su disponibilidad es crucial, si este no es accesible este supone un error crítico en el sistema. por ello, a partir de hadoop 2 es posible configurar un namenode secundario en espera, o más de uno a partir de hadoop 3. estes nodos toman el control si se detecta algún fallo en el nodo primario. es importante que los nodos esten sincronizados y que tengan los mismos metadatos que el nodo primario. datanode este tipo de nodos son los encargados de almadenar los datos y de recuperar los bloques de datos que conforman los archivos así como de gestionar el almacenamiento del nodo. además deben informar periódicamente del estado de los bloques al namenode. la pérdida de un datanode no afecta significativamente a la integridad del sistema, pero la pérdida de muchos podría afectar a la disposibilidad y a la redundancia de los datos. escritura en hdfs cliente solicita la escritura al namenode namenode asigna bloques consultando su tabla de metadatos para determinar qué datanodes deben contener los bloques del archivo. devuelve esta lista de datanodes al cliente. escritura de datos en datanodes por parte del cliente. confirmación al namenode por parte de los datanodes. el namenode actualiza su tabla de metadatos con la nueva información acerta de la ubicación de los bloques de datos del archivo. lectura en hdfs cliente solicita la lectura de un archivo al namenode. el namenode consulta su tabla de metadatos y devuelve la ubicación del archivo al cliente. el cliente solicita los bloques de datos a los datanodes donde están almacenados y estes devuelven los bloques. el cliente reconstruye el archivo a partir de los bloques. el namenode actualiza su tabla de metadatos con nueva información acerca de la ubicación de los bloques de datos del archivo. comandos de hdfs listar ficheros comando descripción hdfs dfs -ls / lista todos los ficheros y directorios para el path / hdfs dfs -ls -h / lista los ficheros con su tamaño en formato legible hdfs dfs -ls -r / lista todos los ficheros y directorios recursivamente (con subdirectorios) hdfs dfs -ls /file* lista todos los ficheros que cumplen el patrón (ficheros que comienzan con 'file') hadoop fs -stat «type:%f» / imprime estadísticas del fichero o directorio en el formato indicado leer y escribir ficheros comando descripción hdfs dfs -text /app.log imprime el fichero en modo texto por la terminal hdfs dfs -cat /app.log muestra el contenido del fichero en la salida estándar hdfs dfs -appendtofile /home/file1 /file2 añade el contenido del fichero local 'file1' al fichero en hdfs ‘file2’ cargar y descargar ficheros comando descripción hdfs dfs -put /home/file1 /hadoop copia el fichero 'file1' del sistema de ficheros local a hdfs en la carpeta \"hadoop\" hdfs dfs -put -f /home/file1 /hadoop copia el fichero 'file1' del sistema de ficheros local a hdfs y lo sobreescribe en el caso de que ya exista hdfs dfs -put -l /home/file1 /hadoop copia el fichero 'file1' del sistema de ficheros local a hdfs. fuerza replicación 1 y permite al datanode persistir los datos de forma perezosa. hdfs dfs -put -p /home/file1 /hadoop copia el fichero 'file1' del sistema de ficheros local a hdfs. mantiene los tiempos de acceso, de modificación y propietario original hdfs dfs -get /file1 /home/ copia el fichero 'file1' de hdfs al sistema de ficheros local hdfs dfs -copytolocal /file1 /home/ copia el fichero 'file1' de hdfs al sistema de ficheros local (igual que el anterior) hdfs dfs -movefromlocal /home/file1 /hadoop copia el fichero 'file1' del sistema de ficheros local a hdfs y luego lo borra del sist. ficheros local gestión de ficheros comando descripción hdfs dfs -cp /hadoop/file1 /hadoop1 copia el fichero al directorio destino en hdfs hdfs dfs -cp -p /hadoop/file1 /hadoop1 copia el fichero al directorio destino en hdfs conservando tiempos de acceso y de modificación, propietario y modo hdfs dfs -rm /hadoop/file1 elimina el fichero 'file1' de hdfs y lo envía a la papelera hdfs dfs -rm -r /hadoop elimina el directorio y su contenido en hdfs hdfs dfs -rm -r /hadoop elimina el directorio y su contenido en hdfs hdfs dfs -rmr /hadoop elimina el directorio y su contenido en hdfs hdfs dfs -rm -skiptrash /file1 elimina el fichero sin dejarlo en la papelera hdfs dfs -mkdir /hadoop2 crea un directorio en hdfs hdfs dfs -touchz /hadoop3 crea un fichero en hdfs con tamaño 0 hadoop fs -getmerge -nl /file1 /file2 /output concatena los ficheros file1 y file2 en el fichero destino /output gestión de permisos comando descripción hdfs dfs -checksum /hadoop/file1 muestra la información checksum del fichero hdfs dfs -chmod 775 /hadoop/file1 cambia los permisos del fichero en hdfs hdfs dfs -chmod -r 755 /hadoop cambia los permisos de los ficheros recursivamente hdfs dfs -chown hadoop:hadoop /file1 cambia el propietario y el grupo del fichero hdfs dfs -chown -r hadoop:hadoop /file1 cambia el propietario y el grupo recursivamente hdfs dfs -chgrp hadoop /file1 cambia el grupo del fichero gestión de administración comando descripción hdfs dfs -df /hadoop muestra la capacidad y el espacio libre y usado del sistema de ficheros hdfs dfs -df -h /hadoop muestra la capacidad y el espacio libre y usado del sistema de ficheros en formato legible hadoop version muestra la versión de hadoop hdfs fsck / comprueba el estado de salud del sistema de ficheros hdfs dfsadmin -safemode leave deshabilita el modo seguro del namenode hdfs namenode -format formatea el namenode hadoop fs -test -e filename si el path existe en hdfs, devuelve 0 hadoop fs -setrep -w 3 /file1 cambia el factor de replicación de un fichero a 3. si se indica un directorio, cambia el factor de replicación de todos los ficheros que contiene yarn: gestión de recursos por qué surge yarn? yarn se encarga de administrar y asignar recursos a las diversas aplicaciones que se ejecutan en el clúster de hadooop. algunos de los objetivos principales de yarn son la escalabilidad, la eficiencia y la capacidad de ejecutar múltiples frameworks de procesamiento de datos no sólo mapreduce. en la verisón 1, mapreduce contaba con un administrador de recursos y un planificador interno. yarn permite separar la gestión de recursos de la lógica de programación. anteriormente se presentaban muchas limitaciones al no admitir apliaciones que siguiesen el modelo mapreduce (como el análisis de grafos) y era necesario transladar los datos a otras plataformas. a partir de hadoop 2 la utilización de otros frameworks (giraph para análisis de datos, storm para análisis de datos en tiempo real, etc) es transparente. esto permite una mejor utilización de los recursos del clúster y una mayor flexibilidad en la ejecución de aplicaciones. arquitectura y componentes yarn consta de tres componentes principales: resource manager, node manager y application master. resource manager se trata del maestro del clúster y se encarga de aceptar las solicitudes de recursos de las aplicaciones, negociar los recursos con los nodos y asignar recursos a la aplicaciones mediante un planificador. cabe destacar que este planificador no ofrece garantías de ejecución de la aplicaciones ni las monitoriza. existe un segundo componente denominado gestor de aplicaciones que se encarga de aceptar las peticiones de trabajos, negocial el contenedor para la ejecutación de la aplicación y proporcionar, en caso de error, el reinicio de los trabajos. node manager se ejecutan en cada nodo y son los encargados de administrar los recursos locales (cpu, almacenamiento, memoria) y reportar su disponibilidad al resource manager. también gestiona el lanzamiento y la supervisión de los contenedores que ejecutan las tareas de las aplicaciones y mapean las variables de entorno necesarias, descargan las dependencias y los servicios necesarios para crar los procesos. application master se crea y ejecuta para cada aplicación dentro de un contenedor. es el responsable de negociar los recursos con el resouce manager y de supervisar el progreso de la aplicación. secuencia de trabajo en hadoop yarn el cliente envía una aplicación yarn al resource manager el resource manager reserva recursos en contenedores para la ejecución de la aplicación el application manager se registra con el resource manager y solicita los recursos necesarios para la aplicación el application manager notifica al node manager la ejecución de los contenedores asignados la aplicación yarn se ejecuta en le contenedor correspondiente el application master supervisa la ejecución y reporta el estado al resource manager y al application manager al finalizar la ejecución el application manager notifica al resource manager federación en hadoop yarn la federación en hadoop yarn pemite la conexión de múltiples clústeres yarn para formar un clúster lógico único. de esta manera podemos lograr una gestión centralizada de recursos lo cual simplifica su administración. una de las ventajas clave es el escalamiento horizontal sin límites dados por el tamaño del clúster. por lo tanto, se facilita la ejecución de trabajos de gran embergadura y distribuidos. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/3C_1C/ICPDM/M01/03_mapreduce.html",
    "title": "Programación MapReduce",
    "body": " index search search back programación mapreduce contents el paradigma de programaci n mapreduce hadoop streaming qu es mapreduce fases de map reduce hadoop streaming ejemplo pr ctico de mapreduce optimizaci n combiners y partitioner programaci n mapreduce con lenguajes de alto nivel hive introducci n a apache hive arquitectura de apache hive cliente cat logo centralizado metastore driver de gesti n hiveql parser optimizador y planificador de consultas motor de ejecuci n almacenamiento de datos estructura interna tipos de datos estructura de datos tablas particiones buckets el paradigma de programación mapreduce: hadoop streaming ¿qué es mapreduce? el flujo de procesamiento de mapreduce se divide en dos etapas: map y reduce las cuales se ejecutan de manera distribuida en distintos nodos de procesamiento mientras que un proceso central denominado job tracker controla su ejecución. fases de map reduce map: los datos de entrada se subdividen en bloques independientes que son procesados de forma paralela por los mappers. normalmente hadoop intenta ejecutar los mappers en los nodos donde se encuentran los datos sobre los que va a trabajar (data locality). esto reduce los tiempos de acceso a los datos y la necesidad de transferencia de datos entre nodos. shuffle & sort: los datos intermedios de los mappers se ordenan. este proceso comienza mientras las tareas map están en progreso, a medida que van terminando. no es necesario esperar a que todas terminen. reduce: comienza cuando todos los datos han sido ordenados en shuffle & sort. recibe como entrada estes datos ordenados estructurados como pares clave valor agrupados por clave. cada reducer toma los valores asociados a una clave y los agrega/procesa y devuelve el resultado como salida que se puede almacenar en hdfs o en otro sistema. generalmente se concatenan varias fases de mapper-reducer para completar una tarea. hadoop streaming hadoop streaming se trata de una utilidad que permite ejecutar aplicaciones en hadoop escritas en cualquier lenguaje, a pesar de que hadoop este escrito en java. este proporciona un interfaz de entrada y de salida (stdin/stdout) que es consumida por las aplicaciones, tal que existe una pasarela de datos que actúa como comunicación entre hadoop y la aplicación. en la imagen anterior se muestra el flujo de un trabajo mapreduce. se leen los datos de entrada y se produce una lista de pares clave-valor. se proporcionan los datos en este formato a un mapper externo a través del canal estándar de entrada. se devuelve el resultado de los mapper en el mismo formato a través del canal estándar de salida. se proporcionan los datos procesados por los mapper al reducer externo a través de la entrada estándar. se devuelve el resultado del reducer a través de stdout. finalmente se almacena el resultado del reducer, bien en hdfs o en otro sistema externo. como podemos ver en todas las fases del proceso de mantiene siempre la estructura de pares clave-valor. ejemplo práctico de mapreduce para ejemplificar mapreduce planteamos el siguiente problema: queremos obtener la frecuencia de cada palabra en un documento. map: dividimos el proceso en dos mappers (idealmente cada proceso mapper se debería de ejecutar en el nodo en el cual se encuentra el bloque de datos). estes se encargan de obtener la frecuencia de las palabras en la \"porción de texto\" sobre el que trabajan. shuffle & sort: se ordenan y se agrupan los valores por la clave, donde la clave en nuestro caso es la palabra y el valor su frecuencia. reduce: se ejecuta un reducer por cada clave presente en el resultado, que agrupa (en nuestro caso suma) los valores bajo cada clave, es decir las frecuencias asociadas a la palabra. optimización: combiners y partitioner mapreduce cuenta con dos componentes para optimizar el procesamiento denominados combiners y partitioners. combiners: agrupan los resultados de cada mapper antes de llegar a la frase de shuffle and sort con el objetivo de reducir el tamaño de los datos que se le proporcionan al reducer. partitioners: se utilizan para determinar cómo se distribuyen los datos a cada reducer. por defecto hadoop distribuye la carga de trabajo de manera uniforme entre los reducers, pero se puede personalizar utilizando los partitioners. programación mapreduce con lenguajes de alto nivel: hive introducción a apache hive hive fue creado por facebook en el año 2007. se trata de una abstracción sobre hadoop, que permite utilizar su lenguaje de consulta, hiveql, para generar de manera automática programas mapreduce. arquitectura de apache hive cliente existen varias maneras de interactuar con hive: interfaz web su interfaz de línea de comandos (cli), beeline hiveserver: un servidor thrift de hive que permite acceder a través de jdbc, odbc o thrift api. catálogo centralizado: metastore hive almacena los metadatos (esquemas de las tablas, tipos de datos, etc) en un catálogo centralizado denominado metastore, que se trata de una base de datos relacional. existen tres tipos de configuraciones: embedded metastore: se integra el código en el mismo proceso que el programa hive y la base de datos. generalmente utilizado en entornos de prueba. local metastore: se ejecuta de manera local pero en un proceso distinto. remote metastore: se configura en remote, tal que se desliga el metastore del resto de procesos. generalmente se utiliza en entornos de producción. driver de gestión es el encargado de gestionar una consulta hiveql durante todo su ciclo de vida. hiveql parser se encarga de transformar las consultas en hiveql a programas mapreduce. optimizador y planificador de consultas optimizador de consultas: reorganiza la consulta para poder optimizarla mediante técnicas como el filtrado anticipado. planificador de consultas: decide cómo y cuándo se ejecutan las consultas. motor de ejecución se encarga de ejecutar la tarea de consulta de forma distribuida y paralela en los nodos del cluster de hadoop. almacenamiento de datos los datos deben estar almacenados en hdfs y generalmente se almacenan en un formato aceptado por bases de datos relacionalales (p.ej. csv) o formatos que se integran con hive como parquet o avro. estructura interna hive impone sobre hdfs una estructura propia que llamaremos esquema o schema, la cual es almacenada en su propia base de datos (metastore). tipos de datos hive soporta tipos de datos primitivos: string, int, boolean y otros tipos de datos como date, así como tipos de datos compuestos: array: son grupos de elementos del mismo tipo. map: define elementos clave-valor: {1: \"flor, 2: \"hoja\", 3: \"perro\", 4: \"gato} struct: permite crear objetos: {\"animal\": \"perro\", \"tipo\": \"mamífero\", \"numero_patas\": 4} estructura de datos tablas las tablas están compuestas por filas y columnas y tienen esquemas bien definidos, pero tienen una estructura lógica que se corresponde con una carpeta en hdfs. existen dos tipos de tablas: tabla interna (o gestionada): son tablas gestionadas por hive. cuando se crea una tabla interna automáticamente se crea un carpeta en hdfs y hive controla tanto la tabla como sus datos. si esta tabla se borra también se borra la carpeta en hdfs. -- creación tabla interna create table libros ( id int, titulo string, autor string, categoria string); ) row format delimited fields terminated by ',' stored as textfile; tabla externa: se trata de una tabla populada con datos ya existentes en hdfs. su estructura se define en la metastore y si borramos la tabla no se borra su contenido en hdfs. esta opción es útil cuando compartimos datos entre distintas herramientas. -- creación tabla externa create external table libros_externa ( id int, titulo string, autor string, categoria string); ) row format delimited fields terminated by ',' stored as textfile location '/curso-bigdata/externa/libros'; en la tabla anterior se indica la ubicación de los datos utilizando location. el término stored as indica el formato del fichero en el que residen los datos. particiones las particiones son subdivisiones en una tabla hive que permite la optimización de las consultas eliminando valores irrelevantes. las subdivisiones se realizan en base a los valores de las columnas, por ejemplo si tenemos una variable nominal se podría particionar la tabla según las distintas categorías. existen dos tipos de particiones: particiones estáticas: son definidas por parte del usuario pero no cambian en el tiempo. particiones dinámicas: hive se ocupa de crear automáticamente las particiones basándose en los valores de la columna especificada. -- creación tabla con particiones create table libros_particion ( id int, titulo string, autor string, ) partitioned by (categoria string); -- insertar datos insert into table libros_particion partition (categoria=fantástico) values (1, 'harry potter y la piedra filosofal', 'j.k. rowling'); (2, 'harry potter y la cámara secreta', 'j.k. rowling'); -- etc buckets los buckets son otra técnica de división de datos, estes están identificados mediante un par 'clave, valor' que distribuye los datos según una función hash. el objetivo principal para utilizar buckets es optimizar las consultas, sobre todo cuando estas son de tipo join o unión. podemos realizar los buckets bien de forma dinámica o estática. la diferencia radica en la elección de la columna que especifiquemos en la cláusula clustered by. -- creación tabla con buckets create table prestamos ( id int, libro_id int, fecha_prestamo string, socio_id int, ) clustered by (libro_id) into 5 buckets; $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/3C_1C/ICPDM/M01/04_data.html",
    "title": "Inyección/Extracción y Serialización/Deserialización de los Datos",
    "body": " index search search back inyección/extracción y serialización/deserialización de los datos contents apache flume las fuentes de datos batch vs streaming herramientas para la inyecci n y extracci n de datos apache scoop apache flume ventajas desventajas arquitectura de apache flume agentes eventos flujo de datos apache avro serializaci n deserializaci n la evoluci n de los formatos estructura la evoluci n de los esquemas ventajas ejemplo de esquema apache parquet formato columnar ventajas apache parquet estructura de un fichero parquet apache flume las fuentes de datos las empresas buscan tener todos sus datos centralizados, sean de la naturaleza que sean. tal que existirá una única fuente de verdad o single source of truth que permite la consistencia de los datos. bajo esta premisa nacen los conceptos de data lake y data warehouse. en un data warehouse los datos deberán adaptarse a una estructura definida antes de poder ser guardados. se utilizan los procesos etl de extracción, transformación y carga para adaptar los datos y su formato a la estructura definida antes de volcarlos. en un data lake los datos se guardan tal cual se reciben, pero pueden ser transformados antes de su extracción. este utiliza procesos elt en los que primero se realiza la carga y cuando queramos extraer información útil de dichos datos, realizaremos una transformación en caso de ser necesario. batch vs streaming el procesamiento batch se da cuando los datos a procesar se encuentran en un almacén de datos estático y estes son finitos, tal que se escogen y procesan por lotes. el procesamiento streaming es el procesamiento sobre datos que fluyen a través de un sistema, conforme se van añadiendo al mismo. estes datos no son finitos y la toma de decisiones sobre ellos se hace en tiempo real. a continuación mostramos las diferencias entre los dos tipos de procesamiento:   procesamiento batch procesamiento streaming hardware los recursos deben ser capaces de procesar y almacenar grandes conjuntos de datos los datos tienen menor tamaño, por lo que los requisitos computacionales y el almacenamiento puede ser menor latencia la latencia puede ser de minutos, horas o días. la latencia debe ser en segundos o milisegundos. tamaño del conjunto de datos grandes lotes de datos. un paquete de datos o varios de ellos, siempre de tamaño menor. análisis cálculo complejo y análisis en un marco temporal más amplio. informes o cálculos simples sobre los datos. herramientas para la inyección y extracción de datos a continuación comentaremos las herramientas que nos permiten la ingesta y extracción de los datos de forma masiva. apache scoop está pensado para la transferencia de datos desde un almacén estructurado a otro y utiliza procesamiento por lotes. sin embargo, desde junio de 2021 el proyecto sqoop dejó de tener continuidad. apache flume flume es un software para la ingesta de datos masivos en streaming. fue presentado por cloudera en el año 2010 y posteriormente se incorporó bajo licencia apache como open source a la fundación apache. flume está basado en el flujo de datos en streaming de eventos sencillos y permite la lectura y escritura de múltiples fuentes de datos. además de ello, flume tiene mecanismos que aseguran la fiabilidad y confiabilidad de los datos. ventajas puede manejar grandes volúmenes de datos eficientemente distribuyendo la carga entre múltiples agentes. presenta una gran flexibilidad, ya que nos permite recoger datos de diversas fuentes sin atender a su formato. se integra perfectamente con el ecosistema hadoop. presenta tolerancia a fallos. desventajas puede resultar difícil configurar los parámetros adecuados para los agentes. esto puede derivar en un fenómeno conocido como backpressure que ocurre cuando el volumen de datos entrantes supera a la cantidad de datos que pueden ser consumidos por flume dando lugar a pérdida de eventos y por lo tanto de información, para evitar esto hay que configurar adecuadamente a los agentes. está estrechamente ligado a la ingesta de datos en hadoop, para la ingesta en otro tipo de sistemas podemos utilizar herramientas como kafka. no ofrece herramientas para el monitoreo y diagnóstico de errores de forma clara para el usuario. arquitectura de apache flume agentes se trata de un conjunto de componentes independientes que dirigen los eventos desde la entrada a la salida. además los agentes pueder recibir y enviarse datos entre sí. un agente está compuesto de tres componentes fundamentales: source: es el punto de entrada de datos de un agente. cada source es configurada para leer datos desde un lugar o ubicación específica y enviarlos al channel del agente. channels: es el lugar temporal donde los datos llegan desde el source y se procesan o no, dependiendo del caso de uso, para transmitirlos al destino final (sink). sinks: son los encargados de leer los datos de los canales y enviarlos al siguiente componente del sistema, que será u otro agente, o el destino final. si los datos son consumidos por los sinks se eliminan de los canales. eventos se trata de una unidad de \"dato\". el dato es extraído por la fuente, enviado y procesado por el canal y consumido por el sink o sumidero. un evento se compone de dos partes: cabecera: registra información de metadata mediante pares clave-valor datos: son almacenados en forma de array en el cuerpo de un evento. flujo de datos el flujo de datos describe el recorrido de los eventos desde el comienzo hasta el destino final. apache avro serialización/deserialización la serialización de un objeto consiste en la conversión de dicho objeto a un formato que puede ser transmitido y almacenado de forma eficiente (p.ej. binario o json). la conversión inversa se denomina deserialización. este proceso se lleva a cabo por los siguientes motivos: almacenamiento: generalmente queremos almacenar los datos de una forma eficiente (minimizando su tamaño). transmisión: en sistemas distribuidos es necesario el paso de datos entre sistemas, por lo tanto necesitamos que los datos esten en un formato que optmice su envío y asegure la reconstrucción de los datos. intercambio de datos: la serialización y deserialización permite intercambiar información manteniendo la integridad de los datos, independientemente del lenguaje de programación. la evolución de los formatos apache avro pertenece a la fundación apache y se integra perfectamente con el ecosistema hadoop. avro es un formato que contiene tanto los datos como el esquema que deben de seguir los datos. en comparación con json, este no fuerza al uso de un esquema de los datos y su tamaño aumenta cuando existen claves repetidas. avro specifica dos formas de llevar a cabo la serialización: binaria: resulta en ficheros más pequeños. json: mejor para depurar y para comunicación en entornos web. avro specifica un orden de datos estándar. estructura un fichero está conformado por dos componentes: cabecera: contiene metadatos acerca del esquema de los datos entre otras cosas. uno o más bloques que pueden contener metadatos o datos. en todo fichero hay al menos un bloque de metadatos (ver block 1 en la siguiente imagen). avro sigue un formato basado en filas, tal que se agupan los datos en grupos de filas. la evolución de los esquemas avro se puede adaptar a la evolución de los esquemas. en concreto tenemos dos tipos de esquema: esquema de escritura: se utiliza en la serialización. esquema de lectura: se utiliza en la deserialización. existen los siguientes tipos de compatibilidad: compatibilidad hacia delante: un nuevo esquema puede leer datos escritos con un esquema anterior. compatibilidad hacia atrás: un esquema antiguo puede leer datos escritos con un nuevo esquema. compatibilidad completa: combina la compatibilidad hacia delante y hacia atrás. para asegurar la compatibilidad de los esquema tenemos diversas reglas: al añadir campos estes siempre deben de tener un valor por defecto. sólo se pueden eliminar campo si estes no son necesarios para las aplicaciones que leen/escriben el esquema. ventajas la compresión de los datos es automática está totalmente tipado los ficheros contienen tanto los datos como la definición del esquema los datos pueden ser procesado por casi cualquier lenguaje permite la evolución sencilla de la definición del esquema de los datos permite el paso de datos entre sistemas escritos en distintos lenguajes ejemplo de esquema vamos a ver cómo definir un esquema para los siguientes datos, uno está almacenado como un archivo csv, mientras que el otro está definido como un fichero json. name, email, age ana,ana@avro.com,34 juan,juan@avro.com,28 alvaro,alvaro@avro.com,35 maria,maria@avro.com,25 luis,luis@avro.com,30 [ {\"name\": \"david\", \"email\": \"david@avro.com\", \"age\": 28}, {\"name\": \"pablo\", \"email\": \"pablo@avro.com\", \"age\": 31}, {\"name\": \"ines\", \"email\": \"ines@avro.com\", \"age\": 34} ] definimos un esquema que define un objeto, en concreto un usuario. por lo tanto, el esquema será de tipo record. los esquemas se escriben en formato json, y hay que indicar por cada campo el nombre de éste y el tipo de datos asociado. { \"type\": \"record\", \"name\": \"user\", \"fields\": [ {\"name\": \"name\", \"type\": \"string\"}, {\"name\": \"email\", \"type\": \"string\"}, {\"name\": \"age\", \"type\": \"int\"}, ] } apache parquet formato columnar los formatos que habíamos estado tratando guardan los datos en filas (csv, avro, json), los formatos de archivos columnares guardan los datos en columnas. lo formatos más populares son apace parquet y apache ocr. por ejemplo, dada la siguiente tabla: la siguiente imagen nos ilustra las diferencia entre guardarla en formato fila y en formato columna: ventajas el formato columnar presenta ventajas a la hora de llevar a cabo agrupaciones en grandes conjuntos de datos. si utilizamos el formato basado en filas deberemos de recorrer toda la tabla, sin embargo con el formato columnar sólo es necesario leer el campo por el cual se lleva a cabo la agrupación. por el mismo motivo este tipo de formato puede suponer menos costes (p.ej. si están alojados en el cloud). generalmente no sólo se cobra por el almacenamiento si no también por la consulta y el uso de los datos. tal que si sólo queremos consultar una columna, con un formato basado en filas de nuevo deberemos de consultar la fila completa, mientras que el formato columnar nos permite sólo obtener el campo consultado. apache parquet parquet es un tipo de fichero en formato columnar diseñado para realizar consultas eficientes sobre las columnas. además permite estructuras complejas de datos anidados y ofrece esquemas de compresión muy eficientes. por ello es popular en campos como el big data, ya que a parte de su eficiencia reduce costes. parquet está sostenido y mantenido en la fundación apache y, por tanto, está disponible para cualquier proyecto bajo licencia apache. estructura de un fichero parquet los ficheros parquet tienen una estructura jerarquizada: encabezado, metadatos y grupos de filas. encabezado: contiene información necesaria para la lectura del fichero. magic number se trata de un número al final y al principio del fichero que asegura que está completo y no corrupto. metadatos: contienen información sobre los datos; el esquema de las columnas, tipos de datos, algunas estadísticas y otros datos relevantes. grupos de filas: contienen los datos organizados por columnas. cada grupo de filas tiene un subconjunto de la tabla, donde las columnas de cada grupo de filas se dividen en páginas, que son las unidades más pequeñas de almacenamiento. la subdivisión en páginas tiene como fin mejorar la eficiencia ya que admiten la compresión individual. podemos encontrar páginas de datos, índices o de diccionario. esquema: define la estructura de los datos y los tipos de datos de cada columna. en caso de que los datos estén anidados también define la jerarquía de estos. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/3C_1C/ICPDM/M02/01_intro.html",
    "title": "Introduction To Apache Spark",
    "body": " index search search back introduction to apache spark contents key features of apache spark history and evolution architecture of apache spark core concepts and apis core concepts apis running spark applications and ecosystem conclusion apache spark is a unified analytics engine designed for large-scale data processing. it provides a consistent set of apis for handling a wide range of data processing tasks, including batch processing, sql queries, streaming computation, and machine learning. spark is essentially a computing engine that focuses on processing data from various storage systems such as cloud storage, distributed file systems, key-value stores, and message buses key features of apache spark unified platform: spark offers a single platform for diverse data processing tasks, enabling developers to use the same engine and apis for different types of data analysis, like processing data in batches, running sql queries, handling real-time data streams, and even machine learning. rich libraries: spark includes a collection of built-in and external libraries, such as spark sql for structured data processing, mllib for machine learning, spark streaming and structured streaming for stream processing, and graphx for graph analytics. designed for big data: spark addresses the challenges of processing massive datasets, driven by changes in hardware towards multi-core processors and the explosion in data volume and storage capabilities. history and evolution origins: spark originated in 2009 at uc berkeley's amplab as a research project aimed at overcoming the limitations of hadoop mapreduce for iterative algorithms. early focus: initial releases concentrated on batch applications and interactive data science using scala and shark (a sql engine). expansion: spark adopted a \"standard library\" approach, expanding with libraries like mllib, spark streaming, and graphx. open source development: in 2013, spark became part of the apache software foundation, leading to active development and widespread adoption. recent developments: recent releases have focused on refining structured apis such as dataframes and datasets for enhanced optimisation architecture of apache spark cluster management: spark uses a cluster manager, such as standalone, yarn, or mesos, to manage cluster resources. application structure: a spark application consists of a driver process and multiple executor processes. driver process: the driver runs the main() function, maintains application information, interacts with the user, and schedules tasks across executors. executor processes: executors execute spark code on data partitions distributed across the cluster. spark supports multiple language apis, including python, java, scala, r, and sql [5]. developers can write applications in their preferred language. core concepts and apis core concepts unified analytics engine: spark provides a consistent set of apis for various data processing tasks, including batch processing, sql queries, streaming computation, and machine learning. computing engine focus: spark primarily processes data loaded from diverse storage systems, rather than functioning as permanent storage itself. parallel processing: spark leverages parallel processing to efficiently analyse massive datasets, addressing the challenges posed by the shift to multi-core processors and the explosion of data. lazy evaluation: spark optimises execution plans before processing, delaying action until triggered. apis sparksession: the entry point for interacting with spark functionality, managing the spark application and providing access to various apis. dataframes: the primary structured api representing tabular data in rows and columns partitions: data is divided into partitions for parallel processing across executors transformations: operations that define modifications to a dataframe without altering the original data, including narrow transformations that operate within partitions and wide transformations that involve shuffling data across partitions. actions: actions trigger the execution of transformations and return results datasets: a type-safe version of the structured api in java and scala, enabling compile-time checks for data types resilient distributed datasets (rdds): spark's lower-level api, providing more control over data partitioning and manipulation but less commonly used in modern spark applications structured streaming: a high-level api that allows applying batch-like operations to streaming data mllib: spark's machine learning library, offering algorithms for classification, regression, clustering, and deep learning running spark applications and ecosystem spark-submit: a command-line tool for submitting spark applications to a cluster, allowing for resource specification, execution parameters, and command-line arguments. spark ecosystem and packages: a wide range of third-party packages expands spark's functionality and integrates with various systems. conclusion spark provides a powerful and versatile platform for tackling big data challenges across various domains. its unified engine, rich libraries, and intuitive apis empower developers to efficiently process, analyse, and extract insights from large datasets. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/3C_1C/ICPDM/M02/02_prog_spark.html",
    "title": "Programming Spark Applications",
    "body": " index search search back programming spark applications contents chapter 3 building and running a spark application building spark jobs with maven chapter 4 creating a sparksession object understanding the sparksession object working with datasets dataframes and rdds building a sparksession object chapter 5 loading and saving data in spark chapter 6 manipulating your rdd chapter 9 foundations of datasets dataframes the proverbial workhorse for data scientists chapter 3: building and running a spark application spark applications can be built and run in different ways: interactive mode with spark shell: this method is suitable for quick prototyping and interactive data exploration. spark provides a shell interface for scala, python, and r, allowing users to execute commands and get immediate feedback. this interactive mode is excellent for learning spark apis, testing code snippets, and performing ad-hoc data analysis. ide for application development: for developing more complex applications, integrated development environments (ides) like eclipse and intellij are popular choices. these ides provide features like code completion, debugging, and project management, making it easier to develop, test, and deploy spark applications. building spark jobs with maven building spark jobs is slightly more intricate than building standard applications. this complexity arises because spark applications often need to be executed on a cluster of machines, requiring spark dependencies to be available on all nodes. there are two primary methods for building spark jobs: building with maven: maven is a widely used build tool in the java ecosystem, and it is officially recommended for packaging spark applications. maven simplifies the build process by managing dependencies, compiling code, and packaging it into a jar file. developers can include spark dependencies through maven central, a public repository for java libraries. maven can also package spark and its dependencies into a single executable jar file, making it easier to deploy and run on a cluster. building with other build systems: while maven is the recommended build tool, spark supports building a \"fat jar\" file that contains all its dependencies. this fat jar can be used with other build systems like sbt, gradle, or even custom build scripts. the process usually involves building the spark assembly jar using sbt and then including it in the build path of the other build system. this approach allows developers to use their preferred build tools while still ensuring that all necessary dependencies are included. steps to build a spark job with maven: create a new directory and generate the maven template. the example shows building a java spark job: mkdir example-java-build/; cd example-java-build mvn archetype:generate \\ -darchetypegroupid=org.apache.maven.archetypes \\ -dgroupid=spark.examples \\ -dartifactid=javawordcount \\ -dfilter=org.apache.maven.archetypes:maven-archetype-quickstart cp ../examples/src/main/java/spark/examples/javawordcount.java \\ javawordcount/src/main/java/spark/examples/javawordcount.java update maven pom.xml to include spark version and jdk version information. add the following code between the <project> tags: <dependencies> <dependency> <groupid>junit</groupid> <artifactid>junit</artifactid> <version>4.11</version> <scope>test</scope> </dependency> <dependency> <groupid>org.spark-project</groupid> <artifactid>spark-core_2.11</artifactid> <version>2.0.0</version> </dependency> </dependencies> <build> <plugins> <plugin> <groupid>org.apache.maven.plugins</groupid> <artifactid>maven-compiler-plugin</artifactid> <configuration> <source>1.7</source> <target>1.7</target> </configuration> </plugin> </plugins> </build> build the jar file: mvn package run the spark job: spark_home=\"../\" spark_examples_jar=\"./target/javawordcount-1.0-snapshot.jar\" java -cp ./target/javawordcount-1.0-snapshot.jar:../../core/target/spark-core-assembly-1.5.2.jar spark.examples.javawordcount local[1] ../../readme chapter 4: creating a sparksession object understanding the sparksession object the sparksession object acts as the primary entry point for interacting with spark functionalities. introduced in spark 2.0.0, it represents a connection to a spark cluster, which can be either local for development and testing or remote for distributed processing on a cluster of machines. the sparksession provides a unified interface for various spark components and operations: unified entry point: before sparksession, developers had to interact with multiple context objects like sparkcontext, sqlcontext, and hivecontext for different functionalities. sparksession encapsulates these contexts, providing a single entry point for all spark operations, simplifying the development process. dataset and dataframe creation: sparksession enables the creation of datasets and dataframes, which are high-level abstractions for representing structured data in spark. datasets are type-safe, providing compile-time type checking, while dataframes offer a schema-based view of the data. sql execution: sparksession facilitates the execution of sql queries against data in spark. it allows users to register dataframes as temporary views and then run sql queries against those views, providing a familiar way to interact with data. rdd access: while datasets and dataframes are the preferred abstractions in spark 2.0.0 and later, sparksession still provides access to the underlying rdds (resilient distributed datasets). developers can obtain the sparkcontext from the sparksession to work with rdds when necessary. working with datasets, dataframes, and rdds spark provides different abstractions for representing and manipulating data: datasets and dataframes: these are high-level, schema-based abstractions introduced in spark 2.0.0. datasets provide type safety and compile-time checking, while dataframes are untyped but offer a schema-based view of the data. both datasets and dataframes offer a rich api for data manipulation, including filtering, sorting, grouping, aggregation, and joining operations. they are built on top of rdds and leverage catalyst, spark's query optimizer, to optimize execution plans for better performance. rdds: rdds are the fundamental data structure in spark, representing an immutable, partitioned collection of data distributed across the cluster. rdds provide low-level control over data and operations, allowing developers to implement custom data processing logic. they are useful for complex computations that cannot be efficiently expressed using dataset or dataframe apis. rdds follow lazy evaluation, meaning that transformations on rdds are not executed immediately but are computed only when an action requiring the results is called. the choice of abstraction depends on the specific use case and the level of control required. datasets and dataframes are generally preferred for most data manipulation tasks due to their higher-level api, performance optimizations, and ease of use. rdds are suitable for situations demanding low-level control or when dealing with unstructured data. building a sparksession object scala and python: val sparksession = new sparksession.builder.master(master_path).appname(\"application name\").config(\"optional configuration parameters\").getorcreate() it's recommended to read values from the environment with reasonable defaults for flexibility in changing environments. spark-shell/pyspark automatically creates the sparksession object and assigns it to the spark variable. access the sparkcontext object using spark.sparkcontext. chapter 5: loading and saving data in spark spark offers flexible mechanisms for loading and saving data from various sources and formats: loading data into rdds: data can be loaded into rdds from various sources, including local collections, text files, csv files, sequence files, and external databases like hbase. sparkcontext provides functions like parallelize(), textfile(), sequencefile(), and newapihadooprdd() to load data into rdds. saving data from rdds: rdds can be saved to different formats like text files, sequence files, and object files. functions like saveastextfile(), saveasobjectfile(), and saveassequencefile() are used to save rdd data. loading and saving data with datasets and dataframes: datasets and dataframes provide more streamlined and efficient methods for data loading and saving. sparksession's read api supports reading data from various formats like csv, json, parquet, avro, and jdbc. similarly, the write api allows saving data to different formats. chapter 6: manipulating your rdd spark offers a rich set of operations for manipulating data in rdds, datasets, and dataframes: transformations: transformations are operations that create new rdds, datasets, or dataframes from existing ones without changing the original data. common transformations include map(), filter(), flatmap(), reducebykey(), groupbykey(), and sortbykey(). actions: actions are operations that trigger computations on rdds, datasets, or dataframes and return results to the driver program. examples of actions include count(), collect(), reduce(), take(), and saveastextfile(). shared states and accumulators: while distributed computation in spark generally discourages shared states, accumulators provide a safe mechanism for aggregating values from different partitions across the cluster. accumulators are write-only variables that can be used to count events or sum values from different parts of the data. broadcast variables: broadcast variables enable efficient sharing of read-only data across the cluster. instead of sending the data to every task, spark broadcasts the data once to each executor node, making it available to all tasks running on that node. example: parsing csv files with error handling (scala) import org.apache.spark.sparkconf import org.apache.spark.sparkcontext import org.apache.spark.sparkfiles import org.apache.spark.api.java.javasparkcontext import au.com.bytecode.opencsv.csvreader import java.io.stringreader object loadcsvwithcountersexample { def main(args: array[string]) { val sc = new sparkcontext(\"local\", \"chapter 6\") println(s\"running spark version ${sc.version}\") val invalidlinecounter = sc.accumulator(0) val invalidnumericlinecounter = sc.accumulator(0) val infile = sc.textfile(\"/volumes/sdxc-01/fdps-vii/data/line_of_numbers.csv\") val splitlines = infile.flatmap(line => { try { val reader = new csvreader(new stringreader(line)) some(reader.readnext()) } catch { case _ => { invalidlinecounter += 1 none } } }) val numericdata = splitlines.flatmap(line => { try { some(line.map(_.todouble)) } catch { case _ => { invalidnumericlinecounter += 1 none } } }) val summeddata = numericdata.map(row => row.sum) println(summeddata.collect().mkstring(\",\")) println(\"errors: \" + invalidlinecounter + \",\" + invalidnumericlinecounter) } } this example demonstrates the use of accumulators to count invalid lines and lines with invalid numeric data. it also utilises flatmap() to handle parsing errors and filter out invalid lines. example: word frequency analysis (python) from pyspark.context import sparkcontext from pyspark.conf import sparkconf from operator import add print(\"running spark version %s\" % (sc.version)) conf = sparkconf() print(conf.todebugstring()) # read and process barack obama's speeches lines = sc.textfile(\"sotu/2009-2014-bo.txt\") word_count_bo = lines.flatmap(lambda x: x.split(' ')). \\ map(lambda x: (x.lower().rstrip().lstrip().rstrip(',').rstrip('.'), 1)). \\ reducebykey(add) word_count_bo.count() # 6658 without lower, 6299 with lower, rstrip, lstrip 4835 # read and process abraham lincoln's speeches lines = sc.textfile(\"sotu/1861-1864-al.txt\") word_count_al = lines.flatmap(lambda x: x.split(' ')). \\ map(lambda x: (x.lower().rstrip().lstrip().rstrip(',').rstrip('.'), 1)). \\ reducebykey(add) word_count_al.count() # sort word counts for barack obama's speeches word_count_bo_1 = word_count_bo.sortby(lambda x: x[1], ascending=false) # print top 10 most frequent words for x in word_count_bo_1.take(10): print(x) # filter out common words common_words = [...] word_count_bo_clean = word_count_bo_1.filter(lambda x: x not in common_words) word_count_al_clean = word_count_al.filter(lambda x: x not in common_words) # find words spoken by obama but not lincoln for x in word_count_bo_clean.subtractbykey(word_count_al_clean).sortby(lambda x: x[1], ascending=false).take(15): print(x) this example illustrates reading text files, splitting into words, calculating word frequencies, sorting, filtering, and comparing word usage between two sets of speeches. chapter 9: foundations of datasets/dataframes – the proverbial workhorse for data scientists spark supports multiple programming languages, including scala, java, python, and r. this multilingual capability allows developers to use the language they are most comfortable with for different parts of a spark application. this approach, known as polyglot programming, offers several advantages: leveraging existing skills: developers can use their existing language skills to work with spark without having to learn a new language. using specialized libraries: different languages have different strengths and specialized libraries. polyglot programming allows developers to use the most suitable language and libraries for specific tasks within a spark application. code reusability: code written in one language can often be reused or adapted for use in other languages, promoting code sharing and reducing development time. spark encourages polyglot programming by providing consistent apis across different languages, making it easy to switch between languages and integrate code written in different languages. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/PR/CC/07.html",
    "title": "Boundaries",
    "body": " index search search back boundaries contents using third-party code exploring and learning boundaries using code that does not yet exist clean boundaries we seldom control all the software in our systems. sometimes we buy third-party packages or use open source. other times we depend on teams in our own company to produce components or subsystems for us. in this chapter we look at practices and techniques to keep the boundaries of our software clean. using third-party code there is a natural tension between the provider of an interface and the user of an interface. providers: which strive for broad applicability and users: which are want an interface focused on their particular needs. let’s look at java.util.map as an example. if our application needs a map of sensors, you might find the sensors set up like this: map sensors = new hashmap(); then, when some other part of the code needs to access the sensor, you see this code: sensor s = (sensor)sensors.get(sensorid); the readability of this code can be greatly improved by using generics, as shown below: map<sensor> sensors = new hashmap<sensor>(); ... sensor s = sensors.get(sensorid ); however, this doesn’t solve the problem that map<sensor> provides more capability than we need. also there will be a lot of places to fix if the interface to map ever changes. a cleaner way to use map might look like the following. public class sensors { private map sensors = new hashmap(); public sensor getbyid(string id) { return (sensor) sensors.get(id); } } so the interface at the boundary (map) is hidden. this interface is also tailored and constrained to meet the needs of the application. it results in code that is easier to understand and harder to misuse. exploring and learning boundaries we could write some tests to explore our understanding of the third-party code (learning tests). we call the third-party api, as we expect to use it in our application. not only are learning tests free, they have a positive return on investment. when there are new releases of the third-party package, we run the learning tests to see whether there are behavioral differences. using code that does not yet exist there is another kind of boundary, one that separates the known from the unknown. there are often places in the code where our knowledge seems to drop off the edge. for example, there was a subsystem, the “transmitter,” that we knew little about, and the people responsible for the subsystem had not gotten to the point of defining their interface. so we defined our own interface, this was the interface we wished we had. this design also gives us a very convenient seam3 in the code for testing. clean boundaries good software designs accommodate change without huge investments and rework. we manage third-party boundaries by having very few places in the code that refer to them. we may wrap them as we did with map, or we may use an adapter to convert from our perfect interface to the provided interface. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/PR/CC/08.html",
    "title": "Unit Tests",
    "body": " index search search back unit tests contents the tree laws of tdd keeping tests clean tests enable the -ilities clean tests domain-specific testing language a dual standard one assert per test single concept per test f i r s t the tree laws of tdd first law: you may not write production code until you have written a failing unit test. second law: you may not write more of a unit test than is sufficient to fail, and not compiling is failing. third law: you may not write more production code than is sufficient to pass the currently failing test. the tests and the production code are written together, with the tests just a few seconds ahead of the production code. if we work this way, we will write a lot of tests, the sheer bulk of those tests, which can rival the size of the production code itself, can present a daunting management problem. keeping tests clean tests must change as the production code evolves. so, the dirtier the tests, the harder they are to change. therefore test code is just as important as production code, it must be kept as clean as production code. tests enable the -ilities no matter how flexible your architecture is, no matter how nicely partitioned your design, without tests you will be reluctant to make changes because of the fear that you will introduce undetected bugs. but with tests that fear virtually disappears. so if your tests are dirty, then your ability to change your code is hampered. clean tests what makes a clean test? readability. what makes tests readable? the same thing that makes all code readable: clarity, simplicity, and density of expression. domain-specific testing language rather than using the apis that programmers use to manipulate the system, we build up a set of functions and utilities that make use of those apis and that make the tests more convenient to write and easier to read. these functions and utilities become a specialized api used by the tests. they are a testing language. a dual standard the code within the testing api does have a different set of engineering standards than production code. it must still be simple, succinct, and expressive, but it need not be as efficient as production code. that is the nature of the dual standard. there are things that you might never do in a production environment that are perfectly fine in a test environment. one assert per test there is a school of thought4 that says that every test function in a junit test should have one and only one assert statement. unfortunately, sometimes you might have to split the tests which results in a lot of duplicate code. the single assert rule is a good guideline, but you may need to break it sometimes. single concept per test perhaps a better rule is that we want to test a single concept in each test function. f.i.r.s.t. clean tests follow five other rules: fast tests: should be fast. they should run quickly. when tests run slow, you won’t want to run them frequently and you won't find problems early enough to fix them. independent: tests should not depend on each other. one test should not set up the conditions for the next test. repeatable: tests should be repeatable in any environment. if your tests aren’t repeatable in any environment, then you’ll always have an excuse for why they fail. self-validating: the tests should have a boolean output. either they pass or fail. timely: the tests need to be written in a timely fashion. unit tests should be written just before the production code that makes them pass. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Calculus/CET/02_06.html",
    "title": "Limits at Infinity. Horizontal Asymptotes",
    "body": " index search search back limits at infinity. horizontal asymptotes contents intuitive definition of a limit at infinity horizontal asymptote evaluating limits at infinity infinite limits at infinity precise definition of a limit at infinity precise definition of an infinite limit at infinity intuitive definition of a limit at infinity let \\(f\\) be a function defined on some interval \\((a, \\infty)\\), then: \\begin{align} \\lim_{x\\rightarrow \\infty} f(x) = l \\end{align} means that the values of \\(f(x)\\) can be made arbitrarily close to \\(l\\) by requiring \\(x\\) to be sufficiently large. geometric illustration of this defintion are shown in figure \\(2\\). let \\(f\\) be a function defined on some interval \\((-\\infty, a)\\), then: \\begin{align} \\lim_{x\\rightarrow -\\infty} f(x) = l \\end{align} means that the values of \\(f(x)\\) can be made arbitrarily close to \\(l\\) by requiring \\(x\\) to be sufficiently large negative. this definition is illustrated in figure \\(3\\). horizontal asymptote the line \\(y = l\\) is called a horizontal asymptote of the curve \\(y = f(x)\\) if either: \\begin{align} \\lim_{x \\rightarrow \\infty} f(x) = l \\end{align} or \\begin{align} \\lim_{x \\rightarrow -\\infty} f(x) = l \\end{align} evaluating limits at infinity most of the limit laws also hold for limits at infinity, with the exception of laws \\(10\\) and \\(11\\). let's see the following theorem on the limit at infinity of a rational function: if \\(r > 0\\) is a rational number, then: \\begin{align} \\lim_{x \\rightarrow \\infty} \\frac{1}{x^r} = 0 \\end{align} if \\(r > 0\\) is a rational number such that \\(x^r\\) is defined for all \\(x\\), then: \\begin{align} \\lim_{x \\rightarrow -\\infty} \\frac{1}{x^r} = 0 \\end{align} infinite limits at infinity the notation: \\begin{align} \\lim_{x \\rightarrow \\infty} f(x) = \\infty \\end{align} means that the values of \\(f(x)\\) become large as \\(x\\) becomes large. similarly: \\begin{align} \\lim_{x \\rightarrow -\\infty} f(x) = \\infty \\end{align} \\begin{align} \\lim_{x \\rightarrow \\infty} f(x) = -\\infty \\end{align} \\begin{align} \\lim_{x \\rightarrow -\\infty} f(x) = -\\infty \\end{align} in general, the limit laws cannot be applied to infinite limits, because \\(\\infty\\) is not a number. precise definition of a limit at infinity let \\(f\\) be a function defined on some interval \\((a, \\infty)\\), then: \\begin{align} \\lim_{x \\rightarrow \\infty} f(x) = l \\end{align} means that for every \\(\\epsilon > 0\\) there is a corresponding number \\(n\\) such that: \\begin{align} \\text{ if } x > n \\text{ then } |f(x) - l| < \\epsilon \\end{align} in words, this says that the values of \\(f(x)\\) can be mace arbitrarily cloe to \\(l\\) by requiring \\(x\\) to be sufficiently lare. graphically it says that by keeping \\(x\\) large enough we can make the graph of \\(f\\) lie between the given horizontal lines \\(y = l - \\epsilon\\) and \\(y = l + \\epsilon\\) as in figure 14. let \\(f\\) be a function defined on some interval \\((-\\infty, a)\\), then: \\begin{align} \\lim_{x \\rightarrow -\\infty} f(x) = l \\end{align} means that for every \\(\\epsilon > 0\\) there is a corresponding number \\(n\\) such that: \\begin{align} \\text{ if } x < n \\text{ then } |f(x) - l| < \\epsilon \\end{align} this definition is illustrated on figure 16. precise definition of an infinite limit at infinity let \\(f\\) be a function defined on some interval \\((a, \\infty)\\), then: \\begin{align} \\lim_{x \\rightarrow \\infty} f(x) = \\infty \\end{align} means that for every positive number \\(m\\) there is a corresponding positive number \\(n\\) such that: \\begin{align} \\text{ if } x > n \\text{ then } f(x) > m \\end{align} this definition is illustrated on figure 19. similar definitions apply when the symbol \\(\\infty\\) is replaced by \\(-\\infty\\). $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/3C_1C/ICPDM/M02/03_lib_spark.html",
    "title": "Librerías/Componentes de Spark",
    "body": " index search search back librerías/componentes de spark contents spark sql spark sql architecture spark sql evolution spark sql programming example workflow important points code examples in spark sql machine learning with spark ml pipelines spark for machine learning ml pipelines addressing the data pipeline in ml structure of spark ml apis code examples from spark machine learning basic statistics with spark datasets linear regression with data transformation and model evaluation classification with decision tree data transformation and model evaluation clustering with k-means data transformation and model evaluation recommendation with als data transformation and model evaluation graphx introduction to graph processing graph processing systems challenges of graph processing spark graphx graphx architecture graphx computational model building graphs with graphx graphx api landscape structural apis community detection and analysis graphx algorithms graph parallel computation apis partition strategies case study alphago tweet analytics code examples in the graphx source building a simple graph defining vertices and edges creating rdds and the graph structural apis extracting subgraphs community detection pagerank calculation aggregate messages api finding the oldest follower finding the oldest followee calculating in-degree and out-degree alphago tweet analytics loading data and creating a dataframe mapping data to vertices and edges creating the graph and running algorithms spark sql spark sql is an important feature in the spark ecosystem that allows integration with different data sources and other subsystems, such as visualization. spark sql is not meant to replace sql databases, but rather to complement spark's data wrangling and input capabilities by providing a versatile query interface for spark data. this ability to scale complex data operations is only valuable if the results can be used flexibly, which is what spark sql achieves. spark sql architecture spark sql's architecture is layered, with each layer performing specific functions. the bottom layer is the data access layer, which works with multiple formats and typically utilizes a distributed filesystem such as hdfs. the computation layer leverages the distributed processing power of the spark engine, including its streaming capabilities, and typically operates on rdds (resilient distributed datasets). the dataset/dataframe layer provides the api for interacting with the data. spark sql sits on top of this layer, providing data access for various applications, dashboards, and bi tools. this architecture allows spark to leverage the vast knowledge base of sql among data professionals and use it to query spark data. spark sql evolution prior to spark 2.0, schemardd was at the heart of spark sql. it essentially attached a schema to an rdd, enabling sql queries to be run on rdds. however, with spark 2.0, datasets became the primary way to work with data. datasets offer the advantages of both rdds and strong typing, providing a more robust and efficient way to handle data. in languages like python and r, which lack compile-time type checking, datasets and dataframes are merged and referred to as dataframes. spark sql programming spark 2.0 introduced sparksession, which replaced sqlcontext, hivecontext, and other components. the sparksession instance has a versatile read method capable of handling various data formats like csv, parquet, json, and jdbc. this method allows you to specify format-related options such as headers and delimiters. to use spark sql, you first need to create a dataset by reading data from a source and informing spark about its structure and types. you can then apply sql statements to query the data. to create a view that can be queried using sql, you can use the createorreplacetempview method. you can then use sql statements to filter, join, and aggregate data within these views. example workflow a typical spark sql workflow involves: defining a case class to represent the data structure. reading the data file using sparksession.read, specifying options like header and inferschema. creating a dataset with the case class as its element type. creating a temporary view using createorreplacetempview for sql access. running sql queries on the view using spark.sql. displaying and analyzing the results using methods like show, head, and orderby important points spark 2.0 simplified spark sql by introducing datasets and sparksession. you can start the spark shell with the -deprecation flag to receive messages about deprecated methods. the read method can infer schema automatically using the inferschema option. use createorreplacetempview to avoid the temptablealreadyexists exception. spark sql enables complex queries involving multiple tables and various operations like filtering, joining, and aggregation. code examples in spark sql example 1: loading a csv file into a dataset case class employee(employeeid : string, lastname : string, firstname : string, title : string, birthdate : string, hiredate : string, city : string, state : string, zip : string, country : string, reportsto : string) // ... ... val filepath = \"/users/ksankar/fdps-v3/\" println(s\"running spark version ${sc.version}\") // val employees = spark.read.option(\"header\",\"true\"). csv(filepath + \"data/nw-employees.csv\").as[employee] println(\"employees has \"+employees.count()+\" rows\") employees.show(5) employees.head() this code snippet first defines a case class called employee representing the structure of the employee data. then, it sets a filepath variable pointing to the directory containing the data files. the code then uses the spark.read.csv method to read the csv file into a dataset called employees. the option(\"header\", \"true\") tells spark that the first row of the csv file contains column headers. the .as[employee] part specifies that the dataset should be composed of employee objects. finally, the code prints the number of rows in the dataset, displays the first \\(5\\) rows using show(5), and retrieves the first row using head(). example 2: creating a view and running sql queries employees.createorreplacetempview(\"employeestable\") var result = spark.sql(\"select * from employeestable\") result.show(5) result.head(3) // employees.explain(true) result = spark.sql(\"select * from employeestable where state = 'wa'\") result.show(5) result.head(3) // result.explain(true) this code creates a temporary view called \"employeestable\" from the employees dataset using createorreplacetempview. this view enables you to query the dataset using sql statements. the first spark.sql statement selects all columns from the \"employeestable\" view. the second query filters the results to include only employees from the state of washington (where state = 'wa'). both queries use show(5) to display the first \\(5\\) rows of the result and head(3) to retrieve the first \\(3\\) rows. example 3: handling multiple tables and joins // ... ... val orders = spark.read.option(\"header\",\"true\"). option(\"inferschema\",\"true\"). csv(filepath + \"data/nw-orders.csv\").as[order] println(\"orders has \"+orders.count()+\" rows\") orders.show(5) orders.head() orders.dtypes // ... ... // // now the interesting part // result = spark.sql(\"select orderdetailstable.orderid, shipcountry, unitprice, qty, discount from orderstable inner join orderdetailstable on orderstable.orderid = orderdetailstable.orderid\") result.show(10) result.head(3) // // sales by country // result = spark.sql(\"select shipcountry, sum(orderdetailstable.unitprice * qty * discount) as productsales from orderstable inner join orderdetailstable on orderstable.orderid = orderdetailstable.orderid group by shipcountry\") result.count() result.show(10) result.head(3) result.orderby($\"productsales\".desc).show(10) // top 10 by sales this example demonstrates loading the \"orders\" table, creating a view, and then performing joins and aggregations. it first reads the \"nw-orders.csv\" file into an orders dataset. notably, it uses the option(\"inferschema\", \"true\") option, which tells spark to automatically infer the schema for the data. this eliminates the need to define a case class beforehand. the code then executes two sql queries. the first query performs an inner join between the \"orderstable\" and \"orderdetailstable\" based on the common \"orderid\" column and selects specific columns from the joined result. the second query calculates total sales (sum(orderdetailstable.unitprice * qty * discount)) per country, groups the results by \"shipcountry\", and orders the final output by \"productsales\" in descending order to show the top \\(10\\) countries by sales. machine learning with spark ml pipelines this section provides a summary of spark's capabilities for machine learning (ml), focusing on ml pipelines and the transition from mllib to ml apis. it covers various ml algorithms, data transformation techniques, and the concept of pipelines for streamlined ml workflows. spark for machine learning spark is attractive for ml due to its ability to handle massive computations. spark 2.0.0 onwards, spark is considered a leading platform for building ml algorithms and applications. spark's ml capabilities are primarily accessed through the org.apache.spark.ml package for scala and java, and pyspark.ml for python. spark supports a wide array of ml algorithms, including basic statistics, linear regression, classification, clustering, recommendation systems, dimensionality reduction, feature extraction, and more. ml pipelines: addressing the data pipeline in ml before spark 1.6.0, the mllib apis operated on rdds, but they lacked support for the data pipelines inherent in ml. with the introduction of dataframes and datasets, mllib evolved into the ml pipeline framework, offering more capabilities and addressing the entire ml workflow. mllib apis are now in maintenance mode and will eventually be deprecated. while you should use ml apis going forward, some functionalities might require using mllib and converting the output rdd to a dataframe for further processing with ml apis. a typical ml process involves several steps: data acquisition: obtain data from internal or external sources, ensuring anonymity and removal of personally identifiable information (pii). data transformation: convert raw data into a usable format, for example, transforming a csv file into a dataframe. feature extraction: extract relevant features from the data, such as separating text into words or normalizing them. data splitting: divide the data into training and testing sets, using appropriate strategies based on data characteristics like time series or class imbalance. model training: fit the training data to different ml models. tune hyperparameters for optimal performance. select the best-performing model for the specific problem. model evaluation: assess the model's performance using the test data. model deployment: implement the trained model in a production environment for real-time predictions. ml pipelines in spark address all stages of this workflow. structure of spark ml apis spark ml apis have a specific structure that can be challenging to navigate initially. familiarity with this structure is key to effectively utilizing spark for ml tasks. the source material provides a diagram to illustrate this, recommending a deeper understanding of the pipeline concept to enhance proficiency in using spark ml classes. code examples from spark machine learning basic statistics with spark datasets this code snippet shows how to load car mileage data from a csv file, compute basic statistics using spark datasets, and calculate the correlation and covariance between specific variables: val spark = sparksession.builder .master(\"local\") .appname(\"chapter 11\") .config(\"spark.logconf\",\"true\") .config(\"spark.loglevel\",\"error\") .getorcreate() println(s\"running spark version ${spark.version}\") val filepath = \"/users/ksankar/fdps-v3/\" val cars = spark.read.option(\"header\",\"true\").option(\"inferschema\",\"true\") .csv(filepath + \"data/car-data/car-milage.csv\") println(\"cars has \"+cars.count()+\" rows\") cars.show(5) cars.printschema() // computing statistics cars.describe(\"mpg\",\"hp\",\"weight\",\"automatic\").show() var cor = cars.stat.corr(\"hp\",\"weight\") println(\"hp to weight : correlation = %2.4f\".format(cor)) var cov = cars.stat.cov(\"hp\",\"weight\") println(\"hp to weight : covariance = %2.4f\".format(cov)) cor = cars.stat.corr(\"raratio\",\"width\") println(\"rear axle ratio to width : correlation = %2.4f\".format(cor)) cov = cars.stat.cov(\"raratio\",\"width\") println(\"rear axle ratio to width : covariance = %2.4f\".format(cov)) sparksession creation: the code starts by creating a sparksession, which is the entry point for spark applications. data loading: the spark.read.csv() method loads data from the specified csv file into a dataframe named cars. the option(\"header\",\"true\") indicates that the first row contains column headers, and option(\"inferschema\",\"true\") instructs spark to automatically infer the data types for each column. basic statistics: the describe() method computes summary statistics like count, mean, standard deviation, min, and max for the specified columns (\"mpg\", \"hp\", \"weight\", \"automatic\"). correlation and covariance: the stat.corr() and stat.cov() methods are used to calculate the correlation and covariance between pairs of variables (\"hp\" and \"weight\", \"raratio\" and \"width\"). linear regression with data transformation and model evaluation this code example demonstrates a linear regression model using spark ml pipelines. it includes data transformation, feature extraction, splitting data into training and testing sets, fitting the model, making predictions, and evaluating the model: // data transformation and feature extraction val cars1 = cars.na.drop() val assembler = new vectorassembler() assembler.setinputcols(array(\"displacement\", \"hp\", \"torque\", \"cratio\", \"raratio\", \"carbbarrells\", \"noofspeed\", \"length\", \"width\", \"weight\", \"automatic\")) assembler.setoutputcol(\"features\") val cars2 = assembler.transform(cars1) cars2.show(40) // data split val train = cars2.filter(cars1(\"weight\") <= 4000) val test = cars2.filter(cars1(\"weight\") > 4000) test.show() println(\"train = \"+train.count()+\" test = \"+test.count()) // linear regression model val alglr = new linearregression() alglr.setmaxiter(100) alglr.setregparam(0.3) alglr.setelasticnetparam(0.8) alglr.setlabelcol(\"mpg\") val mdllr = alglr.fit(train) println(s\"coefficients: ${mdllr.coefficients} intercept: ${mdllr.intercept}\") val trsummary = mdllr.summary println(s\"numiterations: ${trsummary.totaliterations}\") println(s\"iteration summary history: ${trsummary.objectivehistory.tolist}\") trsummary.residuals.show() println(s\"rmse: ${trsummary.rootmeansquarederror}\") println(s\"r2: ${trsummary.r2}\") // predictions val predictions = mdllr.transform(test) predictions.show() // model evaluation val evaluator = new regressionevaluator() evaluator.setlabelcol(\"mpg\") val rmse = evaluator.evaluate(predictions) println(\"root mean squared error = \"+\"%6.3f\".format(rmse)) val mse = evaluator.evaluate(predictions) println(\"mean squared error = \"+\"%6.3f\".format(mse)) data preprocessing: cars.na.drop() removes rows with missing values (na). vectorassembler combines multiple input columns into a single vector column named \"features\", which is required for many ml algorithms. data splitting: the data is split into training and test sets based on the \"weight\" column. linear regression: a linearregression object is created and configured with parameters like maximum iterations (setmaxiter), regularization parameter (setregparam), and elastic net parameter (setelasticnetparam). the model is trained using the fit() method on the training data. model coefficients, intercept, and training summary are printed. predictions: predictions are made on the test data using the transform() method, adding a \"predictions\" column to the resulting dataframe. model evaluation: a regressionevaluator is used to calculate rmse and mse. the evaluate() method calculates the metrics based on the \"mpg\" label column and the predicted values. classification with decision tree, data transformation and model evaluation this example demonstrates a classification task using a decision tree algorithm. it involves data loading, transformation, feature extraction, model training, prediction, and evaluation: // loading data val filepath = \"/users/ksankar/fdps-v3/\" val passengers = spark.read.option(\"header\",\"true\").option(\"inferschema\",\"true\") .csv(filepath + \"data/titanic3_02.csv\") println(\"passengers has \"+passengers.count()+\" rows\") passengers.show(5) passengers.printschema() // data transformation and feature extraction val passengers1 = passengers.select( passengers(\"pclass\"), passengers(\"survived\").cast(doubletype).as(\"survived\"), passengers(\"gender\"), passengers(\"age\"), passengers(\"sibsp\"), passengers(\"parch\"), passengers(\"fare\") ) passengers1.show(5) val indexer = new stringindexer() indexer.setinputcol(\"gender\") indexer.setoutputcol(\"gendercat\") val passengers2 = indexer.fit(passengers1).transform(passengers1) passengers2.show(5) val passengers3 = passengers2.na.drop() println(\"orig = \"+passengers2.count()+\" final = \"+ passengers3.count() + \" dropped = \"+ (passengers2.count() - passengers3.count())) val assembler = new vectorassembler() assembler.setinputcols(array(\"pclass\", \"gendercat\", \"age\", \"sibsp\", \"parch\", \"fare\")) assembler.setoutputcol(\"features\") val passengers4 = assembler.transform(passengers3) passengers4.show(5) // data split val array(train, test) = passengers4.randomsplit(array(0.9, 0.1)) println(\"train = \"+train.count()+\" test = \"+test.count()) // decision tree model val algtree = new decisiontreeclassifier() algtree.setlabelcol(\"survived\") algtree.setimpurity(\"gini\") algtree.setmaxbins(32) algtree.setmaxdepth(5) val mdltree = algtree.fit(train) println(\"the tree has %d nodes.\".format(mdltree.numnodes)) println(mdltree.todebugstring) println(mdltree.tostring) println(mdltree.featureimportances) // predictions val predictions = mdltree.transform(test) predictions.show(5) // model evaluation val evaluator = new multiclassclassificationevaluator() evaluator.setlabelcol(\"survived\") evaluator.setmetricname(\"accuracy\") val accuracy = evaluator.evaluate(predictions) println(\"test accuracy = %.2f%%\".format(accuracy*100)) data loading: the titanic passenger data is loaded from a csv file. data transformation and feature extraction: relevant columns are selected. stringindexer converts the categorical \"gender\" column into a numerical \"gendercat\" column. rows with missing values are dropped. vectorassembler combines selected features into a \"features\" vector column. data splitting: the data is split into training and test sets using randomsplit(). decision tree model: a decisiontreeclassifier is created and configured with parameters like label column, impurity measure (\"gini\"), maximum bins, and maximum depth. the model is trained using the fit() method. model details like the number of nodes, tree structure, and feature importances are printed. predictions: predictions are made on the test data. model evaluation: a multiclassclassificationevaluator is used to calculate the accuracy of the model. clustering with k-means, data transformation and model evaluation this example illustrates k-means clustering: // loading data // ... (code for loading data, similar to previous examples) // data transformation and feature extraction val assembler = new vectorassembler() assembler.setinputcols(array(\"x\", \"y\")) assembler.setoutputcol(\"features\") val data1 = assembler.transform(data) data1.show(5) // clustering model (k=2) var algkmeans = new kmeans().setk(2) var mdlkmeans = algkmeans.fit(data1) // predictions var predictions = mdlkmeans.transform(data1) predictions.show(3) predictions.write.mode(\"overwrite\").option(\"header\",\"true\").csv(filepath + \"data/cluster-2k.csv\") // model evaluation and interpretation (k=2) var wssse = mdlkmeans.computecost(data1) println(s\"within set sum of squared errors (k=2) = %.3f\".format(wssse)) println(\"cluster centers (k=2) : \" + mdlkmeans.clustercenters.mkstring(\"<\", \",\", \">\")) println(\"cluster sizes (k=2) : \" + mdlkmeans.summary.clustersizes.mkstring(\"<\", \",\", \">\")) // clustering model (k=4) algkmeans = new kmeans().setk(4) mdlkmeans = algkmeans.fit(data1) // model evaluation and interpretation (k=4) wssse = mdlkmeans.computecost(data1) println(s\"within set sum of squared errors (k=4) = %.3f\".format(wssse)) println(\"cluster centers (k=4) : \" + mdlkmeans.clustercenters.mkstring(\"<\", \",\", \">\")) println(\"cluster sizes (k=4) : \" + mdlkmeans.summary.clustersizes.mkstring(\"<\", \",\", \">\")) predictions = mdlkmeans.transform(data1) predictions.show(30) predictions.write.mode(\"overwrite\").option(\"header\",\"true\").csv(filepath + \"data/cluster-4k.csv\") data loading: data with two dimensions (x and y) is loaded. data transformation: vectorassembler creates a \"features\" vector column. clustering model: a kmeans object is created and the number of clusters (\\(k\\)) is set. the model is trained using the fit() method. predictions: cluster assignments for each data point are predicted. model evaluation: the computecost() method calculates the within set sum of squared errors (wsse), which is a measure of cluster cohesion. cluster centers and cluster sizes are printed. running with different k: the code runs the clustering with k=2 and k=4, comparing the wsse and cluster characteristics to illustrate the effect of choosing different values for k. recommendation with als, data transformation and model evaluation this example demonstrates a recommendation system using the alternating least squares (als) algorithm // loading data // ... (code for loading data from text files, using rdds and dataframes) // data transformation and feature extraction // ... (code for transforming data using rdds and dataframes) // data splitting val array(train, test) = ratings3.randomsplit(array(0.8, 0.2)) println(\"train = \"+train.count()+\" test = \"+test.count()) // recommendation model val algals = new als() algals.setitemcol(\"product\") algals.setrank(12) algals.setregparam(0.1) algals.setmaxiter(20) val mdlreco = algals.fit(train) // predicting using the model val predictions = mdlreco.transform(test) predictions.show(5) predictions.printschema() // model evaluation and interpretation val pred = predictions.na.drop() println(\"orig = \"+predictions.count()+\" final = \"+ pred.count() + \" dropped = \"+ (predictions.count() - pred.count())) val evaluator = new regressionevaluator() evaluator.setlabelcol(\"rating\") var rmse = evaluator.evaluate(pred) println(\"root mean squared error = \"+\"%.3f\".format(rmse)) var mse = evaluator.evaluate(pred) println(\"mean squared error = \"+\"%.3f\".format(mse)) mse = pred.rdd.map(r => rowsqdiff(r)).reduce(_+_) / predictions.count().todouble println(\"mean squared error (calculated) = \"+\"%.3f\".format(mse)) data loading: movielens data is loaded from text files using rdds and then converted to dataframes. data transformation: the data is transformed to a suitable format for the recommendation algorithm. data splitting: the data is split into training and test sets. recommendation model: an als object is created and configured with parameters like rank, regularization parameter, and maximum iterations. the model is trained on the training data. predictions: predictions are made on the test data. model evaluation: rows with nan predictions are dropped to address the cold start problem. rmse and mse are calculated using a regressionevaluator. mse is also calculated manually for demonstration purposes. graphx this summary provides an introduction to graph processing and the spark graphx framework. introduction to graph processing graph processing involves analysing and manipulating graph structures, which consist of vertices (nodes) connected by edges. this field has long been crucial in industries like logistics, transportation, and social networking, with applications ranging from route optimisation to social network analysis. the importance of graph processing has surged with the rise of the internet, social media, and large datasets. applications now include analysing research collaborations, understanding social behaviour in animal populations, and investigating financial networks like the panama papers. graph processing systems there are two main categories of graph-based systems: graph processing systems excel at executing complex algorithms on large graph datasets. examples include spark graphx, pregel bsp, and graphlab. graph databases, like allegrograph, titan, neo4j, and rdf stores, are designed for efficient graph-based queries. organisations with extensive graph-based applications often employ both a graph database and a graph processing system as part of a larger data processing workflow challenges of graph processing traditional relational database systems struggle with complex graph algorithms due to their iterative and recursive nature, which often span the entire graph. partitioning data across multiple systems, common in database systems, is suboptimal for graph algorithms, particularly for \"long-tail\" graphs with many sparsely connected nodes. frameworks like mapreduce, based on data parallelism and disk-based partitioning, also face challenges in efficiently representing and processing graphs, especially when dealing with the numerous edge cuts inherent in long-tail graphs. spark graphx spark graphx addresses these challenges by offering graph parallelism over data parallelism and utilising spark's data-distributed rdd mechanism. this approach combines the strengths of both data and graph parallelism, enabling efficient processing of complex graph algorithms on large datasets. graphx provides various partitioning and storage schemes to optimise performance and allows for tuning based on specific application requirements and data characteristics. while graphx excels at computation, the new graphframes api integrates dataframes with graphs to facilitate powerful graph queries. graphx architecture graphx is built on top of spark and leverages its distributed processing capabilities, algorithms, and versioned computation graph. some machine learning algorithms within spark also utilise graphx apis. graphx offers a rich computational model, built-in algorithms, and apis for developing custom algorithms. it provides functionalities for: graph creation structure queries attribute transformers structure transformers connection mining primitives graphx computational model graphx uses a property graph model, where: vertices are connected by edges. both vertices and edges can have arbitrary objects as properties, accessible to the apis. it is a directed multigraph, meaning edges have direction, and multiple edges can exist between vertices. this model supports various graph types, including bipartite and tripartite graphs. each vertex consists of a unique id (64-bit integer) and a property object, while edges comprise source and destination vertex ids and a property object. building graphs with graphx there are four ways to create a graph in graphx: loading an edge list file using graphloader.edgelistfile(...). loading edge tuples from rdds using fromedgetuples(). creating a graph from a list of edges using fromedges(). creating a graph using edge and vertex rdds. the last method offers flexibility, especially when manipulating user-defined objects for vertices and edges graphx api landscape the graphx apis are organized into different categories: objects: edge, edgerdd, and others reside under org.apache.spark.graphx. graph object: contains apis like triplets, persist, subgraph, etc.. graph algorithms: separated under the graphops object to distinguish algorithms from graph implementation. analytic functions: functions like svd++, shortestpath, and others are located under lib structural apis graphx provides structural apis for analysing graph structure, such as: numedges and numvertices for getting the number of edges and vertices. triplets for accessing edge and connected vertex information together. indegrees and outdegrees for retrieving incoming and outgoing edge counts for vertices. subgraph for extracting subgraphs based on edge and vertex property predicates. community detection and analysis graphx offers algorithms for exploring network connections and communities, with applications in areas like fraud detection and security. some key algorithms include: trianglecount for identifying and counting triangles within the graph, useful for spam detection and community ranking. connectedcomponents for finding groups of vertices connected by paths. stronglyconnectedcomponents for identifying communities with bidirectional connections between all members graphx algorithms graphx includes various built-in algorithms for graph analysis: algorithm type graphx method/exmaple graph-parallel computation aggregatemessages(), pregel() pagerank pagerank(), staticpagerank(), personalizedpagerank() shortest paths and svd++ shortestpaths(), svd++ label propagation (lpa) labelpropagation() pagerank is a prominent algorithm for ranking the importance of vertices, with variations for static iterations, dynamic convergence, and personalized ranking based on a specified vertex. graph parallel computation apis graphx provides two primary apis for implementing custom graph algorithms: aggregatemessages(): a versatile api for aggregating information from neighbouring edges and vertices, operating similarly to a mapreduce paradigm on the graph. pregel(): a more general api that encompasses aggregatemessages() and offers greater flexibility in algorithm design. partition strategies efficient partitioning of large graphs is crucial for performance in distributed processing. graphx offers different partition strategies to address the challenges of long-tail graphs and minimise communication overhead: edge cut: partitions vertices across machines, with communication cost proportional to the number of edges cut. vertex cut: partitions edges, potentially duplicating vertices, with cost proportional to the number of machines spanned by each vertex. graphx defaults to a vertex cut strategy to mitigate hotspot issues caused by uneven distribution of connections. it offers four main strategies: randomvertexcut, canonicalrandomvertexcut, edgepartition1d, and edgepartition2d. case study: alphago tweet analytics the source provides a case study applying graphx to analyse a retweet network of tweets related to the alphago project. it outlines a data pipeline for collecting, processing, and analysing tweets to understand user rankings, locations, time zones, and follower-followee relationships. the case study demonstrates the process of modelling the retweet network as a graph, defining vertices as users, edges as retweets, and creating objects to store user and tweet attributes. it then showcases using graphx to create the graph from the processed tweet data and apply algorithms like pagerank to analyse user influence within the retweet network. code examples in the graphx source building a simple graph the source demonstrates building a graph representing a \"giraffe graph\" with two strongly connected groups (cliques) linked by a weak connection. defining vertices and edges the first step involves defining the vertices and edges, along with their associated properties: case class person(name:string,age:int) val defaultperson = person(\"na\",0) val vertexlist = list( (1l, person(\"alice\", 18)), (2l, person(\"bernie\", 17)), (3l, person(\"cruz\", 15)), (4l, person(\"donald\", 12)), (5l, person(\"ed\", 15)), (6l, person(\"fran\", 10)), (7l, person(\"genghis\",854)) ) val edgelist = list( edge(1l, 2l, 5), edge(1l, 3l, 1), edge(3l, 2l, 5), edge(2l, 4l, 12), edge(4l, 5l, 4), edge(5l, 6l, 2), edge(6l, 7l, 2), edge(7l, 4l, 5), edge(6l, 4l, 4) ) case class person(name:string,age:int): defines a case class to represent a person with attributes for name and age. this will be used as the vertex property. defaultperson: creates an instance of person with default values, used for vertices not explicitly defined in vertexlist but present in edgelist. vertexlist: a list of tuples, where each tuple represents a vertex. the first element of the tuple is the vertex id (a long integer), and the second is a person object. edgelist: a list of edge objects, where each edge represents a connection between two vertices. the edge constructor takes the source vertex id, destination vertex id, and an integer representing \"betweenness centrality\" as arguments. creating rdds and the graph next, the code creates rdds from the vertex and edge lists and constructs the graph: val vertexrdd = sc.parallelize(vertexlist) val edgerdd = sc.parallelize(edgelist) val graph = graph(vertexrdd, edgerdd,defaultperson) sc.parallelize(...): the parallelize method of the sparkcontext (sc) creates an rdd from the provided list. graph(vertexrdd, edgerdd, defaultperson): this constructs the graph using the vertex rdd, edge rdd, and the defaultperson object for handling missing vertices. structural apis the source presents examples using structural apis to query the graph: graph.numedges graph.numvertices val vertices = graph.vertices vertices.collect.foreach(println) val edges = graph.edges edges.collect.foreach(println) val triplets = graph.triplets triplets.take(3) triplets.map(t=>t.tostring).collect().foreach(println) numedges and numvertices: these methods return the number of edges and vertices in the graph, respectively. vertices and edges: these properties provide access to the rdds containing the vertices and edges of the graph. collect: this action retrieves all elements of an rdd to the driver program. foreach(println): iterates through the collected elements and prints each one. triplets: this property returns an rdd of edgetriplet objects, each representing an edge along with its source and destination vertices and their properties. take(3): retrieves the first three elements of the rdd. map(t => t.tostring): transforms each edgetriplet into a string representation. extracting subgraphs the source demonstrates extracting subgraphs based on edge and vertex properties: val indeg = graph.indegrees indeg.collect() val outdeg = graph.outdegrees outdeg.collect() val alldeg = graph.degrees alldeg.collect() val g1 = graph.subgraph(epred = (edge) => edge.attr > 4) g1.triplets.collect.foreach(println) val g2 = graph.subgraph(vpred = (id, person) => person.age > 21) g2.triplets.collect.foreach(println) indegrees, outdegrees, degrees: these methods calculate the incoming, outgoing, and total degrees for each vertex, respectively. subgraph(epred = ..., vpred = ...): this method creates a subgraph by applying predicates to filter edges and vertices. epred is a function that takes an edge object and returns a boolean indicating whether to include the edge. vpred is a function that takes a vertex id and its corresponding property object and returns a boolean indicating whether to include the vertex. community detection the source shows examples of using graphx algorithms for community detection: val cc = graph.connectedcomponents() cc.triplets.collect graph.connectedcomponents.vertices.map(_.swap).groupbykey.map(_._2).collect cc.vertices.map(_._2).collect.distinct.size cc.vertices.groupby(_._2).map(p=>(p._1,p._2.size)).sortby(x=>x._2,false).collect() val ccs = graph.stronglyconnectedcomponents(10) ccs.triplets.collect ccs.vertices.map(_.swap).groupbykey.map(_._2).collect ccs.vertices.map(_._2).collect.distinct.size val tricounts = graph.trianglecount() val trianglecounts = tricounts.vertices.collect connectedcomponents(): this algorithm finds groups of vertices connected by paths, returning a new graph where each vertex is assigned the id of its connected component. stronglyconnectedcomponents(10): this algorithm identifies strongly connected components, where bidirectional paths exist between all members. the argument 10 specifies the maximum number of iterations. trianglecount(): this algorithm counts the number of triangles each vertex participates in. these code snippets showcase various operations on the resulting graphs, such as collecting triplets, grouping vertices, and counting connected components. pagerank calculation val ranks = graph.pagerank(0.1).vertices ranks.collect().foreach(println) val topvertices = ranks.sortby(_._2,false).collect.foreach(println) pagerank(0.1): this algorithm calculates the pagerank for each vertex in the graph. the argument 0.1 specifies the damping factor. sortby(_._2, false): sorts the pagerank results in descending order based on the pagerank value (_._2). aggregate messages api the source provides examples using the aggregatemessages() api to perform computations on the graph: finding the oldest follower val oldestfollower = graph.aggregatemessages[int]( edgecontext => edgecontext.sendtodst(edgecontext.srcattr.age), (x,y) => math.max(x,y) ) oldestfollower.collect() aggregatemessages[int](...): this api aggregates values from neighbouring vertices and edges. it takes two functions as arguments: sendmsg: a function that operates on each edge context (edgecontext) and sends messages to either the source or destination vertex. in this case, it sends the age of the source vertex (srcattr.age) to the destination vertex using sendtodst. mergemsg: a function that combines messages received at each vertex. here, it uses math.max to determine the oldest age among the received messages. finding the oldest followee val oldestfollowee = graph.aggregatemessages[int]( edgecontext => edgecontext.sendtosrc(edgecontext.dstattr.age), (x,y) => math.max(x,y) ) oldestfollowee.collect() this example is similar to the previous one but uses sendtosrc to send the age of the destination vertex (dstattr.age) to the source vertex. calculating in-degree and out-degree var idegree = graph.aggregatemessages[int]( edgecontext => edgecontext.sendtodst(1), (x,y) => x+y ) idegree.collect() graph.indegrees.collect() val odegree = graph.aggregatemessages[int]( edgecontext => edgecontext.sendtosrc(1), (x,y) => x+y ) odegree.collect() graph.outdegrees.collect() these examples demonstrate implementing the indegrees and outdegrees functionality using the aggregatemessages() api. they send a message of 1 to either the destination (for in-degree) or source (for out-degree) vertex for each edge and then sum the messages received at each vertex using x + y. alphago tweet analytics we present a case study using graphx to analyse a retweet network of tweets related to the alphago project. the provided code snippets focus on data loading and transformation to create the graph: loading data and creating a dataframe import org.apache.spark.sparkcontext import org.apache.spark.sparkconf import org.apache.spark.graphx._ println(new java.io.file( \".\" ).getcanonicalpath) println(s\"running spark version ${sc.version}\") val df = sqlcontext.read.format(\"com.databricks.spark.csv\").option(\"header\", \"false\").option(\"inferschema\", \"true\").option(\"delimiter\",\"|\").load(\"file:/users/ksankar/fdps-v3/data/retweetnetwork-small.psv\") df.show(5) df.count() case class user(name:string, location:string, tz : string, fr:int,fol:int) case class tweet(id:string,count:int) val graphdata = df.rdd println(\"--- the graph data ---\") graphdata.take(2).foreach(println) import statements: import necessary classes from spark and graphx. print statements: print the current directory and spark version. sqlcontext.read...: reads the data from a pipe-separated value (psv) file into a dataframe using the spark-csv package. case class user(...) and case class tweet(...): define case classes to represent user and tweet data. graphdata = df.rdd: extracts the underlying rdd from the dataframe. mapping data to vertices and edges val vert1 = graphdata.map(row => (row(3).tostring.tolong,user(row(4).tostring,row(5).tostring,row(6).tostring,row(7).tostring.toint,row(8).tostring.toint))) println(\"--- vertices-1 ---\") vert1.count() vert1.take(3).foreach(println) val vert2 = graphdata.map(row => (row(9).tostring.tolong,user(row(10).tostring,row(11).tostring,row(12).tostring,row(13).tostring.toint,row(14).tostring.toint))) println(\"--- vertices-2 ---\") vert2.count() vert2.take(3).foreach(println) val vertx = vert1.++(vert2) println(\"--- vertices-combined ---\") vertx.count() val edgx = graphdata.map(row => (edge(row(3).tostring.tolong,row(9).tostring.tolong,tweet(row(0).tostring,row(1).tostring.toint)))) println(\"--- edges ---\") edgx.take(3).foreach(println) vert1 and vert2: these variables use map transformations on the graphdata rdd to extract user data from different columns of the data and create rdds of vertices. vertx = vert1.++(vert2): combines the two vertex rdds. edgx: uses a map transformation to extract tweet data and create an rdd of edges. creating the graph and running algorithms val rtgraph = graph(vertx,edgx) val ranks = rtgraph.pagerank(0.1).vertices println(\"--- page rank ---\") ranks.take(2) println(\"--- top users ---\") val topusers = ranks.sortby(_._2,false).take(3).foreach(println) val topuserswnames = ranks.join(rtgraph.vertices).sortby(_._2._1,false).take(3).foreach(println) println(\"--- how big ? ---\") rtgraph.vertices.count rtgraph.edges.count println(\"--- how many retweets ? ---\") val ideg = rtgraph.indegrees val odeg = rtgraph.outdegrees ideg.sortby(_._2,false).take(3).foreach(println) odeg.sortby(_._2,false).take(3).foreach(println) println(\"--- max retweets ---\") val toprt = ideg.join(rtgraph.vertices).sortby(_._2._1,false).take(3).foreach(println) val toprt1 = odeg.join(rtgraph.vertices).sortby(_._2._1,false).take(3).foreach(println) rtgraph = graph(vertx, edgx): constructs the graph from the vertex and edge rdds. pagerank(0.1): calculates pagerank. sortby(...): sorts results. join(...): joins rdds to combine data. indegrees and outdegrees: calculate in-degree and out-degree values. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/PR/CC/09.html",
    "title": "Classes",
    "body": " index search search back classes contents class organization encapsulation classes should be small the single responsibility principle cohesion maintaining cohesion results in many small classes organizing for change isolating from change class organization following the standard java convention, a class should begin with a list of variables. public static constants, if any, should come first. then private static variables, followed by private instance variables. there is seldom a good reason to have a public variable public functions should follow the list of variables. we like to put the private utilities called by a public function right after the public function itself. encapsulation we like to keep our variables and utility functions private (or protected when accessed by a test). classes should be small! the first rule of classes is that they should be small. how small? we count in reposibilities. the name of a class should describe what responsibilities it fulfills. in fact, naming is probably the first way of helping determine class size. if we cannot derive a concise name for a class, then it’s likely too large. the single responsibility principle the single responsibility principle (srp)2 states that a class or module should have one, and only one, reason to change. cohesion classes should have a small number of instance variables. in general the more variables a method manipulates the more cohesive that method is to its class. a class in which each variable is used by each method is maximally cohesive. maintaining cohesion results in many small classes consider a large function with many variables declared within it. let’s say you want to extract one small part of that function into a separate function. must you pass all four of those variables into the new function as arguments? not at all! if we promoted those four variables to instance variables of the class, then we could extract the code without passing any variables at all. unfortunately, this also means that our classes lose cohesion because they accumulate more and more instance variables. but, if there are a few functions that want to share certain variables, doesn’t that make them a class in their own right? of course it does. when classes lose cohesion, split them! the first thing you might notice is that the program gets a lot longer. organizing for change for most systems, change is continual. every change subjects us to the risk that the remainder of the system no longer works as intended. in a clean system we organize our classes so as to reduce the risk of change. in an ideal system, we incorporate new features by extending the system, not by making modifications to existing code. open-closed principle, or ocp: classes should be open for extension but closed for modification. isolating from change needs will change, therefore code will change. a client class depending upon concrete details is at risk when those details change. we can introduce interfaces and abstract classes to help isolate the impact of those details. by minimizing coupling in this way, our classes adhere to another class design principle known as the dependency inversion principle (dip). in essence, the dip says that our classes should depend upon abstractions, not on concrete details. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/3C_1C/ICPDM/M02/04_monitorization.html",
    "title": "Configuración, monitorización y optimización de Spark",
    "body": " index search search back configuración, monitorización y optimización de spark contents monitoring spark applications what to monitor monitoring the driver and executors monitoring queries and tasks spark logs spark ui spark rest api spark ui history server debugging and spark first aid code examples optimising spark application performance indirect performance enhancements design choices cluster configurations data at rest shuffle configurations memory pressure and garbage collection direct performance enhancements parallelism improved filtering repartitioning and coalescing custom partitioning user-defined functions udfs temporary data storage caching joins aggregations broadcast variables code examples code example 1 registering classes for kryo serialisation code example 2 caching a dataframe monitoring spark applications this document explains how to monitor spark applications using logs and the spark ui. it covers the different components involved in a spark application and what to monitor to ensure its smooth execution. what to monitor when monitoring a spark application, it's essential to monitor the following: processes: monitor processes running your application at the level of cpu usage, memory usage etc. query execution: keep track of jobs, tasks and other aspects of query execution. monitoring the driver and executors importance: the driver holds the application's state and executors run individual jobs. it's crucial to monitor both to ensure their stability. metrics system: spark provides a configurable metrics system based on the dropwizard metrics library to monitor driver and executor states. configuration: the metrics system can be configured using a configuration file located at $spark_home/conf/metrics.properties. output sinks: the metrics can be output to various sinks, including cluster monitoring solutions like ganglia. monitoring queries and tasks granular monitoring: spark allows you to monitor individual queries, jobs, stages, and tasks. performance tuning: this granular information helps you with performance tuning and debugging. spark logs detailed monitoring: spark logs offer a detailed way to monitor applications, highlighting strange events or errors that might cause job failures. integrated logging: if you use the application template provided in this book, your application logs will appear alongside spark's logs. this makes it easy to correlate the two. changing log level: you can change spark's log level to adjust the detail of the logs. log location: logs are either printed to standard error in local mode or saved to files by your cluster manager when running spark on a cluster. benefits of log collection: collecting logs helps you debug issues and can be referenced in the future if an application crashes. spark ui visual monitoring: the spark ui provides a visual interface for monitoring running applications and viewing metrics about your spark workload. accessibility: each spark context launches a web ui, by default on port 4040, accessible via your web browser. multiple applications will launch web uis on increasing port numbers (4041, 4042...). ui tabs: the ui includes tabs for jobs, stages, storage, environment, sql, and executors, providing information on the corresponding aspects of your spark application. example: this document walks through an example using the sql tab to trace a query execution, providing a visual representation of the job, stages and tasks. the example shows how to: navigate to the sql tab in the spark ui after running a sql query. interpret aggregate statistics about the query, such as submission time, duration, and number of jobs. understand the directed acyclic graph (dag) of spark stages, where each blue box represents a stage of spark tasks, forming a job. examine each stage to understand its function. analyse the job's execution in the jobs tab, breaking down stages and tasks. click individual stages to view detailed information about their execution. review the summary metrics section, which provides statistics about various metrics. examine per-executor details to identify any struggling executors. access and understand the more detailed metrics by clicking \"show additional metrics.\" other tabs: storage: shows information about cached rdds/dataframes on the cluster, helpful for seeing if data has been evicted from the cache. environment: shows information about the runtime environment, including scala, java, and configured spark properties. configuration: you can configure the spark ui using network configurations and behaviour settings. refer to the relevant table on spark ui configurations in the spark documentation. spark rest api programmatic access: the spark rest api offers programmatic access to spark's status and metrics. location: the rest api is available at http://localhost:4040/api/v1. purpose: the rest api enables the building of visualisations and monitoring tools on top of spark. data: it exposes similar information to the web ui, except for sql-related information. use: the api is valuable for building custom reporting solutions. for a list of api endpoints, consult the relevant table on rest api endpoints in the spark documentation. spark ui history server post-execution access: the spark ui history server provides access to the spark ui and rest api even after an application ends or crashes. requirement: the application must be configured to save an event log using spark.eventlog.enabled and spark.eventlog.dir settings. usage: once events are logged, you can run the history server as a standalone application to reconstruct the web ui. some cluster managers and cloud services configure logging automatically and run a history server by default. additional configurations: you can further configure the history server, details of which can be found in the spark history server configurations table in the spark documentation. debugging and spark first aid the source outlines various issues and their possible solutions that you might encounter when working with spark, such as: spark jobs not starting: this section explains potential reasons why your spark jobs may not be starting and offers possible solutions. these include verifying network configurations, resource allocation, and cluster setup. errors before execution: this part focuses on debugging errors that occur even before your spark job starts execution. the source suggests scrutinising your code for errors, checking network connectivity, and troubleshooting library or classpath issues. errors during execution: the document addresses issues arising during the execution of a spark job. it recommends checking for data consistency, schema correctness, and logic errors in your code. slow tasks or stragglers: this section focuses on identifying and addressing slow tasks, often termed \"stragglers.\" the source attributes these to uneven data distribution, skewed keys, or hardware problems. it suggests solutions like repartitioning data, increasing memory allocation, and identifying problematic executors. slow aggregations: this section focuses on slow aggregations, recommending solutions such as increasing partitions, executor memory, and optimising data handling, specifically related to null values. slow joins: similar to slow aggregations, this section deals with slow join operations. it suggests exploring different join types, optimising join order, and using broadcast joins when possible. slow reads and writes: this part addresses slow input/output (i/o) operations, particularly with network file systems. it suggests enabling speculation to mitigate transient issues, ensuring adequate network bandwidth, and utilising locality-aware scheduling. driver outofmemoryerror or driver unresponsive: this section explains the critical issue of driver failure due to insufficient memory. it suggests avoiding collecting large datasets to the driver, controlling broadcast join sizes, and optimising memory usage. executor outofmemoryerror or executor unresponsive: this section deals with executor failures due to memory issues. it recommends increasing executor memory, optimising data partitioning and null value handling, and using java monitoring tools to identify problematic objects. unexpected nulls in results: this part focuses on unexpected null values, recommending validating data formats, using accumulators to count parsing errors, and ensuring that transformations result in valid query plans. no space left on disk errors: this section addresses disk space issues, suggesting increasing storage capacity, repartitioning data to avoid skew, and managing log and shuffle files. serialization errors: this part explains serialization errors, typically encountered with custom logic using udfs or rdds. it suggests ensuring that all required data and code can be serialized and properly registering classes when using kryo serialization. code examples the source provides one code example to demonstrate how to use the spark ui for monitoring and debugging. here is the code snippet and an explanation: # in python spark.read\\ .option(\"header\", \"true\")\\ .csv(\"/data/retail-data/all/online-retail-dataset.csv\")\\ .repartition(2)\\ .selectexpr(\"instr(description, 'glass') >= 1 as is_glass\")\\ .groupby(\"is_glass\")\\ .count()\\ .collect() this code snippet performs a series of operations on a csv file using pyspark, spark's python api: spark.read.option(\"header\", \"true\").csv(...): this line reads a csv file located at /data/retail-data/all/online-retail-dataset.csv, specifying that the file has a header row. .repartition(2): the data is repartitioned into two partitions. this action is explicitly taken to demonstrate how the number of partitions affects task distribution in the spark ui. .selectexpr(\"instr(description, 'glass') >= 1 as is_glass\"): this line adds a new column named is_glass. it uses the instr function to check if the description column contains the word \"glass\". if the word is found, the is_glass column is set to true; otherwise, it's set to false. .groupby(\"is_glass\").count(): the data is grouped by the is_glass column, and the count for each group is calculated. .collect(): this action collects the results of the count operation to the driver node. optimising spark application performance this note summarises ways to improve the performance of spark applications based on the source document. it covers both indirect enhancements and direct performance enhancements. indirect performance enhancements these are enhancements you can apply to improve spark jobs generally, rather than focusing on specific jobs or stages. design choices the choices you make when designing your applications can significantly impact performance. here are a few things to consider: choice of language: spark's structured apis perform similarly across languages like scala, java, python, and r. however, if custom transformations are needed, using scala or java is recommended for udfs as they offer better performance and type safety compared to python or r. using dataframes/sql/datasets: these offer better performance compared to rdds due to spark's sql engine optimisations. if you have to use udfs, scala or java will perform better than python or r. object serialisation in rdds: kryo serialisation is recommended over java serialisation as it's more compact and efficient. register the classes you want to serialise with kryo cluster configurations optimising cluster configurations can yield significant performance gains. monitoring machine performance is crucial, especially in shared cluster environments. consider the following: resource allocation: dynamic allocation allows applications to adjust resources based on workload, enabling efficient resource sharing in a cluster. scheduling: using scheduler pools for parallel job execution and dynamic allocation or setting max-executor-cores can optimise resource usage. data at rest efficient data storage is key to fast data reads. opting for structured binary formats and utilising features like data partitioning can optimise read performance. here are some points to consider: file format: use structured, binary formats like apache parquet as they are faster to parse than formats like csv. splittable file types: use splittable file types like gzip, bzip2, or lz4 (especially when compressed) for parallel data reads. avoid non-splittable formats like zip or tar. table partitioning: partition data based on frequently used filter keys like date or customer id to improve query performance by reducing data reads. bucketing: bucketing \"pre-partitions\" data based on potential joins or aggregations, enhancing performance and stability by ensuring consistent data distribution. number of files: aim for a balance between the number and size of files. too many small files increase overhead while fewer large files limit parallelism. an ideal size for files is a few tens of megabytes. data locality: spark can schedule tasks close to data blocks if the storage system supports locality hints (like hdfs), reducing network overhead. statistics collection: collecting statistics on tables (both table-level and column-level) allows the cost-based optimizer to make informed decisions for operations like joins and aggregations. shuffle configurations the external shuffle service can improve performance by allowing nodes to read shuffle data from remote machines even when those machines are busy. consider tuning shuffle configurations like the number of concurrent connections per executor. using kryo serialisation for rdd-based jobs and optimising the number of shuffle partitions can also enhance performance. memory pressure and garbage collection excessive garbage collection can hinder performance. strategies for mitigating this include: using structured apis: structured apis reduce memory pressure by avoiding the creation of jvm objects. monitoring garbage collection: track garbage collection frequency and duration by adding jvm options like -verbose:gc -xx:+printgcdetails -xx:+printgctimestamps to the spark.executor.extrajavaoptions configuration. garbage collection tuning: tune garbage collection based on insights from the gathered statistics. the spark documentation provides detailed guidance on tuning parameters. direct performance enhancements these enhancements focus on specific spark jobs or stages and may require individual inspection and optimisation. parallelism increasing parallelism is a key strategy for speeding up stages that process substantial amounts of data. aim for at least 2-3 tasks per cpu core. adjust the spark.default.parallelism and spark.sql.shuffle.partitions properties accordingly. improved filtering filtering data as early as possible in the data processing pipeline significantly reduces the amount of data processed, improving performance. utilise push-down predicates to filter data at the source level. leveraging partitioning and bucketing also facilitates efficient filtering. repartitioning and coalescing repartitioning, which incurs a shuffle, can improve data balancing across the cluster. however, coalescing, which merges partitions on the same node, is a more efficient option when reducing the number of partitions as it avoids a shuffle. repartitioning can be beneficial before joins or caching. custom partitioning while rarely necessary, custom partitioning at the rdd level provides granular control over data organisation across the cluster, potentially optimising performance and stability. user-defined functions (udfs) minimising the use of udfs is recommended as they introduce overhead by requiring data representation as jvm objects. prioritise the use of structured apis for efficient transformations. explore options like vectorized udfs for python, which process data in batches using pandas data frames. temporary data storage (caching) caching stores frequently accessed datasets in memory or on disk, reducing the need to recompute them. however, consider the cost of serialisation, deserialization, and storage when deciding whether to cache. caching is particularly beneficial for iterative operations or when reusing datasets multiple times. spark offers various storage levels for caching, each with different performance characteristics. refer to table 19-1 in the source for details on the available storage levels. joins understanding the different types of joins and their execution mechanisms is crucial for optimisation. prefer equi-joins as they are easily optimised by spark. strategically filtering data and ordering joins can also improve performance. use broadcast join hints to guide spark's query planning. minimise the use of cartesian joins or full outer joins as they can often be replaced with more efficient filtering-style joins. aggregations optimise aggregations by filtering data beforehand and ensuring sufficient parallelism. when using rdds, choose aggregation methods like reducebykey over groupbykey for improved speed and stability. broadcast variables broadcast variables can improve performance by distributing read-only copies of large datasets used across multiple udf calls to all nodes, reducing data transfer overhead. this technique is beneficial for datasets like lookup tables or machine learning models. code examples the provided source document offers two code examples that focus on: registering classes for kryo serialisation: this snippet demonstrates how to configure spark to use kryo for object serialisation in rdd transformations, which can be more efficient than the default java serialisation. caching a dataframe: this example illustrates how to use the cache() method to store a dataframe in memory for faster access in subsequent operations, showcasing a simple performance optimisation technique. code example 1: registering classes for kryo serialisation conf.registerkryoclasses(array(classof[myclass1], classof[myclass2])) this code snippet, presented in the context of optimising object serialisation in rdds, demonstrates how to register specific classes (myclass1 and myclass2) with the kryo serialiser. kryo is a more efficient serialisation library compared to java's default serialisation mechanism, offering both compactness and speed advantages. to enable kryo serialisation, you need to set the spark.serializer configuration property to org.apache.spark.serializer.kryoserializer. after enabling kryo, you can register the classes you'll be working with using the registerkryoclasses method on the sparkconf object. by registering these classes, you instruct kryo to handle their serialisation and deserialization, potentially leading to improved performance in rdd transformations that involve these custom data types. code example 2: caching a dataframe # in python # original loading code that does *not* cache dataframe df1 = spark.read.format(\"csv\")\\ .option(\"inferschema\", \"true\")\\ .option(\"header\", \"true\")\\ .load(\"/data/flight-data/csv/2015-summary.csv\") df2 = df1.groupby(\"dest_country_name\").count().collect() df3 = df1.groupby(\"origin_country_name\").count().collect() df4 = df1.groupby(\"count\").count().collect() df1.cache() df1.count() # in python df2 = df1.groupby(\"dest_country_name\").count().collect() df3 = df1.groupby(\"origin_country_name\").count().collect() df4 = df1.groupby(\"count\").count().collect() this code example demonstrates the use of caching to optimise the repeated use of a dataframe. initial dataframe loading: the first code block loads a dataframe (df1) from a csv file. three subsequent dataframes (df2, df3, and df4) are derived from df1, each performing a groupby and count operation. without caching, these operations would repeatedly read and parse the original csv file, leading to redundant work. caching the dataframe: the second code block introduces the cache() method applied to df1. this instructs spark to store the dataframe in memory after its first computation. the count() action is used to trigger the caching process as caching is a lazy operation in spark. benefit of caching: the final code block re-executes the groupby and count operations for df2, df3, and df4. due to caching, these operations now access the dataframe from memory, significantly reducing processing time by avoiding the repeated file reads and parsing. this example highlights how caching can substantially improve performance in scenarios where a dataset is reused multiple times. the persist() method, which provides more control over storage levels (memory, disk, or both), is also mentioned as an alternative to cache(). $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/PR/CC/10.html",
    "title": "Systems",
    "body": " index search search back systems contents separate constructing a system from using it factories dependency injection scaling up cross-cutting concerns optimize decision making use standards wisely when they add demonstrable value systems need domain-specific languages in this chapter let us consider how to stay clean at higher levels of abstraction, the system level. separate constructing a system from using it the separation of concerns is one of the oldest and most important design techniques in our craft. one way to separate construction from use is simply to move all aspects of construction to main, or modules called by main, and to design the rest of the system assuming that all objects have been constructed and wired up appropriately. (see figure 11-1) factories sometimes we need to make the application responsible for when an object gets created. in this case we can use the abstract factory pattern to give the application control of when to build the objct, but keep the details of that construction separate from the application code. dependency injection a powerful mechanism for separating construction from use is dependency injection (di), the application of inversion of control (ioc) to dependency management.3 inversion of control moves secondary responsibilities from an object to other objects that are dedicated to the purpose, thereby supporting the single responsibility principle. in the context of dependency management, an object should not take responsibility for instantiating dependencies itself. instead, it should pass this responsibility to another “authoritative” mechanism, thereby inverting the control. the class takes no direct steps to resolve its dependencies; it is completely passive. instead, it provides setter methods or constructor arguments (or both) that are used to inject the dependencies. during the construction process, the di container instantiates the required objects (usually on demand) and uses the constructor arguments or setter methods provided to wire together the dependencies. which dependent objects are actually used is specified through a configuration file or programmatically in a special-purpose construction module. but what about the virtues of lazy-initialization? this idiom is still sometimes useful with di. first, most di containers won’t construct an object until needed. second, many of these containers provide mechanisms for invoking factories or for constructing proxies, which could be used for lazy-evaluation and similar optimizations. scaling up it is a myth that we can get systems “right the first time.” instead, we should implement only today’s stories, then refactor and expand the system to implement new stories tomorrow. this is the essence of iterative and incremental agility. test-driven development, refactoring, and the clean code they produce make this work at the code level. software systems are unique compared to physical systems. their architectures can grow incrementally, if we maintain the proper separation of concerns. cross-cutting concerns note that concerns like persistence tend to cut across the natural object boundaries of a domain. you want to persist all your objects using generally the same strategy. using persistence as an example, you would declare which objects and attributes (or patterns thereof) should be persisted and then delegate the persistence tasks to your persistence framework. the behavior modifications are made noninvasively8 to the target code by the aop framework. an optimal system architecture consists of modularized domains of concern, each of which is implemented with plain old java (or other) objects. the different domains are integrated together with minimally invasive aspects or aspect-like tools. this architecture can be test-driven, just like the code. optimize decision making modularity and separation of concerns make decentralized management and decision making possible. the agility provided by a pojo system with modularized concerns allows us to make optimal, just-in-time decisions, based on the most recent knowledge. the complexity of these decisions is also reduced. use standards wisely, when they add demonstrable value standards make it easier to reuse ideas and components, recruit people with relevant experience, encapsulate good ideas, and wire components together. however, the process of creating standards can sometimes take too long for industry to wait, and some standards lose touch with the real needs of the adopters they are intended to serve. systems need domain-specific languages in software, there has been renewed interest recently in creating domain-specific languages (dsls), which are separate, small scripting languages or apis in standard languages that permit code to be written so that it reads like a structured form of prose that a domain expert might write. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/PR/CC/11.html",
    "title": "Emergence",
    "body": " index search search back emergence contents getting clean via emergent design simple design rule 1 runs all the tests simple design rules 2 refactoring simple design rules 3 no duplication simple design rules 3 expresiveness minimal classes and methods getting clean via emergent design what if by following some rules it waseasier to apply principles such as srp and dip? what if these rules facilitated the emergence of good designs? a design is “simple” if it follows these rules: runs all the tests contains no duplication expresses the intent of the programmer minimizes the number of classes and methods simple design rule 1: runs all the tests a system that is comprehensively tested and passes all of its tests all of the time is a testable system. systems that aren’t testable aren’t verifiable. arguably, a system that cannot be verified should never be deployed. fortunately, making our systems testable pushes us toward a design where our classes are small and single purpose. whilst tight coupling makes it difficult to write tests. simple design rules 2: refactoring once we have tests, we are empowered to keep our code and classes clean. we do this by incrementally refactoring the code. for each few lines of code we add, we pause and reflect on the new design. did we just degrade it? if so, we clean it up and run our tests to demonstrate that we haven’t broken anything. simple design rules 3: no duplication duplication is the primary enemy of a well-designed system. it represents additional work, additional risk, and additional unnecessary complexity. simple design rules 3: expresiveness in order to minimize the potential for defects as we introduce change, it’s critical for us to be able to understand what a system does. as systems become more complex, they take more and more time for a developer to understand, and there is an ever greater opportunity for a misunderstanding. therefore, code should clearly express the intent of its author. you can express yourself by choosing good names. you can also express yourself by keeping your functions and classes small. you can also express yourself by using standard nomenclature. by using the standard pattern names, such as command or visitor, in the names of the classes that implement those patterns, you can succinctly describe your design to other developers. well-written unit tests are also expressive. a primary goal of tests is to act as documentation by example. minimal classes and methods even concepts as fundamental as elimination of duplication, code expressiveness, and the srp can be taken too far. in an effort to make our classes and methods small, we might create too many tiny classes and methods. so this rule suggests that we also keep our function and class counts low. remember, however, that this rule is the lowest priority of the four rules of simple design. so, although it’s important to keep class and function count low, it’s more important to have tests, eliminate duplication, and express yourself. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/PR/CC/12.html",
    "title": "Concurrency",
    "body": " index search search back concurrency contents why concurrency myths and misconceptions challenges concurrency defense principles single responsibility principle limit the scope of the data use copies of data threadds should be as independent as possible know your execution models producer-consumer readers-writers dining philosofers beware dependencies between synchronized methods keep synchronized sections small writing correct shut-down code is hard testing threaded code make your threaded code pluggable run with more threads than processors run on different platforms instrument your code to try and force failures hand-coded automated writing clean concurrent programs is hard, very hard. it is much easier to write code that executes in a single thread. it is also easy to write multithreaded code that looks fine on the surface but is broken at a deeper level. such code works fine until the system is placed under stress. why concurrency? concurrency is a decoupling strategy. it helps us decouple what gets done from when it gets done. myths and misconceptions consider these common myths and misconceptions: concurrency always improves performance: only when there is a lot of wait time that can be shared between multiple threads or multiple processors. design does not change when writing concurrent program: the design of a concurrent algorithm can be remarkably different from the design of a single-threaded system. understanding concurrency issues is not important when working with a container here are a few more balanced sound bites regarding writing concurrent software: concurrency incurs some overhead, both in performance as well as writing additional code. correct concurrency is complex, even for simple problems. concurrency bugs aren’t usually repeatable, so they are often ignored as one-offs instead of the true defects they are. concurrency often requires a fundamental change in design strategy. challenges what makes concurrent programming so difficult? consider the following trivial class: public class x { private int lastidused; public int getnextid() { return ++lastidused; } let’s say we create an instance of x, set the lastidused field to 42, and then share the instance between two threads. now suppose that both of those threads call the method getnextid(). then one possible outcome is that thread one gets the value 43, thread two gets the value 43 and lastidused is 43. this surprising result occurs when the two threads step on each other. this happens because there are many possible paths that the two threads can take through that one line of java code, and some of those paths generate incorrect results. concurrency defense principles what follows is a series of principles and techniques for defending your systems from the problems of concurrent code. single responsibility principle concurrency design is complex enough to be a reason to change in it’s own right and therefore deserves to be separated from the rest of the code. here are a few things to consider: concurrency-related code has its own life cycle of development. concurrency-related code has its own challenges recommendation: keep your concurrency-related code separate from other code. limit the scope of the data as we saw, two threads modifying the same field of a shared object can interfere with each other, causing unexpected behavior. it is important to restrict the number of such critical sections. recommendation: take data encapsulation to heart; severely limit the access of any data that may be shared. use copies of data a good way to avoid shared data is to avoid sharing the data in the first place. if there is an easy way to avoid sharing objects, the resulting code will be far less likely to cause problems. you might be concerned about the cost of all the extra object creation. it is worth experimenting to find out if this is in fact a problem. however, if using copies of objects allows the code to avoid synchronizing, the savings in avoiding the intrinsic lock will likely make up for the additional creation and garbage collection overhead. threadds should be as independent as possible consider writing your threaded code such that each thread exists in its own world, sharing no data with any other thread. recommendation: attempt to partition data into independent subsets than can be operated on by independent threads, possibly in different processors. know your execution models we need to understand some basic definitions. bound resources: resources of a fixed size or number used in a concurrent environment. mutual exclusion: only one thread can access shared data or a shared resource at a time. starvation: one thread or a group of threads is prohibited from proceeding for an excessively long time or forever. deadlock: two or more threads waiting for each other to finish. each thread has a resource that the other thread requires and neither can finish until it gets the other resource. livelock: threads in lockstep, each trying to do work but finding another “in the way.” threads in lockstep, each trying to do work but finding another “in the way.” producer-consumer one or more producer threads create some work and place it in a buffer or queue. one or more consumer threads acquire that work from the queue and complete it. the queue between the producers and consumers is a bound resource. readers-writers coordinating readers so they do not read something a writer is updating and vice versa is a tough balancing act. writers tend to block many readers for a long period of time, thus causing throughput issues. a simple strategy makes writers wait until there are no readers before allowing the writer to perform an update. if there are continuous readers, however, the writers will be starved. on the other hand, if there are frequent writers and they are given priority, throughput will suffer. finding that balance and avoiding concurrent update issues is what the problem addresses. dining philosofers imagine a number of philosophers sitting around a circular table. a fork is placed to the left of each philosopher. there is a big bowl of spaghetti in the center of the table. the philosophers spend their time thinking unless they get hungry. once hungry, they pick up the forks on either side of them and eat. a philosopher cannot eat unless he is holding two forks. replace philosophers with threads and forks with resources and this problem is similar to many enterprise applications in which processes compete for resources. unless carefully designed, systems that compete in this way can experience deadlock, livelock, throughput, and efficiency degradation. beware dependencies between synchronized methods there will be times when you must use more than one method on a shared object. when this is the case, there are three ways to make the code correct: client-based locking—have the client lock the server before calling the first method and make sure the lock’s extent includes code calling the last method. server-based locking—within the server create a method that locks the server, calls all the methods, and then unlocks. have the client call the new method. adapted server—create an intermediary that performs the locking. keep synchronized sections small locks are expensive because they create delays and add overhead. so we want to design our code with as few critical sections as possible. recommendation: keep your synchronized sections as small as possible. writing correct shut-down code is hard writing a system that is meant to stay live and run forever is different from writing something that works for awhile and then shuts down gracefully. graceful shutdown can be hard to get correct. common problems involve deadlock, with threads waiting for a signal to continue that never comes. recommendation: think about shut-down early and get it working early. testing threaded code recommendation: write tests that have the potential to expose problems and then run them frequently, with different programatic configurations and system configurations and load. if tests ever fail, track down the failure. don’t ignore a failure just because the tests pass on a subsequent run. here are a few more fine-grained recommendations: treat spurious failures as candidate threading issues. get your nonthreaded code working first make your threaded code pluggable. make your threaded code tunable. run with more threads than processors. run on different platforms. instrument your code to try and force failures. make your threaded code pluggable write the concurrency-supporting code such that it can be run in several configurations: one thread, several threads, varied as it executes threaded code interacts with something that can be both real or a test double. execute with test doubles that run quickly, slowly, variable. configure tests so they can run for a number of iterations. run with more threads than processors things happen when the system switches between tasks. to encourage task swapping, run with more threads than processors or cores. run on different platforms different operating systems have different threading policies, each of which impacts the code’s execution. multithreaded code behaves differently in different environments. you should run your tests in every potential deployment environment. instrument your code to try and force failures it is normal for flaws in concurrent code to hide. simple tests often don’t expose them. indeed, they often hide during normal processing. how might you increase your chances of catching such rare occurrences? you can instrument your code and force it to run in different orderings. there are two options for code instrumentation: hand-coded automated hand-coded you can insert calls to wait(), sleep(), yield(), and priority() in your code by hand. here is an example of doing just that: public synchronized string nexturlornull() { if(hasnext()) { string url = urlgenerator.next(); thread.yield(); // inserted for testing. updatehasnext(); return url; } return null; } the inserted call to yield() will change the execution pathways taken by the code and possibly cause the code to fail where it did not fail before. there are many problems with this approach: you have to manually find appropriate places to do this. how do you know where to put the call and what kind of call to use? leaving such code in a production environment unnecessarily slows the code down. you may or may not find flaws. what we need is a way to do this during testing but not in production. we also need to easily mix up configurations. automated you could use tools like an aspect-oriented framework to programmatically instrument your code. for example, you could use a class with a single method: public class threadjigglepoint { public static void jiggle() { } } you can add calls to this in various places within your code: public synchronized string nexturlornull() { if(hasnext()) { threadjiglepoint.jiggle(); string url = urlgenerator.next(); threadjiglepoint.jiggle(); updatehasnext(); threadjiglepoint.jiggle(); return url; } return null; } now you use a simple aspect that randomly selects among doing nothing, sleeping, or yielding. or imagine that the threadjigglepoint class has two implementations. the first implements jiggle to do nothing and is used in production. the second generates a random number to choose between sleeping, yielding, or just falling through. if you run your tests a thousand times with random jiggling, you may root out some flaws. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/3C_1C/ICPDM/M03/01.html",
    "title": "Introducción a las arquitecturas de procesamiento de streams: Lambda y Kappa",
    "body": " index search search back introducción a las arquitecturas de procesamiento de streams: lambda y kappa contents what are data streams challenges with data streams key elements for analysing data streams working with data streams data windows architectures for handling data streams in today's world, we are surrounded by a constant flow of data. much of this data is created automatically and used between machines. this data is important because it can teach us things. but it is different from the data we are used to working with. this type of data is called a data stream. what are data streams? a data stream is a series of data that comes into a system over time. it's like a river of information that never stops flowing. here are some important things to remember about data streams: order is important: the order the data comes in matters because it can show how the data is related. think about the temperature recorded every hour. the order helps us see how the temperature changes over the day. it never ends: data streams can go on forever, so we can't store all the information. imagine trying to keep all the tweets ever sent! we only see a part: at any given time, we can only see a small part of the data stream. it's like looking at a small section of a river. speed changes: the speed at which data arrives can change. sometimes it's a trickle, and other times it's a flood! challenges with data streams because data streams are different from traditional data, they pose unique challenges: traditional data mining techniques assume we have all the data at once. with data streams, we only have a part of the data at any time. the way data is spread out (its distribution) can change over time. this is called concept drift and means that a model we built yesterday might not work well today. we may not get feedback on our models right away. this makes it harder to know if our models are working correctly. key elements for analysing data streams to work with data streams, we need special tools: memory: this acts like a temporary storage space to hold incoming data until it can be processed. algorithms: special algorithms are needed to learn from the data and make decisions. these algorithms need to be fast and able to adapt to changing data. change monitoring: we need ways to watch for concept drift, which is when the patterns in the data change over time. performance evaluation: traditional methods for evaluating models don't work well with data streams. new methods are needed to see how well our models are performing. working with data streams: data windows one important technique for handling data streams is called windowing. since we can't store all the data, windows allow us to focus on the most recent data: landmarks: we can define windows based on specific events. think about analysing data between each time a sensor is reset. sliding windows: these windows keep a fixed amount of the most recent data. as new data arrives, old data is dropped. example: imagine you are analysing tweets about a football match. a sliding window might keep only the last 10 minutes of tweets, allowing you to see what people are saying right now. architectures for handling data streams there are two main ways to build systems for processing data streams: lambda architecture: this approach uses two paths: one for real-time processing (online) and one for batch processing (offline). it's like having a team that gives quick updates and another team that does a more detailed analysis later. kappa architecture: this approach uses only real-time processing. it's like having one team that can handle everything quickly. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/3C_1C/ICPDM/M03/02.html",
    "title": "Componentes tecnológicos de adquisición y transmisión/distribución de eventos: Kafka",
    "body": " index search search back componentes tecnológicos de adquisición y transmisión/distribución de eventos: kafka contents introduction apache kafka architecture of kafka reading and writing in kafka kafka command line interface cli conclusion this summary explains apache kafka, a platform for handling large streams of data, based on the provided source text. introduction in large-scale data processing, data needs to be transmitted efficiently from its source to the processing system. traditional methods rely on direct connections between devices, which is not scalable. message queues and pub/sub systems offer improved scalability. message queues involve a single consumer receiving and processing each message. this approach is common in microservices and suitable for bulk task processing. if one consumer fails, another can take over the message. pub/sub systems use a central node called a broker to manage message queues, called topics. all consumers subscribed to a topic receive copies of the messages. this is useful for distributing data to multiple systems and is fault-tolerant, allowing consumers to recover missed messages after a failure. however, traditional pub/sub systems can face performance issues and limited storage capacity in massive data environments. this is where apache kafka comes in. apache kafka apache kafka is a streaming platform that uses the pub/sub model for sending messages and monitoring events. it is designed to handle large data streams with high performance and low latency. kafka offers persistent data storage for a user-defined duration and even includes a processing engine (kafka streams) for data transformation before it reaches the consumers. architecture of kafka kafka's architecture is distributed and fault-tolerant, thanks to its high data replication. a kafka cluster consists of multiple brokers, each typically located on a different server. these brokers store data and can manage multiple topics. each topic can be distributed across multiple brokers, further enhancing fault tolerance. topics are divided into partitions to improve fault tolerance and throughput. a partition is essentially a data stream, acting as the fundamental data structure within kafka. it can be viewed as a log file where data is appended. sequential writing and reading of data in partitions improve performance. each data entry in a partition has a unique identifier called an offset, which is helpful for resuming reading from a specific point. partitions offer scalability, allowing the size of a topic to exceed the capacity of a single machine. they increase throughput by enabling parallel data serving to multiple consumers. additionally, partitions provide redundancy because multiple copies of the same partition (called replicas) are stored on different brokers. if one broker fails, the partition can be recovered from another broker. it's crucial to note that while the order of data arrival is guaranteed within a partition, it is not guaranteed between different partitions. replication is a core feature of kafka's architecture. a replica is a copy of a partition and plays a vital role in fault tolerance. the replication factor determines the number of copies made for each partition. a designated replica acts as the leader, responsible for receiving and sending data to consumers. the remaining replicas, called followers, synchronise with the leader asynchronously using zookeeper. zookeeper is another key component in the architecture, managing service discovery and leader election for kafka brokers. it informs kafka about changes in the cluster's topology, ensuring each node knows about new brokers, broker failures, topic additions or removals, and other events. this provides a synchronised view of the kafka cluster's configuration. reading and writing in kafka producers send events or data to kafka, which are distributed among the different partitions. each piece of data goes to a single partition, ensuring that the order of arrival is maintained only within those partitions. write operations are append-only, meaning data is sequentially added to the end of the partition on disk. consumers can choose the offset from which they want to read data. kafka doesn't keep track of which messages have been read, which simplifies the system but makes complex delivery logic more challenging. consumers are typically organised into groups, ensuring each consumer reads from a different partition and enhancing scalability. kafka command line interface (cli) the kafka cli provides a way to interact with kafka from the command line. it is used for tasks such as initialising zookeeper and brokers, creating and managing topics, publishing data to topics, and consuming data from them. conclusion kafka is a powerful platform designed to handle high-volume data streams in a distributed and fault-tolerant manner. understanding its architecture, features, and command-line interface is crucial for effectively utilising kafka in data processing pipelines. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/3C_1C/ICPDM/M03/03.html",
    "title": "Procesamiento de streams: Apache Spark Streaming",
    "body": " index search search back procesamiento de streams: apache spark streaming contents what is spark streaming how spark streaming works key features using spark streaming additional features this summary will help you understand spark streaming, a system for processing large streams of data in real time. it's based on apache spark, a powerful engine for handling big data. what is spark streaming? spark streaming is a component of apache spark designed for real-time data processing. it takes continuous data streams and processes them in small batches called micro-batches. this approach is based on defining data windows that collect data from the stream and are then processed. one of the key benefits of spark streaming is that it extends the familiar spark api, meaning the syntax is almost identical. this allows developers to work with streaming data using the same tools and concepts they use for batch processing. spark streaming is versatile in terms of data sources and outputs. it can ingest data from various sources like kafka, flume, twitter, and network sockets. similarly, it can write processed data to various destinations like hdfs, databases, and dashboards. how spark streaming works the basic workflow of spark streaming involves: creating micro-batches: the incoming data stream is divided into micro-batches. the default is timestamp-based windows without overlap, and you specify the window size in seconds. processing as rdds: each micro-batch is treated as an rdd (resilient distributed dataset), the fundamental data structure in spark. you can apply the same actions and transformations used in regular spark operations. managing with dstreams: the sequence of micro-batches is stored in a dstream (discretized stream), which provides additional functionality specific to stream processing. essentially, a dstream represents a continuous stream of rdds. key features high-level abstraction: spark streaming hides the complexities of stream processing from the user, simplifying development. code reusability: since micro-batches are processed as rdds, you can reuse existing spark code, including sparksql and mllib libraries. micro-batch approach: this offers advantages like high throughput (processing more instances per unit of time) but comes with increased latency as the minimum processing time is limited by the batch window size. architecture fit: spark streaming is highly suited for lambda architectures where spark handles offline processing, and spark streaming manages online processing. however, it might not be ideal for kappa architectures that aim for purely stream-based processing. using spark streaming create a streaming context: this is done using the spark context and specifies the duration of each micro-batch. define data input: spark streaming supports basic inputs like files, sockets, and rdd queues. it also has advanced input options using libraries for sources like kafka, flume, and kinesis. custom inputs can also be created using ad-hoc connectors. apply transformations: dstreams support various transformations similar to rdds like map, flatmap, filter, reduce, and count. these allow you to manipulate and process data within each micro-batch. define data output: output can be directed to the standard output using dstream.pprint(), saved to external storage with dstream.saveastextfiles(), or processed using custom functions applied to each rdd via dstream.foreachrdd(). start and manage processing: the ssc.start() command initiates data processing without blocking the program. to keep the script running until the stream processing is finished, use ssc.awaittermination(). additional features sliding windows: spark streaming provides the window() function to create sliding windows across multiple rdds. this allows you to analyse data over a larger time frame while still processing in micro-batches. stateful operations: for operations that need to keep track of previous states, spark streaming offers the updatestatebykey() function. this is useful for tasks like accumulating counts or maintaining averages. checkpointing: when using stateful operations, it's essential to activate checkpointing. this periodically backs up the state and metadata to fault-tolerant storage (like hdfs) to ensure recovery in case of failures. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Calculus/CET/02_07.html",
    "title": "Derivatives and Rates of Change",
    "body": " index search search back derivatives and rates of change contents tangents velocities derivatives rates of change tangents the tangent line to the curve \\(y = f(x)\\) at the point \\(p(a, f(a))\\) is the line through \\(p\\) with slope: \\begin{align} m = \\lim_{x \\rightarrow a} \\frac{f(x) - f(a)}{x - a} \\end{align} provided that this limit exists (see figure 1). we sometimes refer to the slope of the tangent line to a curve at a point as the slope of the curve at the point. if we zoom in far enough toward the point, the curve looks almost like a straight line (see figure 2). there is another expression for the slope of a tangent line. if \\(h = x - a\\), then \\(x = a + h\\), and so the slope of the secant line \\(pq\\) becomes: \\begin{align} m_{pq} = \\frac{f(a + h) - f(a)}{h} \\end{align} see figure 3. notice that as \\(x\\) approaches \\(a\\), then \\(h\\) approaches \\(0\\). therefor3 the definition of the slope of the tangent line becomes: \\begin{align} m = \\lim_{h \\rightarrow 0} \\frac{f(a + h) - f(a)}{h} \\end{align} velocities suppose an object moves along a straight line following the equation \\(s = f(t)\\), where \\(s\\) is the displacement of the object from the origin at time \\(t\\). the function \\(f\\) that describes the motion is called position function. in the time interval from \\(t = a\\) to \\(t = a + h\\) the change is position is \\(f(a + h) - f(a)\\) (see figure 5). the average velocity over this time interval is: \\begin{align} \\text{average velocity} = \\frac{\\text{displacement}}{\\text{time}} = \\frac{f(a + h) - f(a)}{h} \\end{align} now suppose we compute the average velocities over shorter and shorter time intervals, that is, we let \\(h\\) approach \\(0\\). we define the velocity or instantaneous velocity \\(v(a)\\) at time \\(t = a\\) to be the limit of these average velocities: \\begin{align} v(a) = \\lim_{h \\rightarrow 0} \\frac{f(a + h) - f(a)}{h} \\end{align} provided that this limit exists. derivatives limits of the form: \\begin{align} \\lim_{h \\rightarrow 0} \\frac{f(a + h) - f(a)}{h} \\end{align} arise whenever we calculate a rate of change in any of the sciences or engineering. the derivative of a function \\(f\\) at a number \\(a\\), denoted by \\(f'(a)\\) is: \\begin{align} f'(a) = \\lim_{h \\rightarrow 0} \\frac{f(a + h) - f(a)}{h} \\end{align} if this limit exists. letting \\(x = a + h \\leftrightarrow h = x - a\\), then an equivalent way of this definition is: \\begin{align} f'(a) = \\lim_{x \\rightarrow a} \\frac{f(x) - f(a)}{x - a} \\end{align} we defined the tangent line to the curve \\(y = f(x)\\) at \\(p(a, f(a))\\) to be the line that passes through \\(p\\) and has slope \\(m\\). by the previous definition this slope \\(m\\) is the same as the derivative \\(f'(a)\\). if we use the point-slope form of the equation of a line, we can write an equation of the tangent line to the curve \\(y = f(x)\\) at the point \\((a, f(a))\\): \\begin{align} y - f(a) = f'(a)(x - a) \\end{align} rates of change suppose that \\(y\\) is a quantity that depends on another quantity \\(x\\), we write \\(y = f(x)\\). if \\(x\\) changes to \\(x_1\\) to \\(x_2\\), then the change in \\(x\\) is: \\begin{align} \\delta x = x_2 - x_1 \\end{align} and the corresponding change in \\(y\\) is: \\begin{align} \\delta y = f(x_2) - f(x_1) \\end{align} the difference quotient is given by: \\begin{align} \\frac{\\delta y}{\\delta x} = \\frac{f(x_2) - f(x_1)}{x_2 - x_1} \\end{align} and is called the average rate of change of \\(y\\) with respect to \\(x\\) over the interval \\([x_1, x_2]\\). this can be interpreted as the slope of the secand line \\(pq\\) in figure 8. by analogy with velocity, if we consider the average rate of change over smaller and smaller intervals, letting \\(\\delta x\\) approach \\(0\\). the limit of these average rates of change is called the (instantaneous) rate of change of \\(y\\) with respect to \\(x\\) at \\(x = x_1\\). this can be interpreted as the slope of the tangent to the curve \\(y = f(x)\\) at \\(p(x_1, f(x_1))\\): \\begin{align} \\lim_{\\delta x \\rightarrow 0} \\frac{\\delta y}{\\delta x} = \\lim_{x_2 \\rightarrow x_1} \\frac{f(x_2) - f(x_1)}{x_2 - x_1} \\end{align} we recognize this limit as the derivative \\(f'(x_1)\\) so the derivative of \\(f'(x_1)\\) is the instantaneous rate of change of \\(y = f(x)\\) with respect to \\(x\\) when \\(x = x_1\\). this means that when the derivative is large the curve is steep (as at the point \\(p\\) in figure 9), therefore the \\(y\\)-values change rapidly. however, when the derivative is small, the curve is relatively flat (as at point \\(q\\)) and the \\(y\\)-values change slowly. then \\(f'(a)\\) is the velocity of a particle at time \\(t = a\\) and its speed is the absolute value of the velocity, \\(|f'(a)|\\). $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/CG/RTGW/08.html",
    "title": "Picking",
    "body": " index search search back picking contents setting up an offscreen framebuffer creating a texture to store colors creating a renderbuffer to store depth information creating a framebuffer for offscreen rendering assigning one color per object in the scene rendering to an offscreen framebuffer clicking on the canvas reading pixels from the offscreen framebuffer looking for hits picking refers to the ability to select objects in a 3d scene. the most common device used for picking is a computer mouse. however, picking can also be performed using other human computer interfaces, such as tactile screens and haptic devices. to start, we should point out that we can select objects by casting a ray (vector) from the camera position (also known as the eye position) into the scene and calculate the objects that lie along its path. this is known as ray-casting and involves detecting intersections between the ray and object surfaces in the scene. in this chapter, we’ll implement picking based on object colors in an offscreen framebuffer. the basic idea behind picking is to assign a different identifier to every object in the scene and render the scene to an offscreen framebuffer. we will start by identifying objects with a unique color. when the user clicks on canvas, we go to the offscreen framebuffer and read the color of the pixel at the location of the click. we can use this color to identify the object that has been selected. the following diagram illustrates this concept: setting up an offscreen framebuffer the results of the rendering on your screen are the contents of the framebuffer. every call to gl.drawarrays, gl.drawelements, and gl.clear will change the contents of the framebuffer. instead of rendering to the default framebuffer, we can also render to a scene that is offscreen – we call this the offscreen framebuffer. to set up a framebuffer, we need to create storage for at least two things: colors and depth information. to store colors, we will use a webgl texture; to store depth information, we will use a renderbuffer. creating a texture to store colors the only difference is that we do not have an image to bind to the texture, so when we call gl.teximage2d, the last argument is null. this is because we are allocating space to store colors for the offscreen framebuffer const canvas = document.getelementbyid('webgl-canvas'); const { width, height } = canvas; const texture = gl.createtexture(); gl.bindtexture(gl.texture_2d, texture); gl.teximage2d(gl.texture_2d, 0, gl.rgba, width, height, 0, gl.rgba, gl.unsigned_byte, null); it's important to note that the width and height of the texture are set to the canvas size. this is because we want to ensure that the offscreen framebuffer resembles the dimensions of our 3d scene. creating a renderbuffer to store depth information renderbuffers are used to provide storage for the individual buffers used in a framebuffer. the depth buffer (z-buffer) is an example of a renderbuffer. it is always attached to the screen framebuffer, which is the default rendering destination in webgl. the code to create a renderbuffer looks like the following code: const renderbuffer = gl.createrenderbuffer(); gl.bindrenderbuffer(gl.renderbuffer, renderbuffer); gl.renderbufferstorage(gl.renderbuffer, gl.depth_component16, width, height); the third line of code determines the storage size of the renderbuffer. similar to before, we need to ensure that for every fragment (pixel) in the framebuffer, we have a color (stored in the texture) and a depth value (stored in the renderbuffer), so the size of the canvas and the size of the render buffer must be the same. creating a framebuffer for offscreen rendering we need to create a framebuffer and attach the texture and the renderbuffer: const framebuffer = gl.createframebuffer(); // frame buffer gl.bindframebuffer(gl.framebuffer, framebuffer); // texture gl.framebuffertexture2d(gl.framebuffer, gl.color_attachment0, gl.texture_2d, texture, 0); // render buffer gl.framebufferrenderbuffer(gl.framebuffer, gl.depth_attachment, gl.renderbuffer, renderbuffer); // clean up gl.bindtexture(gl.texture_2d, null); gl.bindrenderbuffer(gl.renderbuffer, null); gl.bindframebuffer(gl.framebuffer, null); assigning one color per object in the scene we will pick an object based on its primitive color, we need to make sure that the color is constant per object and that each object has a different unique color. in situations where objects may share the same diffuse color, we can create a new essl uniform to store the picking color and make it unique for every object that's rendered into the offscreen framebuffer. the following diagram illustrates the situation: rendering to an offscreen framebuffer in order to perform object selection using the offscreen framebuffer, we need to ensure that both framebuffers are synchronized. the following diagram shows the behavior of the render function: clicking on the canvas the next step is to capture and read the mouse coordinates. the following diagram shows how we use the offset calculation to obtain the clicked canvas coordinates: reading pixels from the offscreen framebuffer webgl allows us to read back from a framebuffer using the readpixels function: gl.readpixels(x, y, width, height, format, type, pixels); we need to ensure that the offscreen framebuffer that we want to read from is the currently bound one. to do so, we bind it by using bindframebuffer: // read one pixel const readout = new uint8array(1 * 1 * 4); gl.bindframebuffer(gl.framebuffer, framebuffer); gl.readpixels(coords.x, coords.y, 1, 1, gl.rgba, gl.unsigned_byte, readout); gl.bindframebuffer(gl.framebuffer, null); here, the size of the readout array is \\(1 \\cdot 1 \\cdot 4\\). this means that it has one pixel of width times one pixel height times four channels, since the format is rgba. looking for hits now, we will check whether the color obtained from the offscreen framebuffer matches any of the objects in our scene. when looking for hits, we compare each object's diffuse color with the label obtained from the offscreen framebuffer. there is, however, an additional step to consider: each color channel comes back in a \\([0, 255]\\) range while the object diffuse colors are in a \\([0, 1]\\) range. we do not need to compare the alpha channel. if we had two objects with the same color but a different alpha channel, we could use the alpha channel in the comparison, but this is not the case in our example. also, it’s important to note that the comparison is not precise, as we are dealing with decimal values in the \\([0, 1]\\) range. because of that, we introduce a fudge factor by assuming that we have a hit after rescaling the colors and subtract the readout (object label) – the difference is less than one. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Calculus/CET/02_08.html",
    "title": "The Derivative as a Function",
    "body": " index search search back the derivative as a function contents other notations theorems how can a function fail to be differentiable higher derivatives if we replace a in equation 1 by a variable \\(x\\), we obtain: \\begin{align} f'(x) = \\lim_{h \\rightarrow 0} \\frac{f(x + h) - f(x)}{h} \\end{align} so we can regard \\(f'\\) as a new function, called the derivative of \\(f\\), which can be interpreted geometrically as the slope of the tangent line to the graph of \\(f\\) at the point \\((x, f(x))\\). this function is called the derivative of \\(f\\) because it has been derived from \\(f\\) by the limiting operation above. the domain of \\(f'\\) is the set \\(\\{x | f'(x) \\text{exists}\\}\\) and may be smaller than the domain of \\(f\\). other notations some common alternative notations for th derive are as follows: \\begin{align} f'(x) = y' = \\frac{dy}{dx} = \\frac{df}{fx} = \\frac{d}{dx} f(x) = df(x) = d_x f(x) \\end{align} the symbols \\(d\\) and \\(\\frac{d}{dx}\\) are called differentiation operators because they indicate the operation of differentiation. the symbol \\(\\frac{dy}{dx}\\) was introduced by leibniz as a synonim for \\(f'(x)\\). we can rewrite the definition of the derivative in leibniz notation in the form: \\begin{align} \\frac{dy}{dx} = \\lim_{\\delta x \\rightarrow 0} \\frac{\\delta y}{\\delta x} \\end{align} to indicate the value of a derivative \\(\\frac{dy}{dx}\\) in leibniz notation at a specific number \\(a\\), we use the notation: \\begin{align} \\eval{\\frac{dy}{dx}}{x=a} \\end{align} theorems a function \\(f\\) is differentiable at \\(a\\) if \\(f'(a)\\) exists. it is differentiable on an open interval \\((a, b)\\) if it is differentiable at every number in the interval. if \\(f\\) is differentiable \\(a\\), then \\(f\\) is continuous at \\(a\\). proof: we assume that \\(f\\) is differentiable at \\(a\\), so we have to prove that \\(f\\) is continuous at \\(a\\), that is we have to show: \\begin{align} \\lim_{x \\rightarrow a} f(x) = f(a) \\end{align} we will do this by showing that the difference \\(f(x) - f(a)\\) approaches \\(0\\). then, multiplying and dividing \\(f(x) - f(a)\\) by \\(x - a\\) \\begin{align} f(x) - f(a) = \\frac{f(x) - f(a)}{x - a} (x - a) \\end{align} by the limit laws: \\begin{align} \\lim_{x \\rightarrow a} [f(x) - f(a)] = \\lim_{x \\rightarrow a} \\frac{f(x) - f(a)}{x - a} (x - a) \\end{align} \\begin{align} = \\lim_{x \\rightarrow a} \\frac{f(x) - f(a)}{x - a} \\cdot \\lim_{x \\rightarrow a} (x - a) \\end{align} because we know that \\(f\\) is differentiable at \\(a\\), then: \\begin{align} f'(a) = \\lim_{x \\rightarrow a} \\frac{f(x) - f(a)}{x - a} \\end{align} exists, such that: \\begin{align} = f'(a) \\cdot (a - a)= f'(a) \\cdot 0 = 0 \\end{align} now we use this result to prove that \\(f\\) is continuous: \\begin{align} \\lim_{x \\rightarrow a} f(x) = \\lim_{x \\rightarrow a} [f(a) + (f(x) - f(a))] \\end{align} \\begin{align} = \\lim_{x \\rightarrow a} f(a) + \\lim_{x \\rightarrow a} [f(x) - f(a)] \\end{align} from our previous lemma we know that \\(\\lim_{x \\rightarrow a} [f(x) - f(a)] = 0\\). then: \\begin{align} = \\lim_{x \\rightarrow a} f(a) + 0 = f(a) \\end{align} therefore \\(f\\) is continuous at \\(a\\). note that the converte of this theorem is false, that is, there are function that are continuous but not differentiable. how can a function fail to be differentiable we consider three scenarios: if the graph of a function \\(f\\) has a corner or a kink in it, then the graph of \\(f\\) has no tangent at this point and \\(f\\) is not differentiable there. by the contrapositive of \"if \\(f\\) is differentiable at \\(a\\), then \\(f\\) is continuous at \\(a\\)\" we know that if \\(f\\) is not continuous at \\(a\\) then \\(f\\) is not differentiable at \\(a\\). if the curve given by \\(f\\) has a vertical tangent line when \\(x = a\\), \\(f\\) is continuous at \\(a\\) and \\(\\lim_{x \\rightarrow a} |f'(x)| = \\infty\\) then \\(f\\) is not differentiable at \\(a\\). figure 7 illustrates the three possibilities: higher derivatives if \\(f\\) is a differentiable function, then its derivative \\(f'\\) is also a function, so \\(f'\\) may have a derivative of its own, denoted by \\((f')' = f''\\), called the second derivative of \\(f\\). using leibniz notation: \\begin{align} \\frac{d}{dx} \\left(\\frac{dy}{dx}\\right) = \\frac{d^2y}{dx^2} \\end{align} in general, we can interpret a second derivative as a rate of change of a rate of change. the most familiar example of this is acceleration. if \\(s(t)\\) is the position function, we know that its first derivative represents the velocity \\(v(t)\\): \\begin{align} v(t) = s'(t) = \\frac{ds}{dt} \\end{align} the instantaneous rate of change of velocity with respect to time is called the acceleration \\(a(t)\\). thus the acceleration function is the derivative of the velocity function, that is the second derivative of the position function: \\begin{align} a(t) = v'(t) = s''(t) \\end{align} or in leibniz notation: \\begin{align} a = \\frac{dv}{dt} = \\frac{d^2s}{dt^2} \\end{align} the third derivative \\(f'''\\) is the derivative of the second derivative \\(f''' = (f'')'\\). it can be interpreted as the slope of the curve \\(y = f''(x)\\) or as the rante of change of \\(f''(x)\\). alternative notations are: \\begin{align} y''' = f'''(x) = \\frac{d}{dx} \\left( \\frac{d^2y}{dx^2} \\right) = \\frac{d^3y}{dx^3} \\end{align} we can also interpret the third derivative physically. given the position function \\(s(t)\\) its third derivative is the derivative of the acceleration function and is called the jerk: \\begin{align} j = \\frac{da}{dt} = \\frac{d^3s}{dt^3} \\end{align} it represents the rate of change of acceleration. it is named like so because a large jerk means a sudden change in acceleration, which causes an abrupt movement. in general, the \\(n\\)th derivative of \\(f\\) is denoted by \\(f^{(n)}\\) and is obtained from \\(f\\) by differentiating \\(n\\) times. if \\(y = f(x)\\), we write: \\begin{align} y^{(n)} = f^{(n)}(x) = \\frac{d^n y}{dx^n} \\end{align} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  }
]