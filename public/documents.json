[
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Robotics/UKF/index.html",
    "title": "Unscented Kalman Filter",
    "body": " index search search back unscented kalman filter it approximates a non-linear transformation of a probability distribution, as a gaussian distribution. assume that we have a probability distribution for a random variable vector defined as: \\begin{align} x \\sim \\mathcal{n}(\\overline{x}, \\sigma_x) \\end{align} given a non-linear transofrm that we want to apply to the distribution: \\begin{align} y = f(x) \\end{align} we want to obtain a gaussian approximation of the resulting transformed distribution: \\begin{align} y \\sim \\mathcal{n}(\\overline{y}, \\sigma_y) \\end{align} numerical solution generate \\(n\\) samples from the original distribution \\begin{align} x_i \\sim \\mathcal{n}(\\overline{x}, \\sigma_x) \\end{align} \\begin{align} i=1, \\cdots, n \\end{align} for each sample \\(x_i\\) apply the non-linear transformation to find the corresponding \\(y_i\\) \\begin{align} y_i = f(x_i) \\end{align} fit a gaussian to the transformed points \\begin{align} \\overline{y} = \\frac{1}{n}\\sum^n y_i \\end{align} \\begin{align} \\sigma_y = \\frac{1}{n} \\sum^n (y_i - \\overline{y}) (y_i - \\overline{y})^t \\end{align} selecting less points to sample let \\(x\\) be a \\(n \\times 1\\) random vector with mean \\(\\overline{x}\\) and covariance \\(p\\), that is \\(x \\sim \\mathcal{n}(\\overline{x}, p)\\) we choose \\(2n\\) sigma points as follows: \\begin{align} x^{(i)} = \\overline{x} + \\delta x^{(i)} \\end{align} \\begin{align} i=1, \\cdots, 2n \\end{align} where: \\begin{align} \\delta x^{(i)} = (\\sqrt{np})_i \\end{align} \\begin{align} i=1, \\cdots, n \\end{align} which means \\(\\delta x^{(i)}\\) is the i-th column of the covariance matrix multiplied by \\(\\sqrt{n}\\). for a \\(2\\times 1\\) state vector, this gives us the two following points: we do the same, but inversing, for the remaining \\(n\\) points: \\begin{align} \\delta x^{(n+i)} = -(\\sqrt{np})_i \\end{align} \\begin{align} i=1, \\cdots, n \\end{align} such that we obtain: from the following image we can see the \\(4\\) points we obtained seem to be a good approximation of the shape of the ellipse: so we can use these points to obtain the new ellipse which resulted from applying the transformation. mean approximation we apply the non-linear transformation to the sigma points: \\begin{align} y^{(i)} = h(x^{(i)}), i = 1, \\cdots, 2n \\end{align} such that we have the following situation: we obtain the weighted mean of the transformed sigma points: \\begin{align} \\overline{y} = \\sum_{i=1}^{2n} w^{(i)} y^{(i)} \\end{align} where \\(w^{(i)} = \\frac{1}{2n}\\). such that: \\begin{align} \\overline{y} = \\frac{1}{2n} \\sum_{i=1}^{2n} y^{(i)} \\end{align} and so, we obtain the following estimated mean: covariance approximation we apply this same methodology for the covariance, given the transformed points \\(y^{(i)}\\) we obtain the weighted covariance: \\begin{align} p_y = \\sum_{i=1}^{2n} w^{(i)} (y^{(i)} - \\overline{y})(y^{(i)} - \\overline{y})^t \\end{align} \\begin{align} = \\frac{1}{2n} \\sum_{i=1}^{2n}(y^{(i)} - \\overline{y})(y^{(i)} - \\overline{y})^t \\end{align} which given us the following estimated covariance: general unscented transformation we now show a general definition which allows for more accuracy: sigma points generation we generate \\(2n+1\\) instead of \\(2n\\) and we define \\(x^{(0)}\\) such that it equals the mean: \\begin{align} x^{(i)} = \\overline{x} + \\delta x^{(i)}, i=0, \\cdots, 2n \\end{align} \\begin{align} \\delta x^{(0)} = 0 \\end{align} \\begin{align} \\delta x^{(i)} = \\left(\\sqrt{(n+k)p}\\right)_i, i=1, \\cdots, n \\end{align} \\begin{align} \\delta x^{(n+i)} = -\\left(\\sqrt{(n+k)p}\\right)_i, i=1, \\cdots, n \\end{align} weight definition the weights are now defined as follows: \\begin{align} w^{(0)} = \\frac{k}{n+k} \\end{align} \\begin{align} w^{(i)} = \\frac{1}{2(n+k)} \\end{align} where \\(k=3-n\\) has shown to help improve accuracy. note that \\((n+k)\\neq 0\\) mean and covariance approximation finally we approximate the mean and the covariance of the transformed distribution the same way we did before: for the mean: \\begin{align} \\overline{y} = \\sum_{i=1}^{2n} w^{(i)} y^{(i)} \\end{align} for the covariance: \\begin{align} p_y = \\sum_{i=1}^{2n} w^{(i)} (y^{(i)} - \\overline{y})(y^{(i)} - \\overline{y})^t \\end{align} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Robotics/AIRobotics/ParticleFilters/Particle Filters.html",
    "title": "Particle Filters",
    "body": " index search search back particle filters properties introduction initial probability resampling motion algorithm resampling example properties state space belief efficiency accuracy continuous multimodal   approximate introduction so, in a first instance, given a floor plan the robot has to perform global localization. that is, it does not know where it is, and it has to find out based on sensor measurements: the robot has range sensors (blue lines), which use sonar sensors (basically sound) to obtain the distance between the robot and the obstacles around it. it uses this sensors to determine a posterior distribution that models its position at a given time. each particle (dot) is a discrete guess whether the robot might be, and it holds the following information: x coordinate, y coordinate, and heading direction. then, the comprise of multiple of these guesses make up the representation for the posterior of the robot's location. so, initially the robot is completely uncertain as to where it is, which derives into a uniform distribution as to where it may be, and thus the particles are scattered all over the floor plan. however as time passes, the particle filter makes them survive according to how consistent these particles are compared to the sensor measurements: in summary, the particles guess where the robot might be moving and then the filter makes them \"survive\" (it does not discard them) using survival of the fittest. this latter statement means that those particles that are more consistent with the measurements are more likely to survive. initial probability at the start the robot only has the map of the room and no other knowledge, therefore there is equal probability that the robot is at any position in the map. hence, we create a set of \\(n\\) particles modeled after a uniform distribution. which means each particle is as likely to be chosen as any other. resampling at first, we have \\(n\\) particles scattered all over the map and most of them are wrong. so now, we can start removing some of the wrong guesses using measurements of the environment. and we do this by resampling \\(n\\) particles. this translates into, we choose \\(n\\) particles that represent the place we believe the robot is in. so, now the filter can go through each of our particles and determine what the measurement would be if our robot was in the position indicated by the particle. in other words, each particle has assigned an importance weight \\(w\\) that determines how likely the measurement \\(z\\) is given a concrete particle \\(p_i\\), (\\(p(z|p_i)\\)). so, given a total of \\(n\\) particles: \\begin{align} n \\begin{cases} p_1 & \\rightarrow w_1\\\\ p_2 & \\rightarrow w_2\\\\ \\vdots\\\\ p_n & \\rightarrow w_n\\\\ \\end{cases} \\end{align} let \\(w = \\sum_i w_i\\) be the sum of all the weights. we introduce a new variable \\(\\alpha\\) which represents the normalized weights: \\begin{align} n \\begin{cases} p_1 & \\rightarrow w_1 & \\rightarrow \\alpha_1 = \\frac{w_1}{w}\\\\ p_2 & \\rightarrow w_2 & \\rightarrow \\alpha_2 = \\frac{w_2}{w}\\\\ \\vdots\\\\ p_n & \\rightarrow w_n & \\rightarrow \\alpha_n = \\frac{w_n}{w}\\\\ \\end{cases} \\end{align} hence, \\(\\sum_i \\alpha_i = 1.0\\). so we have now defined a new probability distribution that describes more clearly the position of our robot because it takes into account our measurement. so, it's time for the resampling. we have to choose \\(n\\) particles from the overall set, where each particle \\(p_i\\) is chosen with probability \\(\\alpha_i\\): note we allow replacement, so we can draw multiple copies of the same particle \\(p_i\\). so what will happen is, the higher \\(\\alpha_i\\) the more likely it is that particle \\(p_i\\) is chosen multiple times, meanwhile the lower \\(\\alpha_i\\) is the more likely it is that it will not be chosen, and therefore simply removed from the set of particles. as you can see in the previous image, we have drawn three times \\(p_2\\), probably because the associated \\(\\alpha_2\\) was larger than the rest of the \\(\\alpha\\). therefore, the particles with a low importance weight will survive with a much lower rate than the ones with a higher importance weight. motion we also have to take into account that our particles cannot be static, but have to move with our robot. so whichever motion is applied to the robot should be applied to every single particle. once the motion is applied we obtain a measurement and perform resampling to choose those particles that are more likely to describe the real position of the robot. note that the motion will most probably contain noise, so we do not want to propagate the motion equally to each particle. what we would want is to add some gaussian noise to the particles to represent somewhat this uncertainty about the motion. algorithm measurement updates we compute the posterior over state distribution: \\begin{align} p(x|z) \\propto p(z|x)p(x) \\end{align} here: \\(p(x)\\) is the distribution over the set of particles. \\(p(z|x)\\) is the distribution that models the importance weights. and by resampling we obtain \\(p(x|z)\\), because we draw with probability equal to the importance weight a given particle. motion updates we compute the posterior over distribution one step later (after movement): \\begin{align} p(x^t) = \\sum p(x^t|x)p(x) \\end{align} where: \\(p(x)\\) is the distribution over the set of particles. and then, we sample from the sum. that is we generate a random particle \\(x^t\\) by applying the motion model \\(p(x^t|x)\\) to the particles \\(p(x)\\). resampling example suppose we have the following data: \\begin{align} n \\begin{cases} p_1 & \\rightarrow w_1 = 0.6 & \\rightarrow \\alpha_1 = \\frac{w_1}{w} = \\frac{0.6}{6.0} = 0.1\\\\ p_2 & \\rightarrow w_2 = 1.2 & \\rightarrow \\alpha_2 = \\frac{w_2}{w} = \\frac{1.2}{6.0} = 0.2\\\\ p_3 & \\rightarrow w_3 = 2.4 & \\rightarrow \\alpha_3 = \\frac{w_3}{w} = \\frac{2.4}{6.0} = 0.4\\\\ p_4 & \\rightarrow w_4 = 0.6 & \\rightarrow \\alpha_4 = \\frac{w_4}{w} = \\frac{0.6}{6.0} = 0.1\\\\ p_5 & \\rightarrow w_2 = 1.2 & \\rightarrow \\alpha_5 = \\frac{w_5}{w} = \\frac{1.2}{6.0} = 0.2\\\\ \\end{cases} \\end{align} then, the probability of never sampling \\(p_3\\) is given by the multiplication rule of probability: on the first draw: \\begin{align} p(\\bar{p_3}) = p(p_1) + p(p_2) + p(p_4) + p(p_5) = 0.6 \\end{align} because we allow for resampling, on the second draw: \\begin{align} 0.6 \\cdot p(\\bar{p_3}) = 0.6 \\cdot (p(p_1) + p(p_2) + p(p_4) + p(p_5)) = 0.6^2 \\end{align} thus, on the fifth and final draw: \\begin{align} 0.6^4 \\cdot p(\\bar{p_3}) = 0.6^4 \\cdot (p(p_1) + p(p_2) + p(p_4) + p(p_5)) = 0.6^5 = 0.0777 \\end{align} however, the probabily of never drawing \\(p_1\\) equals: \\begin{align} p(\\bar{p_1}) = 0.9 ^ 5 = 0.59 \\end{align} therefore, the particles with a low importance weight will survive with a much lower rate than the ones with a higher importance weight. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Robotics/AIRobotics/PIDControl/PIDControl.html",
    "title": "PID Control",
    "body": " index search search back pid control up until now we have created paths that connect dots with straight lines. however this tend to become unnefficient, as you can smooth them to reduce the distance and also to represent the motion of an object is a more realistic way. smoothing algorithm initilize \\(y_i\\) to the non-smooth locations \\(x_i\\): \\(y_i = x_i\\) optimize two criteria: first minimize the distance between the non-smooth point and the smooth point \\begin{align} \\min_i (x_i - y_i)^2 \\end{align} then minimize the distance between two consecutive smooth points \\begin{align} \\min_i (y_i - y_{i+1})^2 \\end{align} to optimize both, we include a parameter \\(\\alpha\\), to minimize the weigthed sum: \\begin{align} \\min (x_i - y_i)^2 + \\alpha (y_i - y_{i+1})^2 \\end{align} we optimize both, because they are in conflict with each other: if we only optimize the first one, we obtain the same path as the original non-smoothed path if we only optimize the second one, we obtain no path pid control if we have a car that has a steering angle \\(\\alpha\\), how would we go about defining this parameter? p controller we set this angle proportional by some factor of \\(\\tau\\) to the crosstrack error. where the crosstrack error refers to the lateral error between the vehicle and the reference trajectory. thus: \\begin{align} \\alpha = \\tau cte \\end{align} note that with this approach we will eventually overshoot when reaching for the reference trajectory. that is because the car it not oriented the same as the trajectory, therefore it needs to reposition once it reaches the trajectory: pd control here the steering angle does no only take into account the \\(cte\\), but it also uses the derivative of cte. the latter will compute how much we are reducing the error in each moment \\(t\\), and use this value to counter steer this angle (reduce the angle): \\begin{align} \\alpha = - \\tau_p cte - \\tau \\frac{\\delta}{\\delta t} cte \\end{align} where: \\begin{align} \\frac{\\delta}{\\delta t} cte = \\frac{cte_t - cte_{t-1}}{\\delta t} \\end{align} systematic bias in real life there is usually some noise when it comes to the angle of the wheels, and we refer to that as systematic bias. for example the wheels might be deviated a certain angle without us knowing. pid control because of this systematic bias, the error with respect to the reference trajectory is very large. therefore if we sum it over time we obtain larger and larger values. so, if we sum this cte error weighted by a factor \\(\\tau_i\\), we can correct this error by counter steering: \\begin{align} \\alpha = - \\tau_p cte - \\tau_d \\frac{\\delta}{\\delta t} cte - \\tau_i \\sum cte \\end{align} where \\(\\sum cte\\) equals the sum of the \\(cte\\) error overtime. note: \\(- \\tau_p cte\\): represents the proportional error \\(- \\tau_d \\frac{\\delta}{\\delta t}\\): represents the differential error \\(- \\tau_i \\sum cte\\): represents the integral error twiddle we use twiddle to optimize a set of parameters. in our case what we do is optimize, that is minimize, the average cte. so, given a parameters vector \\(p = [0, 0, 0]\\) and a vector of potential changes \\(dp = [1, 1, 1]\\) we: execute run() which computes the \"optimal\" steering angle and moves the robot accordingly. it also stores this motion as a trajectory. this function will return a \"goodness\" metric, that will signify the cte. so, after executing run() we get the best error so far. we modify p to make our error smaller, to make this modification we use twiddle. the algorithm is as follows: # compute initial error best_error = run(p) # while the sum of the potential changes is bigger than a tolerance parameter while sum(dp) < tolerance: # iterate over every parameter for i in range(len(p)): # update the parameter value by the value of the corresponding potential change p[i] += dp[i] # compute the new error for this change err = run(p) # does this better the previous error? err < best_error: # make the change bigger dp[i] *= 1.1 # if the error is worse else: # we try updating the parameter by subtracting (by two because we added before) p[i] -= 2*dp[i] err = run(p) # does this better the previous error? err < best_error: # make the change bigger dp[i] *= 1.1 # if substracting does not make the error better else: # we decrease the change dp[i] *= 0.9 basically twiddle decreases/increases the parameters first a little bit, and for each time we make the error better we augment the increase or decrease. and we stop when there are no major changes being made to the parameters, that is sum(dp) < tolerance. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Robotics/AIRobotics/index.html",
    "title": "Artificial Intelligence Robotics",
    "body": " index search search back artificial intelligence robotics histogram localization kalman filters particle filters search pid control slam $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Robotics/AIRobotics/Search/Search.html",
    "title": "Search",
    "body": " index search search back search the process of finding a path from a starting point to the goal location is called robot motion planning or simply planning. then given: map starting location goal location cost function the goal is to find the minimum cost path between the start and the goal. a* consider a square grid having many obstacles and we are given a starting cell and a target cell. we want to reach the target cell (if possible) from the starting cell as quickly as possible. what a* search algorithm does is that at each step it picks the node according to a value \\(f = g + h(x,y)\\), where \\(g\\) is the current cost and \\(h(x,y)\\) is the value of the heuristic function in cell \\((x,y)\\). that is h is the estimated movement cost to move from that given square on the grid to the final destination. this is often referred to as the heuristic, which is nothing but a kind of smart guess. algorithm 1. let openlist equal empty list of nodes 2. let closedlist equal empty list of nodes 3. put startnode on the openlist (leave it's f at zero) 4. while openlist is not empty 5. let currentnode equal the node with the least f value 6. remove currentnode from the openlist 7. add currentnode to the closedlist 8. if currentnode is the goal 9. you've found the exit! 10. let children of the currentnode equal the adjacent nodes 11. for each child in the children 12. if child is in the closedlist 13. continue to beginning of for loop 14. child.g = currentnode.g + distance b/w child and current 15. child.h = distance from child to end 16. child.f = child.g + child.h 17. if child.position is in the openlist's nodes positions 18. if child.g is higher than the openlist node's g 19. continue to beginning of for loop 20. add the child to the openlist dynamic programming given a grid and a goal position, dynammic programming gives you the optimal action for each cell. where the optimal action is to move to the direction that offers the lower distance to the goal. to compute this distance we calculate: \\begin{align} f(x,y) = g = min_{x',y'} f(x', y') + 1 \\end{align} that is, we obtain recursively the distance of each neighbour to the goal and we add one. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Robotics/AIRobotics/Localization/Localization.html",
    "title": "Histogram Localization",
    "body": " index search search back histogram localization probability given by belief probability after sense exact motion inexact motion bayes rule motion using total probability summary localization algorithm probability given by belief suppose every place in the world is modeled after an uniform probability distribution, then every cell the robot has the same probability. probability after sense now suppose the robot is able to sense a color, and each cell has a different color assigned. let's assume the robot senses the color red, then the cells with this color assigned should have a higher probability. therefore we define two values, a hit value and a miss value. if the cell is red, then we multiply its probability by the hit value. if the cell is not red, then we multiply its probability by the miss value. note that the hit value is a big value, and the miss value is lower. thus the probability for miss cells is lower than the probability for hit cells. also, observe that a measurement refers to what the robot senses, that is, a green cell or a red cell. normalize the distribution now that we have altered the values of the probability distribution, it is likely that they do not sum up to one, which is a requirement to every probability function. therefore we need to normalize it. so what we would do is: compute the probabilities after the robot \"senses\" a measurement normalize these probabilities by dividing each probability by the total sum of all probabilities exact motion suppose we have a world made up of a grid with 5 cells with the following probabilities: [\\(\\frac{1}{3}\\)][\\(\\frac{1}{3}\\)][\\(\\frac{1}{9}\\)][\\(\\frac{1}{9}\\)][\\(\\frac{1}{3}\\)] we also know that with 100% probability the world moves to the right. theorem of total probability to compute the probability of each cell after the movement, we use the law of total probability that states: given events a and \\(b = \\{b_1, \\cdots, b_n\\}\\) events in a sample space where \\(b\\) is pairwise disjoint, then: \\begin{align} p(a) = \\sum_n p(a \\cap b_n) \\end{align} then, by the conditional probability formula: \\begin{align} p(a) = \\sum_n p(a|b_n)p(b_n) \\end{align} so to apply this theorem what we do is sum the probabilities of ending up in cell \\(j\\) when we come from cell \\(i\\), which is expressed symbolically: \\begin{align} p(x_{j}) = \\sum_{i=1}^5 p(x_{j}|x_{i}) \\cdot p(x_{i}) = 1 \\cdot p({x_j}_{\\{j=(i+1)\\}}) \\end{align} because we know: \\begin{align} p(x_j|x_i) = \\begin{cases} 1, & j = i + 1 \\\\ 0, & \\text{ in any other case} \\end{cases} \\end{align} inexact motion however what if \\(p(x_j|x_i) < 1\\)? suppose: \\(p(x_{i+2}|x_i) = 0.8\\): the robot moved 2 positions/units with \\(0.8\\) probability \\(p(x_{i+1}|x_i) = 0.1\\): the robot moved 1 positions/units with \\(0.1\\) probability \\(p(x_{i+3}|x_i) = 0.1\\): the robot moved 3 positions/units with \\(0.1\\) probability then for each \\(i\\): \\begin{align} p(x_{j}) = \\sum_{i=1}^5 p(x_{j}|x_{i}) \\cdot p(x_{i}) \\end{align} where: \\begin{align} p(x_{j}|x_{i}) = \\begin{cases} 0.8, & j = i + 2 \\\\ 0.1, & j = i + 1 \\\\ 0.1, & j = i + 3 \\\\ 0, & \\text{ otherwhise } \\end{cases} \\end{align} entropy the entropy will decrease after the measurement update (sense) step, and the entropy will increase after the movement step (move). in general, entropy represents the amount of uncertainty in a system. since the measurement update step decreases uncertainty, entropy will decrease. the movement step increases uncertainty, so entropy will increase after this step. the entropy formula for our case is the following: \\begin{align} entropy = \\sum_{i=1}^5(-p(x_i) \\cdot \\log(p(x_i))) \\end{align} bayes rule suppose: \\(x\\) represents the grid cell \\(z\\) represents the measurements then the bayes rule states: \\begin{align} p(x_i|z) = \\frac{p(z|x_i)p(x_i)}{p(z)} \\end{align} where: \\(p(x_i|z)\\) is called the posterior \\(p(z|x_i)\\) is called the likelihood \\(p(z)\\) is known as the evidence or marginal likelihood (that is, it marginalizes \\(z\\)). to compute \\(p(z)\\) we use the theorem of total probability: \\begin{align} p(z) = \\sum_{i=1}^n p(z|x_i)p(x_i) \\end{align} so, to compute \\(p(x_i|z)\\) we follow the steps: for each \\(x_i\\) compute the non-normalized posterior: \\(\\hat{p}(x_i|z) = p(z|x_i)p(x_i)\\) sum all non-normalized posteriors to obtain the evidence: \\(p(z) = \\sum_{i=1}^n \\hat{p}(x_i|z)\\) for each \\(x_i\\) normalize the posterior with the evidence: \\(p(x_i|z) = \\frac{\\hat{p}(x_i|z)}{p(z)}\\) motion using total probability let's say we are at time \\(t\\), and \\(i\\) determines the cell, then the motion is expressed probabilistically as follows: \\begin{align} p(x_i^t) = \\sum_{j} p(x_i|x_j)p(x_j^{t-1}) \\end{align} if we break down this formula: \\(p(x_i|x_j)\\) is the probability that we end up in the cell \\(x_i\\) given we come from the cell \\(x_j\\) \\(p(x_j^{t-1})\\) is the probability of being in cell \\(x_j\\) at the previous time \\(p(x_i^t)\\) is the probability of being in cell \\(x_i\\) at time \\(t\\) summary belief represents where are possible places the robot might be, that is each cell has an associated probability value sense also known as the measurement update function. for each cell we compute the probability that the robot is in that cell, given a measurement sensed by the robot in the moment \\(t\\) (\\(p(x_k|z)\\), where \\(x_k\\) is the cell and \\(z\\) is the measurement). therefore, for each cell in the world we multiply the previous probability value (given by belief) and the probability that the robot moved to the given cell. for example, to satisfy the probability function properties, we need to normalize it, so it sums up to one. move it is a convolution, for each possible location, after the motion, we reverse engineered the situation and guessed where the world might have come from. so what we do is we compute the probability of each cell using the total probability theorem, so given a cell \\(x_k\\), we compute: \\begin{align} p(x_k) = \\sum_{l}p(x_k|x_l)p(x_l) \\end{align} where \\(p(x_k|x_l)\\) is the probabily that the robot moved to cell \\(x_k\\) from cell \\(x_l\\). usually what we do is stablish a motion using a vector (i.e. \\((0,1) \\in \\mathbb{r}^2\\) to indicate the robot moved one unit up in the two dimensional vector space). for example, this probability may refer to how likely it is that the robot moved to the exact cell, how likely it is that the robot moved to a cell \"beyond\" the goal or how likely it is that the robot moved to a cell that lies \"before\" the goal. so if we have these three probabilities, for each cell we sum the probabilities of the robot being in that cell taking into account the three scenarions: if the robot moved to cell \\(x_k\\) from cell \\(x_l\\), and that cell was the goal, then it moved to that cell with probability \\(p_{exact}\\) and maybe the robot moved to cell \\(x_k\\) from cell \\(x_i\\), however the goal was \\(x_{k+1}\\), then it moved to that cell with probability probability \\(p_{undershoot}\\) maybe the robot moved to cell \\(x_k\\) from cell \\(x_j\\), however the goal was \\(x_{k-1}\\), then it moved to that cell with probability probability \\(p_{overshoot}\\) suppose now that then only cells in the world are mentioned: \\(x_k, x_l, x_i, x_j\\). then for \\(x_k\\) we update the belief as follows: \\begin{align} p(x_k) = p(x_l) * p_{exact} + p(x_i) * p_{undershoot} + p(x_j) * p_{overshoot} \\end{align} localization algorithm next we lay out an example of the localization algorithm implemented in \\(\\mathbb{r}^2\\): # the function localize takes the following arguments: # # colors: # 2d list, each entry either 'r' (for red cell) or 'g' (for green cell) # # measurements: # list of measurements taken by the robot, each entry either 'r' or 'g' # # motions: # list of actions taken by the robot, each entry of the form [dy,dx], # where dx refers to the change in the x-direction (positive meaning # movement to the right) and dy refers to the change in the y-direction # (positive meaning movement downward) # note: the *first* coordinate is change in y; the *second* coordinate is # change in x # # sensor_right: # float between 0 and 1, giving the probability that any given # measurement is correct; the probability that the measurement is # incorrect is 1-sensor_right # # p_move: # float between 0 and 1, giving the probability that any given movement # command takes place; the probability that the movement command fails # (and the robot remains still) is 1-p_move; the robot will not overshoot # its destination in this exercise # # the function should return (not just show or print) a 2d list (of the same # dimensions as colors) that gives the probabilities that the robot occupies # each cell in the world. # # compute the probabilities by assuming the robot initially has a uniform # probability of being in any cell. # # also assume that at each step, the robot: # 1) first makes a movement, # 2) then takes a measurement. # # motion: # [0,0] - stay # [0,1] - right # [0,-1] - left # [1,0] - down # [-1,0] - up # compute the probability of \"hit\" cell and the probability of a \"miss\" cell # # :param float z value sensed by the robot (i.e. 'r' or 'g') # :param float cell_measurement value in the cell (i.e. 'r' or 'g') # :param float sensor_right probability that what the robot sensed is correct # # if the value sensed and the value in the cell are equal hit = 1 and miss = 0 # :return [sensor_right, 0] # otherwhise # :return [0, (1-sensor_right)] def probability_hit_miss(z, cell_measurement, sensor_right): hit = (z == cell_measurement) return [hit * sensor_right, (1-hit) * (1-sensor_right)] # compute the probability of a cell after the measurement of the robot # # :param cell_prior probability stored in the cell before measurement # :param float z value sensed by the robot (i.e. 'r' or 'g') # :param float cell_measurement value in the cell (i.e. 'r' or 'g') # :param float sensor_right probability that what the robot sensed is correct # # if the value sensed and the value in the cell are equal hit = sensor_right, else miss = (1-sensor_right) # :return the probability before measurement multiplied by the probability that the measurement is correct for the # given cell def probability_cell_given_measurement(cell_prior, z, cell_measurement, sensor_right): [hit, miss] = probability_hit_miss(z, cell_measurement, sensor_right) return cell_prior * (hit + miss) # for each cell x_k compute the probability that the robot is in the cell x_k given a measurement z # # :param list world measurements in the world # :param list p current world probabilities # :param list z current measurement of the robot # :param float sensor_right probability that the robot's measurement is correct # # for each cell x_k, where k is the cell [i][j]: # compute unnormalized p(x_k|z) = p(z|x_k) * p(x_k) # where p(x_k) = p[i][k] and # p(z|x_k) is computed in probability_cell_given_measurement and equals: # - sensor_right, if measurement in x_k = z # - (1-sensor_right), if measurement in x_k != z # compute the sum over all p(x_k|z), this sum equals p(z). # obtain normalized p(x_k|z) by dividing each p(x_k|z) by p(z) # :return list q of cell probabilies after measurement update def sense(world, p, z, sensor_right): q=[] # obtain probabilities q = [[ probability_cell_given_measurement(p[i][j], z, world[i][j], sensor_right) for j in range(len(p[0]))] for i in range(len(p))] # sum all probabilities s = sum([sum(row) for row in q]) ## normalize q = [[q[i][j]/s for j in range(len(p[0]))] for i in range(len(p))] return q # obtain probabilities of each cell in the grid after the robot moves # # :param list p current world probabilities # :param list u description of the motion (i.e. [0,1] to move to the right) # :param float p_move probability of moving from one cell to another # # for each cell x_k: # p(x_k) = sum over l=1...m of p(x_k|x_l) * p(x_l) # where # - p(x_k|x_l) = p_move and p(x_l) = p[(i-y) % len(p)][(j-x) % len(p[0])] if the robot moves from cell l = [(i-y)][(j-x)] to cell k = [i][j] # - p(x_k|x_l) = (1- p_move) and p(x_l) = p[i][j] if the robot does not move from cell k = [i][j] # :return list q of cell probabilies after the robot moves def move(p, u, p_move): q = [] [y, x] = u q = [[p_move * p[(i-y) % len(p)][(j-x) % len(p[0])] + (1-p_move) * p[i][j] for j in range(len(p[0]))] for i in range(len(p))] return q # for each pair of motion-measurement, update the grid probabilities of probabilities that represents where the robot is in any given moment # # :param matrix colors grid of measurements # :param list measurements measurements sensed by the robot # :param list motions directions in which the robot moved at each moment (i.e. for [0,1] it moves to the right) # :param float sensor_right probability that the robot's measurement is correct # :param float p_move probability of moving from one cell to another # # :return list q of cell probabilies after finishing updating for every measurement-motion def localize(colors,measurements,motions,sensor_right,p_move): # initializes p to a uniform distribution over a grid of the same dimensions as colors pinit = 1.0 / float(len(colors)) / float(len(colors[0])) p = [[pinit for row in range(len(colors[0]))] for col in range(len(colors))] # update probabilities iteratively for k in range((len(measurements))): p=move(p, motions[k], p_move) p=sense(colors, p, measurements[k], sensor_right) return p so for example, for the following data: colors = [['r','g','g','r','r'], ['r','r','g','r','r'], ['r','r','g','g','r'], ['r','r','r','r','r']] measurements = ['g','g','g','g','g'] motions = [[0,0],[0,1],[1,0],[1,0],[0,1]] where: the robot does not move (\\([0,0]\\)) and senses a green cell 'g'. the robot moves down (\\([0,1]\\)) and senses a green cell 'g'. the robot moves right (\\([1,0]\\)) and senses a green cell 'g'. the robot moves right (\\([1,0]\\)) and senses a green cell 'g'. the robot moves down (\\([0,1]\\)) and senses a green cell 'g'. and the colors is the representation of the world. then, we apply the localization algorithm to obtain the probability distribution that the robot is in each cell: p = localize(colors,measurements,motions,sensor_right = 0.7, p_move = 0.8) show(p) note that the probabily that the robot sensed the measurement correctly (\\(p(z|x_i)\\)) is \\(0.7\\) and the probability that the robot moved to the cell given by the motion vector (\\(p(x_i|x_j)\\)) is \\(0.8\\). this outputs: [[0.01106,0.02464,0.06800,0.04472,0.02465], [0.00715,0.01017,0.08697,0.07988,0.00935], [0.00740,0.00894,0.11273,0.35351,0.04066], [0.00911,0.00715,0.01435,0.04313,0.03643]] where each element in the matrix is the probabily of a cell. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Robotics/AIRobotics/KalmanFilters/Examples.html",
    "title": "Examples",
    "body": " index search search back examples design kalman filters for 2d to design a kalman filter in two dimensions (position, velocity) you need two things: a state transition function, which is usually a matrix \\(f\\): \\begin{align} \\begin{bmatrix} x \\\\ \\hat{x} \\\\ \\end{bmatrix} \\leftarrow f \\begin{bmatrix} x \\\\ \\hat{x} \\\\ \\end{bmatrix} \\end{align} a measurement function, represented by the matrix \\(h\\): \\begin{align} z \\leftarrow h \\begin{bmatrix} x \\\\ \\hat{x} \\\\ \\end{bmatrix} \\end{align} for example, suppose we update the location and the velocity as follows: \\begin{align} x' = x + \\hat{x} \\end{align} \\begin{align} \\hat{x}' = \\hat{x} \\end{align} then the transition function is represented as the following matrix: \\begin{align} f = \\begin{bmatrix} 1 & 1 \\\\ 0 & 1 \\\\ \\end{bmatrix} \\end{align} and for the measurement function, we only observe the location not the velocity, therefore: \\begin{align} h = \\begin{bmatrix} 1 & 0 \\\\ \\end{bmatrix} \\end{align} 4d example motion given a state \\((x, y, \\hat{x}, \\hat{y})\\), where \\((x, y)\\) is the position and \\((\\hat{x}, \\hat{y})\\) is the velocity.if in each iteration the motion update for the state is: \\begin{align} \\begin{matrix} x + dt\\cdot \\hat{x} \\\\ y + dt\\cdot \\hat{y} \\\\ \\hat{x} \\\\ \\hat{y} \\\\ \\end{matrix} \\end{align} so the position moves with time and the velocity does not change with time. then the state transition function is represented by the following matrix: \\begin{align} f = \\begin{bmatrix} 1 & 0 & dt & 0\\\\ 0 & 1 & 0 & dt\\\\ 0 & 0 & 1 & 0\\\\ 0 & 0 & 0 & 1\\\\ \\end{bmatrix} \\end{align} measurement and, because we can only measure the position the measurement update is of the form: \\begin{align} z \\leftarrow \\begin{bmatrix} x \\\\ y \\\\ \\end{bmatrix} \\leftarrow h \\cdot \\begin{bmatrix} x \\\\ y \\\\ \\hat{x} \\\\ \\hat{y} \\\\ \\end{bmatrix} \\end{align} therefore the measurement function is represented as follows: \\begin{align} h = \\begin{bmatrix} 1 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 0 \\\\ \\end{bmatrix} \\end{align} code example so for the following data, which deals with 4d data, that is we store a 2d location and a 2d velocity vector in the state. we will have to take this into account in the different update matrices and uncertainty matrix: # location measurements measurements = [[5., 10.], [6., 8.], [7., 6.], [8., 4.], [9., 2.], [10., 0.]] # initial location initial_xy = [4., 12.] dt = 0.1 x = matrix([[initial_xy[0]], [initial_xy[1]], [0.], [0.]]) # initial state (location and velocity) u = matrix([[0.], [0.], [0.], [0.]]) # external motion # initial uncertainty: 0 for positions x and y, 1000 for the two velocities # p = 0 0 0 0 # 0 0 0 0 # 0 0 1000 0 # 0 0 0 1000 p = matrix([[0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 1000., 0.], [0., 0., 0., 1000.]]) # next state function: generalize the 2d version to 4d # f = 1 0 0.1 0 # 0 1 0 0.1 # 0 0 1 0 # 0 0 0 1 # so, velocity vector (x', y') does not change, and the position vector (x, y) is updated according to the velocity and dt # f · x = x + 0.1x' # y + 0.1y' # x' # y' f = matrix([[1., 0., dt, 0], [0, 1., 0, dt], [0, 0, 1., 0], [0, 0, 0, 1.]]) # measurement function: reflect the fact that we observe x and y but not the two velocities # h = 1 0 0 0 # 0 1 0 0 # so, for the measurement we only take into account the position vector (x,y) and not the velocity # z = h · x = x # y h = matrix([[1., 0., 0., 0.], [0., 1., 0., 0.]]) # measurement uncertainty: use 2x2 matrix with 0.1 as main diagonal # r = 0.1 0 # 0 0.1 r = matrix([[.1, 0.], [0., .1]]) # 4d identity matrix # i = 1 0 0 0 # 0 1 0 0 # 0 0 1 0 # 0 0 0 1 i = matrix([[1., 0., 0., 0.], [0., 1., 0., 0.], [0., 0., 1., 0.], [0., 0., 0., 1.]]) and we execute the filter: filter(x, p) to obtain the following state \\(x\\) and uncertainty matrix \\(p\\): x= [9.999340731787717] [0.001318536424568617] [9.998901219646193] [-19.997802439292386] p= [0.03955609273706198, 0.0, 0.06592682122843721, 0.0] [0.0, 0.03955609273706198, 0.0, 0.06592682122843721] [0.06592682122843718, 0.0, 0.10987803538073201, 0.0] [0.0, 0.06592682122843718, 0.0, 0.10987803538073201] $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Robotics/AIRobotics/KalmanFilters/Kalman Filters.html",
    "title": "Kalman Filters",
    "body": " index search search back kalman filters markov model gaussian distribution measurement and motion motion step measurement step states predicting velocity high dimensional spaces put everything together algorithm this is a tracking technique. it is similar to the histogram localization we talked about previously, however there are some key differences: kalman filter maintains a continuous state (therefore uses a uni-modal distribution: probability density function only has one peak) histogram localization uses discrete state to represent the world (uses a multi-modal distribution: probability density function has multiple peaks) markov model in histogram localization we assigned a probability to each cell in the world: [\\(0.2\\)][\\(0.1\\)][\\(0.5\\)][\\(0.1\\)][\\(0.2\\)] what we did is we divided the continuous space into a finite number of cells, that approximates the posterior distribution (which is continuous: red line) by a histogram (blue bars) over the original distribution. however in kalman filters this distribution is given by a gaussian distribution. gaussian distribution a gaussian distribution is a continuous function which is described in \\(\\mathbb{r}\\) by the mean \\(\\mu\\) and the variance \\(\\sigma^2\\). the formula is the following: \\begin{align} f(x) = \\frac{1}{\\sqrt{2\\pi\\sigma^2}} \\exp^{-\\frac{1}{2}\\frac{(x-\\mu)}{\\sigma^2}} \\end{align} where \\(\\frac{1}{\\sqrt{2\\pi\\sigma^2}}\\) is a constant that normalizes \\(\\exp^{-\\frac{1}{2}\\frac{(x-\\mu)}{\\sigma^2}}\\) remark the bigger the covariance \\(\\sigma^2\\) the wider the distribution, which means we are less certain of the state. if it is narrow, that means we are confident about our location. measurement and motion like with localization kalman filters operate within a cycle, that is, it iterates like so: motion (or prediction): where we predict the position of the car based on data we know. to perform this prediction we sum the location distribution and the distribution that describes the motion. measurement (or measurement update/correction): where we combine the prediction with the measurement made by the sensors. to perform this update we multiply the motion prediction with the distribution that describes the measurement. this is illustrated in the following image: here the predicted state estimate corresponds to the motion step, and the measurement distribution corresponds to the measurement. the result of the product between the two eausl the optimal state estimate. motion step suppose, at moment \\(t\\), your location is represented as follows: where: the blue gaussian distribution represents your best guess (prediction) at where your are at \\(t\\), and is characterized by \\((\\mu, \\sigma^2)\\) the green gaussian distribution represents the motion of \\(\\nu\\) units, which has its own uncertainty, and is characterized by \\((\\nu, r^2)\\) the red gaussian distribution represents you location at time \\(t+1\\) after the motion where this last distribution equals the sum of the other two distributions and is characterized by: \\begin{align} \\hat{\\mu} = \\mu + \\nu \\end{align} \\begin{align} \\hat{\\sigma}^2 = \\sigma^2 + r^2 \\end{align} so, basically the mean is shifted \\(\\nu\\) units and the covariance is made larger by summing \\(\\sigma^2\\) and \\(r^2\\), as a result of summing the distributions. motion noise note that the movement may not be certain, that is why we introduce some gaussian noise. this noise is drawn from a normal distribution where the variance is given by a co-variance matrix \\(q\\) (this matrix describes the uncertainty for the initial state). we define this noise as follows: \\begin{align} u \\sim \\mathcal{n}(0, q) \\end{align} measurement step as we have already said, the update is the result of multiplying the prediction distribution (after motion step), which was characterized in the previous section, by the measurement distribution. this would mean \"creating\" a new distribution that models the robot's current state. we now show how the multiplication of two distributions is performed: updating the mean we are going to show how to the mean is computed when multiplying two distributions. suppose the prior distribution is as follows: where the covariance is very large, so we are very uncertain about a location. and we recieve a measurement of the form: which is much more certain about the location. then the mean will shift accordingly (green line): updating the variance we are going to show how to the variance is computed when multiplying two distributions. so, after multiplying the prior and the measurement shown previously, the resulting gaussian y more certain than both of the prior and the measurement gaussians. that is the covariance of this new gaussian is smaller, so the more measurements we have the more certain the are. why does this happen? well, given these two distributions: where the first distribution is characterized by \\((\\mu, \\sigma^2)\\) and the second distribution is characterized by \\((\\nu, r^2)\\). the product of the two is a distribution characterized by \\((\\hat{\\mu}, \\hat{\\sigma}^2)\\), computed as follows: \\begin{align} \\hat{\\mu} = \\frac{r^2\\mu + \\sigma^2\\nu}{r^2 + \\sigma^2} \\end{align} observe, because \\(\\sigma^2 >> r^2\\) in our example, then \\(\\hat{\\mu}\\) will be closer to the second distribution's mean \\(\\nu\\). also: \\begin{align} \\hat{\\sigma}^2 = \\frac{1}{\\frac{1}{r^2} + \\frac{1}{\\sigma^2}} = \\frac{\\sigma^2 r^2}{\\sigma^2 + r^2} \\end{align} thus, the updated covariance is not affected by the means and will always be smaller than \\(\\sigma^2\\) and \\(r^2\\). we illustrate this is the following image, where the updated distribution is the one drawn in blue: note that the wider distribution represents the prior, the measurement represents the likelihood and the updated distribution represents the posterior. measurement noise however, note that the measurement might also be noisy. so we again introduce gaussian noise \\(v\\) that is modeled after a normal distribution with known variance. that is \\(v \\sim \\mathcal{n}(0, r)\\). this indicates how much we trust the measurements provided by the sensors. this variable is called measurement noise covariance matrix states kalman filters are made up from what it's called states, and we differentiate two different kinds of states: observables (in our case the location) hidden (in our case the velocity, which i can never observe) these two types of states interact with each other in the sense that a sequence of observable variables gives us information about the hidden variables. thus we can estimate what these hidden variables are. applied to our case scenario, multiple observations of where we are, that is, our location, we can estimate how fast we are moving, that is, our velocity. predicting velocity given the following graph: where \\(\\hat{x}\\) represents the velocity and \\(x\\) represents the location. in this first instance, we represent the measurement at with an elongated gaussian because the measurement does not tell us anything about the velocity. however, if we now draw our predicition, given by our motion model which is represented by the red gaussian distribution, we obtain: suppose we take a new measurement (a second observation) represeted by the green normal distribution (remember, it tells us nothing about the velocity), it only gives us information about the location as the first observation did. then: multiply the prior (the red gaussian) and the measurement (the green gaussian) to obtain a really good estimate of an object's velocity and location (black distribution): so we were able to infer the velocity by only observing the location. high dimensional spaces up until now we have generally been operating in a one dimensional space, however if we were to work withing higher dimensional spaces we would need to make use of multivariate gaussians. so a multivariate gaussian in a d-dimensional space is characterized as follows: \\begin{align} \\mu = \\begin{bmatrix} \\mu_0 \\\\ \\vdots \\\\ \\mu_d \\\\ \\end{bmatrix}, \\sigma = \\begin{bmatrix} \\sigma_{11} & \\cdots & \\sigma_{1d}\\\\ \\vdots \\\\ \\sigma_{d1} & \\cdots & \\sigma_{dd}\\\\ \\end{bmatrix} \\end{align} also de density function is now, for \\(x \\in \\mathbb{r}^d\\): \\begin{align} f(x) = (2\\pi)^{-\\frac{d}{2}}|\\sigma|^{-\\frac{1}{2}} \\exp^{-\\frac{1}{2}(x - \\mu)^t\\sigma^{-1}(x-\\mu)} \\end{align} here are some examples of how the kalman filter works for spaces with higher dimension: put everything together motion at a given time \\(k-1\\), we have the following prediction: we use a motion model (in our case a gaussian that represents the movement) to update our prediction as follows: the motion model is described as follows: \\begin{align} x_k = f_{k-1}x_{k-1} + u_{k-1} \\end{align} where: \\(f_{k-1}\\) represents the transition function at time \\(k-1\\) \\(u_{k-1}\\) represents the noise at time \\(k-1\\) measurement then, we use the following observation model: we correct our prediction with this observation model as follows: the measurement model is described as follows: \\begin{align} y_k = h_k x_k + v_k \\end{align} where: \\(h_k\\) is the measurement function at time \\(k\\). this function maps the state into the observable state, that does not have to be the same (refer to states) \\(v_k\\) is the noise at time \\(k\\) iterative process first we make a prediction as to where the robot is at time \\(k\\): \\begin{align} \\check{x}_k = f_{k-1}x_{k-1} \\end{align} \\begin{align} \\check{p}_k = f_{k-1}\\hat{p}_{k-1}f_{k-1}^t + q_{k-1} \\end{align} then we compute the optimal gain \\(k\\) as follows: \\begin{align} k_k = \\check{p}_kh_k^t(h_k\\check{p}_kh^t+r_k)^{-1} \\end{align} this gain basically represents how much we trust our motion estimation versus our measurement estimation. finally we obtain the correction using the measurement model: shift the mean: \\begin{align} \\hat{x}_k = \\check{x}_k + k_k(y_k - h_k\\check{x}_k) \\end{align} where \\(y_k - h_k\\check{x}_k\\) represents the difference between the measurement and the prediction we made. lastly, we update the covariance of our motion model: update the variance: \\begin{align} \\hat{p}_k = (1-k_kh_k)\\check{p}_k \\end{align} algorithm so in the kalman filter cycle what we do is: first we perform the prediction and the correction or measurement update. more concretely: prediction we apply the same formulas we defined in motion model and iterative process to make a prediction: \\begin{align} x = fx + u \\end{align} \\begin{align} p = f \\cdot p \\cdot f^t \\end{align} measurement update now, for the correction: first we compute the intermediate \\(s\\) matrix, which equals the second part of the formula for \\(k\\), \\(h_k\\check{p}_kh^t+r_k\\): \\begin{align} s = h \\cdot p \\cdot h^t + r \\end{align} then we compute the kalman gain (as we defined in iterative process): \\begin{align} k = ph^ts^{-1} \\end{align} obtain difference between measurement (\\(z = y_k\\)) and our prediction \\(h \\cdot x = h_k\\check{x}_k\\) (note where \\(\\check{x}_k\\) comes from, \\(h\\) is usually a matrix that selects a concrete part of the kalman state like the position. see examples): \\begin{align} y = z - h \\cdot x \\end{align} finally obtain the correction: \\begin{align} x' = x + (k \\cdot y) \\end{align} \\begin{align} p' = (i- k\\cdot h) \\cdot p \\end{align} code the filter algorithm follows the same steps laid out in the previous section: def filter(x, p): for n in range(len(measurements)): # prediction x = (f * x) + u p = f * p * f.transpose() # measurement update z = matrix([measurements[n]]) y = z.transpose() - (h * x) s = h * p * h.transpose() + r k = p * h.transpose() * s.inverse() x = x + (k * y) p = (i - (k * h)) * p return x, p $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Robotics/AIRobotics/SLAM/SLAM.html",
    "title": "SLAM",
    "body": " index search search back slam how to create maps and localize a robot at the same time? for this we use a technique known as slam: simultaneous localization and mapping graph slam suppose we have a robot whose initial position is \\(x_0 = 0\\) and \\(y_0 = 0\\) at time \\(0\\), then at time \\(1\\) (because of how we mode our motion) the robot is at \\(x_1 = x_0 + 10\\) and \\(y_1 = y_0\\). however we know that our location is uncertain therefore the position at time \\(1\\) is really described by a gaussian distribution centered around \\(10\\) and with a given variance that signifies how certain we are about our position. so to express this with a gaussian, that we do is define a distribution whose pdf peaks when \\(x_1 = x_0 + 10\\) and \\(y_1 = y_0\\), therefore we would like to maximize both the following equations: \\begin{align} \\frac{1}{\\sqrt{2\\pi\\sigma^2}}\\exp{-\\frac{1}{2}\\frac{(x_1-x_0-10)^2}{\\sigma^2}} \\end{align} \\begin{align} \\frac{1}{\\sqrt{2\\pi\\sigma^2}}\\exp{-\\frac{1}{2}\\frac{(y_1 - y_0)^2}{\\sigma^2}} \\end{align} here if \\(x_1 = x_0 + 10\\), then \\(x_1 - x_0 - 10 = 0\\) and if \\(y_1 = y_0\\) ,then \\(y_1 - y_0 = 0\\). these conditions we define are called constraints, so what graph slam does is creating our probabilities defining a sequence of these constraints. suppose we have a robot that has followed the following path: where each \\(x_i\\) is a vector (usually a three dimensional vector) then graph slam defines the following constraints: initial position constraint: \\(x_0\\) relative motion constraints: \\((x-1 - x_0)\\), \\((x-2 - x_1)\\), \\((x-3 - x_2)\\) (indicated by the red lines). ideally these are the same as the robot motion (direction vector), however in reality it tends to bend to accommodate the map. relative measurement constraints: these are the segment between each position vector (not necessarily every position vector) and each landmark defined in the map, and are also captured by gaussian distributions. in our case \\(z_0, z_1, z_2, z_3\\), the lines colored in green. after we have collected these constraints, what the algorithm does is it relaxes the position vectors \\(x_i\\) to find the most likely configuration of robot path for the given landmarks (that is measurements of distance to the landmark). constraint matrix to define our constraints, suppose we have 3 position vectors \\(x_0, x_1, x_2\\) and two landmarks \\(l_0, l_1\\), then we define the following matrix: \\begin{align} \\begin{array}{c} \\begin{array} - & x_0 & x_1 & x_2 & l_0 & l_1 \\end{array}\\\\[5pt] \\begin{matrix} x_0 \\\\ x_1 \\\\ x_2 \\\\ l_0 \\\\ l_1 \\end{matrix}\\quad \\begin{bmatrix} 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\\\ 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\\\ 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\\\ 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\\\ 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\end{bmatrix} \\begin{bmatrix} 0.0 \\\\ 0.0 \\\\ 0.0 \\\\ 0.0 \\\\ 0.0 \\end{bmatrix}\\quad \\end{array} \\end{align} we denote this structure as follows: \\begin{align} \\omega = \\begin{bmatrix} 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\\\ 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\\\ 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\\\ 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\\\ 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\end{bmatrix} \\end{align} and: \\begin{align} \\xi = \\begin{bmatrix} 0.0 \\\\ 0.0 \\\\ 0.0 \\\\ 0.0 \\\\ 0.0 \\end{bmatrix} \\end{align} suppose \\(x_0\\) moves to \\(x_1\\) by moving \\(5\\) units to the right, that is \\(x_1 = x_0 + 5\\), then we define this constrain in the matrix as follows: \\begin{align} \\begin{array}{c} \\begin{array} - & x_0 & x_1 & x_2 & l_0 & l_1 \\end{array}\\\\[5pt] \\begin{matrix} x_0 \\\\ x_1 \\\\ x_2 \\\\ l_0 \\\\ l_1 \\end{matrix}\\quad \\begin{bmatrix} 1.0 & -1.0 & 0.0 & 0.0 & 0.0 \\\\ -1.0 & 1.0 & 0.0 & 0.0 & 0.0 \\\\ 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\\\ 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\\\ 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\end{bmatrix} \\begin{bmatrix} -5.0 \\\\ 5.0 \\\\ 0.0 \\\\ 0.0 \\\\ 0.0 \\end{bmatrix}\\quad \\end{array} \\end{align} because given the initial constraint \\(x_1 = x_0 + 5\\), if we move around the \\(x_i\\) we get: \\begin{align} x_0 - x_1 = -5 \\end{align} \\begin{align} x_1 - x_0 = 5 \\end{align} now we add another constraint \\(x2 = x_1 - 4\\), therefore: \\begin{align} x_2 - x_1 = -4 \\end{align} \\begin{align} x_1 - x_2 = 4 \\end{align} so the constraint matrix is updated to: \\begin{align} \\begin{array}{c} \\begin{array} - & x_0 & x_1 & x_2 & l_0 & l_1 \\end{array}\\\\[5pt] \\begin{matrix} x_0 \\\\ x_1 \\\\ x_2 \\\\ l_0 \\\\ l_1 \\end{matrix}\\quad \\begin{bmatrix} 1.0 & -1.0 & 0.0 & 0.0 & 0.0 \\\\ -1.0 & 2.0 & -1.0 & 0.0 & 0.0 \\\\ 0.0 & -1.0 & 1.0 & 0.0 & 0.0 \\\\ 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\\\ 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\end{bmatrix} \\begin{bmatrix} -5.0 \\\\ 9.0 \\\\ -4.0 \\\\ 0.0 \\\\ 0.0 \\end{bmatrix}\\quad \\end{array} \\end{align} we add a relative measurement constraint like \\(l_0 - x_1 = 9\\), therefore: \\begin{align} l_0 - x_1 = 9 \\end{align} \\begin{align} x_1 - l_0 = -9 \\end{align} so the constraint matrix is updated to: \\begin{align} \\begin{array}{c} \\begin{array} - & x_0 & x_1 & x_2 & l_0 & l_1 \\end{array}\\\\[5pt] \\begin{matrix} x_0 \\\\ x_1 \\\\ x_2 \\\\ l_0 \\\\ l_1 \\end{matrix}\\quad \\begin{bmatrix} 1.0 & -1.0 & 0.0 & 0.0 & 0.0 \\\\ -1.0 & 3.0 & -1.0 & -1.0 & 0.0 \\\\ 0.0 & -1.0 & 1.0 & 0.0 & 0.0 \\\\ 0.0 & -1.0 & 0.0 & 1.0 & 0.0 \\\\ 0.0 & 0.0 & 0.0 & 0.0 & 0.0 \\end{bmatrix} \\begin{bmatrix} -5.0 \\\\ 0.0 \\\\ -4.0 \\\\ 9.0 \\\\ 0.0 \\end{bmatrix}\\quad \\end{array} \\end{align} note that whenever we add a constraint to two parameters, let's say \\(x_1\\) and \\(x_2\\), we sum one to the diagonal element of the matrix corresponding to \\(x_1\\) and \\(x_2\\). noise given the following motion: we know that the localization of our robot is not an exact value, but is is modeled after a gaussian distribution, so \\(x_1 \\sim \\mathcal{n}(\\mu_{x_1}, \\sigma_{x_1})\\) and \\(x_2 \\sim \\mathcal{n}(\\mu_{x_2}, \\sigma_{x_2})\\). suppose \\(\\sigma_{x_1} = \\sigma_{x_2}\\). then we want to maximize the expected value, which is given by the expressions: \\begin{align} \\frac{1}{\\sqrt{2\\pi\\sigma^2}}\\exp{-\\frac{1}{2}\\frac{(x_1-x_0-10)^2}{\\sigma^2}} \\end{align} \\begin{align} \\frac{1}{\\sqrt{2\\pi\\sigma^2}}\\exp{-\\frac{1}{2}\\frac{(x_2 - x_1 -5)^2}{\\sigma^2}} \\end{align} to maximize both expressions means to maximize their product: \\begin{align} \\max_{x_0, x_1, x_2} \\frac{1}{\\sqrt{2\\pi\\sigma^2}}\\exp{-\\frac{1}{2}\\frac{(x_1-x_0-10)^2}{\\sigma^2}} \\cdot \\frac{1}{\\sqrt{2\\pi\\sigma^2}}\\exp{-\\frac{1}{2}\\frac{(x_2 - x_1 -5)^2}{\\sigma^2}} \\end{align} we also know that constants are irrelevant during maximization: \\begin{align} \\max_{x_0, x_1, x_2} \\exp{-\\frac{1}{2}\\frac{(x_1-x_0-10)^2}{\\sigma^2}} \\cdot \\exp{-\\frac{1}{2}\\frac{(x_2 - x_1 -5)^2}{\\sigma^2}} \\end{align} this maximization is equivalent to the maximization of its logarithm: \\begin{align} \\max_{x_0, x_1, x_2} \\log \\left(\\exp{-\\frac{1}{2}\\frac{(x_1-x_0-10)^2}{\\sigma^2}} \\cdot \\exp{-\\frac{1}{2}\\frac{(x_2 - x_1 -5)^2}{\\sigma^2}}\\right) \\end{align} because the logarithm of a product equal the sum of logarithms: \\begin{align} \\max_{x_0, x_1, x_2} \\left(\\log \\exp{-\\frac{1}{2}\\frac{(x_1-x_0-10)^2}{\\sigma^2}}\\right) + \\left(\\log \\exp{-\\frac{1}{2}\\frac{(x_2 - x_1 -5)^2}{\\sigma^2}}\\right) \\end{align} given \\(\\log \\exp (x) = x\\): \\begin{align} \\max_{x_0, x_1, x_2} \\left(-\\frac{1}{2}\\frac{(x_1-x_0-10)^2}{\\sigma^2}\\right) + \\left(-\\frac{1}{2}\\frac{(x_2 - x_1 -50)^2}{\\sigma^2}\\right) \\end{align} again, constants are irrelevant: \\begin{align} \\max_{x_0, x_1, x_2} \\left(\\frac{(x_1-x_0-10)^2}{\\sigma^2}\\right) + \\left(\\frac{(x_2 - x_1 -5)^2}{\\sigma^2}\\right) \\end{align} so, we end up with equations of the form: \\begin{align} \\frac{1}{\\sigma} x_1 - \\frac{1}{\\sigma} x_0 = \\frac{10}{\\sigma} \\end{align} where now \\(\\sigma\\) symbolizes how confident you are in your location/measurement. usually we define a \\(\\sigma\\) for the location and another \\(\\sigma_{measurement}\\) for the measurement (distance to the landmark). $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Robotics/OnlineTrainingMobileRobotics/Models/Motion Model.html",
    "title": "Motion Model",
    "body": " index search search back motion model introduction the motion of the system will always contain uncertainty, because it does not move perfectly with the command it is given. for example, suppose the robot follows the path illustrated in the next image: however the internal estimate of the system yields the following result: showing that it has a tendency to drift to the right. recursive bayes filter as you may recall from bayes filter our belief at time \\(t\\) was defined as follows: \\[ bel(x_t) = \\eta \\cdot p(z_t | x_t) \\cdot \\int p(x_t | x_{t-1}, u_{1:t}) \\cdot bel(x_{t-1}) dx_{t-1} \\] and we said we used our motion model to estimate the next state of the system \\(\\overline{x_t}\\): \\[ bel(\\overline{x}_t) = \\int p(x_t | x_{t-1}, u_{1:t}) \\cdot bel(x_{t-1}) dx_{t-1} \\] what we are doing here is marginilizing \\(x_t\\) so that we know the probability of being at state \\(x_t\\) given previous states \\(x_{t-1}\\) and control command \\(u_t\\). our motion model specifies a posterior probability, that asks what is the probability of the state being \\(x_t\\) given we were at state \\(x_{t-1}\\) and carried the command \\(u_t\\). typical motion models odometry-based models: we use the measurements (odometry) of the robot about how it moved as a command velocity-based models: we simply tell the system to move at a given velocity. reasons for motion errors of wheeled robots some errors that cause wrong movement estimations are the following: for the three different causes there are physical factors that make our robot move differently that what we expect it to for the given control command. odometry motion model suppose a motion takes place, where the initial point is described as \\((\\overline{x}, \\overline{y}, \\overline{\\theta})\\) and the final point is \\((\\overline{x}', \\overline{y}', \\overline{\\theta}')\\) our odometry information is given by \\(u = (\\delta_{rot1}, \\delta_{trans}, \\delta_{rot2})\\), where \\(\\delta_trans\\) is the distance between the two points, \\(\\delta_{rot1}\\) is the rotation on the first point and \\(\\delta_{rot2}\\) is the rotation on the second point. all of them are defined as follows: \\[ \\delta_{trans} = \\sqrt{(\\overline{x}' - \\overline{x})^2 + (\\overline{y}' - \\overline{y})^2} \\] \\[ \\delta_{rot1} = atan2(\\overline{y}' - \\overline{y}, \\overline{x}' - \\overline{x}) - \\overline{\\theta} \\] \\[ \\delta_{rot2} = \\overline{\\theta}' - \\overline{\\theta} - \\delta_{rot1} \\] each part is illustrated in the following image: $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Robotics/OnlineTrainingMobileRobotics/OccpancyGridMaps/Occpancy Grid Maps.html",
    "title": "Occupancy Grid Maps",
    "body": " index search search back occupancy grid maps introduction description of the mapping task grid maps assumptions occupancy probability joint distribution estimating a map from data static state binary bayes filter odds ratio log odds ration algorithm inverse sensor model for laser range finders introduction occupancy grid maps store information about the environment regarding which parts of the map are occupied and which are free. features vs volumetric maps feature map representations store where on the environment certain points or landmarks lay that the systems uses in order to estimate where it is. volumetric maps are most typically used to store free space. description of the mapping task the goal to obtain a map of a given environment is to compute the most likely map given the sensor data: \\[ m^* = \\arg \\max_m p(m|u_1,z_1, \\cdots, u_t,z_t) \\] however, we will simplify this problem by assuming we already know the poses for certain, thus we swap the control commands \\(u_t\\) for poses \\(x_t\\): \\[ m^* = \\arg \\max_m p(m|x_1,z_1, \\cdots, x_t,z_t) \\] grid maps grid maps discretize the environment by dividing it into a finite number of cells, which encode information about its occupation. that is, a cell is either free or occupied. grids are rigid structures, where cells are distributed uniformly along the grid and represent a definite space. generally we describe cells as pixels. assumptions for each cell, the area corresponding to the cell are completely free or occupied. every cell can be described with a binary random variable that models the occupancy: the world is static. the cells are independent of each other. which means: if i know the occupancy state of a given cell, it does not help me estimate the occupancy state of another. occupancy probability as we have said, each cell is a binary random variable that models the occupancy, that is: if we are certain a cell \\(m_i\\) is occupied: \\(p(m_i) = 1\\) if we are certain a cell \\(m_i\\) is free: \\(p(m_i) = 0\\) if we have no knowledge about the cell \\(m_i\\): \\(p(m_i) = 0.5\\) notation the probability of a cell \\(m_i\\) being occupied is expressed as follows: \\[ p(m_i = occ) = p_{occ}(m_i) = p(m_i) \\] the probability of it being free is given by: \\[ p(m_i = free) = p_{free}(m_i) = 1- p_{occ}(m_i) = p(\\neg m_i) \\] also, the shading in the map tells us how certain we are about \\(p(m_i)\\), that is the more intense the shade the higher the probability. joint distribution the map is described by a probability distribution defined as the joint belief of each cell in the map: \\[ p(m) = p(m_1, m_2, \\cdots, m_n) \\] to simplify this distribution we exploit one of the assumptions made before, that said cells were independent of each other, thus: \\[ p(m) = \\prod_i p(m_i) \\] estimating a map from data our goal is to estimate the map given the sensor data \\(z_{1:t}\\) and the poses \\(x_{1:t}\\), that is: \\[ p(m | z_{1:t}, x_{1:t}) = \\prod_i p(m_i|z_{1:t}, x_{1:t}) \\] in order to do this we use a variant of the bayes filter called binary bayes filter that is optimized for binary random variables (\\(m_i\\)). static state binary bayes filter so, for each cell in the environment \\(m_i\\) we compute: \\[ p(m_i|z_{1:t}, x_{1:t}) \\] we apply the bayes rule to swap \\(m_i\\) for \\(z_t\\), therefore: \\[ p(m_i|z_{1:t}, x_{1:t}) = \\frac{p(z_t|m_i, z_{1:t-1}, x_{1:t})p(m_i, z_{1:t-1}, x_{1:t})}{p(z_t | z_{1:t-1}, x_{1:t})} \\] we apply markov's assumption and assume independence between \\(z_t\\) and the previous observations \\(z_{1:t-1}\\) and poses \\(x_{1:t-1}\\), therefore: \\[ p(m_i|z_{1:t}, x_{1:t}) = \\frac{p(z_t|m_i, x_t)p(m_i, z_{1:t-1}, x_{1:t})}{p(z_t | z_{1:t-1}, x_{1:t})} \\] we also make use of the markov's assumption to discard future poses when we the most up to date observation is of \\(t-1\\): \\[ p(m_i|z_{1:t}, x_{1:t}) = \\frac{p(z_t|m_i, x_t)p(m_i, z_{1:t-1}, x_{1:t-1})}{p(z_t | z_{1:t-1}, x_{1:t})} \\] we apply bayes rule again over \\(p(z_t|m_i, x_t)\\) to swap \\(z_t\\) and \\(m_i\\) again: \\[ p(z_t|m_i, x_t) = \\frac{p(m_i|z_t, x_t) p(z_t|x_t)}{p(m_i|x_t)} \\] we plug this into the previous expression: \\[ p(m_i|z_{1:t}, x_{1:t}) = \\frac{p(m_i|z_t, x_t) p(z_t|x_t) p(m_i, z_{1:t-1}, x_{1:t-1})}{p(m_i|x_t) p(z_t | z_{1:t-1}, x_{1:t})} \\] we assume that \\(p(mi|x_t) \\approx p(mi)\\), because knowing for certain the current pose tells us nothing about the state of the cell: \\[ p(m_i|z_{1:t}, x_{1:t}) = \\frac{p(m_i|z_t, x_t) p(z_t|x_t) p(m_i, z_{1:t-1}, x_{1:t-1})}{p(m_i) p(z_t | z_{1:t-1}, x_{1:t})} \\] we compute this same derivation for the complement of \\(m_i\\): \\[ p(\\neg m_i|z_{1:t}, x_{1:t}) = \\frac{p(\\neg m_i|z_t, x_t) p(z_t|x_t) p(\\neg m_i, z_{1:t-1}, x_{1:t-1})}{p(\\neg m_i) p(z_t | z_{1:t-1}, x_{1:t})} \\] what we are going to do is compute the ratio between these two expressions: \\[ \\frac{p(m_i|z_{1:t}, x_{1:t})}{p(\\neg m_i|z_{1:t}, x_{1:t})} = \\frac{\\frac{p(m_i|z_t, x_t) p(z_t|x_t) p(m_i, z_{1:t-1}, x_{1:t-1})}{p(m_i) p(z_t | z_{1:t-1}, x_{1:t})}}{\\frac{p(\\neg m_i|z_t, x_t) p(z_t|x_t) p(\\neg m_i, z_{1:t-1}, x_{1:t-1})}{p(\\neg m_i) p(z_t | z_{1:t-1}, x_{1:t})}} \\] now, all of the terms that do not depend on \\(m_i\\) can be discarded: \\(p(z_t|x_t)\\) and \\(p(z_t | z_{1:t-1}, x_{1:t})\\), then \\[ \\frac{p(m_i|z_{1:t}, x_{1:t})}{p(\\neg m_i|z_{1:t}, x_{1:t})} = \\frac{\\frac{p(m_i|z_t, x_t)p(m_i, z_{1:t-1}, x_{1:t-1})}{p(m_i)}}{\\frac{p(\\neg m_i|z_t, x_t) p(\\neg m_i, z_{1:t-1}, x_{1:t-1})}{p(\\neg m_i)}} \\] we reorganize the expression: \\[ \\frac{p(m_i|z_{1:t}, x_{1:t})}{p(\\neg m_i|z_{1:t}, x_{1:t})} = \\frac{p(m_i|z_t, x_t)p(m_i, z_{1:t-1}, x_{1:t-1})p(\\neg m_i)}{p(\\neg m_i|z_t, x_t) p(\\neg m_i, z_{1:t-1}, x_{1:t-1})p(m_i)} \\] \\[ \\frac{p(m_i|z_{1:t}, x_{1:t})}{p(\\neg m_i|z_{1:t}, x_{1:t})} = \\frac{p(m_i|z_t, x_t)}{p(\\neg m_i|z_t, x_t)} \\frac{p(m_i, z_{1:t-1}, x_{1:t-1})}{p(\\neg m_i, z_{1:t-1}, x_{1:t-1})} \\frac{p(\\neg m_i)}{ p(m_i)} \\] we express \\(\\neg m_i\\) in terms of \\(m_i\\): \\[ \\frac{p(m_i|z_{1:t}, x_{1:t})}{1-p(m_i|z_{1:t}, x_{1:t})} = \\frac{p(m_i|z_t, x_t)}{ 1- p(m_i|z_t, x_t)} \\frac{p(m_i, z_{1:t-1}, x_{1:t-1})}{1-p(m_i, z_{1:t-1}, x_{1:t-1})} \\frac{1-p(m_i)}{ p(m_i)} \\] note that now we have three expressions: the first one uses the observation \\(z_t\\) the second one is a recursive term the third one describes our prior knowledge about the state of the cell without any other information about the environment. odds ratio what we do now is turn this ratio called odds ratio into the probability as follows: \\[ odds(x) = \\frac{p(x)}{1-p(x)} \\] we multiply by \\(1-p(x)\\) in both sides. \\[ odds(x)(1-p(x)) = p(x) \\] we expand the left hand side expression: \\[ odds(x)-odds(x)p(x) = p(x) \\] we add \\(odds(x)p(x)\\) to both sides: \\[ odds(x) = p(x) + odds(x)p(x) \\] we extract \\(p(x)\\) as a common factor on the right hand side: \\[ odds(x) = p(x) (1 + odds(x)) \\] we divide by \\((1 + odds(x))\\) on both sides: \\[ \\frac{odds(x)}{(1 + odds(x))} = p(x) \\] and finally: \\[ p(x) = \\frac{1}{\\left(1 + \\frac{1}{odds(x)} \\right)} \\] so by using: \\[ p(x) = [1 + odds(x)^{-1}]^{-1} \\] in our update rule: \\[ p(m_i | z_{1:t}, x_{1:t}) = \\left[1 + (\\frac{p(m_i|z_{1:t}, x_{1:t})}{1-p(m_i|z_{1:t}, x_{1:t})})^{-1}\\right]^{-1} \\] \\[ p(m_i | z_{1:t}, x_{1:t}) = \\left[1 + \\frac{1-p(m_i|z_{1:t}, x_{1:t})}{p(m_i|z_{1:t}, x_{1:t})}\\right]^{-1} \\] because: \\[ \\frac{p(m_i|z_{1:t}, x_{1:t})}{1-p(m_i|z_{1:t}, x_{1:t})} = \\frac{p(m_i|z_t, x_t)}{ 1- p(m_i|z_t, x_t)} \\frac{p(m_i, z_{1:t-1}, x_{1:t-1})}{1-p(m_i, z_{1:t-1}, x_{1:t-1})} \\frac{1-p(m_i)}{ p(m_i)} \\] the inverse equals: \\[ \\frac{1-p(m_i|z_{1:t}, x_{1:t})}{p(m_i|z_{1:t}, x_{1:t})} = \\frac{ 1- p(m_i|z_t, x_t)}{p(m_i|z_t, x_t)} \\frac{1-p(m_i, z_{1:t-1}, x_{1:t-1})}{p(m_i, z_{1:t-1}, x_{1:t-1})} \\frac{ p(m_i)}{1-p(m_i)} \\] therefore: \\[ p(m_i | z_{1:t}, x_{1:t}) = \\left[1 + \\frac{ 1- p(m_i|z_t, x_t)}{p(m_i|z_t, x_t)} \\frac{1-p(m_i, z_{1:t-1}, x_{1:t-1})}{p(m_i, z_{1:t-1}, x_{1:t-1})} \\frac{ p(m_i)}{1-p(m_i)}\\right]^{-1} \\] which means, we can obtain information about the state of the \\(m_i\\) grid cell given the observation and the positions. log odds notation to make the computation more efficient we are going to take the log of this expression. the notation will be the following: \\[ l(m_i | z_{1:t}, x_{1:t}) = \\log \\left(\\frac{1-p(m_i|z_{1:t}, x_{1:t})}{p(m_i|z_{1:t}, x_{1:t})}\\right) \\] note that we can map from the log space to the probability space and vice versa as follows: \\[ l(x) = \\log \\frac{p(x)}{1-p(x)} \\] \\[ p(x) = 1- \\frac{1}{1 + \\exp(l(x))} \\] given this facts, we can turn the aforementioned product into a sum, because the log of the product of two terms equal the sum of the log of each term. \\[ l(m_i|z_{1:t}, x_{1:t}) = l(m_i|z_t,x_t) + l(m_i|z_{1:t-1}, x_{1:t-1}) - l(m_i) \\] where: \\(l(m_i|z_t,x_t)\\) is the inverse sensor model, which contains information about what we sensed. \\(l(m_i|z_{1:t-1}, x_{1:t-1})\\) is the recursive term, that is the state of cell on the previous iteration. \\(l(m_i)\\) is the prior. in short: \\[ l_{t,i} = inv\\_sensor\\_model(m_i, x_t, z_t) + l_{t-1, i} - l_0 \\] algorithm as we can see in the algorithm what we do is, given an observation \\(z_t\\) we go through each cell, and if the cell is close to the area where the observation took place then we update the state of the cell taking into account the sensor information. else we just propagate the previous state into the current state: inverse sensor model for laser range finders on the following graph we show the way we update the occupancy probability of the cells. here, the x axis represent several cells and the y axis represents the occupancy probability. at cell \\(n\\) our scanner detects an obstacle at time \\(t\\), this corresponds to the observation \\(z_{t,n}\\). therefore: the probability of cells prior to cell \\(n\\) of being occupied is low, because we were able to shot a laser through them without encountering no obstacle the probability of the n-th cell of being occupied is high, because it is the place where we found the obstacle. the probability of cells after \\(n\\) of bain occupied is unknown because we cannot see after the laser. a similar idea could be applied to sonar range sensor, which measure an area instead of a line: however the graph is a bit different, we now take into account that the sensor might not be completely reliable, therefore when the sonar detects an obstacle at a given distance we spread the probability of being occupied over adjacent cells/distances. example the idea is to add sensor information to a current \"map\" to increase the certainty of the state of each cell: $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Robotics/OnlineTrainingMobileRobotics/index.html",
    "title": "Online Training: Mobile Robotics",
    "body": " index search search back online training: mobile robotics source: online training: mobile robotics by cyrill stachniss bayes filter occpancy grid maps motion model observation model kalman filter extended kalman filter particle filter markov decision processes slam graph-based slam graph-based slam with landmarks $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Robotics/OnlineTrainingMobileRobotics/KalmanFilter/Extended Kalman Filter.html",
    "title": "Extended Kalman Filter",
    "body": " index search search back extended kalman filter introduction local linearization jacobian error under local linearization linearized motion model linearized observation model algorithm kalman gain localization example introduction what happens if we are dealing with non-linear dynamic systems, such that we do not use our linear models anymore: \\[ x_t = a_tx_{t-1} + b_tu_t + \\epsilon_t \\] \\[ z_t = c_t x_t + \\delta_t \\] but we introduce new functions that need not be linear: \\[ x_t = g(u_t, x_{t-1}) + \\epsilon_t \\] \\[ z_t = h(x_t) + \\delta_t \\] before, when we transformed our belief (a gaussian) with a linear transformation, something like the following happened: where the distribution of the upper left is the result of transforming the distribution of the bottom by applying the linear function on the upper right. however, if we try to do this same thing with a non-linear transformation, we could end up with something like this: so, the result of the transformation is clearly no a gaussian. which means, the kalman filter is not applicable anymore. to prevent this problem we are going to use local linearization. local linearization in order to perform local linearization what we do is approximate the non-linear functions \\(g\\) and \\(h\\) by the means of the taylor expansion. thus we re-define our non-linear functions as follows: the linearization for prediction step consists of linearizing around our previous state \\(x_{t-1} = (\\mu_{t-1}, \\sigma_{t-1})\\)and is described as follows: \\[ g(u_t, x_{t-1}) \\approx g(u_t, \\mu_{t-1}) + \\frac{\\delta g(u_t, \\mu_{t-1})}{\\delta x_{t-1}}(x_{t-1} - \\mu_{t-1}) \\] \\(g(u_t, \\mu_{t-1})\\) is the value of our non-linear model at the linearization point \\(\\mu_{t-1}\\), which corresponds to our previous belief. \\(g_t = \\frac{\\delta g(u_t, \\mu_{t-1})}{\\delta x_{t-1}}\\) is the slope of the local linearization at \\(x_{t-1}\\). this is a first partial derivative which constitutes a jacobian. \\((x_{t-1} - \\mu_{t-1})\\) tells us how far we are away from the linearization point \\(\\mu_{t-1}\\). for the correction step we linearize around our predicted state \\(\\overline{x}_t = (\\overline{\\mu}_t, \\overline{\\sigma}_t)\\): \\[ h(x_t) \\approx h(\\overline{\\mu}_t) + \\frac{\\delta h(\\overline{\\mu}_t)}{\\delta x_t} (x_t - \\overline{\\mu}_t) \\] \\(h(\\overline{\\mu}_t)\\) is the value of our non-linear observation model at the linearization point, which now is the predicted belief, that is the best estimate that i have. \\(h_t = \\frac{\\delta h(\\overline{\\mu}_t)}{\\delta x_t}\\) is the jacobian that equals the slope at the linearization point. \\((x_t - \\overline{\\mu}_t)\\) signifies how far away is the variable \\(x_t\\) to our linearization point \\(\\overline{\\mu}_t\\). jacobian given a function \\(f: \\mathbb{r}^n \\rightarrow \\mathbb{r}^m\\), such that given \\(x \\in \\mathbb{r}^n\\), \\(x \\mapsto f(x) \\in \\mathbb{r}^{m}\\). then the jacobian has the following shape: \\[ j = \\begin{bmatrix} \\frac{\\delta f_1}{\\delta x_1} & \\frac{\\delta f_1}{\\delta x_2} & \\cdots & \\frac{\\delta f_1}{\\delta x_n} \\\\ \\vdots & \\cdots & \\cdots & \\vdots \\\\ \\frac{\\delta f_m}{\\delta x_1} & \\frac{\\delta f_m}{\\delta x_2} & \\cdots & \\frac{\\delta f_m}{\\delta x_n} \\end{bmatrix} \\in \\mathbb{r}^{m \\times n} \\] and we can illustrate it graphically: as you can see, for points close to the linearization point, it constitutes a good approximation, but the further we move away the bigger the error is. so, let's revisit the transformation of our gaussian belief. remember we had, the following non-linear transformation: what we do now, is take the mean of our belief \\(\\mu_t\\) and approximate it locally with a linear function by using the taylor expansion as we have explained before. and then we transform our gaussian belief with this linear approximation (represented by the red line) which results in the following transformation: error under local linearization when we perform local linearization the error depends on to factors: the difference between the non-linear function and its linear approximation the uncertainty of our original gaussian distribution. because the larger the uncertainty, more probability mass will fall farther from our linearization point (the mean of that same gaussian distribution), and remember that the further we are from the linearization point the worse the approximation is, and thus the bigger the error is. linearized motion model we defined our linear motion model as follows: \\[ p(x_t|x_{t-1}, u_t) = \\det(2\\pi r_t)^{-\\frac{1}{2}} \\exp(-\\frac{1}{2}(x_t - a_tx_{t-1} - b_tu_t)^tr^{-1}_t(x_t - a_tx_{t-1} - b_tu_t)) \\] if our world is non-linear we substitute \\[ x_t = a_tx_{t-1} + b_tu_t + \\epsilon_t \\] for \\[ x_t = g(u_t, x_{t-1}) + \\epsilon_t \\] therefore the motion model is expressed as follows: \\[ p(x_t|x_{t-1}, u_t) = \\det(2\\pi r_t)^{-\\frac{1}{2}} \\exp(-\\frac{1}{2}(x_t - g(u_t, x_{t-1}))^tr^{-1}_t(x_t - g(u_t, x_{t-1}))) \\] finally we find a linear approximation, such that: \\[ g(u_t, x_{t-1}) \\approx g(u_t, \\mu_{t-1}) + \\frac{\\delta g(u_t, \\mu_{t-1})}{\\delta x_{t-1}}(x_{t-1} - \\mu_{t-1}) = g(u_t, \\mu_{t-1}) + g_t(x_{t-1} - \\mu_{t-1}) \\] and the linearized motion model becomes: \\[ p(x_t|x_{t-1}, u_t) = \\det(2\\pi r_t) ^{-\\frac{1}{2}} \\cdot \\] \\[ \\cdot \\exp(-\\frac{1}{2}(x_t - g(u_t, \\mu_{t-1}) - g_t(x_{t-1} - \\mu_{t-1}))^tr^{-1}_t \\cdot \\] \\[ \\cdot (x_t - g(u_t, \\mu_{t-1}) - g_t(x_{t-1} - \\mu_{t-1}))) \\] where \\(r^{-1}_t\\) describes the motion noise. linearized observation model we defined our linear observation model as follows: \\[ p(z_t|x_t) = \\det(2\\pi q_t)^{-\\frac{1}{2}} \\exp(-\\frac{1}{2}(z_t - c_tx_t)^tq^{-1}_t(z_t - c_tx_t)) \\] if our world is non-linear we substitute \\[ z_t = c_t x_t + \\delta_t \\] for \\[ z_t = h(x_t) + \\delta_t = h(\\overline{\\mu}_t) + \\delta_t \\] note that \\(x_t = \\overline{\\mu}_t\\) here refers to our best estimation up until now, that comes from the prediction step. therefore the observation model is expressed as follows: \\[ p(z_t|x_t) = \\det(2\\pi q_t)^{-\\frac{1}{2}} \\exp(-\\frac{1}{2}(z_t - h(\\overline{\\mu}_{t}))^tq^{-1}_t(z_t - h(\\overline{\\mu}_{t}))) \\] finally we find a linear approximation, such that: \\[ h(x_t) \\approx h(\\overline{\\mu}_t) + \\frac{\\delta h(\\overline{\\mu}_t)}{\\delta x_t} (x_t - \\overline{\\mu}_t) = h(\\overline{\\mu}_t) + h_t (x_t - \\overline{\\mu}_t) \\] and the linearized observation model becomes: \\[ p(z_t|x_t) = \\det(2\\pi q_t)^{-\\frac{1}{2}} \\cdot \\] \\[ \\cdot \\exp(-\\frac{1}{2}(z_t - h(\\overline{\\mu}_t) - h_t (x_t - \\overline{\\mu}_t))^tq^{-1}_t \\cdot \\] \\[ \\cdot (z_t - h(\\overline{\\mu}_t) - h_t (x_t - \\overline{\\mu}_t))) \\] where \\(q^{-1}_t\\) describes the measurement noise. algorithm to take into account the linearized models, we have to make a few changes to the kalman filter algorithm: the first thing that changes is that we use our linearized moition model \\(g(u_t, \\mu_{t-1})\\) to obtain our predicted estate \\(\\overline{x}_t = (\\overline{\\mu}_t, \\overline{\\sigma}_t)\\) we use the jacobian \\(g_t\\) to transform our previous uncertainty \\(\\sigma_{t-1}\\), given the jacobian is the linear transformation that approximates the non-linear transformation we defined originally for our motion model. same thing goes for the correction step. we use the jacobian \\(h_t\\) to apply a linear transformation that allows us to map \\(\\overline{\\sigma}_t\\) from the state space to the observation space, and thus calculate the kalman gain taking into account the measurement noise. then we compute the corrected mean of the estimated state \\(x_t\\) by obtaining the weighted sum of the mean of the predicted state \\(\\overline{\\mu}_t\\) and the correction factor. this correction factor equals the difference between the actual measurement \\(z_t\\) and the mapping of the predicted state to the observation space given by our linearized function \\(h(\\overline{\\mu}_t)\\). this mapping equals the expected measurement given our state is \\(\\overline{\\mu}_t\\). we do the same thing for the uncertainty \\(\\sigma_t\\). kalman gain suppose you have a perfect sensor, that is we trust completely the values given by this sensor and thus we set the measurement noise to be equal to zero (\\(q_t = 0\\)). then, the kalman gain becomes: \\[ k_t = \\overline{\\sigma}_t h_t^t \\cdot (h_t \\overline{\\sigma}_t h_t^t + q_t)^{-1} \\] \\[ k_t = \\overline{\\sigma}_t h_t^t \\cdot (h_t \\overline{\\sigma}_t h_t^t + 0)^{-1} \\] \\[ k_t = \\overline{\\sigma}_t h_t^t \\cdot (h_t^t)^{-1} \\overline{\\sigma}_t^{-1} h_t^{-1} \\] \\[ k_t = \\overline{\\sigma}_t i \\overline{\\sigma}_t^{-1} h_t^{-1} \\] \\[ k_t = i h_t^{-1} = h_t^{-1} \\] so, when we perform the correction over the mean of our belief: \\[ \\mu_t = \\overline{\\mu}_t + k_t (z_t - h(\\overline{\\mu}_t)) \\] \\[ \\mu_t = \\overline{\\mu}_t + h_t^{-1} (z_t - h(\\overline{\\mu}_t)) \\] \\[ \\mu_t = \\overline{\\mu}_t + h_t^{-1} z_t - h_t^{-1}h(\\overline{\\mu}_t) \\] with \\(h_t^{-1}h(\\overline{\\mu}_t)\\) what we are doing is, first computing \\(h(\\overline{\\mu}_t)\\) to map \\(\\overline{\\mu}_t\\) to the observation space, and the undoing this mapping with \\(h_t^{-1}\\), which means: \\[ \\mu_t = \\overline{\\mu}_t + h_t^{-1} z_t - \\overline{\\mu}_t \\] \\[ \\mu_t = \\overline{\\mu}_t - \\overline{\\mu}_t + h_t^{-1} z_t \\] \\[ \\mu_t = h_t^{-1} z_t \\] where \\(h_t^{-1}\\) maps \\(z_t\\) from the observation space to the state space, and this means in this update we trust our observation completely, and therefore our estate equals the observation. on the contrary, suppose the sensor is very unreliable, and so the noise is set to be infinity. then the correction step is executed as follows: \\[ k_t = \\overline{\\sigma}_t h_t^t \\cdot (h_t \\overline{\\sigma}_t h_t^t + q_t)^{-1} \\] \\[ k_t = \\overline{\\sigma}_t h_t^t \\cdot (h_t \\overline{\\sigma}_t h_t^t + \\infty)^{-1} \\] because we are dividing by infinity, \\(k_t = 0\\). so the mean of our belief is computed as follows: \\[ \\mu_t = \\overline{\\mu}_t + k_t (z_t - h(\\overline{\\mu}_t)) \\] \\[ \\mu_t = \\overline{\\mu}_t + 0 (z_t - h(\\overline{\\mu}_t)) \\] \\[ \\mu_t = \\overline{\\mu}_t \\] hence, if the measurement is too noisy, we only take into account our predicted state. localization example localization example using extended kalman filter (from 11') $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Robotics/OnlineTrainingMobileRobotics/KalmanFilter/Kalman Filter.html",
    "title": "Kalman Filter",
    "body": " index search search back kalman filter introduction properties of gaussian distributions linear model models linear motion model linear observation model gaussian world representing the belief algorithm assumptions the kalman filter requires the world to be gaussian, that is every probability distribution used must be gaussian. this filter also assumes linear models. introduction suppose your position on a 2d plane is given by the black dot: let's say you get your estimate as to where you are, inferred from a certain control command. for example if you are trying to move forward in the same direction you estimate your new position will be the cross: this is will be the prediction step. now suppose you get an observation about the distance to the nearest lighthouse: so now we can perform our new state estimate by combining by the means of a weighted sum our prediction along with the measurement: this weighted sum is performed trading off how certain you are about your prediction and how certain you are about your observation. properties of gaussian distributions in order to derive and prove some parts of the kalman filter we exploit the following properties: the product of two gaussian is a gaussian. a gaussian stays gaussian under linear transformations the marginal and conditional distribution of a gaussian is a gaussian linear model what does it mean when we say the kalman filter uses linear models? this means that both the motion model and the observation model can be expressed through a linear function, that is: \\[ f(x) = ax + b \\] one important property is that if a gaussian distribution is transformed through a linear function it stays gaussian. also, we introduce noise by using a zero mean gaussian distribution. models the motion model is defined as follows: \\[ \\overline{x}_t = a_t x_{t-1} + b_tu_t + \\epsilon_t \\] where \\(x_{t-1}\\) is the previous state estimate, \\(u_t\\) is the control command at time \\(t\\) and \\(\\epsilon_t\\) is gaussian noise. let's dive a little deeper: \\(a_t\\) is a matrix \\(n \\times n\\) (a mapping between the state space and the state space) which tells us how the state evolves from \\(t-1\\) to \\(t\\) without control commands or noise. we can use this matrix to encode information about velocity, acceleration, etc. \\(b_t\\) is a matrix \\(n \\times l\\) (a mapping between the control space and the state space) that describes how the control command \\(u_t\\) changes the state from \\(t_1\\) to \\(t\\). \\(\\epsilon_t\\) is a random variable that represents the motion noise with covariance \\(r_t\\). the observation model is defined as follows: \\[ z_t = c_t \\overline{x}_t + \\delta_t \\] where \\(\\overline{x}_t\\) is the estimated state and \\(\\delta_t\\) is gaussian noise. \\(c_t\\) is a matrix \\(k \\times n\\) which describes a mapping between the state \\(\\overline{x}_t\\) to an observation \\(z_t\\). \\(\\delta_t\\) is a random variable that represents the observation noise with covariance \\(q_t\\). linear motion model now that we have defined our linear models, we are going to show how to express the motion under a gaussian: \\[ p(x_t|x_{t-1}, u_t) = \\det(2\\pi r_t)^{-\\frac{1}{2}} \\exp(-\\frac{1}{2}(x_t - a_tx_{t-1} - b_tu_t)^tr^{-1}_t(x_t - a_tx_{t-1} - b_tu_t)) \\] which means we are obtaining the value of a probability distribution that incorporates our linear model for the prediction: \\[ p(x_t|x_{t-1}, u_t) \\sim \\mathcal{n}(a_tx_{t-1} + b_tu_t, r_t) \\] linear observation model we will apply the same reasoning to obtain the observation model under a gaussian: \\[ p(z_t|x_t) = \\det(2\\pi q_t)^{-\\frac{1}{2}} \\exp(-\\frac{1}{2}(z_t - c_t\\overline{x}_t)^tq^{-1}_t(z_t - c_t\\overline{x}_t)) \\] which means we are obtaining the difference between the observation \\(z_t\\) and what i expect to observe \\(\\overline{x}_{t}\\) (\\(z_t - c\\overline{x}_t\\)) while also taking the uncertainty into account \\(q_t^{-1}\\). we compute this incorporating our linear model for the correction step: \\[ p(z_t|x_t) \\sim \\mathcal{n}(c_t\\overline{x}_t, q_t) \\] gaussian world as we have said, we are assuming everything is gaussian. up until now we have described our models by using gaussian distributions, however we still have to make sure these are maintained when we are performing the prediction and the update. so, given the belief at time \\(t\\): if we suppose \\(\\overline{bel}(x_t)\\) is gaussian, then \\(bel(x_t)\\) is gaussian because the product of gaussian distribution is a gaussian distribution. therefore we need to show that \\(\\overline{bel}(x_t)\\) is also gaussian. that is: \\[ \\overline{bel}(x_t) = \\int p(x_t|u_t,x_{t-1})bel(x_{t-1})dx_{t-1} \\] we know, by its definition, that \\(p(x_t|u_t,x_{t-1})\\) is gaussian, and also we can prove by mathematical induction that \\(bel(xx_{t-1})\\) is gaussian. because if we start from a gaussian distributed belief and everything stays gaussian then the belief at time \\(t-1\\) will also be gaussian. noting that the convolution of two gaussian stays gaussian we conclude that \\(\\overline{bel}(x_t)\\) is gaussian and thus \\(bel(t)\\) is also gaussian. let's show however that the integral preserves the gaussian. note that we can express the predicted belief by using our linear models as follows: \\[ \\overline{bel}(x_t) = \\int p(x_t|u_t,x_{t-1}) bel(x_{t-1})dx_{t-1} \\] \\[ = \\int \\det(2\\pi r_t)^{-\\frac{1}{2}} \\exp(-\\frac{1}{2}(x_t - a_tx_{t-1} - b_tu_t)^tr^{-1}_t(x_t - a_tx_{t-1} - b_tu_t))bel(x_{t-1})dx_{t-1} \\] \\[ = \\eta \\int \\exp(-\\frac{1}{2}(x_t - a_tx_{t-1} - b_tu_t)^tr^{-1}_t(x_t - a_tx_{t-1} - b_tu_t))bel(x_{t-1})dx_{t-1} \\] \\[ = \\eta \\int \\exp(-\\frac{1}{2}(x_t - a_tx_{t-1} - b_tu_t)^tr^{-1}_t(x_t - a_tx_{t-1} - b_tu_t)) exp(-\\frac{1}{2}(x_{t-1} - \\mu_{t-1})^t\\sigma_{t-1}^{-1}(x_{t-1} - \\mu_{t-1})) \\] where \\(exp(-\\frac{1}{2}(x_{t-1} - \\mu_{t-1})^t\\sigma_{t-1}^{-1}(x_{t-1} - \\mu_{t-1}))\\) is the expected value of the gaussian that describes our previous belief \\(bel(x_{t-1})\\). now, we combine both exponentials, given \\(exp(x) \\cdot exp(y) = exp(x + y)\\): \\[ \\overline{bel}(x_t) = \\eta \\int \\exp(-l_t)dx_{t-1} \\] given: \\[ l_{t} = \\frac{1}{2}(x_t - a_tx_{t-1} - b_tu_t)^tr^{-1}_t(x_t - a_tx_{t-1} - b_tu_t) \\] \\[ + \\frac{1}{2}(x_{t-1} - \\mu_{t-1})^t\\sigma_{t-1}^{-1}(x_{t-1} - \\mu_{t-1}) \\] we can split \\(l_t\\) up in a part that only depends on \\(x_t\\) and another part that depends on \\(x_t, x_{t-1}\\). such that: \\[ l_t = l_t(x_{t-1}, x_t) + l_t(x_t) \\] thus: \\[ \\overline{bel}(x_t) = \\eta \\int \\exp(-l_t(x_{t-1}, x_t) -l_t(x_t))dx_{t-1} \\] \\[ \\overline{bel}(x_t) = \\eta \\exp(-l_t(x_t)) \\int \\exp(-l_t(x_{t-1}, x_t) )dx_{t-1} \\] this way we have: \\(\\exp(-l_t(x_t))\\): gaussian distribution \\(\\int \\exp(-l_t(x_{t-1}, x_t) )dx_{t-1}\\): this is the marginalization of a gaussian of the variable \\(x_{t-1}\\), which happens to also be a gaussian. therefore we have shown that everything stays gaussian: representing the belief we have said that everything is gaussian, which includes our belief. this belief will be represented, like any other gaussian is, by its mean \\(\\mu\\) and variance \\(\\sigma\\). so our belief at time \\(t\\) would be represented by \\((\\mu_t, \\sigma_t)\\). algorithm the kalman filter algorithm is defined as follows: inputs: \\(\\mu_{t-1}\\): previous mean that describes our belief at time \\(t-1\\) \\(\\sigma_{t-1}\\): previous covariance that describes our uncertainty at time \\(t-1\\) \\(z_t\\): the observation at time \\(t\\). \\(u_t\\): the control command at time \\(t\\). the algorithm is, as usual, divided into a prediction step and a correction step: in the prediction step we estimate our next belief, described by a gaussian \\(\\overline{bel}(x_t) \\sim \\mathcal{n}(\\overline{\\mu_t}, \\overline{\\sigma_t})\\). first we compute our new estimated mean \\(\\overline{\\mu}_t\\) by multiplying our transformation function \\(a_t\\) by the previous mean \\(\\mu_{t-1}\\) which tells us how the state evolves generally without any motion added to it (i.e. velocity, acceleration, etc). to add the motion we add \\(b_tu_{t}\\). then we update our uncertainty. the estimate of the new covariance is derived from how a gaussian changes through a linear transformation, thus we compute \\(a_t \\sigma_{t-1} a_t^t\\). we also add additional noise that the motion adds to the new belief by adding \\(r_t\\). the we apply the correction step: what we mainly do is computing the weighted sum between two distributions first we obtain the weighting factor \\(k_t\\), also known as the kalman gain. this equals a ratio between the prediction and the observation. here we use \\(c_t^t\\) to map our uncertainty from the state space to the observation space. on the denominator we map our uncertainty onto the observation space and we also add the measurement noise \\(q_t\\) then we divide the two terms to obtain a factor that tells us if we trust more the prediction or the correction. then we modify our estimated mean \\(\\overline{\\mu}_{t}\\) with a weighted correction: we compute the error between what we observed and what we predicted \\(z_t - c_t \\overline{\\mu}_t\\) (again \\(c\\) to map to the observation space). then we change the estimated state by this error pondered by \\(k\\). we also update our uncertainty assumptions we can apply the kalman filter as long as the two following assumptions hold: everything is gaussian the motion and observation model are linear however, what if this is not the case? extended kalman filter $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Robotics/OnlineTrainingMobileRobotics/BayesFilter/Bayes Filter.html",
    "title": "Bayes Filter",
    "body": " index search search back bayes filter state estimation recursive state estimation recursive bayes filter intuition derivation prediction and correction step implementation popular filters model examples state estimation state estimation means we want to estimate the state of the system based on sensor measurements and control commands. thus, given observations \\(z\\) and control commands \\(u\\), estimate the current state \\(x\\) at time \\(t\\): \\[ p(x_t|z_{1:t}, u_{1:t}) \\] recursive state estimation recursive state estimation means we want to update our belief based on the observation that comes in reusing the previous distribution that we had. therefore, using the previous definition of the current state, we would introduce recursion by computing \\(x_t\\) based on the current measurement \\(z_t\\), the current control command \\(u_t\\) and the previous state \\(x_{t-1}\\). the latter is in itself also defined recursively. recursive bayes filter intuition we start with no knowledge of the environment, so our state is described by a uniform distribution, indicating we could be located at any point in space. after receiving a measurement \\(z\\), we update our belief. in this case we have sensed a door, and we know there are three doors in our map. therefore the probability of obtaining the measurement \\(z\\) given we are in front of that door is larger than in the other possible positions. so if we combine our previous belief with this measurement's probability distribution, our belief becomes: now we move forward, so we also have to shift our belief forward. note, however, that our movement is not exact, there is also a level of uncertainty, so we describe it by using a distribution. hence, when combining our previous belief with the probability distribution for the motion our certainty about our state decreases, and our belief becomes: we receive yet another measurement \\(z\\), again we have that \\(p(z|x)\\) is larger on the locations where there is a door, because this measurement has sensed a door. so if we combine this probability distribution for this measurement with our previous state we increase our certainty about our current state. therefor, our belief becomes: derivation the belief at time \\(t\\) is given by: \\[ bel(x_t) = p(x_t | z_{1:t}, u_{1:t}) \\] that is, where am i at moment \\(t\\), given all previous observations \\(z_{1:t}\\) and control commands \\(u_{1:t}\\). we now apply bayes rule, to swap \\(x_t\\) and \\(z_t\\) on the conditional probability: \\[ = \\eta \\cdot p(z_t | x_t, z_{1:t-1}, u_{1:t}) \\cdot p(x_t|z_{1:t-1}, u_{1:t}) \\] where \\(\\eta\\) is a normalization constant. now, let's pay attention to \\(p(z_t | x_t, z_{1:t-1}, u_{1:t})\\). by the markov assumption we are going to assume that the current state \\(x_t\\) and the previous observations and control commands are conditionally independent. that is, they do not give any information about the likelihood of the observation \\(z_t\\). thus, we drop them from the equation: \\[ = \\eta \\cdot p(z_t | x_t) \\cdot p(x_t|z_{1:t-1}, u_{1:t}) \\] for \\(p(x_t|z_{1:t-1}, u_{1:t})\\) we are going to use the law of total probability to add a new variable, so we integrate over this new variable. more concretely to add \\(x_{t-1}\\), which will allow us to introduce recursion to our expression: \\[ = \\eta \\cdot p(z_t | x_t) \\cdot \\int p(x_t | x_{t-1}, z_{1:t-1}, u_{1:t}) \\cdot p(x_{t-1}|z_{1:t-1},u_{1:t}) dx_{t-1} \\] we could interpret this rewritten expression as: for each previous state \\(x_{t-1}\\) we multiply \\(p(x_t | x_{t-1}, z_{1:t-1}, u_{1:t})\\), the probability of being in the new state \\(x_t\\) given the previous state \\(x_{t-1}\\), observations \\(z_{1:t-1}\\) and control commands \\(u_{1:t}\\) by \\(p(x_{t-1}|z_{1:t-1},u_{1:t})\\), the probability of being in the state \\(x_{t-1}\\) given the previous observations \\(z_{1:t-1}\\) and control commands \\(u_{1:t}\\) once again we apply the markov assumption over \\(p(x_t | x_{t-1}, z_{1:t-1}, u_{1:t})\\), because knowing where i am at moment \\(t-1\\), we assume the observations \\(z_{1:t-1}\\) do not add any information. however note the control command does indeed hold valuable information, as it tells us action last executed that moved us from \\(x_{t-1}\\) to \\(x_t\\). so we simplify the expression as follows: \\[ = \\eta \\cdot p(z_t | x_t) \\cdot \\int p(x_t | x_{t-1}, u_{1:t}) \\cdot p(x_{t-1}|z_{1:t-1},u_{1:t}) dx_{t-1} \\] we now suppose that knowing what action or command is executed in the future does not tell us anything about the present. hence we ignore the latest control command \\(u_t\\), so the expression becomes: \\[ = \\eta \\cdot p(z_t | x_t) \\cdot \\int p(x_t | x_{t-1}, u_{1:t}) \\cdot p(x_{t-1}|z_{1:t-1},u_{1:t-1}) dx_{t-1} \\] note that we have finally derived a recursive expression for our belief, given: \\[ bel(x_{t-1}) = p(x_{t-1}|z_{1:t-1}, u_{1:t-1}) \\] we substitute this expression in the belief at time \\(t\\): \\[ = \\eta \\cdot p(z_t | x_t) \\cdot \\int p(x_t | x_{t-1}, u_{1:t}) \\cdot bel(x_{t-1}) dx_{t-1} \\] prediction and correction step usually the bayes filter is broken up into: prediction step: estimates where the future state is based on the control command at time \\(t\\) and makes use of the motion model. motion model: \\(p(x_t | x_{t-1}, u_{1:t})\\) \\[ \\hat{bel}(x_t) = \\int p(x_t | x_{t-1}, u_{1:t}) \\cdot bel(x_{t-1}) dx_{t-1} \\] correction step: we get an observation that we use to correct potential mistakes we make in the prediction step. this correction is made using the observation or measurement model. observation model: \\(p(z_t | x_t)\\) \\[ bel(x_t) = \\eta \\cdot p(z_t | x_t) \\cdot \\hat{bel}(x_t) \\] implementation in order to implement a bayes filter we need to define certain things: specify the motion model specify the observation model specify the belief how do we move from one state to the next (i.e. linear model, non-linear model) popular filters kalman filters and efk use gaussians to represent the belief, motion model and observation model they use linear or linearized models particle filter the can use arbitrary models to represent state, motion model and observation model model examples motion model given a current state \\(x_t\\), the motion model could look like: in the first case, let's suppose a point represents the next state \\(x_{t+1}\\) after the control command is applied. if we execute our system \\(n\\) times, we get \\(n\\) estimations that are illustrated by the \\(n\\) points in the graph. they represent an approximation of the distribution that describes our predicted state (illustrated by the graph in the upper left corner). this distribution is our motion model at time \\(t+1\\). for the two middle graphs, we can deduce that our system is certain about the angle of motion, however it shows more uncertainty about the distance. finally in the last two graphs we see the opposite. the system knows how much we moved, that is the distance, but is uncertain about the angle of movement. measurement model suppose we have a sensor that tell us the distance between us and the closest obstacle in front of us. we know that this sensor is noisy, so to mimic that noise we can describe the measurement model as a normal distribution. in the previous image, the star represents the closest obstacle, and we use the gaussian distribution to describe how likely it is of obtaining a given measurement. observe that the further we move away from the actual obstacle the lower is the probability of that measurement taking place. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Robotics/OnlineTrainingMobileRobotics/ParticleFilter/Particle Filter.html",
    "title": "Particle Filter",
    "body": " index search search back particle filter intro particle set particle generation gaussian sampling importance sampling principle characteristics algorithm summary monte carlo localization structure particle filter algorithm for localization example resampling techniques roulette wheel low variance resampling algorithm intro with particle filters we are not restricting ourselves with parametric probability distributions like we do for example with kalman filters where we use gaussian distributions. as usual, we suppose we are given a map, and instead of using one parametric from we use non-parametric samples as a hypothesis of where the system might be. so, we are going to leave behind gaussian distributions to describe the estimate: and we are going to model our estimate using an arbitrary distribution: it turns out that we can describe this kind of distribution using samples: as you can see, the amount of samples in the areas where the density of the probability distribution is higher is also higher and vice versa. basically we have samples distributed over a state space, so imagine each sample signifies a little bit of probability mass, so we only need to count how many samples fall into a certain region to asses the probability that the system is in that region. also, we can weight our samples, so the larger the weight the larger the probability mass associated with that sample (taking into account that the sum of the weight have to amount to one). the weighting of the samples allows us to use less samples to represent the same probability distribution: note that by using samples we are computing an approximation of the probability function. and we use this weighted samples to estimate our belief. some examples are: we use the particles to approximate the probability function, where the more particles fall into a region, the higher the probability of the region. particle set we represent the sample set or particle set as follows: \\[ \\mathcal{x} = \\{\\langle x^{[j]}, w^{[j]}\\rangle\\}_{j=1\\cdots j} \\] where: there are \\(j\\) samples \\(x^{[j]}\\) represents the hypothesis (i.e. the state of the system) \\(w^{[j]}\\) represents the normalized weight assigned to jth particle the sum or integration over the particles represent the posterior (i.e. the probability function): \\[ p(x) = \\sum_{j=1}^j w^{[j]} \\delta_{x^{[j]}} (x) \\] where \\(\\delta\\) is the dirac function. note that \\(\\int \\delta(x) dx = 1\\) particle generation gaussian sampling note that closed form sampling is only possible for a few distributions, for example: for a gaussian distribution to obtain an approximation from sampling, we would sample by summing \\(12\\) times a random (uniformly drawn) number \\(x \\in [-\\sigma, \\sigma]\\), where \\(\\sigma\\) represents the standard deviation, and divide the sum by \\(\\frac{1}{2}\\). then you would draw samples that are approximately close to a gaussian distribution. importance sampling principle but, how can we approximate for another probability distribution functions? it turns out we can do this by sampling from a different probability function that the actual probability function and then compensating for the mistakes that we have done by drawing from this \"mistaken\" probability function. to do this we apply the importance sampling principle which tells us: we can use a different distribution (proposal distribution) \\(\\pi\\) to generate samples from the target (real) distribution \\(f\\). we need to account for the differences between \\(\\pi\\) and \\(f\\) using a weight, given by \\(\\omega = \\frac{f(x)}{\\pi{x}}\\) we need to assert the following pre-condition: \\(f(x) > 0 \\rightarrow \\pi(x) > 0\\) you can see that the weights are larger where the difference between the proposal and the target function is bigger. observe on the right side of the graph that we have drawn a low number of samples because our proposal probability function tells us the us the density on that region is low. however the target function shows a high probability in that same region, so by computing the difference between the proposal and the target function we assign bigger weights to those few particles. characteristics it is a recursive bayes filter uses a non-parametric approach models the distribution using samples and so the model need not be linear. the prediction step consists of drawing samples from the proposal function (takes the motion into account) the correction step consists of weighting the samples by the ration between the target function and the proposal function (takes the observation into account) the more particles we use to approximate the probability function the better the estimate is. algorithm the algorithm is composed of the following three steps: (prediction step) sample the particles using the proposal distribution (this signifies: where could my system be?). because we can choose the proposal function, what we do in this step is sampling from the motion model: \\[ x_t^{[j]} \\sim proposal(x_t|\\cdots) \\] (correction step) compute the importance weights to compensate from the mistakes made by sampling from the proposal distribution. if we derive the following expression, we obtain that the weights are given by the observation model: \\[ w_t^{[j]} = \\frac{target(x_t^{j})}{proposal(x_t^{j})} \\] resampling: draw with replacement \\(j\\) samples \\(i\\) with probability \\(w_t^{[i]}\\). so now we have a resampled set of samples where we update the weights by dividing the by \\(1/j\\) so they are normalized. what we do is generate a new set of samples where we replace the weight by the frequency. we do this because we work with a finite number of samples, so it could be the case that some particles have a very low probability and thus contribute very little to approximating the probability function. so it is better to eliminate those samples and replace them with a sample that is located in an area with high probability. we start with a empty sample set for the prediction step \\(\\hat{\\mathcal{x}}_t\\) and for the correction step \\(\\mathcal{x}_t\\). (prediction step) for \\(j=1\\cdots j\\): sample particle \\(x^{[j]}_t\\) from the proposal distribution \\(\\pi(x_t)\\), this distribution can be defined by the user, and corresponds to the belief at time \\(t-1\\) and constrained to the control command at time \\(t\\), \\(u_t\\). compute the weight by obtaining the difference between the proposal distribution and the target distribution. this results in using the observation model save the pair \\(x_t^{[j]}\\), \\(w_t^{[j]}\\) to the prediction sample set \\(\\hat{\\mathcal{x}}_t\\). (correction step) for \\(j=1\\cdots j\\): draw a particle \\(x_t^{[j]}\\) with replacement from the prediction sample set with probability proportional to the weight of the sample \\(w_t^{[j]}\\). add the particle to the correction sample set \\(\\mathcal{x}_t\\) return the resampled sample set \\(\\mathcal{x}_t\\) summary what the particle filter does is: it takes each particle as a pose hypothesis that says \"this is where the system is at time \\(t\\)\". then it adds weight to each particle signifying how much that pose hypothesis conforms to the given observation, and tells us how likely the hypothesis is. if we do this with \\(n\\) particles what we obtain is a belief, that is, a set of possibilities of where we are which describe my probability distribution. monte carlo localization monte carlo localization refers to the estimation the location and orientation of the system using a particle filter. for example: with a particle filter, our belief shows where the robot is located by having a bigger density of particles right under where the robot is. another example is the following, where we start with all the particles scattered over the map that means the particles are sampled from a uniform distribution so every point in space is equally likely to be the location of the robot. once the robot drives around and obtains new measurements the probability mass concentrates on places where the robot is more likely to be in given the motion commands and the observations. eventually the system converges and you end up with a unimodal distribution that is similar to a gaussian distribution. structure each particle represents a pose hypothesis we represent the proposal probability function by drawing from the motion model. because we are sampling from the motion distribution what we do is increasing the uncertainty about the motion at time \\(t\\) and thus account for the noise present in each motion. \\[ x_t^{[j]} \\sim p(x_t|x_{t-1}, u_t) \\] we apply the correction via the observation model. so the weight of each particle is proportional to the likelihood of an observation \\(z_t\\) given i know where i am \\(x_t\\) and the map of the environment \\(m\\). this result is dependent of the choice made previously of sampling from the motion model. \\[ w_t^{[j]} = \\frac{target}{proposal} \\propto p(z_t|x_t,m) \\] particle filter algorithm for localization we modify slightly our particle filter algorithm to use it for localization: we sample from the motion model \\(p(x_t|u_t, x^{[j]}_{t-1})\\) instead from the generic proposal function \\(\\pi(x_t)\\) we compute the weights with \\(w_t^{[j]} = \\frac{target}{proposal} \\propto p(z_t|x_t,m)\\). example first we start with a uniform distribution, and we sample from that distribution, obtaining \\(j\\) particles distributed over the space with the same probability. then we obtain an observation, and in the weighting step we increase the weight of the samples with are more likely given the observation. in this case the samples in front of doors, while the rest of the particles get a lower weight. then we apply resampling to replace weight by frequencies (the probability mass of a particle is bigger if this particle has been resampled several times, which means it weight was bigger than the rest of the samples). in the following picture the resampling step is executed along with the motion step (so the probability function is offsetted): because the prediction/motion was already performed before, now we obtain another observation: when we obtain the weights, two things happen. first, and as before, the particles (pose hypothesis) more likely to be correct given the observation obtain a larger weight. second, because the is a bigger number of particles in front of the second door the density in this area is bigger than in the areas in front of the other doors. another resampling and prediction step: resampling techniques roulette wheel first we create a roulette wheel where each field represents a particle, and the bigger the weight associated with that particle the bigger the field is: the idea is that, we normalize the weights, and each time we draw a number between zero and one, which will \"point\" to a weight. however this method can lead to suboptimal solutions. suppose that for some reason each time we end up with uniform weight, so that no particle is more likely than any other. then, with the wheel roulette we will duplicate some particles and remove some others. however this does not make sense, because every particle had the same weight. thus we introduce the lower variance resampling. low variance resampling here, the idea is using \\(j\\) arrows instead of only one, where the arrows are at the same angular distance from each other. so in order to sample what we do is, we simply turn the arrows, and where all the arrows end up, that is the samples we choose. this solution is faster, with time complexity equal to \\(o(j)\\) compared to the wheel roulette's \\(o(j \\log j)\\), and resolves the suboptimal solution problem presented earlier. algorithm first we draw a random number between \\(0\\) and \\(\\frac{1}{j}\\) then we pick \\(j-1\\) particles by advancing in the array in steps of \\(\\frac{1}{j}\\) to efficiently implement this what we do is, in each element of the array we store the cummulative weight up until that point: so, we draw a random number between \\(0\\) and \\(\\frac{1}{j}\\), if that number is bigger than the weight accumulated up until weight \\(i\\), then we move to the next one, else if it is less we sample the particle \\(i\\). and then we advance \\(\\frac{1}{j}\\). $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/SVM/Optimal Margin Classifier.html",
    "title": "Optimal Margin Classifier",
    "body": " index search search back optimal margin classifier we use this classifier to categorize datasets that are perfectly separable, that is to say, we use it over data that is linearly separable. this classifier will help us find the green line we saw in the geometric margin. what the optimal margin classifier does is choose the parameters \\(w, b\\) that maximize \\(\\gamma\\) one way to solve this optimization problem is: \\begin{align} \\underset{\\gamma, w, b}{\\max} \\gamma \\end{align} subject to \\begin{align} \\frac{y^{(i)}(w^tx + b)}{||w||} \\geq \\gamma \\end{align} this will cause the maximization of the geometric margin with respect to the training set. the restriction means that we want to maximize \\(\\gamma\\) while having every example have a geometric margin of at least \\(\\gamma\\). because this is a non-convex problem, we will transform it. given \\(\\gamma = \\frac{\\hat{\\gamma}}{||w||}\\), then \\(\\gamma \\cdot ||w|| = \\hat{\\gamma}\\), and so if we multiply in the subject both sides by \\(||w||\\): \\begin{align} \\frac{y^{(i)}(w^tx + b)}{||w||} \\cdot ||w|| \\geq \\gamma \\cdot ||w|| \\leftrightarrow y^{(i)}(w^tx + b) \\geq \\hat{\\gamma} \\end{align} and the optimization problem can be re-written as: \\begin{align} \\underset{\\hat{\\gamma}, w, b}{\\max} \\frac{\\hat{\\gamma}}{||w||} \\end{align} subject to \\begin{align} y^{(i)}(w^tx + b) \\geq \\hat{\\gamma} \\end{align} however, we are still stuck with a non-convex objective \\(\\frac{\\hat{\\gamma}}{||w||}\\). because, as we've said previously scaling the functional margin (changing the magnitude of \\(w^tx + b\\)) does not change the decision boundary itself, we will add an scaling constraint that the functional margin of \\(w, b\\) with respect to the training set must be 1: \\(\\hat{\\gamma} = 1\\) observe, now, that maximizing \\(\\frac{\\hat{\\gamma}}{||w||} = \\frac{1}{||w||}\\) is like minimizing \\(||w||^2\\), we re-write the optimization problem as follows: \\begin{align} \\underset{w, b}{\\min} ||w||^2 \\end{align} subject to \\begin{align} y^{(i)}(w^tx + b) \\geq 1 \\end{align} we will revise once more the optimization problem for the optimal margin classifier. first, we have to suppose two facts: by the representer theorem we can assume that \\(w\\) can be expressed as a linear combination of \\(x\\), that is: \\begin{align} w = \\sum_{i=1}^m \\alpha_i x^{(i)} \\end{align} let's review this claim with logistic regression. we know that we apply stochastic gradient descent (we update \\(\\theta\\) for every example, instead of summing all the examples) on \\(\\theta\\) as follows: \\begin{align} \\theta = \\theta - \\alpha (h_\\theta(x^{(i)}) - y^{(i)})x^{(i)} \\end{align} which means that in every interation we are updating \\(\\theta\\) by adding or substracting a factor \\(\\alpha_i\\) multiplied by \\(x^{(i)}\\). therefore we can show by mathematical induction that if we start with \\(\\theta_0 = c\\), where \\(c\\) is a constant and go on adding and substracting \\(ax^{(i)}\\), where \\(a= \\alpha (h_\\theta(x^{(i)}) - y^{(i)})\\), then \\(w\\) can be expressed as a linear combination of \\(x\\). you can also derive the gradient descent expression in our optimization problem, and show that in this case \\(w\\) is also a linear combination of \\(x\\). we can rewrite \\(w\\) as follows: \\begin{align} w = \\sum_{i=1}^m \\alpha_i y^{(i)} x^{(i)} \\end{align} given any decision boundary, the vector \\(w\\) is always orthogonal to the decision boundary: now, the optimization problem becomes (note \\(w^2 = w^tw\\)): \\begin{align} \\underset{w, b}{min} \\frac{1}{2}||w||^2 = \\underset{w, b}{min} \\frac{1}{2} (\\sum_{i=1}^m \\alpha_i y^{(i)} x^{(i)})^t(\\sum_{j=1}^m \\alpha_j y^{(j)} x^{(j)}) = \\end{align} \\begin{align} \\underset{w, b}{min} \\frac{1}{2} \\sum_{i=1}^m\\sum_{j=1}^m \\alpha_i \\alpha_j y^{(i)}y^{(j)}(x^{(i)})^tx^{(j)} \\end{align} we now denote the inner product of \\((x^{(i)})^t x^{(j)}\\) as \\(\\langle x^{(i)}, x^{(j)} \\rangle\\), so: \\begin{align} \\underset{w, b}{min} \\frac{1}{2} \\sum_{i=1}^m\\sum_{j=1}^m \\alpha_i \\alpha_j y^{(i)}y^{(j)} \\langle x^{(i)}, x^{(j)} \\rangle \\end{align} and the restriction of the optimization becomes: \\begin{align} y^{(i)}(w^tx^{(i)} + b) \\geq 1 \\rightarrow y^{(i)}((\\sum_{j=1}^m \\alpha_j y^{(j)}x^{(j)})^tx^{(i)} + b) \\geq 1 \\rightarrow \\end{align} \\begin{align} y^{(i)}((\\sum_{j=1}^m \\alpha_j y^{(j)}(x^{(j)})^tx^{(i)}) + b) \\geq 1 \\rightarrow y^{(i)}((\\sum_{j=1}^m \\alpha_j y^{(j)} \\langle x^{(j)}, x^{(i)} \\rangle) + b) \\geq 1 \\end{align} applying convex optimization theory you can simplify this optimization problem further to: \\begin{align} \\underset{\\alpha}{max} \\sum_{i=1}^m \\alpha_i - \\frac{1}{2} \\sum_{i=1}^m\\sum_{j=1}^m y^{(i)}y^{(j)}\\alpha_i\\alpha_j\\langle x^{(i)}, x^{(j)}\\rangle \\end{align} subject to \\begin{align} \\alpha_i \\geq 0 \\end{align} \\begin{align} \\sum_{i=1} y^{(i)}\\alpha_i = 0, i=1, \\cdots,m \\end{align} train the classifier to train the svm we have to solve the optimization problem for \\(\\alpha\\) classify an example to predict an example \\(x\\): \\begin{align} h_{w,b} = g(w^tx + b) = g\\left(\\left(\\sum_{i=1}^m \\alpha_i y^{(i)}x^{(i)}\\right)^tx + b\\right) = g\\left(\\left(\\sum_{i=1}^m \\alpha_i y^{(i)} \\langle x^{(i)}, x^{(j)} \\rangle\\right) + b\\right) \\end{align} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/SVM/Functional Margin.html",
    "title": "Functional Margin",
    "body": " index search search back functional margin intuition the functional margin describes how accurately do we classify an example. for example, for binary classification, given an example x: \\begin{align} h_\\theta(x) = g(\\theta x) = \\begin{cases} \\text{ predict } 1 & \\text{ if } \\theta^t x \\geq 0, \\text{ that is } h_\\theta(x)=g(\\theta x) \\geq 0.5\\\\ \\text{ predict } 0 & \\text{ otherwise } \\\\ \\end{cases} \\end{align} let's distinguish between the two cases when classifying an example \\(x^{(i)}\\): (1) if \\(y^{(i)} = 1\\), then we want \\(h_\\theta(x) = g(\\theta x) \\approx 1\\), which means we want \\(\\theta \\cdot x >> 0\\). (2) if \\(y^{(i)} = 0\\), then we want \\(h_\\theta(x) = g(\\theta x) \\approx 0\\), which means we want \\(\\theta \\cdot x << 0\\). as we can see in the following graph, the bigger \\(z = \\theta x\\) the closer \\(g(z)\\) is to one and vice versa. formal definition the functional margin of the hyperplane defined by \\((w, b)\\) with respect to the example \\((x^{(i)}, y^{(i)})\\) is defined as: \\begin{align} \\hat{\\gamma}^{(i)} = y^{(i)}(w^tx^{(i)}+b) \\end{align} so, if we modify slightly the two statements above and use the new notation for svms: if \\(y^{(i)} = 1\\), then we want \\(w^t \\cdot x + b >> 0\\). if \\(y^{(i)} = 0\\), then we want \\(w^t \\cdot x + b << 0\\). the combination of these two declarations yields the definition of the functional margin. why?, well: when \\(y^{(i)}\\) is positive, we want to have \\(w^tx^{(i)} + b >> 0\\) by (1), so \\(\\hat{\\gamma}^{(i)}\\) will be large, because both values are positive when \\(y^{(i)}\\) is negative, we want to have \\(w^tx^{(i)} + b << 0\\) by (2), so \\(\\hat{\\gamma}^{(i)}\\) will be large, because both values are negative so, given an example \\(x^{(i)}\\), if \\(\\hat{\\gamma}^{(i)} > 0\\) that means either \\(y^{(i)} = 1\\) and \\(w^tx + b > 0\\) or \\(y^{(i)} = -1\\) and \\(w^tx + b < 0\\) which shows that the classification is correct. evaluation to evaluate the functional margin with respect to the training set we make use of the worst case notion: \\begin{align} \\hat{\\gamma} = \\underset{i}{\\min} \\hat{\\gamma}^{(i)} \\end{align} that is, we evaluate how well we are doing in the worst example. normalizing the functional margin note that the functional margin is very easy to cheat (to increase its value with any meaningful change to the decision boundary). given our definition for \\(g\\): \\begin{align} g = \\begin{cases} 1, & \\text{ if } z \\geq 0 \\\\ -1, & \\text{ otherwise } \\end{cases} \\end{align} it follows that \\(h_{w,b}(x^{(i)}) = g(2w^tx^{(i)} + 2b) = g(w^tx^{(i)} + b)\\), because what matters is the sign, not the magnitude. however, if you scale \\(w\\) and \\(b\\) by a factor of \\(n\\) where \\(n\\) is a positive number then \\(\\gamma \\) increases because: \\begin{align} \\hat{\\gamma}^{(i)} = (w^tx + b) \\end{align} so, \\begin{align} n \\cdot \\hat{\\gamma}^{(i)} = n \\cdot (w^tx + b) \\end{align} where, \\begin{align} \\hat{\\gamma}^{(i)} < n \\cdot \\hat{\\gamma}^{(i)} \\end{align} one way to avoid this is to normalize the length of the parameters, that is either: add a constraint where \\(||w|| = 1\\) or set \\((w, b)\\) to be \\((\\frac{w}{||w||}, \\frac{b}{||b||})\\) in both cases we are re-scaling the parameters. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/SVM/Geometric Margin.html",
    "title": "Geometric Margin",
    "body": " index search search back geometric margin intuition first of all, let's assume we have a dataset that is linearly separable like: here we have two examples of two decision boundaries that do classify correctly all of the samples. however the red one looks worse than the green one. that is because for the red one there are some examples that are very close to the boundary compared to the rest. whereas for the green one there is a bigger separation. so, first we define a line by the equation \\(w^tx + b = 0\\), therefore: every example \\(x\\) that lies to the left of the line satisfies \\(w^tx + b < 0\\) and every example \\(x\\) that lies to the right of the line satisfies \\(w^tx + b > 0\\) furthermore the geometric margin with respect to a single example \\((x^{(i)}, y^{(i)})\\) is the euclidean distance between the point \\((x^{(i)}, y^{(i)})\\) and the line we have defined as \\(w^tx + b = 0\\). euclidean distance to the decision boundary the decision boundary corresponding to (w, b) is shown, along with the vector w. note that w is orthogonal (at 90º) to the separating hyperplane. consider the point at \\(a\\), which represents the example \\(x^{(i)}\\) with \\(y^{(i)} = 1\\). its distance to the decision boundary, denoted by \\(\\gamma^{(i)}\\), is given by the line segment \\(ab\\). how do we find \\(\\gamma^{(i)}\\): we know \\(\\frac{w}{||w||}\\) is a unit length vector pointing to the same direction as \\(w\\). also \\(a = x^{(i)}\\) we also know that the vector between points \\(a\\) and \\(b\\) is defined like \\(a - b\\), in this scenario, \\(a - b = \\gamma^{(i)}\\frac{w}{||w||}\\), where \\(\\gamma^{(i)}\\) is the length of the vector and \\(\\frac{w}{||w||}\\) is the direction of the vector. thus if we solve for \\(b\\), \\(b = x^{(i)} - \\gamma^{(i)}\\frac{w}{||w||}\\) furthermore, \\(b\\) lies on the decision boundary, therefore: \\begin{align} w^t(b) + b = 0 \\rightarrow w^t\\left(x^{(i)} - \\gamma^{(i)}\\frac{w}{||w||}\\right) + b = 0 \\end{align} solving for \\(y^{(i)}\\) yields: \\begin{align} \\gamma^{(i)} = \\frac{w^tx^{(i)} + b}{||w||} = \\left(\\frac{w}{||w||}\\right)^tx(i) + \\frac{b}{||w||} \\end{align} formal definition the geometric margin of the hyperplane \\((w, b)\\) with respect to \\((x^{(i)}, y^{(i)})\\) is defined as: \\begin{align} \\gamma^{(i)} = \\frac{w^t x^{(i)} + b}{||w||} \\end{align} this is the definition for a positive example (\\(y^{(i)} = 1\\)), and measures the euclidean distance from the decision boundary to the example \\((x^{(i)}, y^{(i)})\\). if we generalize, as to compute the geometric margin for both positive and negative examples: \\begin{align} \\gamma^{(i)} = \\frac{y^{(i)} (w^t x^{(i)} + b)}{||w||} \\end{align} evaluation to evaluate the geometric margin with respect to the training set we make use of the worst case notion: \\begin{align} \\gamma = \\underset{i}{\\min} \\gamma^{(i)} \\end{align} that is, we evaluate how well we are doing in the worst example. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/SVM/SVM.html",
    "title": "SVM",
    "body": " index search search back svm notation functional margin geometric margin functional and geometric margin optimal margin classifier svm kernels the kernel trick applying kernels validity of kernels generality of the kernel trick l1-norm soft margin svm outliers optimization kernel examples the support vector machine allows you to find potential non-linear decision boundaries: svm provides an algorithm that: maps a vector of features to a vector of features of a much higher dimension (manually picking the new features is difficult, that is why we automate it with these types of algorithms) \\begin{align} \\begin{bmatrix} x_1 \\\\ x_2 \\\\ \\end{bmatrix} \\rightarrow \\begin{bmatrix} x_1 \\\\ x_2 \\\\ x_1^2 \\\\ x_2^2 \\\\ x_1\\cdot x_2 \\\\ \\vdots \\end{bmatrix} \\end{align} applies a linear classifier over the high dimensional features (note: if you apply logistic regression to high dimensional vectors then it can learn non-linear decision boundaries) notation labels: \\(y^{(i)} \\in \\{-1, +1\\}\\) now the hypothesis outputs a \\(1\\) or a \\(-1\\), which means: \\begin{align} g(z) = \\begin{cases} 1, & \\text{ if } z \\geq 0 \\\\ 0, & \\text{ otherwise } \\\\ \\end{cases} \\end{align} that is, now instead of a smooth transition of probabilities from zero to one, we have a hard transition between \\(1\\) and \\(-1\\). weights: now the weights \\(\\theta \\in \\mathbb{r}^{(n+1)}\\), where \\(\\theta_0 = 1\\) are divided into: \\(w \\in \\mathbb{r}^{(n)}\\) and \\(b \\in \\mathbb{r}\\). thus we drop the convention of assigning \\(x_0 = 1\\). also now the hypothesis function is defined as: \\(h_{w,b}(x) = g(w^tx + b) = g((\\sum_{i=1}^n w_i x) + b)\\) functional margin functional margin geometric margin geometric margin relationship between functional margin and geometric margin as you may have picked up we can stablish an equality between both margins: \\begin{align} \\gamma^{(i)} = \\frac{\\hat{\\gamma}^{(i)}}{||w||} \\end{align} optimal margin classifier optimal margin classifier svm kernels kernel trick to apply kernels first we will lay out the kernel trick: write the algorithm in terms of the inner products of the training examples \\(\\langle x^{(i)}, x^{(j)} \\rangle=(\\langle x, z \\rangle)\\) let there be a mapping \\(x \\rightarrow \\phi(x)\\), where \\(\\phi(x)\\) is a high dimensional feature vector. find a way to compute \\(k(x, z) = \\phi(x)^t\\phi(z)\\), even if \\(x, z\\) are very high dimensional features vectors (which would be very computationally expensive). where \\(k(x, z)\\) is denoted as the kernel function replace \\(\\langle x, z \\rangle\\) with \\(k(x, z)\\) applying kernels given \\(x, z \\in \\mathbb{r}^n\\), where: \\begin{align} x = \\begin{bmatrix} x_1 \\\\ \\vdots \\\\ x_n \\\\ \\end{bmatrix} \\end{align} we define the mapping \\(\\phi(x) \\in \\mathbb{r}^{n^2}\\) as follows: \\begin{align} \\phi(x) = \\begin{bmatrix} x_ix_i \\\\ \\end{bmatrix} \\end{align} \\(\\forall i, j\\) with \\(1 \\leq i,j \\leq n\\) so we have \\begin{align} k(x, z) = \\phi(x)^t \\phi(z) = \\sum_{i=1}^{n^2} \\phi(x)_i \\phi(z)_i = \\sum_{i=1}^n \\sum_{j=1}^n (x_ix_j) (z_iz_j) \\end{align} which would take \\(o(n^2)\\) time to compute. but, observe that: \\begin{align} (x^tz)^2 = (x^tz)^t(x^tz) = \\sum_{i=1}^n\\sum_{j=1}^n (x_iz_i)(x_jz_j) = \\sum_{i=1}^n\\sum_{j=1}^n (x_ix_j)(z_iz_j) \\end{align} whick takes \\(o(n)\\) time to compute. so we conclude that the kernel can be defined as \\(k(x, z) = (x^tz)^n\\) given \\(x, z \\in \\mathbb{r}^n\\) \\(k(x, z) = (x^tz + c)^2\\) where the mapping function \\(\\phi\\) is defined as: given \\begin{align} x = \\begin{bmatrix} x_1 \\\\ x_2 \\\\ \\end{bmatrix} \\end{align} then: \\begin{align} \\phi(x) = \\begin{bmatrix} x_1x_1 \\\\ x_1x_2 \\\\ x_2x_1 \\\\ x_2x_2 \\\\ \\sqrt{2c}x_1 \\\\ \\sqrt{2c}x_2 \\\\ \\end{bmatrix} \\end{align} given \\(x, z \\in \\mathbb{r}^n\\) \\(k(x, z) = (x^tz+ c)^d\\) where \\(\\phi(x)\\) contains the \\(\\binom{n+d}{d}\\) combinations of monomials of degree d. (note: a monomial of degree 3 could be \\(x_1x_2x_3\\) or \\(x_1x_2^2\\), etc) validity of kernels to test is a kernel is valid we use mercer's theorem that says: k is a valid kernel function (i.e. \\(\\exists \\phi\\) such that \\(k(x, z) = \\phi(x)^t\\phi(z)\\)) if and only if for any \\(d\\) points \\(\\{x^{(1)}, \\cdots , x^{(d)}\\}\\) the corresponding kernel matrix \\(k\\) is positive semi-definite, that is \\(k \\geq 0\\) we are going to prove the first part of this theorem: given examples \\(\\{x^{(1)}, \\cdots , x^{(d)}\\}\\), let \\(k \\in \\mathbb{r}^{d\\times d}\\), be the kernel matrix, such that \\begin{align} k_{ij} = k(x^{(i)}, x^{(j)}) \\end{align} then, if \\(k\\) is a valid kernel: \\begin{align} z^tkz = \\sum_{i=1}^d \\sum_{j=1}^d z_i^t k_{ij} z_j = \\sum_{i=1}^d \\sum_{j=1}^d z_i^t \\phi(x^{(i)})^t \\phi(x^{(j)}) z_j = \\end{align} we expand \\(\\phi(x^{(i)})^t \\phi(x^{(j)})\\) as follows: \\begin{align} = \\sum_{i=1}^d \\sum_{j=1}^d z_i^t \\left[\\sum_{k=1}^d (\\phi(x^{(i)}))_k (\\phi(x^{(j)}))_k\\right] z_j = \\end{align} now, if we rearrange the sums: \\begin{align} = \\sum_{k=1}^d \\left[\\sum_{i=1}^d z_i (\\phi(x^{(i)}))_k\\right]^2 \\end{align} so, because the power of two of any real number is a positive number, and the sum of positive numbers is positive we derive: \\begin{align} \\sum_{k=1}^d \\left[\\sum_{i=1}^d z_i (\\phi(x^{(i)}))_k\\right]^2 \\geq 0 \\end{align} which means that \\(k \\geq 0\\), hence \\(k\\) is a positive, semi-definite matrix generality of the kernel trick the kernel trick can be applied to more algorithms, not only in svm. because, if you have any algorithm written in terms of \\(\\langle x^{(i)}, x^{(j)} \\rangle\\), you can apply the kernel trick to it. some of the algorithms that can be re-written like this are: lineal regression logistic regression gdm pca etc. l1-norm soft margin svm it may be the case where you map your data to a very high dimensional space, but it is still not linearly separable, or the decision boundary becomes too complex: in order to avoid this we will use a modification of the basic algorithm called l1-norm soft margin svm. with this new algorithm the optimization problem becomes \\begin{align} \\underset{w,b,\\xi_i}{min} \\frac{1}{2}||w||^2 + c \\sum_{i=1}^m \\xi_i \\end{align} subject to \\begin{align} y^{(i)}(w^tx^{(i)} + b) \\geq 1 - \\xi_i \\end{align} \\begin{align} \\xi_i \\geq 0, i = 1, \\cdots, m \\end{align} note that if \\(x^{(i)}\\) is classified correctly then \\(y^{(i)}(w^tx^{(i)} + b) \\geq 0\\) and therefore satisfies \\(y^{(i)}(w^tx^{(i)} + b) \\geq 1 - \\xi_i\\), because \\(\\xi_i \\geq 0\\) before the modification, the restriction forced the functional margin to be at least 1, however after the modification, because \\(\\xi_i\\) is positive we relax the restriction. also, we do not want \\(\\xi_i\\) to be too big, that is why it is added to the optimization objective as a cost. graphical representation with the addition of \\(\\xi_i\\) we are allowing some examples to have a functional margin less than 1, by setting \\(\\xi_i \\geq 0\\). for example look at the example \\(x^{(i)}\\) which has \\(\\xi_i = 0.5\\) outliers this relaxation on the restriction upong the geometric margin also avoids the following problem. if you have a lot of data that is linearly separable, but you have one outlier the optimal margin classifier allows for the decision boundary to be drastically changed because its optimization is based on the word performing example (which would be the outlier in this case). thus: however, the l1-norm soft margin svm allows for this example to be classified incorrectly of be close to the decision boundary without changing the boundary which makes it more robuts to outliers. optimization picking up the optimal margin classifier optimization problem, after applying the insight derived from the representer theorem, we have that the only addition needed to implement this algorithm is: \\begin{align} \\underset{\\alpha}{max} \\sum_{i=1}^m \\alpha_i - \\frac{1}{2} \\sum_{i=1}^m\\sum_{j=1}^m y^{(i)}y^{(j)}\\alpha_i\\alpha_j\\langle x^{(i)}, x^{(j)}\\rangle \\end{align} subject to \\begin{align} \\sum_{i=1} y^{(i)}\\alpha_i = 0 \\end{align} \\begin{align} 0 \\leq \\alpha_i \\leq c, i = 1, \\cdots , m \\end{align} the parameter \\(c\\) is a parameter your choose and it determines the level of strictness you want your model to have about some examples being misclassified. kernel examples the gaussian kernel: \\(k(x, z) = \\exp\\left(\\frac{||x-z||^2}{2\\sigma}\\right)\\) linear kernel: \\(k(x, z) = \\phi(x)^t\\phi(z)\\), where \\(\\phi(x) = x\\) polynomial kernel: \\(k(x, z) = (x^tz)^d\\) $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/Grandes Datasets.html",
    "title": "Grandes Datasets",
    "body": " index search search back grandes datasets cuando los conjuntos de datos son muy grandes los algoritmos son computacionalmente más caros: varianza elevada: se obtiene mejor rendimiento con más ejemplos. sesgo/bias elevado: se obtiene mejor rendimiento con más características. stochastic gradient descent el algoritmo de stochastic gradient descent es el siguiente: reordenar aleatoriamente el conjunto de datos para cada ejemplo \\(i\\) y cada característica \\(j\\): \\(\\theta_j = \\theta_j - \\alpha (h_\\theta(x^{(i)}) - y^{(i)})x^{(i)}_j\\) es decir, se ajusta \\(\\theta\\) para cada ejemplo, en lugar de hacer el cálculo sobre todo el conjunto de datos cada iteración es más rápida no converge como batch gradient descent, llega a una aproximación. mini batch gradient descent esta técnica lo que hace el utilizar \\(b\\) ejemplos para calcular el gradiente: para cada \\(b\\) ejemplos y cada característica \\(j\\): \\(\\theta_j = \\theta_j - \\alpha \\frac{1}{b}(h_\\theta(x^{(i)}) - y^{(i)})x^{(i)}_j\\) permite vectorización $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/Gradient Checking.html",
    "title": "Gradient Checking",
    "body": " index search search back gradient checking consiste en la estimación numérica de los gradientes, tal que: \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta} \\approx \\frac{j(\\theta - \\epsilon) - j(\\theta + \\epsilon)}{2 \\cdot \\epsilon} \\end{align} \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_j} \\approx \\frac{j(\\theta_0, ..., \\theta_j - \\epsilon, ..., \\theta_n) - j(\\theta_0, ..., \\theta_j + \\epsilon, ..., \\theta_n)}{2 \\cdot \\epsilon} \\end{align} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/Ceiling Analysis.html",
    "title": "Ceiling Analysis",
    "body": " index search search back ceiling analysis supongamos que tenemos un pipeline que conforma todo nuestro sistema de aprendizaje automático y está formado por: obtención de la imagen detección de texto segmentación de caracteres reconocimiento de caracteres lo que hacemos es determinar una o varias métricas de evaluación, por ejemplo nosotros utilizaremos la precisión. entonces, ahora creamos una tabla indicando el valor de métrica para cada parte del sistema así como para el sitema completo: componente precisión detección del texto 82% segmentación de caracteres 90% reconocimiento de caracteres 100% total 72% a partir de esta tabla podemos comprobar que mejorar la detección en el texto y la segmentación de caracteres mejora el rendimiento del modelo. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/NeuralNetworks/Anexo/Partes del algoritmo en python.html",
    "title": "Algoritmo",
    "body": " index search search back algoritmo dado un conjunto de entrenamiento \\(x\\), donde \\(x\\) es una matriz \\((n + 1) \\times m\\) con \\(m\\) ejemplos: propagación hacia adelante def feed_forward(self, theta=none, capa=none, test=false): if theta is none: # si no se introduce theta como argumento theta = self.theta # inicializar theta con el almacenado en el objeto if test: # si se indica utilizar x_test a = self.x_test n, m = self.x_test.shape # guardar dimensiones de test else: a = self.x # la primera entrada es x n, m = self.x.shape # guardar dimensiones de train if capa is not none: # si se ha indicado una capa if capa <= len(theta) and capa >= 0: # chequeamos que la capa esta dentro de los limites for i in range(capa): # recorremos las capas a = self.sigmoid(theta[i], a) # calculamos la salida de la capa a = np.concatenate((np.matrix(np.ones(m)), a)) # añadimos una fila de unos return a else: print(\"el número de capa no es válido\") # mensaje de error else: for elemento in theta: a = self.sigmoid(elemento, a) # calculamos la salida de la capa actual a = np.concatenate((np.matrix(np.ones(m)), a)) # añadimos una fila de unos h = a[1:, :] # eliminamos los 1 en la última capa return h calculo del coste en la última capa def calculo_coste(self, theta=none, unrolled=false): if theta is none: # si no se introduce theta como argumento theta = self.theta # inicializar theta con el almacenado en el objeto if unrolled: # si theta se ha flatten en un vector de una dimension theta = self._roll_theta(theta) # crear lista con matriz theta de capa capa h = self.feed_forward(theta) # obtener la salida para todos los ejemplo coste = -np.sum(np.diagonal(self.y_hot_enc.t.dot(np.log(h)) + (1 - self.y_hot_enc.t).dot(np.log(1 - h))))/self.m # calcular el error con la matriz codificada de y if self.reg: # si se ha indicado que se aplica regularizacion reg_parcial = 0 # inicializamos la variable temporal for elemento in theta: # para capa reg_parcial += np.sum(np.power(elemento[:, 1:], 2)) # no sumar el término independiente en cada nodo: primera fila reg_result = self.reg_par/(2*self.m)*(reg_parcial) # calcular la regularizacion coste = coste + reg_result return coste actualizar los pesos con propagación hacia atrás: def back_propagation(self, theta=none, unrolled=false, unroll=false): if theta is none: # si no se ha indicado ningun theta como argumento theta = self.theta # inicializar theta con el almacenado en el objeto if unrolled: theta = self._roll_theta(theta) # creamos una lista del array delta = [] # inicializamos las lista temporal que contendra el delta de cada nodo delta_sum = [] # inicializamos la lista temporal que contendra el sumatorio delta gradientes = [] # inicializamos la lista que contendrá los gradientes de cada capa h = self.feed_forward(theta=theta) # calculamos el valor del la salida para empezar a propagar hacia atras delta_next = h - self.y_hot_enc # calculamos el primer delta: el de la ultima capa delta.append(delta_next) # lo añadimos a la lista temporal indice = self.numero_capas - 1 # el indice indica hasta que capa calcular la salida for elemento in reversed(theta[1:]): # recorremos las capas de atras hacia adelante h = self.feed_forward(theta=theta, capa=indice) # calculamos la salida de la capa actual delta_aux = np.multiply(elemento.t.dot(delta_next), self.sigmoid_gradient(elemento, h)) # aplicamos la formula del gradiente delta_next = delta_aux[1:, :] # no cogemos el elemento independiente delta.append(delta_next) # lo añadimos a la lista de delta indice -= 1 # actualizamos el indice delta.reverse() # damos la vuelta a la lista for indice in range(len(delta)): h = self.feed_forward(theta=theta, capa=indice) # obtenemos la salida de cada capa delta_sum.append(delta[indice].dot(h.t)) # añadimos (delta * a) a la lista de delta_mayuscula -> sumatorio for indice in range(len(delta_sum)): gradiente = (1/self.m) * delta_sum[indice] # calculamos el grandiente: delta_mayuscula / m if self.reg: gradiente[1:, :] += (self.reg_par/self.m) * theta[indice][1:, :] # si se indica regularizacion aplicarla: no regularizan primer elemento gradientes.append(gradiente) # lo añadimos a la lista coste = self.calculo_coste(theta=theta) if unroll: # si se ha indicado que se quiere hacer flatten a un vector de una dimension return coste, self._unroll_theta(gradientes) else: return coste, gradientes $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/NeuralNetworks/Anexo/Ejemplo Cálculo Función de Coste.html",
    "title": "Ejemplo Cálculo Función de Coste",
    "body": " index search search back ejemplo cálculo función de coste utilizamos como ejemplo la figura de multiclasificación donde tenemos que \\(c=3\\), y la hipótesis tiene los valores: \\begin{align} h_\\theta(x_1) = \\begin{bmatrix} 0.02 \\\\ 0.1 \\\\ 0.88 \\\\ \\end{bmatrix} \\end{align} y la salida real para el ejemplo \\(x_1\\) tiene los valores: \\begin{align} y_1 = \\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\\\ \\end{bmatrix} \\end{align} entonces la función de coste se calcularía como (observa que esto es sólo para un ejemplo, por lo que obviamos el primer sumatorio): \\begin{align} j(\\theta) = - \\sum_{i=1}^c [y_{ij}\\cdot \\log(h_\\theta(x_j)_i)] + [(1-y_{ij})\\cdot \\log(1-(h_\\theta(x_j)_i))] \\end{align} \\begin{align} j(\\theta) = - \\{[(y_{11}\\cdot\\log(h_\\theta(x_1)_{1})) + (1-y_{11})\\cdot\\log(1-h_\\theta(x_1)_{1})] + \\end{align} \\begin{align} + [(y_{21}\\cdot\\log(h_\\theta(x_1)_{2})) + (1-y_{21})\\cdot\\log(1-h_\\theta(x_1)_{2})] + \\end{align} \\begin{align} + [(y_{31}\\cdot\\log(h_\\theta(x_1)_{3})) + (1-y_{31})\\cdot\\log(1-h_\\theta(x_1)_{3})]\\} \\end{align} sustituimos los valores de cada vector: \\begin{align} j(\\theta) = - \\{ [(0\\cdot\\log(0.02)) + (1-0)\\cdot\\log(1-0.02)] + \\end{align} \\begin{align} + [(0\\cdot\\log(0.1)) + (1-0)\\cdot\\log(1-0.1)] + \\end{align} \\begin{align} + [(1\\cdot\\log(0.88)) + (1-1)\\cdot\\log(1-0.88)] \\} = \\end{align} calculamos los valores: \\begin{align} j(\\theta) = - (\\log(0.98) + \\log(0.9) + \\log(0.88)) \\end{align} \\begin{align} j(\\theta) = - (-0.009 - 0.046 -0.056) = - (-0.111) = 0.111 \\end{align} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/NeuralNetworks/Anexo/Derivadas capas intermedias.html",
    "title": "Derivada capas intermedias",
    "body": " index search search back derivada capas intermedias donde \\(q\\) denota la capa, con \\(1 \\leq q \\leq (k-1)\\). pues lo que tenemos que hacer es, de nuevo, aplicar la regla de la cadena, entre el peso \\(\\theta_{it}^{(q)}\\) (peso \\(t\\) del nodo \\(i\\) de la capa \\(q\\)) y todo nodo \\(a_{lj}^{(q+1)}\\)(es decir para el nodo \\(l\\) en la capa \\(q+1\\) para el ejemplo \\(j\\)). \\[%align \\frac{\\delta j(\\theta)}{\\delta \\theta_{it}^{(q)}} = \\frac{j(\\theta)}{\\delta a^{(q+1)}_{1j}}\\frac{\\delta a_{1j}^{(q+1)}}{\\delta \\theta_{it}^{(q)}} + \\cdots + \\frac{j(\\theta)}{\\delta a^{(q+1)}_{(s_(q+1))j}}\\frac{\\delta a_{(s_(q+1))j}^{(q+1)}}{\\delta \\theta_{it}^{(q)}} \\] donde \\(s_{(q+1)}\\) es el número de nodos en la capa \\(q+1\\). para cada término \\(l\\) de la suma, debemos volver a aplicar la regla de la cadena, tal que: \\[%align \\frac{\\delta j(\\theta)}{\\delta \\theta_{it}^{(q)}} = \\frac{j(\\theta)}{\\delta a^{(q+1)}_{lj}}\\frac{\\delta a_{lj}^{(q+1)}}{\\delta a_{lj}^{(q)}}\\frac{\\delta a_{lj}^{(q)}}{\\delta \\theta_{it}^{(q)}} \\] es decir: \\[%align \\frac{\\delta j(\\theta)}{\\delta \\theta_{it}^{(q)}} = \\sum_{l=1}^{s_{(q+1)}} \\frac{j(\\theta)}{\\delta a^{(q+1)}_{lj}}\\frac{\\delta a_{lj}^{(q+1)}}{\\delta a_{lj}^{(q)}}\\frac{\\delta a_{lj}^{(q)}}{\\delta \\theta_{it}^{(q)}} \\] cabe destacar que \\(\\frac{\\delta a_{lj}^{(q)}}{\\delta \\theta_{it}^{(q)}} = \\frac{\\delta g(z_{lj}^{(q)})}{\\delta z_{lj}^{(q)}} \\frac{\\delta z_{lj}^{(q)}}{\\delta \\theta_{it}^{(q)}}\\) (explicado en derivada de la función del coste). entonces, si generalizamos para todos los ejemplos, \\(m\\): \\[%align \\frac{\\delta j(\\theta)}{\\delta \\theta_{it}^{(q)}} = \\sum_{j=1}^m\\sum_{l=1}^{s_{(q+1)}} \\frac{j(\\theta)}{\\delta a^{(q+1)}_{lj}}\\frac{\\delta a_{lj}^{(q+1)}}{\\delta a_{lj}^{(q)}}\\frac{\\delta a_{lj}^{(q)}}{\\delta \\theta_{it}^{(q)}} \\] $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/NeuralNetworks/Anexo/index.html",
    "title": "Anexo",
    "body": " index search search back anexo clasificación múltiple función de coste retropropagación algoritmo clasificación múltiple para crear una red neuronal que permita trabajar con \\(c\\) clases lo que hacemos es hacer que la red neuronal tenga \\(c\\) nodos en su capa de salida. esto se ilustra en la siguiente imagen: de tal manera que ahora, cada salida \\(y_j\\) será un vector columna \\(c\\times1\\), donde existe un valor por cada categoría, al igual que la hipótesis para el ejemplo \\(j\\), \\(h_\\theta(x_j)\\), es un vector columna \\(c\\times1\\). como podemos ver, los valores de \\(y_j\\) indican claramente a qué clase pertenece el ejemplo \\(j\\) (clase 3), mientras que la hipótesis \\(h_\\theta(x_j)\\) ofrece, para cada clase (columna) la probabilidad de que el ejemplo \\(j\\) pertenezca a esa clase. función de coste notación como ya hemos visto en función del número de clases la salida tendrá distinta forma: clasificación binaria: para cada ejemplo \\(j\\), \\(y_j \\in \\{0, 1\\}\\), \\(h_\\theta(x_j) \\in \\mathbb{r}\\) clasificación múltiple: para cada ejemplo \\(j\\), \\(y \\in \\mathbb{r}^c\\), \\(h_\\theta(x_j) \\in \\mathbb{r}^c\\), donde \\(c\\) es el número de clases sea \\(k\\) el número de capas y \\(s_i\\) el número de nodos en la capa \\(i\\). sea \\(y=(y_{ij})\\) una matriz \\(c\\times m\\), donde \\(m\\) es el número de ejemplos y cada \\(y_{j}\\) es el vector columna \\(c\\times1\\) de salida para el ejemplo \\(j\\). definimos la función de coste como sigue: \\begin{align} j(\\theta) = - \\frac{1}{m} \\left\\{ \\sum_{j=1}^m \\sum_{i=1}^c [y_{ij}\\cdot \\log(h_\\theta(x_j)_i)] + [(1-y_{ij})\\cdot \\log(1-(h_\\theta(x_j)_i))]\\right\\} \\end{align} el primer sumatorio que va de 1 a \\(m\\) se encarga de calcular el coste para cada ejemplo \\(j\\). mientras que el segundo sumatorio, que va de 1 a \\(c\\), se encarga de calcular el coste para cada nodo de salida. esta función se aplica sobre los \\(k\\) nodos en la capa de salida. ejemplo cálculo función de coste regularización definimos la función de coste introduciendo regularización como sigue: \\begin{align} j(\\theta) = - \\frac{1}{m} \\left\\{ \\sum_{j=1}^m \\sum_{i=1}^c [y_{ij}\\cdot \\log(h_\\theta(x_j)_i)] + [(1-y_{ij})\\cdot \\log(1-(h_\\theta(x_j)_i))]\\right\\} + \\frac{\\lambda}{2m} \\sum_{q=1}^k \\sum_{i=1}^{s_q}\\sum_{j=1}^{s_{q+1}} (\\theta_{ji}^{(q)})^2 \\end{align} antes de nada, recordar que \\(s_q\\) denota el número de nodos en la capa \\(q\\). entonces, el primer término de la función es igual que cuando no se aplicaba regularización. expliquemos el segundo término. la regularización, en este caso, consiste en sumar todos los pesos de la red neuronal, por lo tanto: por cada capa \\(q\\), con \\(1 \\leq q \\leq k\\), sumamos todos los elementos de la matriz de pesos \\(\\theta^{q}\\), que como sabemos tiene dimensiones \\(s_{q} \\times s_{q-1}\\) dada la matriz \\(\\theta^{(q)}\\) recorremos cada columna \\(i\\), con \\(1 \\leq i \\leq s_{q-1}\\) recorremos cada elemento \\(j\\) de la columna \\(i\\), con \\(1 \\leq j \\leq s_{q}\\) sumamos al total cada elemento de la matriz \\(\\theta^{(q)}_{ji}\\) una vez se han sumado todas las matrices de pesos obtenemos un escalar, que multiplicamos por \\(\\frac{\\lambda}{2m}\\) múltiple ejemplos la salida de cada capa \\(q\\) es una matriz \\(s_q \\times m\\), donde \\(s_q\\) denota el número de nodos en la capa \\(q\\) y \\(m\\) denota el número de ejemplos. como vimos en nuestras figuras, donde se presentaban los cálculos sólo para un ejemplo, en cada capa \\(q\\) podemos mapear la salida de los \\(s_q\\) nodos a un vector columna \\(s_q \\times 1\\). si generalizamos esto a \\(m\\) ejemplos tenemos que la salida de cada capa es una matriz \\(s_q \\times m\\). esto se ilustra en la siguiente imagen: retropropagación vamos, ahora a explicar cómo se aplica la retropropagación. lo primero que debemos tener en cuenta es que este proceso se basa en la misma idea de optimización que la regresión lineal y la regresión logística, es decir, lo que queremos hacer es minimizar el coste, \\(j(\\theta)\\) sea \\(c\\) el número de nodos en la última capa, \\(\\theta_{it}\\) el peso \\(t\\) del nodo \\(i\\) de la última capa \\(k\\), \\(a_{ij}^{(k)}\\) la salida del nodo \\(i\\) para el ejemplo \\(j\\) en la capa \\(k\\): calculamos el gradiente de la última capa \\(k\\) como: \\(\\frac{\\delta j(\\theta)}{\\delta \\theta_{it}^{(k)}} = \\frac{\\delta j(\\theta)}{\\delta a_{1j}^{(k)}}\\frac{\\delta a_{1j}^{(k)}}{\\delta \\theta_{it}^{(k)}}\\) calculamos el gradiente en capas intermedias utilizando la regla de la cadena como: \\(\\frac{\\delta j(\\theta)}{\\delta \\theta_{it}^{(q)}} = \\sum_{i=1}^{s_{(q+1)}} \\frac{\\delta j(\\theta)}{\\delta a_{ij}^{(q+1)}}\\frac{\\delta a_{ij}^{(q+1)}}{\\delta a_{ij}^{(q)}}\\frac{\\delta a_{ij}^{(q)}}{\\delta \\theta_{it}^{(q)}}\\) normalmente en las capas intermedias, \\(q\\), nos referimos al término \\(\\frac{\\delta j(\\theta)}{\\delta a_{ij}^{(q+1)}}\\) como \\(\\delta^{(q+1)}_{ij}\\). explicación de la retropropagación derivada de la función de coste a continuación explicamos cómo derivar la función de coste (paso 1). derivada de la función de coste capas intermedias veamos, ahora, cómo llevar a cabo el paso 2: ¿cómo calculamos el gradiente (o lo que contribuye el peso \\(it\\) en el error) para los pesos de las capas intermedias?, es decir, cómo calculamos: \\[%align \\frac{\\delta j(\\theta)}{\\delta \\theta_{it}^{(q)}} \\] derivadas capas intermedias ejemplo de retropropagación ejemplo de retropropagación algoritmo partes del algoritmo en python notación época: iteración en el entrenamiento pesos (\\(w_j^k, b_j^k\\)): se inicializan de forma aletoria (evitar simetría) y con valores bajos. criterios de finalización \\(j\\) o gradiente de \\(j\\) inferior a un umbral número máximo de épocas velocidad de apredizaje \\(\\mu\\) intermedia: evita lentitud en las oscilaciones caída en mínimos locales que pueden tener \\(j\\) elevado. es por ello que se ejecuta varias veces el entrenamiento y se selecciona aquel que obtenga mejor resultado. actualización de pesos patrón a patrón en lugar de tras computar el error sobre todo el dataset. puede evitar mínimos locales y converge antes. función de activación sigmoide para clasificación o linear para regresión pseudocódigo $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/NeuralNetworks/Anexo/Explicación de la retropropagación.html",
    "title": "Explicación de la retropropagación",
    "body": " index search search back explicación de la retropropagación descenso gradiente derivada del error gradiente capa de salida retropropagación del gradiente gradiente acumulado derivadas de las funciones de activación componentes: \\(w_j^k\\): peso de la neurona \\(j=1...i_k\\) en la capa \\(k=1...h\\) \\(a_{ij}^k=(w_j^k)^th_i^{k-1}+b_j^k\\): \\(i=1...n\\) (patrón), \\(k=1...h\\)(capa), \\(j=1...i_k\\) (neurona de la capa \\(k\\)). \\(h_i^{k-1}\\): salida de la capa \\(k-1\\) con \\(i_{k-1}\\) valores (uno por cada neurona \\(j=1...i_{k-1}\\) para cada patrón \\(x_i\\). \\(h_i^k\\): salida de la capa \\(k\\) para cada patrón \\(x_i\\): \\(h_{ij}=f(a_{ij}^k)\\) con \\(j=1...i_k\\) \\(y_{ij}\\): salida verdadera de la neurona de salida \\(j\\) y el patrón \\(x_i\\). descenso gradiente \\begin{align} \\delta w_j^k=-\\mu \\frac{\\delta j}{\\delta w_j^k} \\end{align} \\begin{align} \\delta b_j^k=-\\mu \\frac{\\delta j}{\\delta b_j^k} \\end{align} para \\(k=1...h\\). de tal forma que se actualizan los pesos \\(w_j^k\\) y el offset \\(b_j^k\\) de la capa \\(k\\) y de la neurona \\(j\\). tenemos que la capa de salida está compuesta de \\(i_h\\) neuronas que se recorren con el índice \\(j\\). accedemos a la salida verdadera del ejemplo \\(i\\) para la neurona \\(j\\) (\\(y_{ij}\\)) y restamos la salida predicha \\(h_{ij}^h\\) que hace referencia a la salida de la función de activación de la capa \\(h\\) para la neurona \\(j\\) y el ejemplo \\(i\\). la diferencia se eleva al cuadrado para obtener mse. también se puede vectorizar restando los vectores \\(y_i\\) y \\(h_i^h \\in \\mathbb{r}^j\\). de esta manera obtenemos el error para el patrón \\(x_i\\): \\(j_i\\). derivada del error aplicamos la regla de la cadena sobre \\(j_i\\), ya que este depende de \\(a_{ij}^k\\): \\begin{align} \\frac{\\delta j_i}{\\delta w_j^k}=\\frac{\\delta j_i}{\\delta a_{ij}^k}\\frac{\\delta a_{ij}^k}{\\delta w_j^k} \\end{align} \\begin{align} \\frac{\\delta j_i}{\\delta b_j^k}=\\frac{\\delta j_i}{\\delta a_{ij}^k}\\frac{\\delta a_{ij}^k}{\\delta b_j^k} \\end{align} definimos: \\begin{align} \\delta_{ij}^k \\equiv \\frac{\\delta j_i}{\\delta a_{ij}^k} \\end{align} este indica el gradiente de la capa siguiente, para evitar tener que calcularlo. \\begin{align} \\frac{\\delta a_{ij}^k}{\\delta w_j^k} = h_i^{k-1} \\end{align} \\begin{align} \\frac{\\delta a_{ij}^k}{\\delta b_j^k} = 1 \\end{align} debido a que el valor de \\(a_{ij}^k\\) es la combinación lineal de la entradas y los pesos, donde las entradas son las salidas de la capa anterior (\\(k-1\\)), es decir \\(h_i^{k-1}\\), de tal manera que: \\begin{align} a_{ij}^k = (w_j^k)^th_i^{k-1}+b_j^k \\end{align} por lo que la derivada en función de \\(w_j^k\\) se corresponde con \\(h_i^{k-1}\\) y la derivada en función de \\(b_j^k\\) es 1. gradiente si sustituimos \\(\\delta_{ij}^k \\equiv \\frac{\\delta j_i}{\\delta a_{ij}^k}\\) y \\(\\frac{\\delta a_{ij}^k}{\\delta w_j^k} = h_i^{k-1}\\) en \\(\\frac{\\delta j_i}{\\delta w_j^k}=\\frac{\\delta j_i}{\\delta a_{ij}^k}\\frac{\\delta a_{ij}^k}{\\delta w_j^k}\\) obtenemos: \\begin{align} \\delta w_j^k=-\\mu \\frac{\\delta j}{\\delta w_j^k} \\end{align} \\begin{align} \\delta w_j^k=-\\mu \\sum_{i=1}^n \\frac{\\delta j_i}{\\delta a_{ij}^k}\\frac{\\delta a_{ij}^k}{\\delta w_j^k} = -\\mu \\sum_{i=1}^n\\delta_{ij}^kh_i^{k-1} \\end{align} hacemos los mismo para el offset sustituyendo \\(\\delta_{ij}^k \\equiv \\frac{\\delta j_i}{\\delta a_{ij}^k}\\) y \\(\\frac{\\delta a_{ij}^k}{\\delta b_j^k} = 1\\) en \\(\\frac{\\delta j_i}{\\delta b_j^k}=\\frac{\\delta j_i}{\\delta a_{ij}^k}\\frac{\\delta a_{ij}^k}{\\delta b_j^k}\\) obtenemos: \\begin{align} \\delta b_j^k=-\\mu \\frac{\\delta j}{\\delta b_j^k} \\end{align} \\begin{align} \\delta b_j^k= -\\mu \\sum_{i=1}^n\\frac{\\delta j_i}{\\delta a_{ij}^k}\\frac{\\delta a_{ij}^k}{\\delta b_j^k}=-\\mu \\sum_{i=1}^n\\delta_{ij}^k \\end{align} capa de salida calculamos \\(\\delta_{ij}^k\\) en la capa de salida (\\(k=h\\)), cuyo valor se va a propagar hacia las capas anteriores. lo que vamos a calcular es \\(\\delta_{ij}^k \\equiv \\frac{\\delta j_i}{\\delta a_{ij}^k}\\). tenemos que la función de coste para el patrón \\(i\\), \\(j_i\\) viene definida por: \\begin{align} j_i=\\frac{1}{2}\\sum_{j=1}^{i_h}(y_{ij}-h_{ij}^h)^2=\\frac{|y_i-h_i^h|^2}{2} \\end{align} además el valor de \\(a_{ij}^k\\), que es la combinación lineal de las entradas (salidas de las neuronas capa anterior, \\(k-1\\)) y los pesos junto con el offset: \\begin{align} a_{ij}^k=(w_j^k)^th_i^{k-1}+b_j^k \\end{align} por lo tanto en la capa final: \\begin{align} \\frac{\\delta j_i}{\\delta a_{ij}^h}=\\frac{1}{2}\\frac{\\delta (y_{ij}-h_{ij}^h)^2}{\\delta (y_{ij}-h_{ij}^h)}\\frac{\\delta (y_{ij}-h_{ij}^h)}{\\delta a_{ij}^h} \\end{align} donde: \\begin{align} \\frac{\\delta (y_{ij}-h_{ij}^h)^2}{\\delta (y_{ij}-h_{ij}^h)}=2(y_{ij}-h_{ij}^h) \\end{align} \\begin{align} \\frac{\\delta (y_{ij}-h_{ij}^h)}{\\delta a_{ij}^h}=\\frac{\\delta y_{ij}}{\\delta a_{ij}^h}-\\frac{\\delta h_{ij}^h}{\\delta a_{ij}^h}=0-f'(a_{ij}^h) \\end{align} ya que sabemos que \\(h_{ij}^h=f(a_{ij}^h)\\), por lo que: \\begin{align} \\frac{\\delta h_{ij}^h}{\\delta a_{ij}^h}=\\frac{\\delta f(a_{ij}^h)}{\\delta a_{ij}^h}=f'(a_{ij}^h) \\end{align} una vez desarrollado todo esto sustiuimos los resultados en \\(\\frac{\\delta j_i}{\\delta a_{ij}^h}\\): \\begin{align} \\frac{\\delta j_i}{\\delta a_{ij}^h}=\\frac{1}{2}2(y_{ij}-h_{ij}^h)(-f'(a_{ij}^h))=(y_{ij}-h_{ij}^h)f'(a_{ij}^h) \\end{align} de tal forma que: \\begin{align} \\delta_{ij}^h=\\frac{\\delta j_i}{\\delta a_{ij}^h}=(y_{ij}-h_{ij}^h)f'(a_{ij}^h)=\\epsilon_{ij}^hf'(a_{ij}^h) \\end{align} donde se define \\(\\epsilon_{ij}^h\\) como: \\begin{align} \\epsilon_{ij}^h=y_{ij}-h_{ij}^h \\end{align} finalmente obtenemos que el antigradiente en la última capa \\(h\\) viene dado por: \\begin{align} \\delta w_j^h=-\\mu \\sum_{i=1}^n\\delta_{ij}^hh_i^{h-1}=-\\mu\\sum_{i=1}^n\\epsilon_{ij}^hf'(a_{ij}^h)h_i^{h-1} \\end{align} \\begin{align} \\delta b_j^h=-\\mu \\sum_{i=1}^n\\delta_{ij}^h=-\\mu\\sum_{i=1}^n\\epsilon_{ij}^hf'(a_{ij}^h) \\end{align} retropropagación del gradiente para las capas anteriores a la capa de salida (\\(k<h\\)): \\begin{align} \\delta_{ij}^k=\\frac{\\delta j_i}{\\delta a_{ij}^k}=\\sum_{l=1}^{i_{k+1}}\\frac{\\delta j_i}{\\delta a_{il}^{k+1}}\\frac{\\delta a_{il}^{k+1}}{\\delta a_{ij}^k}=\\sum_{l=1}^{i_{k+1}}\\delta_{il}^{k+1}\\frac{\\delta a_{il}^{k+1}}{\\delta a_{ij}^k} \\end{align} en este caso se utiliza la regla de la cadena para obtener \\(\\delta_{ij}^k\\) de modo que se tienen en cuenta todas las combinaciones del gradiente acumulado \\(\\delta a_{il}^{k+1}\\) con la neurona actual (\\(\\delta a_{ij}^k\\)) donde \\(l=1...i_{k+1}\\), es decir se tienen encuenta todas las neuronas de la capa siguiente. con grafos, la regla de la cadena se puede interpretar como todos los caminos posibles desde la capa de salida hasta la neurona \\(j\\) en la capa \\(k\\). cada camino une cada neurona \\(l\\) de la capa siguiente: \\(\\delta_{il}^{k+1}\\) (el cual ya tiene el gradiente acumulado de las capas siguientes) con una neurona \\(j\\) de la capa actual: \\(\\delta a_{ij}^k\\) de la siguiente forma: \\(\\delta_{il}^{k+1}\\frac{\\delta a_{il}^{k+1}}{\\delta a_{ij}^k}\\). además se suman todas las combinación posibles: \\(\\sum_{l=1}^{i_{k+1}}\\). esto nos permite utilizar el gradiente acumulado calculado en la capa siguiente que se propaga hacia atrás en la red neuronal, lo que evita tener que calcular \\(\\frac{\\delta j_i}{\\delta a_{ij}^k}\\). por otro lado tenemos: \\begin{align} a_{il}^{k+1}=(w_l^{k+1})^th_i^{k}+b_l^{k+1} \\end{align} que es el cálculo de la neurona \\(l\\) de la capa siguiente, por lo que utiliza como entradas las salidas de la neurona de esta capa \\(h_i^{k}\\). esta es la versión vectorizada del cálculo, si lo expresamos como sumatorio: \\begin{align} a_{il}^{k+1}=\\sum_{m=1}^{i_k}w_{lm}^{k+1}h_{im}^{k}+b_{lm}^{k+1}=\\sum_{m=1}^{i_k}w_{lm}^{k+1}f(a_{im}^{k})+b_{lm}^{k+1} \\end{align} de tal forma que se multiplican los \\(i_k\\) pesos de la capa siguiente (\\(w_{lm}^{k+1}\\)) con las \\(i_k\\) salidas de la capa actual (\\(h_{im}^{k}\\)) y sumamos los offset (\\(b_{lm}^{k+1}\\)). además sabemos que \\(h_{im}^{k}=f(a_{im}^{k})\\). por lo tanto: \\begin{align} \\frac{\\delta a_{il}^{k+1}}{\\delta a_{ij}^k}=\\sum_{m=1}^{i_k}(\\frac{\\delta(w_{lm}^{k+1}f(a_{im}^{k}))}{\\delta a_{ij}^k}+\\frac{\\delta b_{lm}^{k+1}}{\\delta a_{ij}^k}) \\end{align} la primera derivada tiene la siguiente forma: \\begin{align} \\frac{\\delta(w_{lm}^{k+1}f(a_{im}^{k}))}{\\delta a_{ij}^k}=w_{lm}^{k+1}\\frac{\\delta f(a_{im}^{k})}{\\delta a_{ij}^k} \\end{align} \\begin{align} \\frac{\\delta f(a_{im}^{k})}{\\delta a_{ij}^k} =\\begin{cases} f'(a^k_{im})=f'(a^k_{ij}) & m=j\\\\ 0 & m \\ne j \\end{cases} \\end{align} por lo que podemos eliminar el sumatorio sobre \\(m\\) y la derivada sobre el offset ya que su valor es nulo: \\begin{align} \\frac{\\delta a_{il}^{k+1}}{\\delta a_{ij}^k}=w_{lj}^{k+1}f'(a^k_{ij}) + 0 \\end{align} gradiente acumulado si volvemos a \\(\\delta_{ij}^k=\\frac{\\delta j_i}{\\delta a_{ij}^k}=\\sum_{l=1}^{i_{k+1}}\\delta_{il}^{k+1}\\frac{\\delta a_{il}^{k+1}}{\\delta a_{ij}^k}\\). sustituimos \\(\\frac{\\delta a_{il}^{k+1}}{\\delta a_{ij}^k}\\) obteniendo: \\begin{align} \\delta_{ij}^k=\\frac{\\delta j_i}{\\delta a_{ij}^k}=\\sum_{l=1}^{i_{k+1}}\\delta_{il}^{k+1}w_{lj}^{k+1}f'(a^k_{ij}) \\end{align} podemos extraer \\(f'(a^k_{ij})\\) ya que esta no depende de \\(l\\): \\begin{align} \\delta_{ij}^k=f'(a^k_{ij})\\sum_{l=1}^{i_{k+1}}\\delta_{il}^{k+1}w_{lj}^{k+1} \\end{align} si definimos: \\begin{align} \\epsilon_{ij}^k=\\sum_{l=1}^{i_{k+1}}\\delta_{il}^{k+1}w_{lj}^{k+1} \\end{align} tenemos que: \\begin{align} \\delta_{ij}^k=f'(a^k_{ij})\\epsilon_{ij}^k \\end{align} derivadas de las funciones de activación la derivada de la función sigmoide: \\begin{align} f'(t)=af(t)(1-f(t)) \\end{align} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/NeuralNetworks/Anexo/Ejemplo de retropropagación.html",
    "title": "Ejemplo de retropropagación",
    "body": " index search search back ejemplo de retropropagación por ejemplo, supongamos que tenemos una red con tres capas, entonces \\(k=3\\), dado un ejemplo \\(x_j\\). en este caso tenemos que capa 3 la derivada en la última capa, para el único vector de pesos \\(\\theta^{(3)}_1\\) que tiene \\(n\\) elementos (features o características), es: \\(\\frac{\\delta j(\\theta)}{\\delta \\theta_{1t}^{(3)}}\\), para cada \\(t\\), \\(0 \\leq t \\leq n\\) como: \\begin{align} j(\\theta) = e^{(3)}(a_1^{(3)}) = e^{(3)}(g(z_1^{(3)})) = e^{(3)}(g(\\theta^{(3)}\\cdot a^{(2)})) \\end{align} donde denotamos la función que calcula el error entre lo predicho y la salida real como \\(e\\), y \\(g\\) es la función de activación. entonces, aplicamos la regla de la cadena para cada elemento \\(t\\) en el vector de pesos: \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_{1t}^{(3)}} = \\frac{\\delta j(\\theta)}{\\delta a_1^{(3)}}\\frac{\\delta a_1^{(3)}}{\\delta z_1^{(3)}}\\frac{\\delta z_1^{(3)}}{\\delta \\theta_{1t}^{(3)}} \\end{align} si vectorizamos: \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_{1}^{(3)}} = \\frac{\\delta j(\\theta)}{\\delta a_1^{(3)}}\\frac{\\delta a_1^{(3)}}{\\delta z_1^{(3)}}\\frac{\\delta z_1^{(3)}}{\\delta \\theta_{1}^{(3)}} \\end{align} capa 2 si ahora queremos obtener la derivada para uno de los vectores de pesos en la capa \\(2\\), volvemos a aplicar la regla de la cadena. tenemos ahora que desestructurar la función de coste todavía más, hasta obtener la expresión que incluye las salidas de la capa \\(1\\), \\(a^{(1)}\\). \\begin{align} j(\\theta) = e^{(3)}(g(\\theta^{(3)}\\cdot a^{(2)})) = e^{(3)}(g(\\theta^{(3)}\\cdot g(z^{(2)}))) = e^{(3)}(g(\\theta^{(3)}\\cdot g(\\theta^{(2)} \\cdot a^{(1)}))) \\end{align} sea \\(\\delta^{(3)}_{1j}\\): \\begin{align} \\delta^{(3)}_{1j} = \\frac{\\delta j(\\theta)}{\\delta a_{1j}^{(3)}}\\frac{\\delta a_{1j}^{(3)}}{\\delta z_{1j}^{(3)}} \\end{align} entonces, aplicamos la regla de la cadena para cada nodo \\(i\\) de la capa \\(2\\) y para cada elemento \\(t\\): \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_{it}^{(2)}} = \\sum_{l=1}^{s_{(3)}} \\delta_{lj}^{(3)}\\frac{\\delta z_{lj}^{(3)}}{\\delta a_{lj}^{(2)}}\\frac{\\delta a_{lj}^{(2)}}{\\delta z_{lj}^{(2)}}\\frac{\\delta z_{lj}^{(2)}}{\\delta \\theta_{it}^{(2)}} = \\delta_{1j}^{(3)}\\frac{\\delta z_{1j}^{(3)}}{\\delta a_{1j}^{(2)}}\\frac{\\delta a_{1j}^{(2)}}{\\delta z_{1j}^{(2)}}\\frac{\\delta z_{1j}^{(2)}}{\\delta \\theta_{it}^{(2)}} \\end{align} si vectorizamos: \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_{i}^{(2)}} = \\delta_{j}^{(3)}\\frac{\\delta z^{(3)}}{\\delta a_{j}^{(2)}}\\frac{\\delta a_{j}^{(2)}}{\\delta z_{j}^{(2)}}\\frac{\\delta z_{j}^{(2)}}{\\delta \\theta_{i}^{(2)}} \\end{align} capa 1 para la capa \\(1\\), volvemos a expandir la función de coste para ver cómo aplicar la regla de la cadena: \\begin{align} j(\\theta) = e^{(3)}(g(\\theta^{(3)}\\cdot g(\\theta^{(2)} \\cdot a^{(1)}))) = e^{(3)}(g(\\theta^{(3)}\\cdot g(\\theta^{(2)} \\cdot g(z^{(1)})))) = \\end{align} \\begin{align} = e^{(3)}(g(\\theta^{(3)}\\cdot g(\\theta^{(2)} \\cdot g(\\theta^{(1)} x_j)))) \\end{align} para simplificar la notación: sea, para cada nodo \\(l\\) de la capa \\(2\\) \\begin{align} \\delta^{(2)}_{lj} = \\delta_{1j}^{(3)}\\frac{\\delta z_1^{(3)}}{\\delta a_{lj}^{(2)}}\\frac{\\delta a_{lj}^{(2)}}{\\delta z_{lj}^{(2)}} \\end{align} aplicamos la regla de la cadena, tal que para cada nodo \\(l\\) de la capa \\(2\\): \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_{it}^{(1)}} = \\sum_{l=1}^{s_{(2)}} \\delta_{lj}^{(2)}\\frac{\\delta z_{lj}^{(2)}}{\\delta a_{lj}^{(1)}}\\frac{\\delta a_{lj}^{(1)}}{\\delta z_{lj}^{(1)}}\\frac{\\delta z_{lj}^{(1)}}{\\delta \\theta_{it}^{(1)}} \\end{align} si vectorizamos: \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_{i}^{(1)}} = \\delta_{j}^{(2)}\\frac{\\delta z_{j}^{(2)}}{\\delta a_{j}^{(1)}}\\frac{\\delta a_{j}^{(1)}}{\\delta z_{j}^{(1)}}\\frac{\\delta z_{j}^{(1)}}{\\delta \\theta_{i}^{(1)}} \\end{align} el procedimiento se ilustra en la siguiente figura: $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/NeuralNetworks/Anexo/Derivada de la función de coste.html",
    "title": "Derivada de la Función de Coste",
    "body": " index search search back derivada de la función de coste sabemos que la función de coste: \\[%align j(\\theta) = - \\frac{1}{m} \\left\\{ \\sum_{j=1}^m\\sum_{i=1}^c (y_{ij}\\cdot \\log(h_\\theta(x_j)_i)) + [(1-y_{ij})\\log(1-h_\\theta(x_j)_i)]\\right\\} \\] donde \\(\\theta_{it}^{(k)}\\) es el peso que conecta el nodo \\(i\\) de la capa \\(k\\) con el nodo \\(t\\) de la capa \\((k-1)\\), es decir, es el elemento en la fila \\(i\\) columna \\(t\\) de la matriz de pesos de la capa \\(k\\), \\(\\theta^{(k)}\\). por la regla de la cadena, separamos la derivada de la función del coste en función de los pesos en dos términos: \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_{it}^{(k)}} = \\sum_{j=1}^m \\sum_{i=1}^c \\frac{\\delta e^{(k)}}{\\delta a_{ij}^{(k)}} \\frac{\\delta a_{ij}^{(k)}}{\\delta \\theta_{it}^{(k)}} \\end{align} capa de salida procedemos a calcular la derivada: \\[%align \\frac{\\delta j(\\theta)}{\\delta \\theta_{it}^{(k)}} = \\frac{\\delta}{\\delta \\theta_{it}^{(k)}} \\left(- \\frac{1}{m}\\right) \\left\\{ \\sum_{j=1}^m\\sum_{i=1}^c (y_{ij}\\cdot \\log(h_\\theta(x_j)_i)) + [(1-y_{ij})\\log(1-h_\\theta(x_j)_i)]\\right\\} \\] sacamos el término constante de la derivada y aplicamos la propiedad: \"la derivada de una suma equivale a la suma de las derivadas\" \\[%align \\frac{\\delta j(\\theta)}{\\delta \\theta_{it}^{(k)}} = \\left(- \\frac{1}{m}\\right) \\sum_{j=1}^m\\sum_{i=1}^c \\frac{\\delta}{\\delta \\theta_{it}^{(k)}} \\left\\{(y_{ij}\\cdot \\log(h_\\theta(x_j)_i)) + [(1-y_{ij})\\log(1-h_\\theta(x_j)_i)]\\right\\} \\] sea \\(h_\\theta(x_j) = a^{(k)}_j\\), es decir la salida de la última capa para el ejemplo \\(j\\). \\[%align \\frac{\\delta j(\\theta)}{\\delta \\theta_{it}^{(k)}} = \\left(- \\frac{1}{m}\\right) \\sum_{j=1}^m\\sum_{i=1}^c \\frac{\\delta}{\\delta \\theta_{it}^{(k)}} \\left\\{(y_{ij}\\cdot \\log(a^{(k)}_{ij})) + [(1-y_{ij})\\log(1-a^{(k)}_{ij})]\\right\\} \\] sacaremos el término \\(y_{ij}\\) de la derivada y juntemos todas las expresiones: \\[%align \\frac{\\delta j(\\theta)}{\\delta \\theta_{it}^{(k)}} = \\left(- \\frac{1}{m}\\right) \\sum_{j=1}^m\\sum_{i=1}^c \\left\\{y_{ij} \\left(\\frac{\\delta}{\\delta \\theta_{it}^{(k)}} \\log(a^{(k)}_{ij}) \\right) + (1-y_{ij}) \\left(\\frac{\\delta}{\\delta \\theta_{it}^{(k)}} \\log(1-a^{(k)}_{ij})\\right)\\right\\} \\] aplicamos la regla de la cadena sobre el logaritmo: \\[%align \\frac{\\delta j(\\theta)}{\\delta \\theta_{it}^{(k)}} = \\left(- \\frac{1}{m}\\right) \\sum_{j=1}^m\\sum_{i=1}^c \\left\\{y_{ij} \\left(\\frac{\\delta \\log(a_{ij}^{(k)})}{\\delta a_{ij}^{(k)}} \\frac{\\delta a_{ij}^{(k)}}{\\delta \\theta_{it}^{(k)}} \\right) + (1-y_{ij}) \\left(\\frac{\\delta \\log(1-a^{(k)}_{ij})}{\\delta (1-a^{(k)}_{ij})} \\frac{\\delta (1-a^{(k)}_{ij})}{\\delta \\theta_{it}^{(k)}} \\right)\\right\\} \\] como sabemos: \\(\\frac{\\delta (1)}{\\delta \\theta_{it}^{(k)}} = 0\\), entonces \\(\\frac{\\delta(1-a_{ij}^{(k)})}{\\delta \\theta_{it}^{(k)}} = \\frac{\\delta (1)}{\\delta \\theta_{it}^{(k)}} - \\frac{\\delta a_{ij}^{(k)}}{\\delta \\theta_{it}^{(k)}} = 0 + (-1) \\frac{\\delta a_{ij}^{(k)}}{\\delta \\theta_{it}^{(k)}}\\) entonces \\[%align \\frac{\\delta j(\\theta)}{\\delta \\theta_{it}^{(k)}} = \\left(- \\frac{1}{m}\\right) \\sum_{j=1}^m\\sum_{i=1}^c \\left\\{y_{ij} \\left(\\frac{\\delta \\log(a_{ij}^{(k)})}{\\delta a_{ij}^{(k)}} \\frac{\\delta a_{ij}^{(k)}}{\\delta \\theta_{it}^{(k)}} \\right) + (1-y_{ij}) \\left((-1)\\frac{\\delta \\log(1-a^{(k)}_{ij})}{\\delta (1-a^{(k)}_{ij})} \\frac{\\delta a^{(k)}_{ij}}{\\delta \\theta_{it}^{(k)}} \\right)\\right\\} \\] sacamos \\(\\frac{\\delta a_{ij}^{(k)}}{\\delta \\theta_{it}^{(k)}}\\) como factor común y aplicamos el \\((-1)\\): \\[%align \\frac{\\delta j(\\theta)}{\\delta \\theta_{it}^{(k)}} = \\left(- \\frac{1}{m}\\right) \\sum_{j=1}^m\\sum_{i=1}^c \\frac{\\delta a_{ij}^{(k)}}{\\delta \\theta_{it}^{(k)}}\\left\\{y_{ij} \\frac{\\delta \\log(a_{ij}^{(k)})}{\\delta a_{ij}^{(k)}} - \\left((1-y_{ij})\\frac{\\delta \\log(1-a^{(k)}_{ij})}{\\delta (1-a^{(k)}_{ij})} \\right)\\right\\} \\] sustituimos \\(\\frac{\\delta e^{(k)}}{\\delta a_{ij}^{(k)}} = \\left\\{y_{ij} \\frac{\\delta \\log(a_{ij}^{(k)})}{\\delta a_{ij}^{(k)}} - \\left((1-y_{ij})\\frac{\\delta \\log(1-a^{(k)}_{ij})}{\\delta (1-a^{(k)}_{ij})} \\right)\\right\\}\\) \\[%align \\frac{\\delta j(\\theta)}{\\delta \\theta_{it}^{(k)}} = \\left(- \\frac{1}{m}\\right) \\sum_{j=1}^m\\sum_{i=1}^c \\frac{\\delta e^{(k)}}{\\delta a_{ij}^{(k)}} \\frac{\\delta a_{ij}^{(k)}}{\\delta \\theta_{it}^{(k)}} \\] si resolvemos las derivadas de los logaritmos obtenemos: \\[%align \\frac{\\delta e^{(k)}}{\\delta a_{ij}^{(k)}} = y_{ij} \\frac{\\delta \\log(a_{ij}^{(k)})}{\\delta a_{ij}^{(k)}} - (1-y_{ij})\\frac{\\delta \\log(1-a_{ij}^{(k)})}{\\delta (1-a_{ij}^{(k)})} \\] nos centraremos ahora en la derivada que nos falta \\(\\frac{\\delta a_{ij}^{(k)}}{\\delta \\theta_{it}^{(k)}}\\): sabemos que, vectorizando la operación, \\(a^{(k)}_j = g(z^{(k)}_j)\\), donde \\(g\\) es la función de activación (en este caso sigmoide). además: \\[%align z^{(k)}_j = \\theta^{k} \\cdot a^{(k-1)}_j \\] por lo tanto, para cada nodo \\(i\\) en la última capa \\(k\\): \\[%align z^{(k)}_{ij} = \\sum_{l=1}^{s_{(k-1)}} \\theta^{(k)}_{il} \\cdot a^{(k-1)}_{lj} \\] donde \\(s_{(k-1)}\\) es el número de nodos en la capa \\(k-1\\). entonces, aplicamos de nuevo la regla de la cadena: \\[%align \\frac{\\delta a_{ij}^{(k)}}{\\delta \\theta_{it}^{(k)}} = \\frac{\\delta g(z_{ij}^{(k)})}{\\delta z_{ij}^{(k)}} \\frac{\\delta z_{ij}^{(k)}}{\\delta \\theta_{it}^{(k)}} \\] resolvemos la derivada para el segundo término: \\[%align \\frac{\\delta z_{ij}^{(k)}}{\\delta \\theta_{it}^{(k)}} = \\sum_{l=1}^{s_{(k-1)}} \\frac{\\delta}{\\delta \\theta_{it}^{(k)}} \\theta^{(k)}_{il} \\cdot a^{(k-1)}_{lj} \\] tal que: \\[%align \\frac{\\delta}{\\delta \\theta_{it}^{(k)}} \\theta^{(k)}_{il} \\cdot a^{(k-1)}_{lj} = \\begin{cases} a_{lj}^{(k-1)}, & t = l \\\\ 0, & t \\neq l \\\\ \\end{cases} \\] por lo tanto, como sólo hay un \\(l\\) con \\(l = t\\) donde \\(1 \\leq l \\leq s_{(k-1)}\\), entonces: \\[%align \\frac{\\delta z_{ij}^{(k)}}{\\delta \\theta_{it}^{(k)}} = a_{lj}^{(k-1)} = a_{tj}^{(k-1)} \\] juntamos ambos términos de la derivada inicial, con \\(\\frac{\\delta g(z_{ij}^{(k)})}{\\delta z_{ij}^{k}} = \\sigma'(z_{ij}^{(k)})\\) \\[%align \\frac{\\delta a_{ij}^{(k)}}{\\delta \\theta_{it}^{(k)}} = \\frac{\\delta g(z_{ij}^{(k)})}{\\delta z_{ij}^{(k)}} \\frac{\\delta z_{ij}^{(k)}}{\\delta \\theta_{it}^{(k)}} = \\sigma'(z_{ij}^{(k)}) a_{tj}^{(k-1)} \\] vamos a resumir lo que tenemos hasta ahora. por la regla de la cadena, separamos la derivada de la función del coste en función de los pesos en dos términos: \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_{it}^{(k)}} = \\sum_{j=1}^m \\sum_{i=1}^c \\frac{\\delta e^{(k)}}{\\delta a_{ij}^{(k)}} \\frac{\\delta a_{ij}^{(k)}}{\\delta \\theta_{it}^{(k)}} \\end{align} si sustituimos ambos términos, para la capa de salida \\(k\\): \\[%align \\frac{\\delta j(\\theta)}{\\delta \\theta_{it}^{(k)}} = \\left(- \\frac{1}{m}\\right) \\sum_{j=1}^m\\sum_{i=1}^c \\sigma'(z_{ij}^{(k)}) a_{tj}^{(k-1)}\\left\\{ \\frac{y_{ij}}{a_{ij}^{(k)}} - \\left(\\frac{(1-y_{ij})}{(1-a^{(k)}_{ij})} \\right)\\right\\} \\] $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/NeuralNetworks/Neural Networks.html",
    "title": "Neural Networks",
    "body": " index search search back neural networks architecture algorithm output layer forward propagation parameters outputs graphical representation optimization problem loss function optimization back-propagation vectorization improving a neural network activation functions initialization techniques anexo architecture input: given any input \\(x\\) the first thing we do is flatten it. for example if \\(x\\) is a rgb image of \\(64 \\times 64\\), then \\(x \\in \\mathbb{r}^{64 \\times 64 \\times 3}\\) (for each of the \\(64 \\times 64\\) pixels we have three color channels: red, green, blue), is flattened into a vector in \\(\\mathbb{r}^{(64*64*3) \\times 1}\\) neuron: is an operation that has two parts: linear part: we denote the linear part like \\(z^{[i]}\\), where \\(i\\) is the current layer. activation part layer: a layer is a compound of neurons that are not connected with each other. algorithm the principal steps of the algorithm are: initialize the weights \\(w\\) and biases \\(b\\) randomly find the optimal \\(w, b\\) use the optimized \\(w, b\\) to predict the output by using the formula \\(\\hat{y} = \\sigma(wx +b)\\) output layer sigmoid the output layer will be different depending on the problem we are tackling. for example if we want to discriminate between 3 classes then the output layer could be as follows: so now the output is a vector \\(\\hat{y} \\in \\mathbb{r}^{c \\times 1}\\) where \\(c\\) is the number of classes. softmax the previous classifier allows for outputting multiples classes in the result, that is we can obtain a predicted output of the form \\(\\hat{y} = \\begin{bmatrix} 1 \\\\1 \\\\ 0 \\end{bmatrix}\\). what if we want to add a constraint such that only one class can be predicted. then we use the softmax function as the activation function on the output layer: thus, instead of a probability for each class what we obtain is a probability distribution for all the classes. relu on linear regression we do not want the activation function to be linear, because then the whole network becomes a very large linear regression. instead we use as an activation function the relu function (rectified linear unit), whose output is zero if the input value is negative and linear otherwise. loss function the loss function when using the sigmoid function on the output layer is as follows: \\begin{align} \\mathcal{l} = - \\frac{1}{q} \\sum_{k=1}^q [y^{(k)} \\log(\\hat{y}^{(k)}) + (1- y^{(k)})\\log(1-\\hat{y}^{(k)})] \\end{align} where \\(\\hat{y}^{(k)}\\) are the predicted values and \\(q\\) is the total number of neurons on the output layer. however, if we use the softmax function as the activation function on the last layer we have to use a different derivative because this function does depend on the outputs of the other neurons. thus, we make use of a function called cross entropy loss: \\begin{align} \\mathcal{l}_{ce} = - \\sum_{k=1}^q y^{(k)} \\log(\\hat{y}^{(k)}) \\end{align} for linear regression we use as the loss function the l1-norm or the l2-norm. the latter is defined as follows: \\begin{align} \\mathcal{l} = || \\hat{y} - y ||_2^2 \\end{align} forward propagation the forward propagation equations are the following: \\begin{align} z^{[i]} = w^{[i]} a^{[i-1]} + b^{[i]} \\tag{1} \\end{align} where \\(i\\) is the layer with \\(i \\geq 1\\), and the first layer equals the input matrix, that is \\(a^{[0]} = x\\). by applying the activation function over \\((1)\\): \\begin{align} a^{[i]} = g(z^{[i]}) \\end{align} where \\(g\\) is the activation function (e.g \\(\\sigma(z^{[i]})\\)). now, what are the shapes of these matrices? \\(z^{[i]} \\in \\mathbb{r}^{s_i \\times m}\\) \\(a^{[i]} \\in \\mathbb{r}^{s_i \\times m}\\) where \\(s_i\\) is the number of neurons on the ith layer and \\(m\\) is the number of examples. note that the shape of the final layer changes depending on the task. so if \\(k\\) is the number of layers: in linear regression: \\(\\hat{y} = a^{[k]} \\in \\mathbb{r}^{1 \\times m}\\) in multi-class classification: \\(\\hat{y} = a^{[k]} \\in \\mathbb{r}^{c \\times m}\\), where \\(c\\) is the number of classes. also the shape of the weights are \\(w[i] \\in \\mathbb{r}^{s_i \\times s_{i-1}}\\), that is, this matrix is compatible with the outputs of the previous layer (\\(a^{[i-1]} \\in \\mathbb{r}^{s_{i-1} \\times m}\\)) and the linear part of the next layer (\\(z^{[i]} \\in \\mathbb{r}^{s^i \\times m}\\)). however, the bias are \\(b^{[i]} \\in \\mathbb{r}^{s^i \\times 1}\\), therefore we cannot perform an element wise summation because the shape of \\((w^{[i]} a^{[i-1]}) \\in \\mathbb{r}^{s_i \\times m}\\) and \\(b^{[i]}\\) are not compatible. to avoid this problem we apply a technique called broadcasting to \\(b\\), such that we replicate \\(b^{[i]}\\) \\(m\\) times: \\begin{align} \\hat{b}^{[i]} = \\begin{bmatrix} | & | & \\cdots & | \\\\ b^{[i]} & b^{[i]} & \\cdots & b^{[i]} \\\\ | & | & \\cdots & | \\\\ \\end{bmatrix} \\in \\mathbb{r}^{s_i \\times m} \\end{align} to sum up, the shapes of the data and the parameters on each layer \\(i\\) are: parameters \\begin{align} \\hat{b}^{[i]} = \\begin{bmatrix} | & | & \\cdots & | \\\\ b^{[i]} & b^{[i]} & \\cdots & b^{[i]} \\\\ | & | & \\cdots & | \\\\ \\end{bmatrix} \\in \\mathbb{r}^{s_i \\times m} \\end{align} \\begin{align} w^{[i]} = \\begin{bmatrix} | & | & \\cdots & | \\\\ w^{[i](1)} & w^{[i](2)} & \\cdots & w^{[i](s_{i-1})} \\\\ | & | & \\cdots & | \\\\ \\end{bmatrix} \\in \\mathbb{r}^{s_i \\times s_{i-1}} \\end{align} outputs note that for each example \\(j\\) on layer \\(i\\) \\(z^{[i](j)} = (w^{[i]} a^{[i-1](j)} + \\hat{b}^{[i]})\\), then: \\begin{align} z^{[i]} = \\begin{bmatrix} | & | & \\cdots & | \\\\ z^{[i](1)} & z^{[i](2)} & \\cdots & z^{[i](m)} \\\\ | & | & \\cdots & | \\\\ \\end{bmatrix} \\in \\mathbb{r}^{s_i \\times m} \\end{align} \\begin{align} a^{[i]} = \\begin{bmatrix} | & | & \\cdots & | \\\\ g(z^{[i](1)}) & g(z^{[i](2)}) & \\cdots & g(z^{[i](m)}) \\\\ | & | & \\cdots & | \\\\ \\end{bmatrix} \\in \\mathbb{r}^{s_i \\times m} \\end{align} graphical representation now we present a small example of how forward propagation works on neural networks: optimization problem what we want to do is find the parameters \\(w^{[i]}, b^{[i]}\\) for each layer \\(i\\) that minimize the cost. loss function so first of all we define a cost function for the objective \\(\\mathcal{l}(\\hat{y}, y)\\), where \\(\\hat{y}\\) is the predicted output and \\(y\\) is the real output. the cost function will depend on the type of problem (classification, regression). optimization the we optimize the loss function we defined by using backward propagation. for each layer \\(l=1, \\cdots, k\\), where \\(k\\) is the number of layers, we apply batch gradient descent (not mandatory, but here it is convenient as we can vectorize the derivatives) as follows: \\begin{align} w^{[l]} = w^{[l]} - \\alpha \\frac{\\delta \\mathcal{l}(\\hat{y}, y)}{\\delta w^{[l]}} \\end{align} \\begin{align} b^{[l]} = b^{[l]} - \\alpha \\frac{\\delta \\mathcal{l}(\\hat{y}, y)}{\\delta b^{[l]}} \\end{align} back-propagation to compute the derivatives of the cost function with respect to \\(w^{[l]}\\) and \\(b^{[l]}\\) we use the chain rule. output layer suppose we have \\(k\\) layers, then we start by calculating \\(\\frac{\\delta \\mathcal{l}(\\hat{y}, y)}{\\delta w^{[k]}}\\) and \\(\\frac{\\delta \\mathcal{l}(\\hat{y}, y)}{\\delta b^{[k]}}\\), that is, the derivatives on the last layer. thus, to update \\(w^{[k]}\\) (we apply the same logic for \\(b^{[k]}\\)): \\begin{align} \\frac{\\delta \\mathcal{l}(\\hat{y}, y)}{\\delta w^{[k]}} = \\sum_{i=1}^m \\frac{\\delta \\mathcal{l}(\\hat{y^{(i)}}, y^{(i)})}{\\delta w^{[k]}} = \\end{align} because \\(\\hat{y^{(i)}} = (a^{[k]})^{(i)}\\): \\begin{align} = \\sum_{i=1}^m \\frac{\\delta \\mathcal{l}((a^{[k]})^{(i)}, y^{(i)})}{\\delta w^{[k]}} \\end{align} we apply the chain rule on the derivative, therefore: \\begin{align} = \\sum_{i=1}^m \\frac{\\delta \\mathcal{l}((a^{[k]})^{(i)}, y^{(i)})}{\\delta (a^{[k]})^{(i)}} \\frac{\\delta (a^{[k]})^{(i)}}{\\delta w^{[k]}} \\end{align} because \\((a^{[k]})^{(i)} = g((z^{[k]})^{(i)})\\), where \\(g\\) is the activation function: \\begin{align} = \\sum_{i=1}^m \\frac{\\delta \\mathcal{l}((a^{[k]})^{(i)}, y^{(i)})}{\\delta (a^{[k]})^{(i)}} \\frac{\\delta g((z^{[k]})^{(i)})}{\\delta w^{[k]}} \\end{align} we apply the chain rule on the last derivative, therefore: \\begin{align} = \\sum_{i=1}^m \\frac{\\delta \\mathcal{l}((a^{[k]})^{(i)}, y^{(i)})}{\\delta (a^{[k]})^{(i)}} \\frac{\\delta g((z^{[k]})^{(i)})}{\\delta (z^{[k]})^{(i)}} \\frac{\\delta (z^{[k]})^{(i)}}{\\delta w^{[k]}} \\end{align} hidden layers what about the previous layer \\(k-1\\)? \\begin{align} \\frac{\\delta \\mathcal{l}(\\hat{y}, y)}{\\delta w^{[k-1]}} = \\sum_{i=1}^m \\frac{\\delta \\mathcal{l}(\\hat{y^{(i)}}, y^{(i)})}{\\delta w^{[k-1]}} = \\end{align} because \\(\\hat{y^{(i)}} = (a^{[k]})^{(i)}\\): \\begin{align} = \\sum_{i=1}^m \\frac{\\delta \\mathcal{l}((a^{[k]})^{(i)}, y^{(i)})}{\\delta w^{[k-1]}} \\end{align} we apply the chain rule on the derivative, therefore: \\begin{align} = \\sum_{i=1}^m \\frac{\\delta \\mathcal{l}((a^{[k]})^{(i)}, y^{(i)})}{\\delta (a^{[k]})^{(i)}} \\frac{\\delta (a^{[k]})^{(i)}}{\\delta w^{[k-1]}} \\end{align} because \\((a^{[k]})^{(i)} = g((z^{[k]})^{(i)})\\), where \\(g\\) is the activation function: \\begin{align} = \\sum_{i=1}^m \\frac{\\delta \\mathcal{l}((a^{[k]})^{(i)}, y^{(i)})}{\\delta (a^{[k]})^{(i)}} \\frac{\\delta g((z^{[k]})^{(i)})}{\\delta w^{[k-1]}} \\end{align} we apply the chain rule on the last derivative, therefore: \\begin{align} = \\sum_{i=1}^m \\frac{\\delta \\mathcal{l}((a^{[k]})^{(i)}, y^{(i)})}{\\delta (a^{[k]})^{(i)}} \\frac{\\delta g((z^{[k]})^{(i)})}{\\delta (z^{[k]})^{(i)}} \\frac{\\delta (z^{[k]})^{(i)}}{\\delta w^{[k-1]}} \\end{align} \\begin{align} = \\sum_{i=1}^m \\frac{\\delta \\mathcal{l}((a^{[k]})^{(i)}, y^{(i)})}{\\delta (a^{[k]})^{(i)}} \\frac{\\delta (a^{[k]})^{(i)}}{\\delta (z^{[k]})^{(i)}} \\frac{\\delta (z^{[k]})^{(i)}}{\\delta w^{[k-1]}} \\end{align} as you can see the first two derivatives are the same as the derivatives on the layer \\(k\\), let's denote \\((\\delta^{[k]})^{(i)} = \\frac{\\delta \\mathcal{l}((a^{[k]})^{(i)}, y^{(i)})}{\\delta (a^{[k]})^{(i)}} \\frac{\\delta (a^{[k]})^{(i)}}{\\delta (z^{[k]})^{(i)}}\\) the accumulated gradient on layer \\(k\\) for example \\(i\\), then: \\begin{align} = \\sum_{i=1}^m (\\delta^{[k]})^{(i)} \\frac{\\delta (z^{[k]})^{(i)}}{\\delta w^{[k-1]}} \\end{align} because \\((z^{[k]})^{(i)} = w^{[k]} (a^{[k-1]})^{(i)} + b^{[k]}\\): \\begin{align} = \\sum_{i=1}^m (\\delta^{[k]})^{(i)} \\frac{\\delta (w^{[k]} (a^{[k-1]})^{(i)} + b^{[k]})}{\\delta w^{[k-1]}} \\end{align} \\begin{align} = \\sum_{i=1}^m (\\delta^{[k]})^{(i)} \\frac{\\delta (z^{[k-1]})^{(i)}}{\\delta (a^{[k-1]})^{(i)}} \\frac{\\delta (a^{[k-1]})^{(i)}}{\\delta w^{[k-1]}} \\end{align} because \\((a^{[k-1]})^{(i)} = g((z^{[k-1]})^{(i)})\\) \\begin{align} = \\sum_{i=1}^m (\\delta^{[k]})^{(i)} \\frac{\\delta (z^{[k-1]})^{(i)}}{\\delta (a^{[k-1]})^{(i)}} \\frac{\\delta g((z^{[k-1]})^{(i)})}{\\delta (z^{[k-1]})^{(i)}} \\frac{\\delta (z^{[k-1]})^{(i)}}{\\delta w^{[k-1]}} \\end{align} we apply the chain rule on the last derivative, hence: \\begin{align} = \\sum_{i=1}^m (\\delta^{[k]})^{(i)} \\frac{\\delta (z^{[k-1]})^{(i)}}{\\delta (a^{[k-1]})^{(i)}} \\frac{\\delta g((z^{[k-1]})^{(i)})}{\\delta (z^{[k-1]})^{(i)}} \\frac{\\delta (z^{[k-1]})^{(i)}}{\\delta w^{[k-1]}} \\end{align} \\begin{align} = \\sum_{i=1}^m (\\delta^{[k]})^{(i)} \\frac{\\delta (z^{[k-1]})^{(i)}}{\\delta (a^{[k-1]})^{(i)}} \\frac{\\delta (a^{[k-1]})^{(i)}}{\\delta (z^{[k-1]})^{(i)}} \\frac{\\delta (z^{[k-1]})^{(i)}}{\\delta w^{[k-1]}} \\end{align} vectorization output layer accumulated gradient for layer \\(k\\): \\(\\delta_w^{[k]} = \\frac{\\delta \\mathcal{l}(\\hat{y}, y)}{\\delta a^{[k]}} \\frac{\\delta a^{[k]}}{\\delta z^{[k]}}\\) gradient for layer \\(k\\): \\(\\frac{\\delta \\mathcal{l}(\\hat{y}, y)}{\\delta w^{[k]}} = \\delta_w^{[k]} \\frac{\\delta z^{[k]}}{\\delta w^{[k]}}\\) hidden layer accumulated gradient for layer \\(k-1\\): \\(\\delta_w^{[k-1]} = \\delta_w^{[k]} \\frac{\\delta z^{[k]}}{\\delta a^{[k-1]}} \\frac{\\delta a^{[k-1]}}{\\delta z^{[k-1]}}\\) gradient for layer \\(k-1\\): \\(\\frac{\\delta \\mathcal{l}(\\hat{y}, y)}{\\delta w^{[k-1]}} = \\delta_w^{[k-1]} \\frac{\\delta z^{[k-1]}}{\\delta w^{[k-1]}}\\) graphical representation on the following image we show how to obtain the gradient of the first element of the first layer's first neuron's weights \\(w^{[1]}_{11}\\) on the first layer: improving a neural network activation functions why do we need activation functions? well, suppose you have the following network where the activation function is the identity function. that is \\(a^{[i]} = g(z^{[i]}) = z^{[i]}\\): then: \\begin{align} \\hat{y} = a^{[3]} = z^{[3]} = w^{[3]} a^{[2]} + b^{[3]} = w^{[3]} z^{[2]} + b^{[3]} = w^{[3]} (w^{[2]} a^{[1]} + b^{[2]}) + b^{[3]} \\end{align} \\begin{align} = w^{[3]} (w^{[2]} z^{[1]} + b^{[2]}) + b^{[3]} = w^{[3]} (w^{[2]} (w^{[1]} x + b^{[1]}) + b^{[2]}) + b^{[3]} \\end{align} \\begin{align} = w^{[3]} (w^{[2]} w^{[1]} x + w^{[2]} b^{[1]} + b^{[2]}) + b^{[3]} \\end{align} \\begin{align} = w^{[3]} w^{[2]} w^{[1]} x + w^{[3]} w^{[2]} b^{[1]} + w^{[3]} b^{[2]} + b^{[3]} \\end{align} if \\begin{align} w = w^{[3]} w^{[2]} w^{[1]} \\end{align} \\begin{align} b = w^{[3]} w^{[2]} b^{[1]} + w^{[3]} b^{[2]} + b^{[3]} \\end{align} then: \\begin{align} \\hat{y} = wx + b \\end{align} as you can see if we do not use activation functions, it does not mater how deep your network is, it is going to be equivalent to a linear regression. depending on the task at hand we use different activation functions: sigmoid: \\(\\sigma(z) = \\frac{1}{1 + e^{-z}}\\), it maps \\(z \\in (-\\infty, \\infty)\\) to \\((0, 1)\\) it is good for classification works well when the values are in the linear region of the function however when the values are on the extremes the gradient (slope) is very small, therefore it ends up vanishing in the network. relu: \\(relu(z) = \\begin{cases}0 & z \\leq 0 \\\\ 1 & z > 0\\end{cases}\\) tanh: \\(tanh(z) = \\frac{e^z - e^{-z}}{(e^z + e^{-z})}\\) initialization techniques usually we normalize the input to avoid having saturated activation functions. to normalize: \\begin{align} x^{(i)}_j = \\frac{x^{(i)}_j - \\mu_j}{\\sigma_j} \\end{align} for every example \\(i\\) and feature \\(j\\). where: \\(\\mu_j\\) is the mean of the \\(j\\) feature, thus: \\(\\mu_j = \\frac{1}{m} \\sum_{i=1}^m x^{(i)}_j\\) \\(\\sigma_j^2\\) is the variance of the \\(j\\) feature, thus: \\(\\sigma_j^2 = \\frac{1}{m} \\sum_{i=1}^m (x^{(i)}_j - \\mu_j)^2\\) vanishing/exploding gradients suppose you have the following network, where the activation function is the identity function and \\(b=0\\). then \\(\\hat{y} = w^{[l]} a^{[l-1]} = w^{[l]} w^{[l-1]} a^{[l-2]} = \\cdots = w^{[l]} w^{[l-1]} \\cdots w^{[1]} x\\) therefore, if: \\begin{align} w^{[l]} = \\begin{bmatrix} 1.5 & 0 \\\\ 0 & 1.5 \\\\ \\end{bmatrix} \\end{align} then: \\begin{align} \\hat{y} = \\begin{bmatrix} 1.5^l & 0 \\\\ 0 & 1.5^l \\\\ \\end{bmatrix} \\end{align} which means we end up with an exploding gradient. the inverse happens when: \\begin{align} w^{[l]} = \\begin{bmatrix} 0.5 & 0 \\\\ 0 & 0.5 \\\\ \\end{bmatrix} \\end{align} then: \\begin{align} \\hat{y} = \\begin{bmatrix} 0.5^l & 0 \\\\ 0 & 0.5^l \\\\ \\end{bmatrix} \\end{align} which results in a vanishing gradient. to avoid this somewhat, we need to initialize the weights properly. what we want is for the weights to be very close to one to avoid the exploding/diminishing problem. intuition given a single neuron: then \\(a = g(z)\\) and \\(z = w_1 x_1 + \\cdots + w_n x_n\\). we can see that \\(z\\) will increase if \\(n\\) increases, therefore we would want \\(w_i\\) to be as small as \\(n\\) is large, that is: \\begin{align} w_i = \\frac{1}{n} \\end{align} initialization techniques if we want the value of \\(w^{[l]}\\) to be proportional to the number of inputs coming from the layer \\(l\\) (\\(n^{[l-1]}\\)). it works very well for sigmoid activation: w[k] = np.random.randn(shape)*np.sqrt(1/n[l-1]) for relu: w[k] = np.random.randn(shape)*np.sqrt(2/n[l-1]) xavier initialization (used with tanh): \\(w^{[l]} \\sim \\sqrt{\\frac{1}{n^{[l-1]}}}\\) her initialization: \\(w^{[l]} \\sim \\sqrt{\\frac{2}{n^{[l]} + n^{[l-1]}}}\\) also you need to initialize the weights randomly, else you will run into the symmetry problem, where all neurons learn the same thing (that is they update very similarly). optimization mini batch gradient descent mini batch gradient descent is a trade off between batch gradient descent and stochastic gradient descent. also, because mini batch gradient descent is an approximation it introduces some noise on the loss function: however mini batch gradient descent is more used because batch gradient descent can be very computationally expensive. momentum algorithm this algorithm combines gradient descent and momentum. suppose you have the following contour plot, where the horizontal axis is much more extended that the vertical axis. by default on gradient descent the gradient of the loss will be orthogonal to the contour at the given point, as we can see: however, what we would like, so it would converge faster, is to make it move more horizontally than vertically. in order to do that we use a technique called momentum. it takes intro account past updates to find the right way to go. if you take an average of past updates, then: vertical axis: it practically cancels itself because it oscillates a lot horizontal axis: its value it's maintained because the past and present gradients go in the same direction to update the weights we apply the following equation: \\begin{align} \\upsilon = \\beta \\upsilon + (1 - \\beta) \\frac{\\delta \\mathcal{l}(\\hat{y}, y)}{\\delta w} \\end{align} where: \\(\\upsilon\\): stores past updates \\(\\frac{\\delta \\mathcal{l}(\\hat{y}, y)}{\\delta w}\\): stores the current update we average with \\(\\beta\\) and \\((1 - \\beta)\\) finally we update the weights: \\begin{align} w = w - \\alpha \\upsilon \\end{align} anexo for more info about cost function and how to derive them: anexo $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/Ecuación Normal.html",
    "title": "Ecuación Normal",
    "body": " index search search back ecuación normal descripción de los datos hipótesis funcion de coste minimización del coste anotaciones descripción de los datos \\(x = (x_{ij})\\) una matriz \\(m \\times (n + 1)\\) donde cada \\(x_{i}\\) es un vector fila \\(1 \\times (n+1)\\), que incluye los valores de todas las características para el ejemplo \\(i\\). \\begin{align} x = \\begin{bmatrix} x_1 \\\\ \\vdots \\\\ x_i \\\\ \\vdots \\\\ x_m \\\\ \\end{bmatrix} \\end{align} cabe destacar que \\(x_{i0} = 1\\), es el término independiente. \\(\\theta = (\\theta_i)\\) es un vector columna \\((n+1)\\times 1\\) donde cada \\(\\theta_i\\) es el peso de la característica \\(i\\), tal que: \\begin{align} \\theta = \\begin{bmatrix} \\theta_0 \\\\ \\vdots \\\\ \\theta_n\\end{bmatrix} \\end{align} \\(y = (y_j)\\) es un vector columna \\(m\\times 1\\) donde cada \\(y_j\\) es la salida real para el ejemplo \\(j\\), tal que: \\begin{align} y = \\begin{bmatrix} y_1 \\\\ \\cdots \\\\ y_m\\end{bmatrix} \\end{align} hipótesis dado un conjunto de \\(m\\) datos, es decir matriz \\(x\\), de dimensiones \\(m \\times (n+1)\\), la hipótesis se define como: \\begin{align} h_\\theta(x) = x \\cdot \\theta = \\begin{bmatrix} x_1 \\cdot \\theta = \\sum_{i=0}^{n+1} \\theta_i x_{1i} \\\\ \\vdots \\\\ x_j \\cdot \\theta = \\sum_{i=0}^{n+1} \\theta_i x_{ji} \\\\ \\vdots \\\\ x_m \\cdot \\theta = \\sum_{i=0}^{n+1} \\theta_i x_{mi} \\\\ \\end{bmatrix} \\end{align} observa que ahora \\(x\\) y \\(\\theta\\) están colocados de forma inversa a como lo hacíamos en la regresión lineal y la regresión logística. esto es debido a que hemos transpuesto las matrices \\(x\\) y \\(\\theta\\), con respecto a como las habíamos definido en las secciones anteriores. el cálculo es el mismo. funcion de coste se define la función de coste, \\(j(\\theta)\\) como: \\begin{align} j(\\theta) = \\frac{1}{2m} (x\\theta - y)^t(x\\theta - y) \\end{align} la expresión \\((x\\theta - y)^t(x\\theta - y)\\) es equivalente a \\((h_\\theta(x) - y)^2\\), que se utilizaba en la función de coste de la regresión lineal. regularización con regularización, se define la función de coste, \\(j(\\theta)\\) como: \\begin{align} j(\\theta) = \\frac{1}{2m} (x\\theta - y)^t(x\\theta - y) + \\frac{1}{2m} \\lambda \\theta^t\\theta \\end{align} minimización del coste con la ecuación normal, en lugar de actualizar el vector de pesos \\(\\theta\\) de forma iterativa, lo que hacemos es igualar la derivada del coste en base a los pesos a cero utilizando derivación matricial: \\[%align \\delta_\\theta j(\\theta) = \\begin{bmatrix} \\frac{\\delta j(\\theta)}{\\delta \\theta_0} \\\\ \\vdots \\\\ \\frac{\\delta j(\\theta)}{\\delta \\theta_i} \\\\ \\vdots \\\\ \\frac{\\delta j(\\theta)}{\\delta \\theta_n} \\\\ \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ \\vdots \\\\ 0 \\\\ \\vdots \\\\ 0 \\\\ \\end{bmatrix} = \\overrightarrow{0} \\] a continuación exponemos cómo se calcula la derivada: sustituímos la función de coste: \\[%align \\delta_\\theta j(\\theta) = \\delta_\\theta \\frac{1}{2m}(x \\theta - y)^t (x \\theta - y) \\] aplicamos la propiedad \\((a + b)^t = a^t + b^t\\) \\[%align \\delta_\\theta j(\\theta) = \\delta_\\theta \\frac{1}{2m}((x\\theta)^t - y^t) (x \\theta - y) \\] sacamos el factor constante de la derivada y realizamos la multiplicación: \\[%align \\delta_\\theta j(\\theta) = \\frac{1}{2m} \\delta_\\theta (x\\theta)^t(x\\theta) - (x\\theta)^ty -y^tx\\theta + y^ty \\] aplicamos la propiedad \\(ab = b^ta^t\\), tal que \\(y^t(x\\theta) = (x\\theta)^t((y)^t)^t = (x\\theta)^ty\\) \\[%align \\delta_\\theta j(\\theta) = \\frac{1}{2m} \\delta_\\theta (x\\theta)^t(x\\theta) - (x\\theta)^ty - (x\\theta)^ty + y^ty \\] agrupamos términos compatibles: \\[%align \\delta_\\theta j(\\theta) = \\frac{1}{2m} \\delta_\\theta (x\\theta)^t(x\\theta) - 2(x\\theta)^ty + y^ty \\] como \\(\\delta_\\theta y^ty=0\\): \\[%align \\delta_\\theta j(\\theta) = \\frac{1}{2m} \\delta_\\theta (x\\theta)^t(x\\theta) - 2(x\\theta)^ty \\] finalmente calculamos la derivada matricial: \\[%align \\delta_\\theta j(\\theta) = \\frac{1}{2m} 2x^t(x\\theta) - 2x^ty = \\frac{1}{m} x^t(x\\theta) - x^ty \\] ahora igualamos la expresión obtenida a cero: \\[%align \\delta_\\theta j(\\theta) = \\frac{1}{m} [x^tx\\theta - x^ty] = 0 \\] multiplicamos por \\(m\\) en ambos lados de la ecuación: \\[%align x^tx\\theta - x^ty = 0 \\] sumamos \\(x^ty\\) en ambos lados de la ecuación: \\[%align x^tx\\theta - x^ty + x^ty= x^ty \\] \\[%align x^tx\\theta = x^ty \\] multiplicamos por \\((x^tx)^{-1}\\) por la izquierda en ambos lados de la ecuación: \\[%align (x^tx)^{-1}x^tx\\theta = (x^tx)^{-1}x^ty \\] \\[%align i\\theta = (x^tx)^{-1}x^ty \\] \\[%align \\theta = (x^tx)^{-1}x^ty \\] de tal manera que ahora hemos calculado el vector de pesos óptimo que minimiza el coste. regularización con regularización debemos derivar la función que coste que incluye el parámetro de regularización: \\begin{align} j(\\theta) = \\frac{1}{2m} (x\\theta - y)^t(x\\theta - y) + \\frac{1}{2m} \\lambda \\theta^t\\theta \\end{align} el primer término ya lo hemos derivado, por lo tanto procedemos a derivar el segundo término: \\[%align \\delta_\\theta \\frac{1}{2m} \\lambda \\theta^t\\theta \\] sacamos el factor constante \\(\\frac{\\lambda}{2m}\\) fuera de la derivada \\[%align \\frac{\\lambda}{2m} \\delta_\\theta [\\theta^t\\theta] \\] llevamos a cabo la derivada matricial: \\[%align \\frac{\\lambda}{2m} 2 \\theta = \\frac{\\lambda}{m} \\theta \\] juntamos las derivadas de ambos términos: \\[%align \\delta_\\theta j(\\theta) = \\frac{1}{m} [x^tx\\theta - x^ty] + \\frac{\\lambda}{m} \\theta \\] sacamos \\(\\frac{1}{m}\\) como factor común e igualamos a cero \\[%align \\delta_\\theta j(\\theta) = \\frac{1}{m} (x^tx\\theta - x^ty + \\lambda\\theta) = 0 \\] multiplicamos por \\(m\\) en ambos lados de la ecuación: \\[%align x^tx\\theta - x^ty + \\lambda\\theta = 0 \\] sumamos \\(x^ty\\) en ambos lados de la ecuación: \\[%align x^tx\\theta - x^ty + x^ty + \\lambda\\theta = x^ty \\] \\[%align x^tx\\theta + \\lambda\\theta = x^ty \\] sacamos \\(\\theta\\) como factor común \\[%align (x^tx + \\lambda i)\\theta = x^ty \\] donde \\(i\\) es la matriz identidad e dimensiones \\((n+1) \\times (n+1)\\). multiplicamos \\((x^tx + \\lambda i)^{-1}\\) por la izquierda en ambos lados de la ecuación: \\[%align (x^tx + \\lambda i)^{-1}(x^tx + \\lambda i)\\theta = (x^tx + \\lambda i)^{-1}x^ty \\] \\[%align i\\theta = (x^tx + \\lambda i)^{-1}x^ty \\] \\[%align \\theta = (x^tx + \\lambda i)^{-1}x^ty \\] de tal forma que hemos calculado el \\(\\theta\\) óptimo que minimiza el coste, utilizando regularización. anotaciones no se debe utilizar la ecuación normal cuando el número de ejemplos \\(m\\) es muy grande, ya que es rendimiento del algoritmo es malo hay que tener cuidado con si las matrices son inversibles si \\(m \\leq n\\), entonces las matrices no son invertibles. si \\(\\lambda > 0\\), entonces aseguramos la inversibilidad de las matrices. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/index.html",
    "title": "Machine Learning Stanford Coursera",
    "body": " index search search back machine learning stanford coursera apredizaje supervisado regresión lineal regresión logística ecuación normal neural networks gradient checking inicialización aleatoria evaluación de modelos svm aprendizaje no supervisado en el aprendizaje no supervisado, los ejemplos de entrenamiento no tienen etiquetas (\\(y\\)). se utilizan para buscar correlación y patrones en los ejemplos de entrenamiento. clustering dimensionality reduction expectation-maximization algorithms sistemas de recomendación grandes datasets aprendizaje online map reduce datos artificiales ceiling analysis $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/Aprendizaje Online.html",
    "title": "Aprendizaje Online",
    "body": " index search search back aprendizaje online en estos tipos de problemas se generan datos de forma continua, tal que para cada nuevo dato: obtenemos \\((x, y)\\) actualizamos \\(\\theta\\) utilizando el nuevo ejemplo: \\(\\theta_j = \\theta_j - \\alpha (h_\\theta(x) - y)x_j\\) ejemplo aprender a buscar. supongamos que lo queremos aprender es aquellos resultados que le interesen más al usuario. si tenemos los siguientes datos: \\(x\\): características del producto \\(y\\): si el usuario hace click entonces, lo que queremos aprender es \\(p(y= 1|x;\\theta)\\), tal que por ejemplo enseñemos los 10 productos cuya probabilidad es mayor. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/Datos Artificiales.html",
    "title": "Datos Artificiales",
    "body": " index search search back datos artificiales cómo podemos generar datos? manualmente modificando los datos de entrada (añadir ruido en sonido, distorsionar imagen, etc) no obstante, debemos evitar añadir ruido aleatorio, ya que esto no ayuda a extraer características significativas del conjunto de datos. estos métodos se suelen utilizar si el modelos tiene un sesgo bajo y se produce underfitting, (por lo que hace falta añadir características). $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/Inicialización aleatoria.html",
    "title": "Inicialización aleatoria",
    "body": " index search search back inicialización aleatoria cuando creamos una red neuronal, si inicializamos todos los pesos \\(\\theta\\) a cero, entonces todos los nodos serán iguales. por ello se inicializa \\(\\theta\\) con valores aleatorios dentro de un rango \\([- \\epsilon, \\epsilon]\\) $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/DimensionalityReduction/Dimensionality Reduction.html",
    "title": "Dimensionality Reduction",
    "body": " index search search back dimensionality reduction standardize data pca find underlying space represent the subspace algorithm layout performing eigen decomposition ica intuition solution given examples \\(\\{x^{(i)}\\}_{i=1}^n\\) where \\(x^{(i)} \\in \\mathbb{r}^d\\), we want to find out if our data lives is a low dimensional space. look at the next example: we can see that the two features are correlated, and we can project the points onto a line, reducing the space from two dimensions to one. so it might be the case that some features are highly correlated, and so de d-dimensional space can be as a k-dimensional space where \\(0 < k < d\\): \\begin{align} \\begin{bmatrix} x_{11} & \\cdots & x_{1d} \\\\ \\vdots & \\ddots & \\vdots \\\\ x_{n1} & \\cdots & x_{nd} \\\\ \\end{bmatrix} \\rightarrow \\begin{bmatrix} x_{11} & \\cdots & x_{1k} \\\\ \\vdots & \\ddots & \\vdots \\\\ x_{n1} & \\cdots & x_{nk} \\\\ \\end{bmatrix} \\end{align} standardize data a lot of the times the units of each feature in the data make the values in one column (feature) be much bigger than the values in another column. thus, the first step is to standardize your data: center data have it have variance equal to one so we transform our data as follows: \\begin{align} x_j^{(i)} = \\frac{x_j^{(i)} - \\mu_j}{\\sigma_j} \\end{align} where: \\(u_j\\) is the mean of the feature \\(j\\) over the \\(n\\) examples, such that \\(u_j = \\frac{1}{n}\\sum_{i=1}^nx^{(i)}_j\\) \\(\\sigma_j\\) is the standard deviation of the feature \\(j\\) over the \\(n\\) examples, where \\(\\sigma_j^2 = \\frac{1}{n}\\sum_{i=1}^n(x^{(i)}_j - \\mu_j)^2\\) pca find underlying space to reduce the dimensionality of our data we first define a subspace and then we project each point onto the subspace. this projection is the closes point in the subspace to the point we are trying to project, this has as a consequence that the \"line\" connecting the point to its projection is always perpendicular to the subspace: the goal is to choose the subspace that maximizes the variance of the projected points, to retain the maximum possible variance of the data. as you can see if we choose the blue line as the subspace the variance is much bigger that if we choose the red line: represent the subspace let us suppose the subspace is defined by a basis vector \\(u \\in \\mathbb{r}^d\\) where \\(u\\) is a unit vector, then projection of \\(\\overrightarrow{x^{(i)}}\\) on to the space spanned by \\(u\\) will be: \\begin{align} proj(u)\\overrightarrow{x^{(i)}} \\end{align} where \\(proj(u)\\) is the projection matrix and \\(x^{(i)} \\in \\mathbb{r}^d\\). so, because \\(proj(u) = \\frac{uu^t}{u^tu}\\), then the projected point is defined as: \\begin{align} proj(u)\\overrightarrow{x^{(i)}} = \\frac{uu^t}{u^tu} \\overrightarrow{x^{(i)}} = ((x^{(i)})^tu)u \\end{align} where \\(((x^{(i)})^tu)\\) is an scalar. so, now our goal is to find a \\(u\\) that maximizes the variance across the \\(n\\) examples. that is, we want to maximize the sum of the square of the norms of the projected points: more formally: \\begin{align} u = \\underset{u}{\\arg \\max} \\frac{1}{n}\\sum_{i=1}^n ||proj(u)x^{(i)}||^2 = \\frac{1}{n}\\sum_{i=1}^n ||((x^{(i)})^tu)u||^2 \\end{align} because the norm of a unit vector multiplied by a scalar is just the square of the scalar (for \\(3 \\cdot \\begin{pmatrix} 1 & 0 & 0 \\end{pmatrix}\\): \\(||\\begin{pmatrix} 3 & 0 & 0 \\end{pmatrix}|| = (\\sqrt{3^2 + 0^2 + 0^2})^2 = 3^2\\)): \\begin{align} u = \\underset{u}{\\arg \\max} \\frac{1}{n}\\sum_{i=1}^n ((x^{(i)})^tu)^2 = \\frac{1}{n}\\sum_{i=1}^n ((x^{(i)})^tu)^t((x^{(i)})^tu) = \\frac{1}{n}\\sum_{i=1}^n u^t x^{(i)} (x^{(i)})^t u \\end{align} because \\(u, u^t\\) are a common factor in the sum: \\begin{align} u = \\underset{u}{\\arg \\max} \\left[u^t \\left(\\frac{1}{n}\\sum_{i=1}^n x^{(i)} (x^{(i)})^t \\right) u\\right] \\end{align} now, we know that given the optimization problem of the form \\(\\underset{u}{\\arg \\max} \\left[u^t a u\\right]\\), the solution \\(u\\) is the eigenvector corresponding to the largest eigenvalue of \\(a\\). in this scenario, \\(a = \\left(\\frac{1}{n}\\sum_{i=1}^n x^{(i)} (x^{(i)})^t \\right)\\), which equals the sample covariance matrix, which is defined as: \\begin{align} \\frac{1}{n} \\sum_{i=1}^n (x^{(i)} - \\mu)^t (x^{(i)} - \\mu) = \\frac{1}{n} \\sum_{i=1}^n (x^{(i)} - 0)^t (x^{(i)} - 0) = \\frac{1}{n} \\sum_{i=1}^n (x^{(i)})^t x^{(i)} \\end{align} note that, because our data is now centered after standardizing it, the mean \\(\\mu\\) equals zero. hence, we want to calculate the eigenvectors of the sample covariance matrix of x. mind you, we have derived this solution for a space defined by only one vector \\(u\\). however given basis vectors \\((u_1, \\cdots, u_k)\\) the optimization problem holds and the solution are the \\(k\\) eigenvectors corresponding to the \\(k\\) largest eigenvalues of \\(a\\). algorithm layout the steps of pca are the following: calculate the sample covariance matrix as \\(x^tx\\) calculate the eigenvector and eigenvalues of \\(x^tx\\), such that: \\begin{align} \\begin{matrix} (\\lambda_1, u_1) \\\\ (\\lambda_2, u_2) \\\\ \\vdots \\\\ (\\lambda_d, u_d) \\\\ \\end{matrix} \\end{align} are the \\(d\\) eigenvectors (\\(u_i\\)) and eigenvalues (\\(\\lambda_i\\)). we assume the tuples are ordered in decreasing order with respect to the eigenvalues, such that if \\(i > j\\) then \\(\\lambda_i > \\lambda_j\\). find \\(k\\) such that we satisfy a confidence level with respect to the variance, i.e. suppose you want to preserve 95% of the variance of the original data then: \\begin{align} \\frac{\\sum_{i=1}^k \\lambda_i}{\\sum_{j=1}^d \\lambda_j} = 95\\% \\end{align} choose the \\(k\\) eigenvectors with the largest corresponding eigenvalues. performing eigen-decomposition first of all, let us present two properties regarding eigen-decompositions of a matrix \\(x\\): if \\(x\\) is a square matrix and symmetric then \\(x\\) has orthogonal eigenvectors and real eigenvalues. if \\(x\\) is also positive semi-definite then the eigenvalues are positive. in our case, the eigen-decomposition is done over \\(x^tx\\), therefore this matrix is guaranteed to be a square matrix, symmetric and positive semi-definite. then, performing the eigen decomposition of \\(x^tx\\) is equivalent to performing singular value decomposition (svd) over \\(x\\), such that the single values equal the square root of the eigenvalues. large datasets to perform pca on large datasets we use a technique called power iteration, which consists on: for \\(i=0\\), initialize \\(u^{(i)}\\) to random values other than zero set \\(i = i+1\\), and \\(u^{(i)} = (x^tx)u^{(i-1)}\\) re-scale \\(u^{(i)}\\) to have unit length such that: \\(u^{(i)}=\\frac{(x^tx)u^{(i-1)}}{||(x^tx)u^{(i-1)}||}\\) go to step 2. eventually it will converge to the largest eigenvector. rephrasing pca another way to describe the problem solved by pca, equivalent to the maximization variance perspective, is: find a subspace such that the projection of the points are as close to the original data as possible, that is minimize the sum of the distances between the projected points and the original points. ica this algorithm pretends to solve what is commonly known as the source separation problem, where we are given a dataset \\(x\\) that is a mixture of some source data \\(s\\). we then use these mixed sources \\(x\\) to construct a unmixing matrix \\(w\\) to recover the source \\(s\\). intuition imagine there are \\(d\\) speakers and \\(d\\) microphones randomly distributed in a room, such that: \\(s \\in \\mathbb{r}^d\\) is the representation of what a speaker says. so \\(s_j^{(i)}\\) is what the \\(j\\) speaker said in moment \\(i\\). \\(x \\in \\mathbb{r}^d\\) is the representation of what a microphone records. so \\(x_j^{(i)}\\) is what the \\(j\\) microphone recorded in moment \\(i\\). for example, given two speaker, what they say is represented as follows: meanwhile the recordings of the microphones are the following: we are only given \\(x\\), and the goal is to recover the original speech signal spoken by each speaker. we assume that \\(x\\) is a linear combination of what each speaker says, thus \\(x = as\\), where \\(a\\) is a quare matrix \\(d \\times d\\) and is called the mixing matrix. what we want to do is to compute the inverse of \\(a\\), \\(w\\) such that \\(w = a^{-1}\\), where \\(w\\) is called the unmixing matrix. then: \\begin{align} a^{-1}x = a^{-1}as \\rightarrow a^{-1}x = s \\rightarrow wx = s \\rightarrow s = wx \\end{align} solution to solve this problem we make the following assumptions: the number of sources \\(s\\) are equal to the number of \"examples\" in the mixed dataset \\(x\\) \\(x\\) is a linear combination of \\(s\\), such that \\(s = wx\\) \\(s_j\\) is independent of \\(s_k\\), whenever \\(j \\neq k\\). that is to say, each belongs to a different probability distribution, and are two independent random variables. each \\(s_j\\) is not gaussian. intuition suppose we are given a random variable \\(x\\) such that \\(x ~ unif [0,1]\\), then the probability density function is: let us define a new distribution as follows \\(y=2x\\), then the probability density function is: note, that the function is \"stretched\" as to always satisfy the condition that the integral of \\(pdf\\) must equal 1, which is the same as saying the area under the function is 1. so now, \\(p_y (y) = p_x(x) \\cdot \\frac{1}{2} = p_x(\\frac{y}{2})\\cdot\\frac{1}{2}\\), because \\(x = \\frac{y}{2}\\). but what happens in a higher dimension? that is, what happens when we multiply \\(x \\in \\mathbb{r}^d\\) by a mixing matrix \\(w \\in \\mathbb{r}^{d \\times d}\\). well, given \\(y \\in \\mathbb{r}^{d \\times d}\\), such that \\(y=wx\\), then to perform a change of random variable we use the jacobian: \\begin{align} p_y(y) = p_x(x)\\frac{1}{|w|} = p_x(w^{-1}y)\\frac{1}{|w|} \\end{align} where \\(|w|\\) is the determinant of \\(w\\). first of all we define the distribution of the mixed dataset as follows: \\begin{align} p_x(x) = \\prod_{j=1}^d p_s (s_j) |w| = \\prod_{j=1}^d p_s (w_j^tx) |w| \\end{align} note that \\(s_j=(w_j)^tx\\). we also assume that \\(p_s\\) is distributed according to a logistic distribution, thus: cumulative distribution function (cdf): \\(\\frac{1}{1+e^{-x}} = \\sigma(x)\\) probability density function (pdf): \\(\\sigma(x)\\sigma(1-x)\\) so, we obtain the likelihood of \\(w\\) as follows: \\begin{align} l(w) = \\sum_{i=1}^n \\left[\\left(\\sum_{j=1}^d \\log[\\sigma(x^{(i)})(1-\\sigma(x^{(i)}))]\\right) + \\log{|w|}\\right] \\end{align} where \\(w\\) is the parameter we are trying to obtain. so, to solve the optimization problem: we define the maximization of the likelihood as the objective we compute the derivative of \\(l(w)\\) and perform gradient descent, such that the update step is as follows: \\begin{align} w = w - \\alpha \\left\\{\\begin{bmatrix} (1- 2\\sigma(w_1^tx^{(i)})) \\\\ (1- 2\\sigma(w_2^tx^{(i)})) \\\\ \\vdots \\\\ (1- 2\\sigma(w_d^tx^{(i)})) \\\\ \\end{bmatrix} (x^{(i)})^t + (w^t)^{-1} \\right\\} \\end{align} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/Sistemas de Recomendación.html",
    "title": "Sistemas de Recomendación",
    "body": " index search search back sistemas de recomendación dados los parámetros: \\(n_\\mu\\): número de usuarios \\(n_m\\): número de ítems valorables \\(r(i,j)\\): marcador de si el ítem ha sido valorado, tal que: \\begin{align} r(i, j) = \\begin{cases} 1, & \\text{ si el usuario j ha valorado el ítem i} \\\\ 0, & \\text{ en cualquier otro caso} \\end{cases} \\end{align} \\(y^{(i, j)}\\): valoración del usuario \\(j\\) al ítem \\(i\\). el objetivo de un sistema de recomendación es predecir los valores de las valoraciones donde \\(r(i, j) \\neq 1\\) (es decir predecir las valoraciones de usuarios hacia ítems que no han valorado con anteioridad) content based recommendations cada ítem está definido por \\(n\\) características. para cada usuario \\(j\\), debemos obtener \\(\\theta^{(j)} \\in \\mathbb{r}^{n+1}\\), de tal manera que para predecir la valoración de \\(x^{(i)} \\rightarrow h_\\theta(x^{(i)}) = (\\theta^{(j)})^t x^{(i)}\\) función de coste sea \\(m^{(j)}\\) el número de ítems valorados por el usuario \\(j\\), entonces la función de coste se define como: \\begin{align} j(\\theta) = \\frac{1}{2m^{(j)}}\\sum_{j=1}^{n_\\mu} \\sum_{i; r(i, j) = 1} ((\\theta^{(j)})^t x^{(i)} - y^{(i, j)})^2 + \\frac{\\lambda}{2m^{(j)}} \\sum_{k=1}^{n_\\mu} \\theta^{(j)}_k \\end{align} donde \\(\\theta = \\{\\theta_1, \\cdots, \\theta_{n_\\mu}\\}\\) es decir queremos minimizar la \"distancia\" entre lo predicho \\((\\theta^{(j)})^t x^{(i)}\\) para el ítem (que ha sido valorado, por lo tanto \\(r(i, j) = 1\\)) y el usuario \\(i\\) y la valoración real \\(y^{(i, j)}\\). descenso gradiente lo que queremos es minimizar el coste, por lo tanto, calculamos \\(\\frac{\\delta j(\\theta)}{\\delta \\theta_j}\\) para obtener el vector en dirección al mayor incremento en la función, seguidamente, utilizar su opuesto, obtenemos el vector que apunta a la dirección de menor incremento. es decir, aplicamos descenso gradiente como sigue: para \\(k = 0\\): \\begin{align} \\theta_k^{(j)} = \\theta_k^{(j)} - \\alpha \\left(\\sum_{i; r(i,j)=1} (\\theta^{(j)})^tx^{(i)} - y^{(i,j)}x^{(i)}_k \\right) \\end{align} para \\(k \\neq 0\\): \\begin{align} \\theta_k^{(j)} = \\theta_k^{(j)} - \\alpha \\left(\\sum_{i; r(i,j)=1} (\\theta^{(j)})^tx^{(i)} - y^{(i,j)}x^{(i)}_k + \\lambda \\theta_k^{(j)} \\right) \\end{align} collaborative filtering collaborative filtering consiste en calcular las características de cada usuario (ejemplo \\(x^{(i)}\\)) en función de los pesos \\(\\theta^{(j)}\\). una vez hecho esto se calculan los pesos óptimos que que minimizan la función de coste y volvemos a obtener las características de cada usuario en función de estes nuevos pesos. este proceso se describe más formalmente a continuación: problema de optimización el problema de optimización se describe como sigue: dados \\(\\theta^{(1)}, \\cdots, \\theta^{n_\\mu}\\): para un ejemplo \\(x^{(i)}\\) \\begin{align} \\underset{x^{(i)}}{\\min{}} \\frac{1}{2} \\sum_{j:r(i,j)=1} ((\\theta^{(j)})^tx^{(i)} - y^{(i,j)})^2 + \\frac{\\lambda}{2} \\sum_{k=1}^n (x_k^{(i)})^2 \\end{align} para todos los ejemplos del conjunto \\(x^{0}, \\cdots, x^{(n_m)}\\): \\begin{align} \\underset{x^{(1)}, \\cdots, x^{(n_m)}}{\\min{}} \\frac{1}{2} \\sum_{i=1}^{n_m} \\sum_{j:r(i,j)=1} ((\\theta^{(j)})^tx^{(i)} - y^{(i,j)})^2 + \\frac{\\lambda}{2} \\sum_{i=1}^{n_m}\\sum_{k=1}^n (x_k^{(i)})^2 \\end{align} es decir queremos minimizar la \"distancia\" entre lo predicho \\((\\theta^{(j)})^t x^{(i)}\\) para el ítem (que ha sido valorado, por lo tanto \\(r(i, j) = 1\\)) y el usuario \\(i\\) y la valoración real \\(y^{(i, j)}\\). además como queremos obtener los valores de \\(x\\) que minimizan el coste, los añadimos como coste a problema de optimización para evitar overfitting. algoritmo el algoritmo consta de los siguientes pasos: inicializar \\(x^{(1)}, \\cdots, x^{(m)}\\) y \\(\\theta^{(1)}, \\cdots, \\theta^{(n_\\mu)}\\) de forma aleatoria. calcular \\(x\\) a partir de \\(\\theta\\) calcular \\(\\theta\\) a partir de \\(x\\) volvemos al paso 2. es decir, queremos obtener \\(x\\) y \\(\\theta\\) que optimice el siguiente problema: \\begin{align} \\underset{x^{(1)}, \\cdots, x^{(n_m)}, \\theta^{(1)}, \\cdots, \\theta^{(n_\\mu)}}{\\min{}} \\frac{1}{2} \\sum_{i=1}^{n_m} \\sum_{j:r(i,j)=1} ((\\theta^{(j)})^tx^{(i)} - y^{(i,j)})^2 + \\frac{\\lambda}{2} \\sum_{i=1}^{n_m}\\sum_{k=1}^n (x_k^{(i)})^2 + \\frac{\\lambda}{2} \\sum_{i=1}^{n_\\mu}\\sum_{k=1}^n (\\theta_k^{(i)})^2 \\end{align} observa que, como estamos optimizando tanto \\(\\theta\\) como \\(x\\), entonces los añadimos como coste a la función de optimización para evitar overfitting: \\(\\frac{\\lambda}{2} \\sum_{i=1}^{n_m}\\sum_{k=1}^n (x_k^{(i)})^2\\) \\(\\frac{\\lambda}{2} \\sum_{i=1}^{n_\\mu}\\sum_{k=1}^n (\\theta_k^{(i)})^2\\) para aplicar la optimización utilizamos descenso gradiente: primero en función de \\(x\\) y después en función de \\(\\theta\\): \\begin{align} x^{(i)}_k = x^{(i)}_k - \\alpha \\left( \\sum_{j:r(i, j)=1} ((\\theta^{(j)})^t x^{(i)} - y^{(i, j)}) \\theta_k^{(j)} + \\lambda x^{(i)}_k\\right) \\end{align} \\begin{align} \\theta^{(j)}_k = \\theta^{(j)}_k - \\alpha \\left( \\sum_{i:r(i, j)=1} ((\\theta^{(j)})^t x^{(i)} - y^{(i, j)}) x_k^{(i)} + \\lambda \\theta^{(j)}_k\\right) \\end{align} buscar ítems relacionados si \\(||x^{(i)} - x^{(j)}\\)|| es un valor pequeño entonces los ítems \\(i\\) y \\(j\\) son similares. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/Clustering.html",
    "title": "Clustering",
    "body": " index search search back clustering k-means escogemos e inicializamos \\(k\\) centroides que servirán para hacer de clústers. para cada ejemplo \\(j\\): asignamos el centroide más cercano una vez asignados todos los ejemplos, resituamos cada centroide en función de los ejemplos asignados al mismo. volvemos al paso 2. algoritmo entrada: número de clústers \\(k\\) conjunto de entrenamiento: \\(\\{x^{(0)}, \\cdots, x^{(m)}\\}\\), con \\(x^{(i)} \\in \\mathbb{r}^n\\) inicializamos los \\(k\\) centroides \\((\\mu_1, \\cdots, \\mu_k) \\in \\mathbb{r}^n\\) de forma aleatoria. repetimos: para cada ejemplo \\(x^{(j)}\\), \\(c^{(j)}\\) es el índice del centroide más cercano a \\(x^{(j)}\\): \\(\\underset{i}{min}||x^{(j)} - \\mu_i||\\) para cada clúster: \\(\\mu_i\\) es la media de los puntos \\(x^{(j)}\\) asignados al centroide \\(i\\): \\(\\mu_i = \\frac{1}{t} \\left[\\sum_{j=1}^t x^{(j)} \\text{ donde } c^{(j)} = i\\right]\\), donde \\(t\\) es el número de ejemplos asignados al centroide \\(i\\). si el centroide no tiene puntos, se elimina o se vuelve a inicializar de forma aleatoria. clústers no claramente separables cuando los datos contienen mucho ruido lo que se hace es resolver el siguiente problema de optimización: \\begin{align} \\underset{c^{(1)}, \\cdots, c^{(m)}, \\mu_1, \\cdots, \\mu_k}{min} j(c^{(1)}, \\cdots, c^{(m)}, \\mu_1, \\cdots, \\mu_k) \\end{align} donde la función de coste \\(j\\) se define como: \\begin{align} j(c^{(i)}, \\mu_i) = \\frac{1}{m} \\sum_{i=1}^m ||x^{(i)} - \\mu_{c^{(i)}}||^2 \\end{align} es decir, el coste es equivalente a la suma de la distancia entre el ejemplo \\(x^{(i)}\\) y su clúster asignado \\(\\mu_{c^{(i)}}\\), para cada ejemplo. el algoritmo de optimización lo que hace es: minimiza el coste con respecto a \\(c\\) minimiza el coste con respecto a \\(\\mu\\) inicialización aleatoria debemos escoger un número de centroides \\(k\\) menor que el número de ejemplos \\(m\\). inicializamos cada centroide equivalente a un ejemplo aleatorio del conjunto de entrenamiento: \\(\\mu_i = x^{(j)}\\) hay que tener en cuenta que, en función de la inicialización de los centroides, se pueden obtener distintos resultados en el problema de optimización, por ello lo que se hace es: aplicar el algoritmo muchas veces escoger el modelo que obtuvo menor coste este proceso es viable si el número de clústers es pequeño. parametrización de clústering una forma de escoger el número de clústers \\(k\\) es utilizando el método del codo: se aplica el modelo con un número distinto de clústers se evalúa con alguna métrica el rendimiento (coste) del modelo y se elige el ofrece una mayor mejora con respecto a un número de clústers menor $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/Regresión Logística.html",
    "title": "Regresión Logística",
    "body": " index search search back regresión logística descripción de los datos hipótesis funcion de coste descenso gradiente descripción de los datos \\(x = (x_{ij})\\) una matriz \\(n \\times m\\) donde cada \\(x_{ij}\\) es la característica \\(i\\) del ejemplo \\(j\\), tal que \\begin{align} x = \\begin{bmatrix} x_{11} & \\cdots & x_{1m} \\\\ \\cdots & \\ddots & \\cdots \\\\ x_{n1} & \\cdots & x_{nm} \\\\ \\end{bmatrix} \\end{align} cada columna es un ejemplo en cada fila están los valores de una característica \\(\\theta = (\\theta_i)\\) es un vector fila \\(1\\times n\\) donde cada \\(\\theta_i\\) es el peso de la característica \\(i\\), tal que: \\begin{align} \\theta = \\begin{bmatrix} \\theta_1 & \\cdots & \\theta_n\\end{bmatrix} \\end{align} \\(y = (y_j)\\) es un vector fila \\(1\\times m\\) donde cada \\(y_j\\) es la salida real para el ejemplo \\(j\\), tal que: \\begin{align} y = \\begin{bmatrix} y_1 & \\cdots & y_m\\end{bmatrix} \\end{align} donde cada salida \\(y_j\\), para un clasificador de dos clases sólo puede tener los valores \\(0\\) o \\(1\\). hipótesis para un valor \\(z\\), la función sigmoide \\(g\\) se define como: \\begin{align} g(z) = \\frac{e^z}{(1+e^z)} = \\frac{1}{(1 + e^{-z})} \\end{align} sea \\(g\\) la función sigmoide. dado un ejemplo, es decir un vector columna \\(x\\), de dimensiones \\(n \\times 1\\), la hipótesis se define como: \\begin{align} h_\\theta(x) = g\\left(\\sum_{i=1}^n \\theta_i \\cdot x_i\\right) = \\begin{cases} 0, & h_\\theta(x) < 0.5 \\\\ 1, & h_\\theta(x) \\geq 0.5 \\\\ \\end{cases} \\end{align} dado un conjunto de \\(m\\) datos, es decir matrix \\(x\\), de dimensiones \\(n \\times m\\), la hipótesis se define como: \\begin{align} h_\\theta(x) = \\theta\\cdot x = \\begin{bmatrix}g(\\sum_{i=1}^n \\theta_i \\cdot x_{i1}) & \\cdots & g(\\sum_{i=1}^n \\theta_i \\cdot x_{im})\\end{bmatrix} \\end{align} el resultado es un vector fila \\(1 \\times m\\), es decir como el vector de salidas \\(y\\) funcion de coste se define la función de coste, \\(j(\\theta)\\) como: \\begin{align} j(\\theta) = \\frac{1}{m}\\sum_{j=1}^m \\text{coste}(h_\\theta(x_j)) \\end{align} donde \\(\\text{coste}\\) es una función definida como sigue: \\begin{align} \\text{coste}(h_\\theta(x_j)) = [-y_j \\log(h_\\theta(x_j))] - [(1-y_j)\\log(1-h_\\theta(x_j))] \\end{align} regularización con regularización, se define la función de coste, \\(j(\\theta)\\) como: \\begin{align} j(\\theta) = -\\frac{1}{m}\\sum_{j=1}^m [y_j \\log(h_\\theta(x_j))] + [(1-y_j)\\log(1-h_\\theta(x_j))] + \\frac{1}{2m} \\lambda \\sum_{i=1}^n \\theta_i^2 \\end{align} descenso gradiente para actualizar el vector de pesos \\(\\theta\\) aplicamos el descenso gradiente. para cada peso \\(\\theta_i\\): \\begin{align} \\theta_i = \\theta_i - \\alpha \\left( \\frac{\\delta j(\\theta)}{\\delta \\theta_i}\\right) \\end{align} la derivada del coste en función del peso \\(\\theta_i\\) se calcula como sigue: sustituimos la función de coste \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_i} = \\frac{\\delta}{\\delta \\theta_i} \\left(-\\frac{1}{m}\\sum_{j=1}^m [y_j \\log(h_\\theta(x_j))] + [(1-y_j)\\log(1-h_\\theta(x_j))]\\right) = \\end{align} sacamos el factor constante \\(\\frac{1}{m}\\) y aplicamos la propiedad \"la derivada de una suma equivale a la suma de las derivadas\", tal que: \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_i} = -\\frac{1}{m}\\sum_{j=1}^m \\frac{\\delta}{\\delta \\theta_i} \\left([y_j \\log(h_\\theta(x_j))] + [(1-y_j)\\log(1-h_\\theta(x_j))]\\right) = \\end{align} \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_i} = -\\frac{1}{m}\\sum_{j=1}^m \\left(\\frac{\\delta}{\\delta \\theta_i} [y_j \\log(h_\\theta(x_j))]\\right) + \\left(\\frac{\\delta}{\\delta \\theta_i}[(1-y_j)\\log(1-h_\\theta(x_j))]\\right) = \\end{align} sacamos los factores constantes \\(y_j\\) y \\(1-y_j\\) y aplicamos la regla de la cadena: \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_i} = -\\frac{1}{m}\\sum_{j=1}^m \\left(y_j\\frac{\\delta\\log(h_\\theta(x_j))}{\\delta h_\\theta(x_j)} \\frac{\\delta h_\\theta(x_j)}{\\delta \\theta_i}\\right) + \\left((1-y_j)\\frac{\\delta\\log(1-h_\\theta(x_j))}{\\delta (1- h_\\theta(x_j))}\\frac{\\delta (1- h_\\theta(x_j))}{\\delta \\theta_i}\\right) = \\end{align} tenemos que, para el último término: \\begin{align} \\frac{\\delta (1- h_\\theta(x_j))}{\\delta \\theta_i} = \\frac{\\delta(1)}{\\delta \\theta_i} - \\frac{\\delta h_\\theta(x_j)}{\\delta \\theta_i} = - \\frac{\\delta h_\\theta(x_j)}{\\delta \\theta_i} \\end{align} por lo tanto, si sustituimos: \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_i} = -\\frac{1}{m}\\sum_{j=1}^m \\left(y_j\\frac{\\delta\\log(h_\\theta(x_j))}{\\delta h_\\theta(x_j)} \\frac{\\delta h_\\theta(x_j)}{\\delta \\theta_i}\\right) + \\left((1-y_j)\\frac{\\delta\\log(1-h_\\theta(x_j))}{\\delta (1- h_\\theta(x_j))}(-1)\\frac{\\delta h_\\theta(x_j)}{\\delta \\theta_i}\\right) = \\end{align} aplicamos la regla \\(\\frac{\\delta \\log(x)}{\\delta x} = \\frac{1}{x}\\), sacamos la expresión \\(\\frac{\\delta h_\\theta(x_j)}{\\delta \\theta_i}\\) como factor común y hacemos negativo el segundo término: \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_i} = -\\frac{1}{m}\\sum_{j=1}^m \\left(\\frac{y_j}{h_\\theta(x_j)} \\right) - \\left(\\frac{(1 - y_j)}{1-h_\\theta(x_j)}\\right) \\frac{\\delta h_\\theta(x_j)}{\\delta \\theta_i} = \\end{align} aplicamos operationes aritméticas: \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_i} = -\\frac{1}{m}\\sum_{j=1}^m \\left(\\frac{(y_j)(1-h_\\theta(x_j)) - (1-y_j)(h_\\theta(x_j))}{h_\\theta(x_j)(1-h_\\theta(x_j))} \\right)\\frac{\\delta h_\\theta(x_j)}{\\delta \\theta_i} = \\end{align} centrémonos ahora en \\(\\frac{\\delta h_\\theta(x_j)}{\\delta \\theta_i}\\). para calcular esta derivada, primero expresamos la hipótesis utilizando la función sigmoide: \\begin{align} \\frac{\\delta h_\\theta(x_j)}{\\delta \\theta_i} = \\frac{\\delta}{\\delta \\theta_i} g(\\theta x_j) \\end{align} aplicamos la regla de la cadena \\begin{align} \\frac{\\delta h_\\theta(x_j)}{\\delta \\theta_i} = \\frac{\\delta g(\\theta x_j)}{\\delta \\theta x_j} \\frac{\\delta \\theta x_j}{\\delta \\theta_i} \\end{align} sabemos que la derivada del segundo término \\(\\frac{\\delta \\theta x_j}{\\delta \\theta_i}\\) equivale a \\(x_{ij}\\), por lo tanto, calcularemos sólo \\(\\frac{\\delta g(\\theta x_j)}{\\delta \\theta x_j}\\) sea: \\begin{align} g(\\theta x_j) = \\frac{1}{1 + e^{-\\theta x_j}} = (1 + e^{-\\theta x_j})^{-1} \\end{align} aplicamos la regla de la cadena \\begin{align} \\frac{\\delta g(\\theta x_j)}{\\delta \\theta x_j} = \\frac{\\delta(1 + e^{-\\theta x_j})^{-1}}{\\delta(1+e^{-\\theta x_j})}\\frac{\\delta(1+e^{-\\theta x_j})}{\\delta \\theta x_j} \\end{align} resolvemos la primera derivada aplicando las propiedades de las derivadas sobre los polinomios y volvemos a aplicar la propiedad de que la derivada de una suma equivale a la suma de las derivadas en el segundo término: \\begin{align} \\frac{\\delta g(\\theta x_j)}{\\delta \\theta x_j} = (-1)(1 + e^{-\\theta x_j})^{-2}\\left[\\frac{\\delta (1)}{\\delta \\theta x_j} + \\frac{\\delta e^{-\\theta x_j}}{\\delta \\theta x_j} \\right] \\end{align} como \\(\\frac{\\delta (1)}{\\delta \\theta x_j}\\) equivale a cero: \\begin{align} \\frac{\\delta g(\\theta x_j)}{\\delta \\theta x_j} = (-1)(1 + e^{-\\theta x_j})^{-2} \\frac{\\delta e^{-\\theta x_j}}{\\delta \\theta x_j} \\end{align} resolvemos la última derivada, sabiendo que \\(\\frac{\\delta e^x}{\\delta x} = e^x\\) \\begin{align} \\frac{\\delta g(\\theta x_j)}{\\delta \\theta x_j} = (-1)(1 + e^{-\\theta x_j})^{-2} (-1) e^{-\\theta x_j} = (1 + e^{-\\theta x_j})^{-2} e^{-\\theta x_j} = \\frac{e^{-\\theta x_j}}{(1 + e^{-\\theta x_j})^2} \\end{align} como \\(\\frac{e^{-\\theta x_j}}{(1 + e^{-\\theta x_j})^2} = \\left(\\frac{1}{1+e^{-\\theta x_j}}\\right)\\left(1 - \\frac{1}{1 + e^{-\\theta x_j}}\\right)\\), entonces: \\begin{align} \\frac{\\delta g(\\theta x_j)}{\\delta \\theta x_j} = \\frac{e^{-\\theta x_j}}{(1 + e^{-\\theta x_j})^2} = \\left(\\frac{1}{1+e^{-\\theta x_j}}\\right)\\left(1 - \\frac{1}{1 + e^{-\\theta x_j}}\\right) = h_\\theta(x_j) (1- h_\\theta(x_j)) \\end{align} ya que según la definición de la hipótesis \\(h_\\theta(x_j) = \\frac{1}{1 + e^{-\\theta x_j}}\\) por lo tanto, juntado los resultados, tenemos que: \\begin{align} \\frac{\\delta h_\\theta(x_j)}{\\delta \\theta_i} = \\frac{\\delta g(\\theta x_j)}{\\delta \\theta x_j} \\frac{\\delta \\theta x_j}{\\delta \\theta_i} = h_\\theta(x_j) (1- h_\\theta(x_j)) x_{ij} \\end{align} volvemos, entonces, a la derivada de la función de coste y sustituimos \\(\\frac{\\delta h_\\theta(x_j)}{\\delta \\theta_i}\\) \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_i} = -\\frac{1}{m}\\sum_{j=1}^m \\left(\\frac{(y_j)(1-h_\\theta(x_j)) - (1-y_j)(h_\\theta(x_j))}{h_\\theta(x_j)(1-h_\\theta(x_j))} \\right) h_\\theta(x_j) (1- h_\\theta(x_j)) x_{ij} = \\end{align} los términos \\(h_\\theta(x_j) (1- h_\\theta(x_j))\\) se cancelan tal que: \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_i} = -\\frac{1}{m}\\sum_{j=1}^m \\left((y_j)(1-h_\\theta(x_j)) - (1-y_j)(h_\\theta(x_j)) \\right) x_{ij} = \\end{align} aplicamos operaciones aritméticas: \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_i} = -\\frac{1}{m}\\sum_{j=1}^m (y_j - y_jh_\\theta(x_j) - h_\\theta(x_j) + y_jh_\\theta(x_j)) x_{ij} \\end{align} el término \\(y_jh_\\theta(x_j)\\) se cancela, tal que: \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_i} = -\\frac{1}{m}\\sum_{j=1}^m (y_j - h_\\theta(x_j)) x_{ij} \\end{align} finalmente movemos el \\((-1)\\) dentro del sumatorio: \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_i} = \\frac{1}{m}\\sum_{j=1}^m (h_\\theta(x_j)-y_j) x_{ij} \\end{align} por lo tanto la función del descenso gradiente equivale a: \\begin{align} \\theta_i = \\theta_i - \\alpha \\left( \\frac{\\delta j(\\theta)}{\\delta \\theta_i}\\right) = \\theta_i - \\alpha \\left[\\frac{1}{m} \\left(\\sum_{j=1}^m (h_\\theta(x_j) - y_j) \\cdot x_{ij}\\right) \\right] \\end{align} observa que tiene la misma forma que para la regresión lineal, pero la hipótesis para la regresión logística está definida en términos de la función sigmoide regularización con regularización debemos derivar la función de coste que incluye el parámetro de regularización: \\begin{align} \\theta_i = \\theta_i - \\alpha \\left( \\frac{\\delta j(\\theta)}{\\delta \\theta_i}\\right) + \\frac{\\lambda}{2m} \\sum_{k=1}^n \\theta_k^2 \\end{align} el primer término ya lo hemos derivado, por lo tanto procedemos a derivar el segundo término: \\begin{align} \\frac{\\delta}{\\delta \\theta_i} \\left(\\frac{\\lambda}{2m} \\sum_{k=1}^n \\theta_k^2\\right) = \\frac{\\lambda}{2m} \\left(\\sum_{k=1}^n \\frac{\\delta}{\\delta \\theta_i} \\theta_k^2\\right) \\end{align} donde \\begin{align} \\frac{\\delta}{\\delta \\theta_i} \\theta_k^2 = \\begin{cases} 2 \\theta_k, & k = i \\\\ 0, & k \\neq i \\end{cases} \\end{align} como para todo \\(k\\), con \\(1 \\leq k \\leq n\\) sólo hay un \\(k\\), tal que \\(k = i\\), entonces: \\begin{align} \\frac{\\delta}{\\delta \\theta_i} \\left(\\frac{\\lambda}{2m} \\sum_{k=1}^n \\theta_k^2\\right) = \\frac{\\lambda}{2m} 2\\theta_i = \\frac{\\lambda}{m} \\theta_i \\end{align} por lo tanto la función del descenso gradiente equivale a: \\begin{align} \\theta_i = \\theta_i - \\alpha \\left( \\frac{\\delta j(\\theta)}{\\delta \\theta_i}\\right) = \\theta_i - \\alpha \\left[\\frac{1}{m} \\left(\\sum_{j=1}^m (h_\\theta(x_j) - y_j) \\cdot x_{ij}\\right) + \\frac{\\lambda}{m}\\theta_i\\right] \\end{align} al igual que antes, observa que tiene la misma forma que para la regresión lineal, pero la hipótesis para la regresión logística está definida en términos de la función sigmoide $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/ExpectationMaximization/Expectation-Maximization Algorithms.html",
    "title": "Expectation Maximization",
    "body": " index search search back expectation maximization introduction gaussian mixture models em algorithm with gmm's e-step m-step optimal parameters of a gmm iterative process recap: anomaly detection generalized em algorithm jensen's inequality motivation e-step m-step putting everything together derive em for gmm e-step m-step introduction this technique is employed in density estimation problems and anomaly detection. such problems aim to represent data in a compact form using a statistical distribution, e.g., gaussian, beta, or gamma. you can think of those problems as a clustering task but from a probabilistic point of view. this is what makes the em algorithm a probabilistic generative model. thus, if we are given \\(n\\) samples, we model them with \\(p(x)\\), such that if \\(p(x) < \\epsilon\\), where \\(\\epsilon\\) is some threshold, then we detect an anomaly. however, you may expect that a single gaussian with its mean and variance cannot map thousands of instances in a dataset into a set of \\(k\\) clusters accurately, so we may assume that there are \\(k\\) distributions that describe the data, hence we use mixture models. for example, imagine you have the following dataset: it looks like the data comes from two different gaussian distributions: so to model this data we use a mixture of gaussian models. note that if we knew by which distribution each sample was generated, we would simply use mle, however we do not know this information, therefore we use the expectation maximization algorithm and we introduce the latent variable \\(z\\) in place of the predicted output \\(y\\) we had in supervised learning algorithms. to model the data, first of all, we suppose that there is a latent (hidden/unobserved) random variable \\(z\\), and \\(x^{(i)}, z^{(i)}\\) are distributed (by a joint distribution) like so \\begin{align} p(x^{(i)},z^{(i)}) = p(x^{(i)}|z^{(i)}) p(z^{(i)}) \\end{align} where \\(z^{(i)} \\sim multinomial(\\phi)\\), that is \\(z^{(i)}\\) is distributed according to a multinomial distribution. this distribution models for each \\(z^{(i)}\\) the probability of it being equal to \\(1, 2, ..., k\\), where \\(k\\) is the number of clusters. this will denote the probability of a point \\(x^{(i)}\\) being drawn from each of the distributions. and \\(p(x^{(i)}|z^{(i)}=j)\\) is the probability of \\(x^{(i)}\\) being generated by the cluster \\(j\\). where \\(x^{(i)}|z^{(i)} = j\\) is drawn from a normal distribution \\(\\mathcal{n}(\\mu_j, \\sigma_j)\\). gaussian mixture models to build a density estimator model, we cannot rely on a simple distribution. mixture models try to tackle this limitation by combining a set of distributions to create a convex space where we can search for the optimal parameters for such distributions using maximum likelihood estimation (mle). a mixture model is expressed by the following equations: \\begin{align} p(x^{(i)}) = \\sum_{j=1}^k \\phi^{(i)}_j p_j(x^{(i)}) \\tag{1} \\end{align} \\begin{align} 0 \\leq \\phi^{(i)}_j \\leq 1, \\sum_{j=1}^k \\phi^{(i)}_j = 1 \\end{align} where \\(k\\) is the number of mixture components (clusters), \\(\\phi^{(i)}_j\\)'s are the mixture weights, and \\(p_j(x^{(i)})\\)'s are members of a family of distributions (gaussian, poisson, bernoulli, etc). so for each example \\(x^{(i)}\\) and for each distribution \\(j\\), each weight \\(\\phi^{(i)}_j\\) is between 0 and 1, and the sum over \\(k\\) of the weights \\(\\phi_j^{(i)}\\) for every example \\(x^{(i)}\\) equals one. consequently, a gmm is a mixture model where the \\(p_j(x^{(i)})\\) is a finite combination of gaussian distributions. therefore, a gmm can be precisely defined by the following set of equations: \\begin{align} p(x^{(i)};\\theta) = \\sum_{j=1}^k \\phi^{(i)}_j \\mathcal{n}(x^{(i)};\\mu_j,\\,\\sigma_j) \\end{align} \\begin{align} 0 \\leq \\phi^{(i)}_j \\leq 1, \\sum_{j=1}^k \\phi^{(i)}_j = 1 \\end{align} where \\(\\theta\\) is the collection of all the parameters of the model (mixture weights, means, and covariance matrices): \\begin{align} \\theta = \\{\\phi_1, \\cdots, \\phi_k, \\mu_1, \\cdots, \\mu_k, \\sigma_1, \\cdots, \\sigma_k\\} \\end{align} for example, the following plot shows what a gmm derived from 3 mixture components looks like: as a consequence, for each data point, \\(x^{(i)}\\) (in red), we can compute the probability that it belongs to each component (\\(p(x^{(i)}|z^{(i)} = j)\\), where \\(j = 1, 2, 3\\))(make a “soft” assignment). this quantity is called “responsibility”. em algorithm with gmm's the expectation maximization algorithm is comprised of two steps: guess the value of the responsibilities \\(w^{(i)}_j\\), that represent the \"amount\" of each \\(x^{(i)}\\) that was generated from the distribution \\(j\\) (or the probability that the \\(j\\)th distribution generated the point \\(x^{(i)}\\)). compute the values of the parameters of the distributions: \\(\\theta = \\{\\phi, \\mu, \\sigma\\}\\) according to the \\(mle\\) (maximum likelihood estimation) with respect to the parameters. thus, we want to maximize \\(\\mathcal{l}(\\phi, \\mu, \\sigma)\\). e-step in this step, as we have said, we will compute the value of the responsibilities with the given parameters \\(\\phi, \\mu, \\sigma\\). so for each example \\(i\\) and each component (distribution) \\(j\\), the amount of \\(x^{(i)}\\) that is generated by the component \\(j\\) is given by: \\begin{align} w^{(i)}_j = p(z^{(i)} = j | x^{(i)}; \\phi_j, \\mu_j, \\sigma_j) \\end{align} by bayes' rule, we can rewrite the equation as follows: \\begin{align} w^{(i)}_j = \\frac{p(x^{(i)}|z^{(i)} = j)p(z^{(i)} = j)}{\\sum_{l=1}^k \\left[p(x^{(i)}|z^{(i)} = l)p(z^{(i)} = l)\\right]} \\end{align} note that the likelihood \\(p(x^{(i)}|z^{(i)} = j)\\) and each likelihood \\(p(x^{(i)}|z^{(i)} = l)\\) come from a gaussian distribution, therefore: \\begin{align} p(x^{(i)}|z^{(i)} = j) = \\frac{1}{(2\\pi)^{\\frac{n}{2}}|\\sigma_j|^{\\frac{1}{2}}} \\exp\\left(-\\frac{1}{2}(x^{(i)} - \\mu_j)^t \\sigma_j^{-1} (x^{(i)} - \\mu_j)\\right) \\tag{2} \\end{align} to simplify notation we will denote \\(p(x^{(i)}|z^{(i)} = j)\\) as \\(\\mathcal{n}(\\mu_j, \\sigma_j)\\). on the other hand, the prior \\(p(z^{(i)} = j)\\) comes from a multinomial distribution, hence: \\begin{align} p(z^{(i)} = j) = \\phi_j \\tag{3} \\end{align} combining all the expressions: \\begin{align} w^{(i)}_j = \\frac{\\phi_j\\mathcal{n}(\\mu_j, \\sigma_j)}{\\sum_{l=1}^k \\left[\\phi_l\\mathcal{n}(\\mu_l, \\sigma_l)\\right]} \\tag{4} \\end{align} all that is left to do is plug all of the values into each equation \\((2)\\) and \\((3)\\) (this values are known, given the equations are written in terms of the distributions' parameters) and compute each \\(w^{(i)}_j\\) given \\((4)\\). m-step in this step what we do is maximize the log likelihood of the distributions' parameters \\(\\theta\\), that is we maximize \\(\\mathcal{l}(\\phi, \\mu, \\sigma)\\). but first, let us see how do we maximize the parameters in gmm. optimal parameters of a gmm we are going to show how to maximize the log likelihood of the parameters of a gaussian mixture model. the goal of the gmm is to represent the distribution of the data as accurately as possible using a linear combination of gaussian distributions. given a dataset \\(x\\) of \\(m\\) data points, we assume they are i.i.d (independent and identically distributed), therefore the maximum likelihood estimator over \\(x\\) can be expressed as the product of the individual likelihoods. to simplify the equations, we are going to directly apply the logarithm to the mle function: \\begin{align} \\log \\mathcal{l}(x|\\theta) = \\log p(x|\\theta) = \\log \\prod_{i=1}^m p(x^{(i)}|\\theta) = \\sum_{i=1}^m \\log p(x^{(i)}|\\theta) \\end{align} by \\((1)\\) we know that \\(p(x^{(i)}|\\theta)\\) is a linear combination of gaussian distributions, therefore: \\begin{align} \\log \\mathcal{l}(x|\\theta) = \\sum_{i=1}^n \\log \\sum_{j=1}^k \\phi_j^{(i)}\\mathcal{n}(x^{(i)}|\\mu_j, \\sigma_j) \\end{align} this equation is not tractable, so we won't get an analytical solution by just taking the its derivative with respect to \\(\\theta\\) and setting it to 0. the following set of equations outline how we would evaluate it: \\begin{align} \\frac{\\delta \\mathcal{l}}{\\delta \\mu_j} \\sum_{i=1}^m \\frac{\\delta \\log p(x^{(i)}|\\theta)}{\\delta \\mu_j} = 0^t \\end{align} \\begin{align} \\frac{\\delta \\mathcal{l}}{\\delta \\sigma_j} \\sum_{i=1}^m \\frac{\\delta \\log p(x^{(i)}|\\theta)}{\\delta \\sigma_j} = 0 \\end{align} \\begin{align} \\frac{\\delta \\mathcal{l}}{\\delta \\phi_j} \\sum_{i=1}^m \\frac{\\delta \\log p(x^{(i)}|\\theta)}{\\delta \\phi_j} = 0 \\end{align} observe that the computation of each parameter from \\(\\theta (\\mu, \\sigma, \\phi)\\) depends on the other parameters in a complex way. to solve those equations, we can use the strategy of optimizing some parameters while keeping the others fixed. going back to the expectation maximization algorithm, there is a way of updating the individual parameters of a gmm given prior (initialized at random) parameters \\(\\mu, \\sigma, \\phi\\). this approach works by updating some parameters while keeping the others fixed. so, by solving the derivatives presented above we derive the three following updating rules: \\begin{align} \\hat{\\mu}_j = \\frac{\\sum_{i=1}^m w^{(i)}_jx^{(i)}}{\\sum_{l=1}^m w^{(l)}_j} \\end{align} \\begin{align} \\hat{\\sigma}_j = \\frac{\\sum_{i=1}^m w^{(i)}_j (x^{(i)} - \\hat{\\mu}_j)(x^{(i)} - \\hat{\\mu}_j)^t}{\\sum_{l=1}^m w^{(l)}_j} \\end{align} \\begin{align} \\hat{\\phi}_j = \\frac{1}{m} \\sum_{i=1}^m w^{(i)}_j \\end{align} to simplify a bit the notation, if \\(n_j = \\sum_{l=1}^m w^{(i)}_l\\): \\begin{align} \\hat{\\mu}_j = \\frac{1}{n_j} \\sum_{i=1}^m w^{(i)}_jx^{(i)} \\end{align} \\begin{align} \\hat{\\sigma}_j = \\frac{1}{n_j}\\sum_{i=1}^m w^{(i)}_j (x^{(i)} - \\hat{\\mu}_j)(x^{(i)} - \\hat{\\mu}_j)^t \\end{align} \\begin{align} \\hat{\\phi}_j = \\frac{n_j}{m} \\end{align} note that the update of \\(\\mu, \\sigma, \\phi\\), all depend on the responsibilities (\\(w^{(i)}_j\\)), which by its turn, depends on \\(\\mu, \\sigma, \\phi\\). that’s why there's not a closed-form solution to equations. furthermore these equations do not aim to precisely maximize over \\(\\theta\\) the actual log likelihood. instead they maximize a proxy function of the log-likelihood over \\(\\theta\\), namely, the expected log-likelihood, which can be derived from the log-likelihood using jensen's inequality as follows: \\begin{align} \\hat{\\mathcal{l}}(x|\\theta) = \\sum_{i=1}^m\\sum_{j=1}^k w^{(i)}_j \\log \\left( \\frac{\\phi_j \\mathcal{n}(x^{(i)} | \\mu_j, \\sigma_j)}{w^{(i)}_j} \\right) \\tag{5} \\end{align} iterative process the process consists of an iterative process that alternates between two steps. the first step is to compute the responsibilities (e step) of each mixture component for each data point using the current parameters (\\(\\mu, \\sigma, \\phi\\)). the second step consists of updating the parameters (m step) in order to maximize the expected log-likelihood given by \\((5)\\) the e and m steps are repeated until there is no significant progress in the proxy function of the log-likelihood computed after the m step. recap: anomaly detection thus, when the parameters \\(\\theta\\) are optimized, we can compute \\(p(x) = \\sum_{j=1}^k p(x|z = j)\\) and if \\(p(x) < \\epsilon\\) you can flag \\(x\\) as an anomaly. generalized em algorithm jensen's inequality convex function we are going to show what jensen's inequality is about. so: let \\(f\\) be a convex function (e.g. \\(f''(x) > 0\\)) and let \\(x\\) be a random variable, then \\begin{align} f(e[x]) \\leq e[f(x)] \\end{align} where \\(e\\) is the expected value. further, if \\(f''(x) > 0\\) (we say f is strictly convex, that is f is not a straight line), then: \\begin{align} e[f(x)] = f(e[x]) \\leftrightarrow \\text{ x is a constant, more formally } x = e[x] \\text{ with probability 1} \\end{align} concave function we are going to apply the same arguments with a concave function. note that a concave function equals the negative of a convex function, thus: let \\(f\\) be a concave function (e.g. \\(f''(x) < 0\\)) and let \\(x\\) be a random variable, then \\begin{align} f(e[x]) \\geq e[f(x)] \\end{align} where \\(e\\) is the expected value. further, if \\(f''(x) < 0\\) (we say f is strictly concave), then: \\begin{align} e[f(x)] = f(e[x]) \\leftrightarrow \\text{ x is a constant, more formally } x = e[x] \\text{ with probability 1} \\end{align} some intuition given any convex function (the inverse also applies to concave functions), if we draw a chord between any two points, its middle point (that is the expected value of the function or \\(e[f(x)]\\)) is always above that the value of the expected value under the function (that is \\(f(e[x])\\)). graphically: motivation given a model for \\(p(x, z , \\theta)\\) where \\(\\theta\\) are the parameters of the model. we only observe \\(x = \\{x^{(1)}, \\cdots, x^{(m)}\\}\\). the goal is to obtain by the maximum likelihood estimation the value of \\(\\theta\\) that maximizes the log likelihood, defined as: \\begin{align} \\theta = \\underset{\\theta}{\\arg \\max{l(\\theta)} } = \\sum_{i=1}^m \\log (p(x^{(i)}; \\theta)) \\end{align} if we marginalize \\(z^{(i)}\\): \\begin{align} \\theta = \\underset{\\theta}{\\arg \\max{l(\\theta)} } = \\sum_{i=1}^m \\log \\sum_{z^{(i)}} (p(x^{(i)}, z^{(i)}; \\theta)) \\end{align} e-step in the e-step we construct a lower bound from a given theta: so, let's say \\(l(\\theta)\\) is the log likelihood. on the first iteration, the graph would be as follows: and on the second iteration: we iterate until there are no significant changes in the lower bound, that is the algorithm converges to a local optimum (it should be noted the optimum is local not absolute, and it depends on the initialization of the distributions' parameters). m-step now, in the m-step we maximize the log likelihood as follows: \\begin{align} \\underset{\\theta}{\\max{ }} \\sum_{i=1}^m \\log p(x^{(i)}; \\theta) \\end{align} by marginalizing \\(z^{(i)}\\): \\begin{align} \\underset{\\theta}{\\max{ }} \\sum_{i=1}^m \\log \\sum_{z^{(i)}} p(x^{(i)}, z^{(i)}; \\theta) \\end{align} we now introduce a probability distribution over \\(z^{(i)}\\) (thus \\(\\sum_{z^{(i)}}q(z^{(i)}) = 1\\)), and we multiply by \\(\\frac{q(z^{(i)})}{q(z^{(i)})}\\): \\begin{align} \\underset{\\theta}{\\max{ }} \\sum_{i=1}^m \\log \\sum_{z^{(i)}} q(z^{(i)}) \\frac{p(x^{(i)}, z^{(i)}; \\theta)}{q(z^{(i)})} \\end{align} now, by the definition of expected value (given a sequence of real values \\(a_1, \\cdots, a_n\\) with probabilities \\(p_1, \\cdots, p_n\\), the expected value is defined as: \\(e = \\sum_{i=1}^n p_i a_i\\)), if \\(p_i = q(z^{(i)})\\) and \\(a_i = \\frac{p(x^{(i)}, z^{(i)}; \\theta)}{q(z^{(i)})}\\) \\begin{align} \\underset{\\theta}{\\max{ }} \\sum_{i=1}^m \\log e_{z^{(i)}\\sim q} \\left[\\frac{p(x^{(i)}, z^{(i)}; \\theta)}{q(z^{(i)})}\\right] \\end{align} if we apply the concave version of jensen's inequality we obtain a lower bound of the form: \\begin{align} \\sum_{i=1}^m \\log e_{z^{(i)}\\sim q} \\left[\\frac{p(x^{(i)}, z^{(i)}; \\theta)}{q(z^{(i)})}\\right] \\geq \\sum_{i=1}^m e_{z^{(i)} \\sim q} \\left[\\log \\frac{p(x^{(i)}, z^{(i)}; \\theta)}{q(z^{(i)})} \\right] \\end{align} if \\(\\log (x) = f(x)\\), then this equation can be mapped to the inequality: \\begin{align} f(e[x]) \\geq e[f(x)] \\end{align} note that \\(log\\) is a concave function. if we \"unpack\" the expected value: \\begin{align} \\sum_{i=1}^m e_{z^{(i)} \\sim q} \\left[\\log \\frac{p(x^{(i)}, z^{(i)}; \\theta)}{q(z^{(i)})} \\right] = \\sum_{i=1}^m \\sum_{z^{(i)}} \\log q(z^{(i)}) \\left[\\frac{p(x^{(i)}, z^{(i)}; \\theta)}{q(z^{(i)})}\\right] \\end{align} make log likelihood and lower bound equal on theta for each \\(\\theta\\) on the e-step you wan the value of \\(\\theta\\) under the lower bound function to be equal to \\(l(\\theta)\\), which is what guarantees that when you optimize the lower bound you optimize \\(l(\\theta)\\). so, for a given iteration the current value of \\(\\theta\\), denoted by \\(\\hat{\\theta}\\), we want: \\begin{align} \\sum_{i=1}^m \\log e_{z^{(i)}\\sim q} \\left[\\frac{p(x^{(i)}, z^{(i)}; \\hat{\\theta})}{q(z^{(i)})}\\right] = \\sum_{i=1}^m e_{z^{(i)} \\sim q} \\left[\\log \\frac{p(x^{(i)}, z^{(i)}; \\hat{\\theta})}{q(z^{(i)})} \\right] \\end{align} remember, by the extension on jensen's inequality we know that \\(e[f(x)] = f(e[x])\\) if and only if \\(x\\) is a constant. in this case \\begin{align} x = \\frac{p(x^{(i)}, z^{(i)}; \\hat{\\theta})}{q(z^{(i)})} = constant \\end{align} for this to hold, we need \\(q(z^{(i)})\\) to be directly proportional to \\(p(x^{(i)}, z^{(i)}; \\hat{\\theta})\\) (so when one is bigger the other is bigger and vice versa, so the ratio between the two remains constant). so: \\begin{align} q(z^{(i)}) \\propto p(x^{(i)}, z^{(i)}; \\hat{\\theta}) \\end{align} because \\(\\sum_{z^{(i)}}q(z^{(i)}) = 1\\), a way to ensure this is to set each \\(q^{(i)} = p(x^{(i)}, z^{(i)}; \\hat{\\theta})\\) and then normalize it to make sure the sum of \\(q\\) over \\(z^{(i)}\\) equals one. hence: \\begin{align} q(z^{(i)}) = \\frac{p(x^{(i)}, z^{(i)}; \\hat{\\theta})}{\\sum_{z^{(i)}} p(x^{(i)}, z^{(i)}; \\hat{\\theta})} \\end{align} it turns out you can further derive this equation to be: \\begin{align} q(z^{(i)}) = p(z^{(i)}|x^{(i)}; \\hat{\\theta}) \\end{align} putting everything together so, after everything we have seen, we can summarize the em generalized algorithm as follows: if \\(\\theta\\) is the value of the parameters in the current iteration: e-step: set \\begin{align} q_i(z^{(i)}) = p(z^{(i)}|x^{(i)}; \\theta) \\end{align} m-step: set \\begin{align} \\theta := \\underset{\\theta}{\\arg \\max} \\sum_{i=1}^m \\sum_{z^{(i)}} q_i(z^{(i)}) \\log \\left[\\frac{p(x^{(i)}, z^{(i)};\\theta)}{q_i(z^{(i)})}\\right] \\end{align} derive em for gmm from the generalized algorithm given a model described by: \\(p(x^{(i)}, z^{(i)}) = p(x^{(i)}|z^{(i)}) p(z^{(i)})\\) where \\(z^{(i)} \\sim multinomial(\\phi)\\) (which means \\(p(z^{(i)} = j) = \\phi_j\\)) and \\(x^{(i)} | z^{(i)} \\sim \\mathcal{n}(\\mu_j, \\sigma_j)\\) e-step on the e-step we compute: \\(q_i(z^{(i)}) p(z^{(i)} = j | x^{(i)}; \\phi, \\mu, \\sigma)\\) if we look at e-step from gmm's we can see that the expression above equals \\(w^{(i)}_j\\). m-step now on the m-step what we do is maximize the lower bound we have constructed in the e-step. for that we need to compute the value of the parameters \\(\\phi, \\mu, \\sigma\\) that maximize this function, that is: \\begin{align} \\underset{\\phi, \\mu, \\sigma}{\\max} \\sum_{i=1}^m \\sum_{z^{(i)}} q_i(z^{(i)}) \\log \\left( \\frac{p(x^{(i)}, z^{(i)}; \\phi, \\mu, \\sigma)}{q_i(z^{(i)})} \\right) = \\end{align} as we know \\(q_i(z^{(i)}) = w^{(i)}_j\\) and \\(p(x^{(i)}, z^{(i)}) = p(x^{(i)}|z^{(i)}) p(z^{(i)})\\), thus: \\begin{align} = \\sum_{i=1}^m \\sum_{j}^k w^{(i)}_j \\log \\left( \\frac{p(x^{(i)}|z^{(i)} = j, \\mu_j, \\sigma_j) p(z^{(i)} = j)}{w^{(i)}_j} \\right) \\end{align} we also know that \\(p(z^{(i)} = j) = \\phi_j\\) and \\(x^{(i)} | z^{(i)} \\sim \\mathcal{n}(\\mu_j, \\sigma_j)\\), therefore: \\begin{align} = \\sum_{i=1}^m \\sum_{j}^k w^{(i)}_j \\log \\left( \\frac{\\mathcal{n}(x^{(i)}; \\mu_j, \\sigma_j) \\phi_j}{w^{(i)}_j} \\right) \\end{align} where: \\begin{align} \\mathcal{n}(x^{(i)}; \\mu_j, \\sigma_j) = \\frac{1}{(2\\pi)^{1/2}|\\sigma_j|^{1/2}} \\exp \\left( -\\frac{1}{2}(x^{(i)} - \\mu_j)^t \\sigma_j^{-1}(x^{(i)} - \\mu_j)\\right) \\end{align} from now on we denote \\(\\sum_{i=1}^m \\sum_{j}^k w^{(i)}_j \\log \\left( \\frac{\\mathcal{n}(x^{(i)}; \\mu_j, \\sigma_j) \\phi_j}{w^{(i)}_j} \\right)\\) as \\(\\mathcal{l}(\\phi, \\mu, \\sigma)\\): to maximize this formula over \\(\\phi, \\mu\\) and \\(\\sigma\\) you have to compute the derivatie of the function with respect to each parameter, such that: \\(\\delta_{\\mu_j} (\\mathcal{l}(\\phi, \\mu, \\sigma)) = 0\\), then: \\(\\mu_j = \\sum_{i}^m \\frac{w^{(i)}_j x^{(i)}_j}{w^{(i)}_j}\\) (same as in m-step in gmm's) \\(\\delta_{\\sigma_j} (\\mathcal{l}(\\phi, \\mu, \\sigma)) = 0\\) and \\(\\delta_{\\phi_j} (\\mathcal{l}(\\phi, \\mu, \\sigma)) = 0\\) $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/Regresión Lineal.html",
    "title": "Regresión Lineal",
    "body": " index search search back regresión lineal descripción de los datos hipótesis funcion de coste descenso gradiente descripción de los datos \\(x = (x_{ij})\\) una matriz \\(n \\times m\\) donde cada \\(x_{ij}\\) es la característica \\(i\\) del ejemplo \\(j\\), tal que \\begin{align} x = \\begin{bmatrix} x_{11} & \\cdots & x_{1m} \\\\ \\cdots & \\ddots & \\cdots \\\\ x_{n1} & \\cdots & x_{nm} \\\\ \\end{bmatrix} \\end{align} cada columna es un ejemplo en cada fila están los valores de una característica \\(\\theta = (\\theta_i)\\) es un vector fila \\(1\\times n\\) donde cada \\(\\theta_i\\) es el peso de la característica \\(i\\), tal que: \\begin{align} \\theta = \\begin{bmatrix} \\theta_1 & \\cdots & \\theta_n\\end{bmatrix} \\end{align} \\(y = (y_j)\\) es un vector fila \\(1\\times m\\) donde cada \\(y_j\\) es la salida real para el ejemplo \\(j\\), tal que: \\begin{align} y = \\begin{bmatrix} y_1 & \\cdots & y_m\\end{bmatrix} \\end{align} hipótesis dado un ejemplo, es decir un vector columna \\(x\\), de dimensiones \\(n \\times 1\\), la hipótesis se define como: \\begin{align} h_\\theta(x) = \\sum_{i=1}^n \\theta_i \\cdot x_i \\end{align} dado un conjunto de \\(m\\) datos, es decir matriz \\(x\\), de dimensiones \\(n \\times m\\), la hipótesis se define como: \\begin{align} h_\\theta(x) = \\theta\\cdot x = \\begin{bmatrix}\\sum_{i=1}^n \\theta_i \\cdot x_{i1} & \\cdots & \\sum_{i=1}^n \\theta_i \\cdot x_{im}\\end{bmatrix} \\end{align} el resultado es un vector fila \\(1 \\times m\\), es decir como el vector de salidas \\(y\\) funcion de coste se define la función de coste, \\(j(\\theta)\\) como: \\begin{align} j(\\theta) = \\frac{1}{2m}\\sum_{j=1}^m (h_\\theta(x_j) - y_j)^2 \\end{align} esta función de coste se denomina mínimos cuadrados. regularización con regularización, se define la función de coste, \\(j(\\theta)\\) como: \\begin{align} j(\\theta) = \\frac{1}{2m}\\sum_{j=1}^m (h_\\theta(x_j) - y_j)^2 + \\frac{1}{2m} \\lambda \\sum_{i=1}^n \\theta_i^2 \\end{align} descenso gradiente para actualizar el vector de pesos \\(\\theta\\) aplicamos el descenso gradiente. para cada peso \\(\\theta_i\\): \\begin{align} \\theta_i = \\theta_i - \\alpha \\left( \\frac{\\delta j(\\theta)}{\\delta \\theta_i}\\right) \\end{align} la derivada del coste en función del peso \\(\\theta_i\\) se calcula como sigue: sustituimos la función de coste \\begin{align} \\frac{\\delta j(\\theta)}{\\delta \\theta_i} = \\frac{\\delta}{\\delta \\theta_i} \\left(\\frac{1}{2m}\\sum_{j=1}^m (h_\\theta(x_j) - y_j)^2\\right) = \\end{align} sacamos el factor constante de la derivada \\begin{align} = \\frac{1}{2m} \\frac{\\delta}{\\delta \\theta_i} \\left(\\sum_{j=1}^m (h_\\theta(x_j) - y_j)^2\\right) \\end{align} aplicamos la propiedad que dice que la derivada de una suma equivale a la suma de las derivadas \\begin{align} = \\frac{1}{2m} \\left(\\sum_{j=1}^m \\frac{\\delta}{\\delta \\theta_i}(h_\\theta(x_j) - y_j)^2\\right) \\end{align} aplicamos la regla de la cadena \\begin{align} = \\frac{1}{2m} \\left(\\sum_{j=1}^m \\frac{\\delta(h_\\theta(x_j) - y_j)^2}{\\delta (h_\\theta(x_j) - y_j)} \\frac{\\delta (h_\\theta(x_j) - y_j)}{\\delta \\theta_i}\\right) \\end{align} aplicamos aritmética \\begin{align} = \\frac{1}{2m} \\left(\\sum_{j=1}^m 2(h_\\theta(x_j) - y_j) \\left[\\frac{\\delta (h_\\theta(x_j))}{\\delta \\theta_i} - \\frac{\\delta (y_j)}{\\delta \\theta_i}\\right]\\right) \\end{align} como la derivada de \\(y_i\\) es función de \\(\\theta_i\\) es cero, procedemos a calcular la derivada de \\(h_\\theta(x_j)\\): \\begin{align} \\frac{\\delta h_\\theta(x_j)}{\\delta \\theta_i} = \\frac{\\delta}{\\delta \\theta_i} \\sum_{k=1}^n \\theta_k x_{kj} = \\sum_{k=1}^n \\frac{\\delta}{\\delta \\theta_i} \\theta_k x_{kj} \\end{align} donde \\begin{align} \\frac{\\delta}{\\delta \\theta_i} \\theta_k x_{kj} = \\begin{cases} x_{kj}, & k = i \\\\ 0, & k \\neq i \\\\ \\end{cases} \\end{align} como para todo \\(k\\), con \\(1 \\leq k \\leq n\\) sólo hay un \\(k\\), tal que \\(k = i\\), entonces: \\begin{align} \\frac{\\delta h_\\theta(x_j)}{\\delta \\theta_i} = x_{kj} \\end{align} volemos a la derivada del peso, con \\(\\frac{\\delta h_\\theta(x_j)}{\\delta \\theta_i} = x_{kj}\\) y \\(\\frac{\\delta y_j}{\\delta \\theta_i} = 0\\): \\begin{align} = \\frac{1}{2m} \\left(\\sum_{j=1}^m 2(h_\\theta(x_j) - y_j) \\left[x_{ij} - 0\\right]\\right) \\end{align} \\begin{align} = \\frac{1}{2m} \\left(\\sum_{j=1}^m 2(h_\\theta(x_j) - y_j) \\cdot x_{ij}\\right) \\end{align} sacamos el factor constante 2 como factor común que se elimina con 1/2 \\begin{align} = \\frac{1}{m} \\left(\\sum_{j=1}^m (h_\\theta(x_j) - y_j) \\cdot x_{ij}\\right) \\end{align} finalmente, sustituimos todo en la función del gradiente: \\begin{align} \\theta_i = \\theta_i - \\alpha \\left( \\frac{\\delta j(\\theta)}{\\delta \\theta_i}\\right) = \\theta_i - \\alpha \\left[\\frac{1}{m} \\left(\\sum_{j=1}^m (h_\\theta(x_j) - y_j) \\cdot x_{ij}\\right)\\right] \\end{align} regularización con regularización debemos derivar la función que coste que incluye el parámetro de regularización: \\begin{align} \\theta_i = \\theta_i - \\alpha \\left( \\frac{\\delta j(\\theta)}{\\delta \\theta_i}\\right) + \\frac{\\lambda}{2m} \\sum_{k=1}^n \\theta_k^2 \\end{align} el primer término ya lo hemos derivado, por lo tanto procedemos a derivar el segundo término: \\begin{align} \\frac{\\delta}{\\delta \\theta_i} \\left(\\frac{\\lambda}{2m} \\sum_{k=1}^n \\theta_k^2\\right) = \\frac{\\lambda}{2m} \\left(\\sum_{k=1}^n \\frac{\\delta}{\\delta \\theta_i} \\theta_k^2\\right) \\end{align} donde \\begin{align} \\frac{\\delta}{\\delta \\theta_i} \\theta_k^2 = \\begin{cases} 2 \\theta_k, & k = i \\\\ 0, & k \\neq i \\end{cases} \\end{align} como para todo \\(k\\), con \\(1 \\leq k \\leq n\\) sólo hay un \\(k\\), tal que \\(k = i\\), entonces: \\begin{align} \\frac{\\delta}{\\delta \\theta_i} \\left(\\frac{\\lambda}{2m} \\sum_{k=1}^n \\theta_k^2\\right) = \\frac{\\lambda}{2m} 2\\theta_i = \\frac{\\lambda}{m} \\theta_i \\end{align} por lo tanto la función del descenso gradiente equivale a: \\begin{align} \\theta_i = \\theta_i - \\alpha \\left( \\frac{\\delta j(\\theta)}{\\delta \\theta_i}\\right) = \\theta_i - \\alpha \\left[\\frac{1}{m} \\left(\\sum_{j=1}^m (h_\\theta(x_j) - y_j) \\cdot x_{ij}\\right) + \\frac{\\lambda}{m}\\theta_i\\right] \\end{align} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/Evaluación de modelos.html",
    "title": "Evaluación de modelos",
    "body": " index search search back evaluación de modelos separación de datos entrenamiento en regresión lineal entrenamiento en regresión logística selección de modelos cross validation proceso de selección diagnóstico: sesgo vs varianza regresión lineal con regularización curva de aprendizaje debugging un algoritmo de aprendizaje medidas de evaluación balance entre precisión y recall separación de datos a la hora de entrenar un modelo, separamos los datos en dos conjuntos: conjunto de entrenamiento: \\(70\\%\\) - \\(80\\%\\) conjunto de test: \\(30\\%\\) - \\(20\\%\\) entrenamiento en regresión lineal el proceso de entrenamiento en la regresión lineal consiste en: entrenar el modelo sobre el conjunto de entrenamiento y obtener la matriz de pesos \\(\\theta\\) minimizando el coste \\(j(\\theta)\\) calcular el coste sobre el conjunto de test \\(j_{test}(\\theta)\\) \\[%align j_{test}(\\theta) = \\frac{1}{2m} \\sum_{i=1}^{m_{test}} (h_\\theta(x^{(i)}_{test}) - y^{(i)}_{test})^2 \\] entrenamiento en regresión logística el proceso de entrenamiento en la regresión logística consiste en: entrenar el modelo sobre el conjunto de entrenamiento y obtener la matriz de pesos \\(\\theta\\) minimizando el coste \\(j(\\theta)\\) calcular el coste sobre el conjunto de test \\(j_{test}(\\theta)\\) \\[%align j_{test}(\\theta) = - \\frac{1}{m} \\sum_{i=1}^{m_{test}} \\left[y^{(i)}_{test} \\log(h_\\theta(x^{(i)}_{test})) + (1-y^{(i)}_{test})\\log(1-h_\\theta(x^{(i)}_{test})) \\right] \\] el error de clasificación en la regresión logística se define como sigue: \\begin{align} error(h_\\theta(x), y) = \\begin{cases} 1, & \\text{ si } h_\\theta(x) \\geq 0.5 \\rightarrow \\log(h_\\theta(x)) = 1 \\text{ e } y = 0 \\\\ 1, & \\text{ si } h_\\theta(x) < 0.5 \\rightarrow \\log(h_\\theta(x)) = 0 \\text{ e } y = 1 \\\\ 0, \\text{ en cualquier otro caso } \\\\ \\end{cases} \\end{align} selección de modelos supongamos que tenemos \\(n\\) modelos, tal que cada modelo es equivalente al anterior pero con una característica más en sus datos: modelo 1: \\(h_\\theta(x) = \\theta_0 + \\theta_1 \\cdot x_1\\) modelo 2: \\(h_\\theta(x) = \\theta_0 + \\theta_1 \\cdot x_1 + \\theta_2 \\cdot x_2\\) modelo n: \\(h_\\theta(x) = \\theta_0 + \\theta_1 \\cdot x_1 + \\theta_2 \\cdot x_2 + \\cdots + \\theta_n \\cdot x_n\\) para evaluar los modelos lo que hacemos es escoger el que menor coste obtenga sobre el conjunto de test, tras ser entrenado sobre el conjunto de entrenamiento. \\begin{align} \\begin{bmatrix} \\theta^{(1)} \\\\ \\theta^{(2)} \\\\ \\vdots \\\\ \\theta^{(n)} \\\\ \\end{bmatrix} \\rightarrow \\begin{bmatrix} j_{test}(\\theta^{(1)}) \\\\ j_{test}(\\theta^{(2)}) \\\\ \\vdots \\\\ j_{test}(\\theta^{(n)}) \\\\ \\end{bmatrix} \\end{align} sin embargo, se puede dar el problema de que el mejor simplemente produzca overfitting sobre el conjunto de test (lo cual es probable cuando el vector de pesos tiene dimensiones grandes). para solventar este problema: cross validation separaremos el conjunto de datos en tres conjuntos: conjunto de entrenamiento: \\(60\\%\\) conjunto de validación cruzada (cross validation): \\(20\\%\\) conunto de test: \\(20\\%\\) por lo tanto ahora la función de coste para cada conjunto tiene la forma: función de coste para el conjunto de entrenamiento: \\begin{align} j_{train}(\\theta) = \\frac{1}{2m_{train}} \\sum_{i=1}^{m_{train}} error(h_\\theta(x^{(i)}), y^{(i)}) \\end{align} función de coste para el conjunto de test: \\begin{align} j_{test}(\\theta) = \\frac{1}{2m_{test}} \\sum_{i=1}^{m_{test}} error(h_\\theta(x^{(i)}), y^{(i)}) \\end{align} función de coste para el conjunto de validación cruzada: \\begin{align} j_{cv}(\\theta) = \\frac{1}{2m_{cv}} \\sum_{i=1}^{m_{cv}} error(h_\\theta(x^{(i)}), y^{(i)}) \\end{align} proceso de selección entonces ahora para seleccionar un modelo lo que hacemos que para cada modelo \\(q\\): minimizamos \\(j_{train}(\\theta^{(q)})\\) para obtener los pesos \\(\\theta^{(q)}\\) óptimos. calculamos el coste sobre el conjunto de validación cruzada \\(j_{cv}(\\theta^{(q)})\\) una vez hecho esto para todos, escogemos el modelo que ofrezca el mejor coste sobre el conjunto de validación cruzada y calculamos \\(j_{test}(\\theta^{(q)})\\) para evaluar la capacidad de generalización del modelo. diagnóstico: sesgo vs varianza underfitting: cuando se produce underfitting el coste de entrenamiento y el coste de validación tienen valores similares y ambos tiene valores bastante altos overfitting: cuando se produce overfitting el coste de entrenamiento es mucho menor que el coste de validación cruzada. regresión lineal con regularización también es importante observar cómo afecta el parámetro de regularización a nuestros modelos. por ejemplo, en la regresión linear, la función de coste tiene la forma: \\begin{align} j(\\theta) = \\frac{1}{2m}\\sum_{j=1}^m (h_\\theta(x_j) - y_j)^2 + \\frac{1}{2m} \\lambda \\sum_{i=1}^n \\theta_i^2 \\end{align} por lo tanto, el aumentar o reducir \\(\\lambda\\) es directamente proporcional al coste. si el parámetro de regularización \\(\\lambda\\) es muy grande entonces los pesos van a tender a ser muy pequeños (ya que el coste aumenta al aumentar el valor de \\(\\lambda\\)) si el parámetro de regularización \\(\\lambda\\) es muy pequeño entonces los pesos van a poder ser grandes (ya que el coste se reduce al reducir el valor de \\(\\lambda\\)) escoger el parámetro de regularización para escoger el parámetro de regularización seguimos el mismo proceso que para escoger el mejor modelo, para cada modelo \\(q\\): minimizamos \\(j_{train}(\\theta^{(q)})\\) para obtener los pesos \\(\\theta^{(q)}\\) óptimos. calculamos el coste sobre el conjunto de validación cruzada \\(j_{cv}(\\theta^{(q)})\\) una vez hecho esto para todos, escogemos el modelo que ofrezca el mejor coste sobre el conjunto de validación cruzada y calculamos \\(j_{test}(\\theta^{(q)})\\) para evaluar la capacidad de generalización del modelo. curva de aprendizaje a continuación vamos a estudiar cómo afecta el tamaño del conjunto de datos \\(m\\), el sesgo y la varianza a nuestro modelo: cuanto mayor es el tamaño, más difícil es encontrar una hipótesis que se adapte (\\(j_{train}(\\theta)\\) es mayor), pero el modelo generaliza mejor (\\(j_{cv}(\\theta)\\) es menor) cuando el sesgo (bias) es grande, entonces se produce underfitting y las predicciones de nuestro modelo son malas: el error del modelo es elevado, tanto sobre el conjunto de entrenamiento como sobre el conjunto de validación cruzada tener más ejemplos ayuda al modelo cuando la varianza (variance) es grande, entonces se produce overfitting, tal que el error en el conjunto de validación cruzada es muy alto: el modelo se adapta al conjunto de datos, por lo que el error de entrenamiento es menor tener más muestras ayuda al modelo debugging un algoritmo de aprendizaje para arreglar el overfitting que se produce cuando la varianza es elevada: obtener más datos de entrenamiento utilizar menos características (reducir el grado del vector de pesos), pero tras un proceso de selección de aquellas más relevantes intentar aumentar el parámetro de regularización para arregar el underfitting que se produce cuando el sesgo es elevado: añadir más características añadir características polinómicas intentar reducir el parámetro de regularización en las redes neuronales: las redes pequeñas tienden a producir underfitting pero son menos costosas computacionalmente las redes grandes tienen más características, por lo tanto hay una mayor probabilidad de overfitting gestionar datos sesgados: hay que ser consciente que a veces, por ejemplo en problemas de clasificación, hay categorías que con más comunes que el resto medidas de evaluación la precisión y el recall son medidas de evaluación que se complementan:     resultado resultado     1 0 predicción 1 verdadero positivo (tp) falso positivo (fp) predicción 0 falso negativo (fn) verdadero negativo (tn) precisión = \\(\\frac{tp}{\\text{ # positivos predichos }} = \\frac{tp}{tp + fp}\\) recall = \\(\\frac{tp}{\\text{ # positivos reales }} = \\frac{tp}{tp + fn}\\) balance entre precisión y recall cuánto mayor es la precisión menor es el recall y viceversa. entonces si queremos un modelo más preciso: \\begin{align} \\begin{cases} \\text{predecir } 1, \\text{ si } h_\\theta(x) \\geq 0.7 \\\\ \\text{predecir } 0, \\text{ si } h_\\theta(x) < 0.7 \\\\ \\end{cases} \\end{align} entonces, la precisión es mayor ya que el número de \\(fp\\) es menor, pero el recall es menor, ya que el número de \\(fn\\) es mayor. lo mismo pasa si queremos evitar falsos negativos, entonces hacemos: \\begin{align} \\begin{cases} \\text{predecir } 1, \\text{ si } h_\\theta(x) \\geq 0.5 \\\\ \\text{predecir } 0, \\text{ si } h_\\theta(x) < 0.5 \\\\ \\end{cases} \\end{align} tal que se reduce el número de \\(fn\\), y se aumenta el recall, pero el número de \\(fp\\) es mayor, por lo que se reduce la precisión. entonces, para encontrar un punto de balance entre las dos medidas tenemos que seleccionar un valor límite, tal que hacemos la predicción en base a \\(h_\\theta(x) \\geq \\text{ limite }\\). para calibrar ese límite podemos utilizar dos métricas de evaluación: la media de ambas métricas: \\(\\frac{p + r}{2}\\), funciona mal cuando \\(p >> r\\) o \\(r >> p\\), ya que el valor va a ser alto, pero no se ha encontrado un equilibrio. la puntuación \\(f_1 = 2 \\cdot \\frac{p\\cdot r}{(p + r)}\\), tal que cuanto mayor sea esta puntuación mejor ahora \\begin{align} \\begin{cases} f_1 \\approx 0, && p >> r \\\\ f_1 \\approx 0, && r >> p \\\\ \\end{cases} \\end{align} para escoger el límite lo que se hace es calcular la puntuación \\(f_1\\) sobre el conjunto de validación cruzada, y se escoge aquel límite que ofrezca la mayor puntuación. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/ML/StanfordCoursera/Map Reduce.html",
    "title": "Map Reduce",
    "body": " index search search back map reduce map reduce nos permite paralelizar los algoritmos. por ejemplo, supongamos que: tenemos \\(m = 400\\) datos utilizamos batch gradient descent para resolver el problema de optimización tenemos un número de pc equivalente a 4 sea \\(i\\) el índice de un pc este entrena sobre \\(x^{(i)}, \\cdots, x^{(i+100)}\\) calculamos el coste parcial para este conjunto de datos como: \\(temp_j^{(k)} = \\sum_{i}^{i+100} (h_\\theta(x^{(i)}) - y^{(i)})x^{(i)}_j\\) ahora, combinamos todos los pesos y aplicamos descenso gradiente: \\(\\theta_j = \\theta_j - \\alpha \\frac{1}{400} \\left( \\sum_{i}^k temp_j^{(i)}\\right)\\) este tipo de técnicas se utilizan si los algoritmos de entrenamiento pueden ser utilizamos como la suma de funciones, tanto el coste como el gradiente. también es aplicable a pcs con múltiples cores. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/MBJ/T3/02_information_criteria_and_crossvalidation.html",
    "title": "Information criteria and cross-validation",
    "body": " index search search back information criteria and cross-validation for historical reasons, measures of predictive accuracy are referred to as information criteria. these criteria are usually based on something called deviance that it's calculated by taking the negative two times the logarithm of the likelihood of the data given a point estimate of the model, \\(-2 \\log p(y|\\hat{\\theta}))\\). when we make predictions about new data that the model hasn't seen before, these predictions are usually less accurate than what we'd expect based on how well the model fits the data it was trained on. even if the family of models being fit happens to include the true data-generating process, and even if the parameters in the model happen to be sampled exactly from the specified prior distribution. we are interested in prediction accuracy for two reasons: to measure the performance of a model. to compare models. when comparing models with the same number of parameters, we can directly compare their best-fit log predictive densities. but when comparing models of different sizes or complexities we need to adjust for the fact that larger models can sometimes fit data better just by chance. estimating out-of-sample predictive accuracy using available data several methods are available to estimate the expected predictive accuracy without waiting for out-of-sample data. within-sample predictive accuracy: a naive estimate of the expected log predictive density for new data is the log predictive density for existing data using the computed lppd. this summary is in general an overestimate of elppd because it is evaluated on the data from which the model was fit. adjusted within-sample predictive accuracy: given that lppd is a biased estimate of elppd, the next logical step is to correct that bias. formulas such as aic, dic, and waic (all discussed below) give approximately unbiased estimates of elppd. cross-validation: one can attempt to capture out-of-sample prediction error by fitting the model to training data and then evaluating this predictive accuracy on a holdout set. cross-validation can be computationally expensive. akaike information criterion (aic) in much of the statistical literature on predictive accuracy, inference for \\(\\theta\\) is summarized not by a posterior distribution \\(p_{\\text{post}}\\) but by a point estimate \\(\\hat{\\theta}\\), typically the maximum likelihood estimate. out-of-sample predictive accuracy is then defined not by the expected log posterior predictive density (elppd) but by \\(\\text{elpd}_{\\hat{\\theta}} = \\mathbb{e}_f[\\log p(\\tilde{y}|\\tilde{\\theta}(y))]\\). let \\(k\\) be the number of parameters estimated in the model. aic is defined as follows: \\begin{align} \\hat{\\text{elpd}}_{\\text{aic}} = -2 \\log p(y|\\hat{\\theta}_{\\text{mle}}) + 2k \\end{align} subtracting \\(k\\) from the log predictive density given the maximum likelihood estimate \\(\\theta_{\\text{mle}}\\) is a correction to account for how much the fitting of \\(k\\) parameters will increase predictive accuracy, purely by chance. when we move beyond linear models with simple priors, just adding the number of fitted parameters \\(k\\) to adjust the deviance isn't accurate. informative priors and hierarchical structures typically decrease overfitting compared to simple estimation methods like least squares or maximum likelihood. in models with informative priors or hierarchical setups, the actual number of parameters depends heavily on the variance of the group-level parameter. deviance information criterion (dic) and effective number of parameters dic is a somewhat bayesian version of aic making two changes, replacing the maximum likelihood estimate with the posterior mean \\(\\hat{\\theta}_{\\text{bayes}} = \\mathbb{e}[\\theta|y]\\) and replacing \\(k\\) with a data-based bias correction. the new measure of predictive accuracy is: \\begin{align} \\hat{\\text{elpd}}_{dic} = \\log p(y|\\hat{\\theta}_{\\text{bayes}}) - p_{\\text{dic}} \\end{align} where \\(p_{\\text{dic}}\\) is the effective number of parameters, defined as: \\begin{align} p_{\\text{dic}} = 2 \\left(\\log p(y|\\hat{\\theta}_{\\text{bayes}}) - \\mathbb{e}_{post}[\\log p(y|\\theta)]\\right) \\end{align} where \\(\\mathbb{e}_{post}[\\log p(y|\\theta)]\\) is an average of \\(\\theta\\) over its posterior distribution. this is computed using simulation \\(\\theta^s, s= 1, \\cdots, s\\) as: \\begin{align} \\text{computed } p_{\\text{dic}} = 2 \\left(\\log p(y|\\hat{\\theta}_{\\text{bayes}}) - \\frac{1}{s} \\sum_{s=1}^s \\log p(y|\\theta^s)\\right) \\end{align} when the average value of \\(\\theta\\) in the posterior distribution matches the highest point (mode), it leads to the maximum log predictive density. however, if the average value is significantly different from the mode, it can result in a negative value for \\(p_{\\text{dic}}\\). an alternative version of dic uses a slightly different effective number of parameters: \\begin{align} p_{\\text{dic}_{\\text{alt}}} = 2 \\mathbb{v}_{\\text{post}}[\\log p(y|\\theta)] \\end{align} of these two measures, \\(p_{\\text{dic}}\\) is more numerically stable but \\(p_{\\text{dic}_{\\text{alt}}}\\) has the advantage of always being positive. the actual quantity called dic is defined in terms of the deviance rather than the log predictive density; thus: \\begin{align} \\text{dic} = -2 \\log p(y|\\hat{\\theta}_{\\text{bayes}}) + 2p_{dic} \\end{align} watanabe-akaike or widely applicable information criterion (waic) waic is a more fully bayesian approach for estimating the out-of-sample expectation. starting with the computed lppd and then adding a correction for effective number of parameters to adjust for overfitting. two adjustments have been proposed: \\begin{align} p_{\\text{waic}1} = 2 \\sum_{n=1}^n \\left(\\log(\\mathbb{e}_{\\text{post}}[p(y_i|\\theta)]) - \\mathbb{e}_{\\text{post}}[\\log p(y_i|\\theta)] \\right) \\end{align} computed by replacing the expectations by averages over the \\(s\\) posterior draws \\(\\theta^s\\): \\begin{align} \\text{computed } p_{\\text{waic}1} = 2 \\sum_{n=1}^n \\left(\\log\\left(\\frac{1}{s}\\sum_{s=1}^s p(y_i|\\theta^s)\\right) - \\frac{1}{s}\\sum_{s=1}^s \\log p(y_i|\\theta^s) \\right) \\end{align} the other measure uses the variance of individual terms: \\begin{align} p_{\\text{waic}2} = \\sum_{i=1}^n \\mathbb{v}_{\\text{post}}[\\log p(y_i|\\theta)] \\end{align} to compute it we compute the posterior sample variance (\\(\\mathbb{v}_{s=1}^s\\)) of the log predictive density for each data point \\(y_i\\) and we sum over all the data points: \\begin{align} \\text{computed } p_{\\text{waic}2} = \\sum_{i=1}^n \\mathbb{v}_{s=1}^s[\\log p(y_i|\\theta^s)] \\end{align} we can then use either \\(p_{\\text{waic}1}\\) or \\(p_{\\text{waic}2}\\) as a bias correction: \\begin{align} \\hat{\\text{elppd}}_{\\text{waic}} = \\text{lppd} - p_{\\text{waic}} \\end{align} as with \\(\\text{aic}\\) and \\(\\text{dic}\\), we define \\(\\text{waic}\\) so as to be on the deviance scale: \\begin{align} \\text{waic} = -2\\text{lppd} + 2p_{\\text{waic}2} \\end{align} for a normal linear model with a large sample size, known variance, and a uniform prior distribution on the coefficients, \\(p_{\\text{waic}1}\\) and \\(p_{\\text{waic}2}\\) are roughly equal to the number of parameters in the model. in general, this adjustment approximates the number of \"unconstrained\" parameters in the model. a parameter is counted as \\(1\\) if it's estimated without constraints or prior information, \\(0\\) if it's fully constrained, or if all the information comes from the prior distribution, or a value in between if both the data and prior distributions provide information. waic stands out because it averages over the whole posterior distribution rather than relying on a single point estimate, which is what aic and dic do. this makes waic more relevant when it comes to predicting new data in a bayesian framework. however, using waic requires dividing the data into \\(n\\) parts, which can be challenging in certain data setups like time series or spatial data. aic and dic don't require this explicit partition, but they assume that residuals are independent given a point estimate \\(\\hat{\\theta}\\), which may not fully capture posterior uncertainty. effective number of parameters as a random variable the number of parameters estimated in a model, as measured by \\(p_{\\text{dic}}\\) and \\(p_{\\text{waic}}\\), can vary depending on the observed data. let's take a simple example: imagine a model where the data \\(y_1, \\cdots, y_n\\) follow a normal distribution with a mean parameter \\(\\theta\\) and a known standard deviation of \\(1\\). the parameter \\(\\theta\\) is drawn from a uniform distribution between \\(0\\) and infinity, meaning it's positive but otherwise not informative. now, consider two scenarios: imagine you have a bunch of data points, but they are all very close to zero. in this case, the model has to consider that the parameter \\(\\theta\\) could be anywhere from very small positive values up to infinity. however, since the data are all close to zero, they don't provide much information about where \\(\\theta\\) might lie. the only constraint is that \\(\\theta\\) has to be positive. because the data don't give a strong indication of where \\(\\theta\\) might be, we say the effective number of parameters is roughly half. this is because half of the information about \\(\\theta\\) comes from the data, and the other half comes from the prior constraint that \\(\\theta\\) must be positive. now, imagine your data points are all large and positive. in this case, the constraint that \\(\\theta\\) must be positive doesn't really affect things much because the data already tell us that \\(\\theta\\) needs to be positive to explain those large positive values. since the data provide most of the information about where \\(\\theta\\) might lie, we say the effective number of parameters is approximately \\(1\\). this means that the data have a stronger influence on determining \\(\\theta\\) in this scenario. this example shows that even with the same model and true parameters, the effective number of parameters can change depending on the observed data. bayesian information criterion (bic) bic is a way to decide between different models by considering both how well the model fits the data and how complex the model is. the formula for bic is: \\begin{align} -2 \\log (p(y|\\hat{\\theta})) + k \\log(n) \\end{align} where \\(p(y|\\hat{\\theta})\\) is the likelihood of the data given the estimated parameters, \\(k\\) is the number of parameters in the model and \\(n\\) is the sample size. bic aims to approximate the marginal probability density of the data under the model, which can be used for comparing models and estimating relative posterior probabilities. bic tends to favor simpler models for large datasets because it penalizes complexity more, so a complicated model may perform well in predicting data but still have a high bic due to the penalty for complexity. unlike aic, which doesn't take the sample size into account, bic penalizes complex models more as the sample size increases. unlike aic, dic, and waic, bic doesn't focus on predicting future data but rather on estimating the probability of the observed data under the model. leave-one-out cross-validation in bayesian cross-validation, we split the data into two parts: a training set (\\(y_{\\text{ytrain}}\\)) and a holdout set (\\(y_{\\text{holdout}}\\)). we repeat this process multiple times, such that for each split: we train the model using the training set (\\(\\text{ytrain}\\)). this gives us a distribution of possible parameter values called \\(p_{\\text{train}}(\\theta) = p(\\theta|y_{\\text{train}})\\). then, we use this trained model to make predictions on the holdout set (\\(y_\\text{holdout}\\)). we evaluate the performance of our predictions using the log predictive density: \\begin{align} \\log p_{\\text{train}}(y_{\\text{holdout}}) = \\log \\mathbb{e}_{\\text{post}}[p_{\\text{train}}(y_{\\text{holdout}})] = \\log \\int p_{\\text{pred}}(y_{\\text{holdout}}|\\theta)p_{\\text{train}}(\\theta)d\\theta \\end{align} assuming the posterior distribution \\(p(\\theta|y_{\\text{train}})\\) is summarized by \\(s\\) simulation draws \\(\\theta^s\\), we calculate the log predictive density as: \\begin{align} \\log \\left(\\frac{1}{s} \\sum_{s=1}^s p(y_{\\text{holdout}}|\\theta^s)\\right) \\end{align} in loocv, we split the data into \\(n\\) partitions, where each partition represents a single data point. performing the analysis for each of the \\(n\\) data points yields n different inferences \\(p_{\\text{post}(-i)}\\), each summarized by \\(s\\) posterior simulations, \\(\\theta^{is}\\). the bayesian loo-cv estimate of out-of-sample predictive fit is: \\begin{align} \\text{lppd}_{\\text{loo-cv}} = \\sum_{i=1}^n \\log (p_{\\text{post}(-i)}(y_i)) \\end{align} computed as: \\begin{align} \\sum_{i=1}^n \\log \\left(\\frac{1}{s} \\sum_{s=1}^s p(y_i|\\theta^{is})\\right) \\end{align} where \\(\\theta^s\\) represents the \\(s\\) simulations under the posterior distribution \\(p(\\theta|y_{-1})\\). each prediction is conditioned on \\(n − 1\\) data points, which causes underestimation of the predictive fit. for large \\(n\\) the difference is negligible, but for small \\(n\\) (or when using \\(k\\)-fold cross-validation) we can use a first order bias correction b by estimating how much better predictions would be obtained if conditioning on \\(n\\) data points: \\begin{align} b = \\text{lppd} - \\overline{\\text{lppd}}_{-i} \\end{align} where: \\begin{align} \\overline{\\text{lppd}}_{-i} = \\frac{1}{n} \\sum_{i=1}^n \\sum_{j=1}^n \\log p_{\\text{post}(-i)}(y_j) \\end{align} computed as: \\begin{align} \\frac{1}{n} \\sum_{i=1}^n \\sum_{j=1}^n \\log \\left(\\frac{1}{s} \\sum_{s=1}^s p(y_j|\\theta^{is})\\right) \\end{align} the bias-corrected bayesian loo-cv is then: \\begin{align} \\text{lppd}_{\\text{cloo-cv}} = \\text{lppd}_{\\text{loo-cv}} + b \\end{align} the bias correction \\(b\\) is rarely used as it is usually small, but we include it for completeness. we compute an estimate of the effective number of parameters as: \\begin{align} p_{\\text{loo-cv}} = \\text{lppd} - \\text{lppd}_{\\text{loo-cv}} \\end{align} or, using bias-corrected loo-cv: \\begin{align} p_{\\text{cloo-cv}} = \\text{lppd} - \\text{lppd}_{\\text{cloo-cv}} \\end{align} \\begin{align} = \\overline{\\text{lppd}}_{-i} - \\text{lppd}_{\\text{loo-cv}} \\end{align} cv, like waic, requires the data to be split into distinct and ideally independent pieces. this can be challenging for structured models where the data isn't easily divided. additionally, cv can be computationally expensive, especially if the model needs to be re-fit for each fold. however, there are some shortcuts available, such as leave-one-out cross-validation (loo-cv), which can efficiently approximate predictions using the full posterior distribution. under certain conditions, different information criteria (like aic, dic, and waic) have been shown to be equivalent to loo-cv as the size of the dataset becomes very large. aic is equivalent to loo-cv when using maximum likelihood estimates. dic is a variation of regularized information criteria that approximates loo-cv using plug-in predictive densities. waic has been shown to be equivalent to bayesian loo-cv. loo-cv predicts the outcome for one data point using all other data points except that one. waic predicts the outcome for a data point using all observed data points. this difference becomes noticeable when dealing with small datasets or complex models, like hierarchical models. in regression or hierarchical models, loo-cv focuses on predicting specific data points, while waic predicts outcomes based on all observed data. this distinction can be important in models where predictions at one point are only weakly influenced by other data points. summary all the different measures discussed above are based on adjusting the log predictive density of the observed data by subtracting an approximate bias correction. the measures differ both in their baseline measures of fit and in their adjustments. aic starts with the log predictive density of the data conditional on the maximum likelihood estimate \\(\\hat{\\theta}\\), dic conditions on the posterior mean \\(\\mathbb{e}[\\theta|y]\\), and waic starts with the log predictive density, averaging over \\(p_{\\text{post}}(\\theta) = p(\\theta|y)\\). of these three approaches, only waic is fully bayesian and so it is our preference when using a bias correction formula. cross-validation can be applied to any measure of fit; we use the log pointwise posterior predictive density as with waic. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/MBJ/T3/03_model_comparison_based_on_predictive_performance.html",
    "title": "Model Comparison Based on Predictive Performance",
    "body": " index search search back model comparison based on predictive performance there are two common scenarios where we compare models. first, when we expand a model, we naturally want to compare the simpler version to the more complex one. we want to see if adding complexity improves the model's performance. conversely, if we simplify a model, we want to understand what information we might be losing. in essence, we're trying to figure out how much complexity is necessary to accurately represent the data. when comparing nested models, the bigger model usually fits the data better but can be more complex and harder to understand. so, we need to ask two main questions: does the better fit of the larger model justify its added complexity? and are the extra parameters in the larger model reasonable based on our prior knowledge? in the second scenario, we're comparing models that aren't nested. for example, we might compare two regression models that use different predictors to explain the same data. in these cases, we're not necessarily trying to pick one model over the other. instead, we might want to build a larger model that includes both sets of predictors, along with any interactions between them. this way, we get a more comprehensive picture. however, it's still useful to compare the performance of each model on its own to see how well they do individually. example on the eight schools example we defined three separate models: no pooling: separate estimates for each of the eight schools, reflecting that the experiments were performed independently. this model has eight parameters: an estimate for each school. complete pooling: a combined estimate averaging the data from all schools into a single number, reflecting that the eight schools come from the same population. this model has only one, shared, parameter. hierarchical model: a bayesian meta-analysis, partially pooling the eight estimates toward a common mean. this model has eight parameters but they are constrained through their hierarchical distribution and are not estimated independently; thus the effective number of parameters should be some number less than 8. in the following table we show the performance metrics for each of the models using predivtive log densities and information criteria. aic the log predictive density is higher—that is, a better fit—for the no pooling model. this makes sense: with no pooling, the maximum likelihood estimate is right at the data, whereas with complete pooling there is only one number to fit all \\(8\\) schools. however, the ranking of the models changes after adjusting for the fitted parameters (\\(8\\) for no pooling, \\(1\\) for complete pooling), and the expected log predictive density is estimated to be the best (that is, aic is lowest) for complete pooling. the last column of the table is blank for aic, as this procedure is defined based on maximum likelihood estimation which is meaningless for the hierarchical model. dic for both the no-pooling and complete-pooling models with their flat priors, dic provides results similar to aic. however, for the hierarchical model, dic falls in between the two extremes: it fits the data better than complete pooling but not as well as no pooling, and it suggests an effective number of parameters closer to \\(1\\) than to \\(8\\). this indicates that the estimated school effects are mostly pooled back to their common mean. when considering the correction for fitting, complete pooling emerges as the winner, which aligns with the idea that the data support very little variation between groups. waic this bayesian measure, similar to dic, indicates slightly worse fit to observed data for each model. this is because the posterior predictive density has a wider distribution, resulting in lower density values at the mode compared to the predictive density conditional on the point estimate. however, the correction for the effective number of parameters is lower with waic compared to dic. for models with no pooling and hierarchical models, the effective number of parameters (\\(p_{\\text{waic}}\\)) is about half of what's estimated by dic, suggesting that waic behaves as expected when there's only one data point per parameter. conversely, for complete pooling, \\(p_{\\text{waic}}\\) is only slightly less than \\(1\\), which aligns with expectations given the sample size of \\(8\\). overall, \\(p_{\\text{waic}}\\) is much less than pdic for all three models, mainly because the waic already considers much of the uncertainty stemming from parameter estimation. cross validation for this example, it's impossible to cross-validate the no-pooling model because it would mean predicting the performance of one school using data from the other seven, which isn't feasible. this highlights a key difference from information criteria, which assume predictions for the same schools and can work even in the absence of pooling. however, for the complete pooling and hierarchical models, we can directly perform leave-one-out cross-validation. in this setup, cross-validation predicts based only on information from other schools, while waic considers both the local observation and information from other schools. although both methods predict unknown future data, they differ in the amount of information used. as the hierarchical prior becomes less informative (or more vague), the predictive performance estimates diverge further, with the difference approaching infinity when the hierarchical prior becomes uninformative, effectively yielding the no-pooling model. comparing the three models in this dataset, the complete pooling model performs best in predicting new data. surprisingly, setting the hierarchical variance \\(\\tau\\) to zero results in a better fit to the data compared to both no pooling and complete pooling models. however, despite this result, we still prefer the hierarchical model because we don't believe \\(\\tau\\) is truly zero. for instance, the estimated effects in schools a and c show some differences, although they are not statistically significant. the data suggest that there might be no variation in effects between schools, but we are not entirely confident in this conclusion. therefore, while the model with \\(\\tau = 0\\) performs well, we might consider using a more informative prior distribution for \\(\\tau\\) to better capture the uncertainty and avoid implausible scenarios. in general, predictive accuracy measures are useful in parallel with posterior predictive checks to see if there are important patterns in the data that are not captured by each model. evaluating predictive error comparisons when comparing models for their predictive accuracy, we face two main challenges: statistical significance and practical significance. statistical significance arises from the uncertainty in estimating how well a model predicts new data. this uncertainty is due to variation in individual prediction errors, which can affect the averages we calculate from any finite dataset. a practical estimate of related sampling uncertainty can be obtained by analyzing the variation in the expected log predictive densities \\(\\hat{\\text{elppd}}\\) using parametric or nonparametric approaches. in some cases, we can use scoring functions that are familiar to experts in a particular field to understand the significance of differences in predictive accuracy. however, in situations where there are no established measures like auc, it can be challenging to interpret the significance of differences in log predictive probability between two models. one way to gauge the importance of such differences is by comparing them to simpler models. consider a scenario where we have two models for a survey of voters in an election: one model predicts a \\(50\\)/\\(50\\) chance for each voter to support either party, while the other model correctly assigns probabilities of \\(0.4\\) and \\(0.6\\) to the voters. in this case, the improvement in log predictive probability from using the better model can be calculated. for instance, if we have \\(1000\\) voters, the improvement would be \\(20\\), but for only \\(10\\) voters, the improvement would be just \\(2\\). this aligns with our intuition: a clear improvement in prediction is more noticeable in a larger dataset than in a smaller one where noise might overshadow the improvement. bias induced by model selection cross-validation and information criteria are methods that adjust for using the data twice—once for building the model and again for evaluating its performance. they aim to provide unbiased estimates of how well a model predicts new data. however, when these methods are used to select a model from multiple options, the estimate of predictive performance for the chosen model can be biased because of the selection process. when there are only a few models to compare, any bias introduced by the selection process is usually small. however, if there are many models to choose from, especially as the number of observations or predictors increases, the selection process can lead to significant overfitting. while it's possible to estimate and correct for this bias using additional cross-validation, it doesn't guarantee that the selected model will have the best predictive performance. therefore, cross-validation and information criteria are better suited for understanding models rather than selecting the best one among many options. challenges the methods we have for measuring how well predictive models fit still have their flaws. aic, dic, and waic don't always work perfectly: aic struggles with strong prior information, dic gives odd results when the average of the posterior distribution isn't reliable, and waic can be tricky to use with structured data like spatial or network data. cross-validation seems like a good alternative, but it can be slow to compute and doesn't always work well with dependent data. bayesian statisticians often don't rely solely on predictive error comparisons in their work because of various limitations. however, there are situations where comparing very different models is necessary, and in those cases, predictive comparisons can be valuable. additionally, measures of effective numbers of parameters are useful for understanding statistical methods. currently, we prefer cross-validation because it's similar to waic in large samples. however, in finite cases with weak priors or strong outliers, pareto-smoothed importance sampling loo-cv is both computationally efficient and robust. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/MBJ/T3/04_model_comparison_using_bayes_factors.html",
    "title": "Model Comparison Using Bayes Factors",
    "body": " index search search back model comparison using bayes factors in this chapter, we've been talking about how to evaluate and compare models by looking at how well they predict outcomes. another way to compare models is using bayesian analysis, where we use something called the bayes factor. so, if we have two models, let's call them \\(h_1\\) and \\(h_2\\), the bayes factor is just the ratio of how probable they are after we've looked at the data: \\begin{align} \\frac{p(h_2|y)}{p(h_1|y)} = \\frac{p(h_2)}{p(h_1)} \\times \\text{ bayes factor }(h_2;h_1) \\end{align} where \\begin{align} \\text{ bayes factor }(h_1; h_2) = \\frac{p(y|h_2)}{p(y|h_2)} = \\frac{\\int p(\\theta_2|h_2) p(y|\\theta_2, h_2) d\\theta_2}{\\int p(\\theta_1|h_1) p(y|\\theta_1, h_1) d\\theta_1} \\end{align} the bayes factor is only defined when the marginal density of \\(y\\) under each model is proper. this bayesian approach might sound good, but we usually don't recommend it. that's because the likelihood of the data given the model can be strongly influenced by parts of the model that are chosen somewhat arbitrarily and can't be tested with data. bayes factors can work well when the underlying model is truly discrete and for which it makes sense to consider one or the other model as being a good description of the data. we illustrate with an example from genetics. example: a discrete example in which bayes factors are helpful in the genetics example we talked about earlier, we can use bayes factors to help us make sense of things. imagine we have two possible scenarios: \\(h_1\\), where the woman is affected, and \\(h_2\\), where she's not affected. we can represent these scenarios using some numbers. for example, let's say \\(\\theta = 1\\) means she's affected, and \\(\\theta = 0\\) means she's not. now, let's say before we look at any data, we're equally likely to believe either scenario. so, the odds of h2 compared to h1 are 1 to 1, that is \\(\\frac{p(h_2)}{p(h_1)} = 1\\). then, when we look at the data and find out the woman has two unaffected sons, the data is \\(4\\) times more likely under \\(h_2\\) than under \\(h_1\\). that is \\(\\frac{p(y|h_2)}{p(y|h_1)} = \\frac{1.0}{0.25}\\). the posterior odds are thus \\(\\frac{p(h_2|y)}{p(h_1|y)} = 4\\) this example is helpful for bayes factors because the scenarios we're comparing make sense scientifically, and there are no other possible scenarios in between. also, the way the data fits with each scenario makes sense and gives us clear results. bayes factors don't work as well for models that are continuous. for instance, if we're looking at something like the effectiveness of a treatment, which can vary along a scale, it doesn't make sense to assign a probability to it being exactly zero. similarly, if we're comparing different models in regression, like deciding which variables to include, it's better to have all the possible variables in our consideration. we can then use a prior distribution to decide how much to trust each variable, even if we think some might not have much impact. to show why bayes factors struggle with continuous models, let's consider the example of the 8 schools problem, comparing the no-pooling and complete-pooling models. example. a continuous example where bayes factors are a distraction suppose we had analyzed the data from the 8 schools using bayes factors for the discrete collection of previously proposed standard models, no pooling (\\(h_1\\)) and complete pooling (\\(h_2\\)): \\begin{align} h_1: p(y|\\theta_1, \\cdots, \\theta_j) = \\prod_{j=1}^j text{n}(y_j|\\theta_j, \\sigma_j^2), p(\\theta_1, \\cdots, \\theta_j) \\propto 1 \\end{align} \\begin{align} h_2: p(y|\\theta_1, \\cdots, \\theta_j) = \\prod_{j=1}^j text{n}(y_j|\\theta_j, \\sigma_j^2), \\theta_1 = \\cdots = \\theta_j = \\theta \\propto 1 \\end{align} if we try to use bayes factors to pick or combine these models, we run into a problem. the bayes factor, which is the ratio of how likely the data is under one model compared to another, isn't defined here. that's because the prior distributions we're using are improper, which means they don't behave properly in the calculations. specifically, when we try to divide one function by another, we end up with \\(\\frac{0}{0}\\), which doesn't give us a clear answer. so, if we want to stick with the idea of assigning probabilities to these two specific models, we have two options: either use proper prior distributions or carefully construct improper ones in a way that makes sense. however, no matter which route we take, the results won't be very satisfying. more explicitly, suppose we replace the flat prior distributions in \\(h_1\\) and \\(h_2\\) by independent normal prior distributions, \\(\\text{n}(0, a^2)\\), for some large \\(a\\). the resulting posterior distribution for the effect in school \\(j\\) is: \\begin{align} p(\\theta_j|y) = (1 - \\lambda)p(\\theta_j|y, h_1) + \\lambda p(\\theta_j|y, h_2) \\end{align} the bayes factor, which compares how likely the data is under different models, is very sensitive to the prior variance, which is represented by \\(a^2\\). as we increase \\(a\\) (while keeping the data and prior odds fixed), the results tend to favor one model over the other more strongly. this means that bayes factors can't be reliably used with non-informative prior densities, even if we carefully define them in certain ways. another problem with bayes factors in this example is that they behave differently as we change the number of schools in the model. the results can vary significantly depending on how many schools are included, which doesn't make much sense from a scientific perspective. so, if we were to use bayes factors here, we'd likely run into issues during the model-checking stage, where we compare the model's predictions to what we know from real-world knowledge. instead, it might be better to use a smoother, continuous family of models that bridges the gap between the extreme models. this continuous model doesn't assign discrete probabilities to extreme values that don't make scientific sense. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/MBJ/T3/01_measure_precditive_accuracy.html",
    "title": "Measures of Predictive Accuracy",
    "body": " index search search back measures of predictive accuracy we begin by considering different ways of defining the accuracy or error of a model’s predictions then discuss methods for estimating predictive accuracy or error from data. preferably, the measure of predictive accuracy is specifically tailored for the application at hand, and it measures as correctly as possible the benefit (or cost) of predicting future data with the model. point prediction in point prediction (predictive point estimation or point forecasting) a single value is reported as a prediction of the unknown future observation. measures of predictive accuracy for point prediction are called scoring functions. for example, the mean squared error: \\begin{align} \\frac{1}{n} \\sum_{i=1}^n (y_i - \\mathbb{e}[y_i|\\theta])^2 \\end{align} or its weighted version: \\begin{align} \\frac{1}{n} \\sum_{i=1}^n \\frac{(y_i - \\mathbb{e}[y_i|\\theta])^2}{\\mathbb{v}[y_i|\\theta]} \\end{align} these are easy to compute but they are less appropiated for models that are far from the normal distribution. probabilistic prediction in probabilistic prediction (probabilistic forecasting) the aim is to report inferences about \\(\\hat{y}\\) in such a way that the full uncertainty over \\(\\hat{y}\\) is taken into account. these are called scoring rules. examples include the quadratic, logarithmic, and zero-one scores good scoring rules for prediction are: proper: the scoring rule encourages the decision maker to be honest when reporting their beliefs. local: the scoring rule takes into account the fact that some predictions may be worse than others, and it adjusts accordingly. for example the log predictive density or log-likelihood, \\(p(y|\\theta)\\), which is proportional to the mean squared error if the model is normal with constant variance. why not use the log posterior? the answer is that we are interested here in summarizing the fit of model to data, and for this purpose the prior is relevant in estimating the parameters but not inassessing a model's accuracy. we are not saying that the prior cannot be used in assessing a model's fit to data; rather we say that the prior density is not relevant in computing predictive accuracy. predictive accuracy for a single data point the best way to measure how well a model fits is by seeing how accurately it predicts outcomes in new data that it hasn't seen before (out-of-sample predictive performance), but that comes from the same process as the original data. we label \\(f\\) as the true model, \\(y\\) as the observed data and \\(\\tilde{y}\\) as future data. the out-of-sample predictive fit for a new data point \\(\\tilde{y}_i\\) using logarithmic score is: \\begin{align} \\log p_{\\text{post}}(\\tilde{y}_i) = \\log \\mathbb{e}_{\\text{post}}[p(\\tilde{y}_i|\\theta)] = \\end{align} by the definition of the expected value for a random variable: \\begin{align} = \\log \\int p(\\tilde{y}_i|\\theta) p_{\\text{post}}(\\theta)d\\theta \\end{align} where \\(p_{\\text{post}}(\\tilde{y}_i)\\) is the predictive density for \\(\\tilde{y}_i\\) induced by the posterior distribution \\(p_{\\text{post}}(\\theta)\\). note that we use \\(p_{\\text{post}}\\) and \\(\\mathbb{e}_{\\text{post}}\\) to denote any probability or expectation that averages over the posterior distribution of \\(\\theta\\). averaging over the distribution of future data the future data \\(\\tilde{y}_i\\) are themselves unknown and thus we define the expected out-of-sample log predictive density. by the definition of expected value of the function \\(\\log (x)\\) over \\(\\tilde{y}\\) with respect to a function \\(f\\) that describes the distribution of the data, we compute the expected log predictive density or elpd for a new data point as follows: \\begin{align} \\mathbb{e}_f[\\log p_{\\text{post}}(\\tilde{y}_i)] = \\int \\log (p_{\\text{post}}(\\tilde{y}_i)) f(\\tilde{y}_i) d\\tilde{y} \\end{align} in general we do not know the data distribution \\(f\\). a natural way to estimate the expected out-of-sample log predictive density would be to plug in an estimate for \\(f\\), but this will tend to imply too good a fit. for now we consider the estimation of predictive accuracy in a bayesian context. one can define a measure of predictive accuracy for the \\(n\\) data points taken one at a time: \\begin{align} \\sum_{i=1}^n \\mathbb{e}_f[\\log(p_{\\text{post}}(\\tilde{y}_i))] \\end{align} this gives us the expected log pointwise predictive density for a new dataset. using a single-point measure instead of dealing with the entire set of predictions (the joint distribution \\(p_{\\text{post}}(\\tilde{y})\\)) allows us to connect it to cross-validation, which helps us approximate how well our model performs on new data based on the data we already have. it is sometimes useful to consider predictive accuracy given a point estimate \\(\\theta(\\tilde{y})\\) (sampled data point given the parameter \\(\\theta\\)?). this gives us the expected log predictive density given \\(\\hat{\\theta}\\): \\begin{align} \\mathbb{e}_f[\\log(p(\\tilde{y}|\\theta))] \\end{align} evaluating predictive accuracy for a fitted model in practice the parameter \\(\\theta\\) is not known, so we cannot know the log predictive density \\(\\log p(y|\\theta)\\), which tells us how well our model predicts new data based on \\(\\theta\\). so, instead of using \\(\\theta\\) directly, we use something called the posterior distribution, denoted as \\(p_{\\text{post}}(\\theta) = p(\\theta|y)\\). this distribution gives us a range of possible values for \\(\\theta\\) based on the data we have. from this distribution, we can summarize how accurately our model predicts new data. so we define the log pointwise predictive density or lppd as: \\begin{align} \\log \\prod_{i=1}^n p_{\\text{post}}(y_i) = \\sum_{i=1}^n \\log \\int p(y_i|\\theta)p_{\\text{post}}(\\theta)d\\theta \\end{align} to calculate this predictive density, we can use samples drawn from the posterior distribution \\(p_{\\text{post}}(\\theta)\\) using simulation. these samples are labeled as \\(\\theta_s\\), where \\(s\\) ranges from \\(1\\) to \\(s\\). so we define the computed log pointwise predictive density or computed lppd as: \\begin{align} \\sum_{i=1}^n \\log \\left(\\frac{1}{s}\\sum_{s=1}^s p(y_i|\\theta^s)\\right) \\end{align} we basically compute the sample mean of the likelihood \\(p(y_i|\\theta)\\) for over all the \\(\\{\\theta^s\\}_{s=1}^s\\) we typically assume that the number of simulation draws \\(s\\) is large enough to fully capture the posterior distribution. the lppd of observed data y is an overestimate of the elppd for future data. hence the plan is to start with lppd and then apply some sort of bias correction to get a reasonable estimate of elppd. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/MBJ/01_intro.html",
    "title": "T1. Introduccion a la Inferencia Bayesiana",
    "body": " index search search back t1. introduccion a la inferencia bayesiana the three steps of bayesian data analysis the process of bayesian data analysis can be idealized by dividing it into the following three steps: setting up a full probability model: a joint probability distribution for all observable and unobservable quantities in a problem. conditioning on observed data: calculating and interpreting the appropriate posterior distribution. evaluating the fit of the model and the implications of the resulting posterior distribution we distinguish between two kinds of estimands quantities that are not directly observable: for example, parameters that govern the hypothetical process leading to the observed data, for which statistical inferences are made. potentially observable quantities (such as future observations of a process, or the outcome under the treatment not received) notation \\(\\theta\\): unobservable vector quantities or population parameters. \\(y\\): observed data \\(\\tilde{y}\\): unknown, but potentially observable, quantities. exchangeability we assume assume that the \\(n\\) values \\(y_i\\) may be regarded as exchangeable. we express uncertainty as a joint probability density \\(p(y_1, \\cdots, y_n)\\) that is invariant to permutations of the indexes. we commonly model data from an exchangeable distribution as independently and identically distributed (iid). explanatory variables observations on each unit that we do not model as random. hierarchical modeling hierarchical models (also called multilevel models), which are used when information is available on several different levels of observational units. bayesian inference we define a prior distribution \\(p(\\theta)\\), and a sampling distribution (or data distribution) is given by \\(p(y|\\theta)\\), such that the joint probability distribution for \\(\\theta\\) and \\(y\\) is obtained as follows: \\begin{align} p(\\theta,y) = p(\\theta|y)p(y) \\end{align} by baye's rule: \\begin{align} p(\\theta|y) = \\frac{p(\\theta, y)}{p(y)} = \\frac{p(y|\\theta)p(\\theta)}{p(y)} \\end{align} where \\(p(y) = \\sum_y p(y, \\theta) = \\sum_y p(y|\\theta) p(y) = \\int_y p(y|\\theta) p(y) dy\\) an equivalent form is omitting the factor \\(p(y)\\), yielding the unnormalized posterior density: \\begin{align} p(\\theta|y) \\propto p(y|\\theta)p(\\theta) \\end{align} prediction the marginal distribution of \\(y\\) or prior predictive distribution is given by: \\begin{align} p(y) = \\int p(y, \\theta) dy = \\int p(y|\\theta) p(\\theta) d\\theta \\end{align} the distribution of \\(\\tilde{y}\\) is called the posterior predictive distribution, posterior because it is conditional on the observed \\(y\\) and predictive because it is a prediction for an observable \\(\\tilde{y}\\). it is defined as the marginalization of \\(\\tilde{y}\\) over \\(y\\). \\begin{align} p(\\tilde{y}|y) = \\int p(\\tilde{y}, \\theta|y)d\\theta \\end{align} we note that the statistical process is also conditioned on the unobservable data \\(\\theta\\). por la propiedad \\(p(x, y|z) = p(x|y, z)p(z)\\): \\begin{align} = \\int p(\\tilde{y}|y, \\theta)p(\\theta|y) d\\theta \\end{align} asumimos independencia condicional entre \\(y\\) y \\(\\tilde{y}\\): \\begin{align} = \\int p(\\tilde{y}|\\theta)p(\\theta|y) d\\theta \\end{align} likelikhood when regarded as a function of \\(\\theta\\), for fixed y \\(p(y|\\theta)\\) is the likelihood function. likelihood and odds ratios odds a posteriori: \\begin{align} \\frac{p(\\theta_1|y)}{p(\\theta_2|y)} = \\frac{\\frac{p(y|\\theta_1)p(\\theta_1)}{p(y)}}{\\frac{p(y|\\theta_2)p(\\theta_2)}{p(y)}} = \\frac{p(y|\\theta_1)p(\\theta_1)}{p(y|\\theta_2)p(\\theta_2)} \\end{align} odds a priori: \\begin{align} \\frac{p(\\theta_1)}{p(\\theta_2)} \\end{align} likelihood ratio: \\begin{align} \\frac{p(\\theta_1|y)}{p(\\theta_2|y)} \\end{align} probability theory the expected value of a continuous random variable \\(u\\) is given by: \\begin{align} \\mathbb{e}[u] = \\int u p(u)du \\end{align} the variance for a continuous random variable \\(u\\) is given by: \\begin{align} \\mathbb{e}[u] = \\int (u - \\mathbb{e}[u])^2 p(u)du \\end{align} the expected value of a discrete random variable \\(u\\) is given by: \\begin{align} \\mathbb{e}[u] = \\sum u p(u) \\end{align} the variance for a discrete random variable \\(u\\) is given by: \\begin{align} \\mathbb{e}[u] = \\sum (u - \\mathbb{e}[u])^2 p(u) \\end{align} means and variances of conditional distributions given two continuous random variables \\(u\\) and \\(y\\), the mean of \\(u\\) can be obtained by averaging the conditional mean over the marginal distribution of \\(v\\): \\begin{align} \\mathbb{e}(u) = \\int u p(u) du = \\int u \\left(\\int p(u, v)\\right) dv du \\end{align} \\begin{align} = \\int \\left(\\int u p(u|v) du \\right) p(v) dv = \\int \\mathbb{e}_u[u|v] p(v) dv = \\mathbb{e}_v[\\mathbb{e}_u[u|v]] \\end{align} the corresponding result for the variance: \\begin{align} \\mathbb{v}[u] = \\mathbb{e}[\\mathbb{v}[u|v]] - \\mathbb{v}[\\mathbb{e}[u|v]] \\end{align} transformation of variables suppose \\(p_u(u)\\) is the density of the vector \\(u\\), and we transform to \\(v = f(u)\\), where \\(v\\) has the same number of components as \\(u\\). if \\(p_u\\) is a discrete distribution, and \\(f\\) is a one-to-one function, then the density of \\(v\\) is given by: \\begin{align} p_v(v) = p_u(f^{-1}(v)) \\end{align} if \\(p_u\\) is a continuous distribution, and \\(v = f(u)\\) is a one-to-one transformation, then the joint density of the transformed vector is: \\begin{align} p_v(v) = |j| p_u(f^{-1}(v)) \\end{align} where \\(|j|\\) is the absolute value of the determinant of the jacobian of the transformation \\(u = f^{−1}(v)\\) as a function of \\(v\\). $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/MBJ/T4/01_gibbs_sampler.html",
    "title": "Gibbs Sampler",
    "body": " index search search back gibbs sampler introduction many smart techniques have been developed to create and sample from different types of posterior distributions. one common method is called markov chain simulation, also known as markov chain monte carlo (mcmc). it works by first drawing values of a parameter (usually denoted as \\(\\theta\\)) from rough estimates of the distribution, and then adjusting those draws to better match the actual distribution we're interested in, called the posterior distribution, denoted as \\(p(\\theta|y)\\). the drawing process is done step by step, with each draw depending on the previous one, forming what's called a markov chain. figure 11.1 shows a simple example of markov chain simulation, using what's called a metropolis algorithm. imagine we have a parameter called \\(\\theta\\) that is a vector with two components, such that \\(\\theta \\sim \\text{n}(0, i)\\). now, let's look at figure 11.1a, which shows the early steps of this simulation. the picture represents all the possible values that \\(\\theta\\) can take, and each of the five squiggly lines shows the path taken by a random walk. these random walks start either near the center or at the edges of the distribution and move around based on a series of random steps. in figure 11.1b, we see the later stages of the same simulation. each of the random walks has now traced a path throughout the entire space of possible \\(\\theta\\) values. they've settled into a common pattern, which matches the target distribution we're interested in. finally, in figure 11.1c, we can use the information gathered from the second halves of these simulated random walks to make inferences about \\(\\theta\\). in our use of markov chain simulation, we create multiple separate sequences. each sequence starts from a particular point, like \\(\\theta_0\\), and then we move step by step, drawing a new value \\(\\theta_t\\) from a transition distribution \\(t_t(\\theta_t|\\theta_{t−1})\\), which depends on the previous draw. markov chain simulation is used when it is not possible to sample \\(\\theta\\) directly from \\(p(\\theta|y)\\) instead we sample iteratively in such a way that at each step of the process we expect to draw from a distribution that becomes closer to \\(p(\\theta|y)\\). once the simulation algorithm has been implemented and the simulations drawn, it is absolutely necessary to check the convergence of the simulated sequences; for example, the simulations of figure 11.1a are far from convergence and are not close to the target distribution. gibbs sampler imagine you have a \\(d\\)-dimensional parameter vector \\(\\theta\\) that's been split into smaller parts, such that \\(\\theta = (\\theta_1, \\cdots, \\theta_d)\\). each time the gibbs sampler runs, it goes through each of the dimensions, one at a time, while keeping the rest fixed. so, if there are \\(d\\) dimensions, there are \\(d\\) steps in each iteration \\(t\\). at each iteration, we pick an order for the \\(d\\) parts of \\(\\theta\\). then, we go through each part one by one and we sample a new value for each part based on the current values of all the other parts. this continues for each part until we've updated all of them once, and then we start the process over again for the next iteration. \\begin{align} p(\\theta_j|\\theta_{-j}^{t-1}, y) \\end{align} where \\(\\theta_{-j}^{t-1}\\) represents all the components of \\(\\theta\\) except for \\(\\theta_j\\) at their current values: \\begin{align} \\theta_{-j}^{t - 1} = (\\theta_1^t, \\cdots, \\theta^t_{j - 1}, \\theta_{j + 1}^{t - 1}, \\theta_{d}^{t - 1}) \\end{align} thus, each subvector \\(\\theta_j\\) is updated conditional on the latest values of the other components of \\(\\theta\\), which are the iteration \\(t\\) values for the components already updated and the iteration \\(t − 1\\) values for the others. here, we illustrate the workings of the gibbs sampler with a simple example. example: bivariate normal distribution consider a single observation \\((y_1, y_2)\\) from a bivariate normally distributed population with unknown mean \\(\\theta = (\\theta_1, \\theta_2)\\) and known covariance matrix \\(\\begin{bmatrix}1 & \\rho \\\\ \\rho & 1\\end{bmatrix}\\). with a uniform prior distribution on \\(\\theta\\), the posterior distribution is: \\begin{align} \\begin{bmatrix} \\theta_1 \\\\ \\theta_2 \\\\ \\end{bmatrix} | y \\sim \\text{n}(\\begin{bmatrix} y_1 \\\\ y_2 \\\\ \\end{bmatrix}, \\begin{bmatrix} 1 & \\rho \\\\ \\rho & 1 \\\\ \\end{bmatrix}) \\end{align} we need the conditional posterior distributions, which, from the properties of the multivariate normal distribution, are: \\begin{align} \\theta_1 |\\theta_2, y \\sim \\text{n}(y_1 + \\rho(\\theta_2 - y_2), 1 - \\rho^2) \\end{align} \\begin{align} \\theta_2 |\\theta_1, y \\sim \\text{n}(y_2 + \\rho(\\theta_1 - y_1), 1 - \\rho^2) \\end{align} the gibbs sampler proceeds by alternately sampling from these two normal distributions. figure 11.2 illustrates for the case \\(\\rho = 0.8\\), data \\((y_1, y_2) = (0, 0)\\), and four independent sequences started at \\((\\pm 2.5, \\pm 2.5)\\). $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/MBJ/T4/05_effective_number_of_simulations.html",
    "title": "Effective Number of Simulation Draws",
    "body": " index search search back effective number of simulation draws one way to define effective sample size for correlated simulation draws is to consider the statistical efficiency of the average of the simulations \\(\\overline{\\psi}_{..}\\), as an estimate of the posterior mean, \\(\\mathbb{e}[\\psi|y]\\). this might be inappropriate, for example, if there is particular interest in accurate representation of low-probability events in the tails of the distribution. continuing with this definition, it is usual to compute effective sample size using the following asymptotic formula for the variance of the average of a correlated sequence: \\begin{align} \\lim_{n \\rightarrow \\infty} mn \\mathbb{v}[\\overline{\\psi}_{..}] = \\left(1 + 2 \\sum_{t = 1}^{\\infty} \\rho_t\\right) \\mathbb{v}[\\psi|y] \\end{align} where \\(\\rho_t\\) is the autocorrelation of the sequence \\(\\psi\\) at \\(t\\). in the presence of correlation we then define the effective sample size as: \\begin{align} n_{eff} = \\frac{mn}{1 + 2 \\sum_{t = 1}^{\\infty} \\rho_t} \\end{align} the asymptotic nature of the previous equations might seem disturbing given that in reality we will only have a finite simulation, but this should not be a problem given that we already want to run the simulations long enough for approximate convergence to the (asymptotic) target distribution. we then estimate the correlations as: \\begin{align} \\hat{\\rho}_t = 1 - \\frac{v_t}{2 \\overline{\\mathbb{v}}^+} \\end{align} where: \\begin{align} v_t = \\frac{1}{m(n - t)} \\sum_{j=1}^m \\sum_{i = t+1}^n (\\psi_{i,j} - \\psi_{i - t, j})^2 \\end{align} unfortunately we cannot simply sum all of these to estimate \\(n_{eff}\\) given that for large values of \\(t\\) the sample correlation \\(\\psi_t\\) is too noisy. instead we compute a partial sum, starting from \\(t = 0\\) and continuing until the sum of autocorrelation estimates for two successive iterationsis negative: \\begin{align} \\hat{n}_{eff} = \\frac{mn}{1 + 2 \\sum_{t = 1}^t \\hat{\\rho}_t} \\end{align} all these calculations should be performed using only the saved iterations, after discarding the warm-up period. bounded or long-tailed distributions the above convergence diagnostics are based on means and variances, and they will not work so well for parameters or scalar summaries for which the posterior distribution, \\(p(\\phi|y)\\), is far from gaussian. for summaries \\(\\phi\\) whose distributions are constrained or otherwise far from normal, we can preprocess simulations using transformations before computing the potential scale reduction factor \\(\\hat{r}\\) and the effective sample size \\(\\hat{n}_{eff}\\). stopping the simulations we monitor convergence for the entire multivariate distribution, \\(p(\\theta|y)\\), by computing the potential scale reduction factor \\(\\hat{r}\\) and the effective sample size \\(\\hat{n}_{eff}\\) for each scalar summary of interest. we recommend computing the potential scale reduction for all scalar estimands of interest; if \\(\\hat{r}\\) is not near \\(1\\) for all of them, continue the simulation runs. we can use effective sample size \\(\\hat{n}_{eff}\\) to give us a sense of the precision obtained from our simulations. as a default rule, we suggest running the simulation until \\(\\hat{n}_{eff}\\) is at least \\(5m\\), that is, until there are the equivalent of at least \\(10\\) independent draws per sequence. for some purposes, more precision will be desired, and then a higher effective sample size threshold can be used. once \\(\\hat{r}\\) is near \\(1\\) and \\(\\hat{n}_{eff}\\) is more than \\(10\\) per chain for all scalar estimands of interest, just collect the \\(mn\\) simulations (with warm-up iterations already excluded) and treat them as a sample from the target distribution. even if an iterative simulation appears to converge and has passed all tests of convergence, it still may actually be far from convergence if important areas of the target distribution were not captured by the starting distribution and are not easily reachable by the simulation algorithm. when we declare approximate convergence, we are actually concluding that each individual sequence appears stationary and that the observed sequences have mixed well with each other. these checks are not hypothesis tests. there is no p-value and no statistical significance. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/MBJ/T4/03_using_gibbs_and_metropolis.html",
    "title": "Using Gibbs and Metropolis as Building Blocks",
    "body": " index search search back using gibbs and metropolis as building blocks the gibbs sampler is the simplest of the markov chain simulation algorithms, and it is our first choice for conditionally conjugate models. the metropolis algorithm can be used for models that are not conditionally conjugate. a general problem with conditional sampling algorithms is that they can be slow when parameters are highly correlated in the target distribution. interpretation of the gibbs sampler as a special case of the metropolis-hastings algorithm we first define iteration \\(t\\) to consist of a series of \\(d\\) steps, with step \\(j\\) of iteration \\(t\\) corresponding to an update of the subvector \\(\\theta_j\\) conditional on all the other elements of \\(\\theta\\). then the jumping distribution, \\(j_{j,t}(\\cdot|\\cdot)\\) is defined as follows: \\begin{align} j_{j, t}^{\\text{gibbs}}(\\theta^*|\\theta^{t-1}) = \\begin{cases} p(\\theta_j^*|\\theta_{-j}^{t-1}, y) & \\text{ if } \\theta_{-j}^* = \\theta_{-j}^{t-1} \\\\ 0 & \\text{ otherwise} \\end{cases} \\end{align} such that at step \\(j\\) of iteration \\(t\\) it only jumps along the \\(j\\)th subvector, and does so with the conditional posterior density of \\(\\theta_j\\) given \\(\\theta_{-j}^{t - 1}\\). the only possible jumps are to parameter vectors \\(\\theta^*\\) that match \\(\\theta^{t-1}\\) on all components other than the \\(j\\)th. under this jumping distribution, the ratio at the \\(j\\)th step of iteration t is: \\begin{align} r = \\frac{\\frac{p(\\theta^*|y)}{j_{j, t}^{\\text{gibbs}}(\\theta^*|\\theta^{t-1})}}{\\frac{p(\\theta^{t-1}|y)}{j_{j,t}^{\\text{gibbs}}(\\theta^{t-1}|\\theta^*)}} \\end{align} \\begin{align} = \\frac{\\frac{p(\\theta^*|y)}{p(\\theta_j^*|\\theta^{t-1}_{-j}, y)}}{\\frac{p(\\theta^{t-1}|y)}{p(\\theta^{t-1}_j|\\theta^{t-1}_{-j}, y)}} \\end{align} \\begin{align} = \\frac{p(\\theta^{t-1}_{-j}, y)}{p(\\theta^{t-1}_{-j}, y)} \\end{align} \\begin{align} = 1 \\end{align} and thus every jump is accepted. the second line above follows from the first because, under this jumping rule, \\(\\theta^*\\) differs from \\(\\theta^{t−1}\\) only in the \\(j\\)th component. the third line follows from the second by applying the rules of conditional probability to \\(\\theta = (\\theta_j, \\theta_{−j})\\) and noting that \\(\\theta^*_{-j} = \\theta^{t-1}_{-j}\\). it is possible to define gibbs sampling without the restriction that each component be updated in each iteration, as long as each component is updated periodically. gibbs sampler with approximations for some problems, sampling from some, or all, of the conditional distributions \\(p(\\theta_j|\\theta_{−j}, y)\\) is impossible, but one can construct approximations, which we label \\(g(\\theta_j|\\theta_{−j})\\), from which sampling is possible. the jumping function at the jth metropolis step at iteration \\(t\\) is then: \\begin{align} j_{j, t}(\\theta^*|\\theta^{t-1}) = \\begin{cases} g(\\theta^*_j|\\theta_{-j}^{t-1}) & \\text{ if } \\theta^*_{-j} = \\theta^{t-1}_{-j} \\\\ 0 & \\text{ otherwise } \\end{cases} \\end{align} and the ratio \\(r\\) must be computed and the acceptance or rejection of \\(\\theta^*\\) decided. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/MBJ/T4/04_inference_and_assesing_convergence.html",
    "title": "Inference and Assessing Convergence",
    "body": " index search search back inference and assessing convergence the basic method of inference from iterative simulation is the same as for bayesian simulation in general: use the collection of all the simulated draws from \\(p(\\theta|y)\\) to summarize the posterior density and to compute quantiles, moments, and other summaries of interest as needed. difficulties of inference from iterative simulation iterative simulation adds two challenges to simulation inference: if the iterations have not proceeded long enough the simulations may be unrepresentative of the target distribution (figure 11.1a) the iterative simulation draws present within-sequence correlation. serial correlation in the simulations is not necessarily a problem because, at convergence, the draws are identically distributed as \\(p(\\theta|y)\\). but such correlation can cause inefficiencies in simulations. we handle these problems as follows: we design the simulation runs to allow effective monitoring of convergence by simulating multiple sequences with starting points dispersed throughout parameter space. we monitor the convergence of all quantities of interest by comparing variation between and within simulated sequences until \"within\" variation roughly equals \"between\" variation. only when the distribution of each simulated sequence is close to the distribution of all the sequences mixed together can they all be approximating the target distribution. if the simulation efficiency is low, the algorithm may be altered. discarding early iterations of the simulation runs to diminish the influence of the starting values, we discard the first half of each sequence and focus attention on the second half. so our inferences will be based on the assumption that the distributions of the simulated values \\(\\theta_t\\), for large enough \\(t\\), are close to the target distribution, \\(p(\\theta|y)\\). we refer to the practice of discarding early iterations in markov chain simulation as warm-up. depending on the context, different warm-up fractions (number of elements on the sequence to discard) can be appropriate. dependence of the iterations in each sequence once approximate convergence has been reached, is whether to thin the sequences by keeping every \\(k\\)th simulation draw from each sequence and discarding the rest. whether or not the sequences are thinned, if the sequences have reached approximate convergence, they can be directly used for inferences about the parameters \\(\\theta\\) and any other quantities of interest. multiple sequences with overdispersed starting points our recommended approach to assessing convergence of iterative simulation is based on comparing different simulated sequences, as illustrated in figure 11.1. in figure 11.1a, the multiple sequences clearly have not converged; the variance within each sequence is much less than the variance between sequences. later, in figure 11.1b, the sequences have mixed, and the two variance components are essentially equal. monitoring scalar estimands we monitor each scalar estimand or other scalar quantities of interest separately. estimands include all the parameters of interest in the model and any other quantities of interest (for example, the ratio of two parameters or the value of a predicted future observation). it is often useful also to monitor the value of the logarithm of the posterior density, which has probably already been computed if we are using a version of the metropolis algorithm. challenges of monitoring convergence: mixing and stationarity figure 11.3a illustrates that, to achieve convergence, the sequences must together have mixed. the second graph in figure 11.3 shows two chains that have mixed, in the sense that they have traced out a common distribution, but they do not appear to have converged. figure 11.3b illustrates that, to achieve convergence, each individual sequence must reach stationarity. so to check convergence we have to simultaneously tests mixing (if all the chains have mixed well, the separate parts of the different chains should also mix) and stationarity (at stationarity, the first and second half of each sequence should be traversing the same distribution). splitting each saved sequence into two parts we diagnose convergence (as noted above, separately for each scalar quantity of interest) by checking mixing and stationarity. our approach consists on splitting each chain in half and check that all the resulting halfsequences have mixed. we start with some number of simulated sequences in which the warm-up period has already been discarded. we then take each of these chains and split into the first and second half. let \\(m\\) be the number of chains (after splitting) and \\(n\\) be the length of each chain. for example, suppose we simulate \\(5\\) chains, each of length \\(1000\\), and then discard the first half of each as warm-up. we are then left with \\(5\\) chains, each of length \\(500\\), and we split each into two parts: iterations \\(1–250\\) (originally iterations \\(501–750\\)) and iterations \\(251–500\\) (originally iterations \\(751–1000\\)). we now have \\(m = 10\\) chains, each of length \\(n = 250\\). assessing mixing using between- and within-sequence variances for each scalar estimand \\(\\psi\\), we label the simulations as \\(\\psi_{ij}, (i = 1, \\cdots, n; j = 1, \\cdots, m)\\), and we compute \\(b\\) and \\(w\\), the between- and within-sequence variances: \\begin{align} b = \\frac{n}{m - 1} \\sum_{j=1}^m (\\overline{\\psi}_{.j} - \\overline{\\psi}_{..})^2 \\end{align} where: \\begin{align} \\overline{\\psi}_{.j} = \\frac{1}{n} \\sum_{i=1}^n \\psi_{ij} \\end{align} \\begin{align} \\overline{\\psi}_{..} = \\frac{1}{m} \\sum_{j=1}^m \\overline{\\psi}_{.j} \\end{align} and \\begin{align} w = \\frac{1}{m} \\sum_{j=1}^m s_{j}^2 \\end{align} where \\begin{align} s^2_j = \\frac{1}{n - 1} \\sum_{i = 1}^n (\\psi_{ij} - \\overline{\\psi}_{.j})^2 \\end{align} we can estimate \\(\\mathbb{v}[\\psi|y]\\), the marginal posterior variance of the estimand, by a weighted average of \\(w\\) and \\(b\\), namely: \\begin{align} \\hat{\\mathbb{v}}^+[\\psi|y] = \\frac{n - 1}{n}w + \\frac{1}{n} b \\end{align} this quantity overestimates the marginal posterior variance assuming the starting distribution is appropriately overdispersed, but is unbiased under stationarity. meanwhile, for any finite \\(n\\), the \"within\" variance \\(w\\) should be an underestimate of \\(\\mathbb{v}[\\psi|y]\\) because the individual sequences have not had time to range over all of the target distribution and, as a result, will have less variability; in the limit as \\(n \\rightarrow \\infty\\), the expectation of \\(w\\) approaches \\(\\mathbb{v}[\\psi|y]\\). we monitor convergence of the iterative simulation by estimating the factor by which the scale of the current distribution for \\(\\psi\\) might be reduced if the simulations were continued in the limit \\(n \\rightarrow \\infty\\). this potential scale reduction is estimated by: \\begin{align} \\hat{r} = \\sqrt{\\frac{\\hat{\\mathbb{v}}[\\psi|y]}{w}} \\end{align} which declines to \\(1\\) as \\(n \\rightarrow 1\\). if the potential scale reduction is high, then we have reason to believe that proceeding with further simulations may improve our inference about the target distribution of the associated scalar estimand. example. bivariate unit normal density with bivariate normal jumping kernel (continued) table 11.1 displays posterior inference for the two parameters of the distribution as well as the log posterior density. after \\(50\\) iterations, the variance between the five sequences is much greater than the variance within, for all three univariate summaries considered. however, the five simulated sequences have converged adequately after \\(2000\\) or certainly \\(5000\\) iterations for the quantities of interest. the comparison with the true target distribution shows how some variability remains in the posterior inferences even after the markov chains have converged. the method of monitoring convergence presented here has the key advantage of not requiring the user to examine time series graphs of simulated sequences. inspection of such plots is a notoriously unreliable method. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/MBJ/T4/02_metropolist_algorithm.html",
    "title": "Metropolis and Metropolis-Hastings Algorithms",
    "body": " index search search back metropolis and metropolis-hastings algorithms the metropolis-hastings algorithm is a general term for a family of markov chain simulation methods that are useful for sampling from bayesian posterior distributions. we have already seen the gibbs sampler in the previous section; it can be viewed as a special case of metropolis-hastings. the metropolis algorithm the metropolis algorithm is an adaptation of a random walk with an acceptance/rejection rule to converge to the specified target distribution. the algorithm proceeds as follows. draw a starting point \\(\\theta_0\\), for which \\(p(\\theta_0|y) > 0\\), from a starting distribution \\(p_0(\\theta)\\). the starting distribution might be based on an approximation or we may simply choose starting values dispersed around a crude approximate estimate. for \\(t = 1, 2, \\cdots\\): sample a proposal \\(\\theta^*\\) from a jumping distribution (or proposal distribution) at time \\(t\\), \\(j_t(\\theta^*|\\theta^{t-1})\\). for the metropolis algorithm (but not the metropolis-hastings algorithm, as discussed later in this section), the jumping distribution must be symmetric. calculate the ratio of the densities: \\begin{align} r = \\frac{p(\\theta^*|y)}{p(\\theta^{t- 1}|y)} \\end{align} set: \\begin{align} \\theta^t = \\begin{cases} \\theta^* & \\text{ with probability } \\min(r, 1) \\\\ \\theta^{t-1} \\text{ otherwise } \\end{cases} \\end{align} the acceptance/rejection rule of the metropolis algorithm can be stated as follows: if the jump increases the posterior density, set \\(\\theta^t = \\theta^*\\); if the jump decreases the posterior density, set \\(\\theta^t = \\theta^*\\) with probability equal to the density ratio, \\(r\\), otherwise set \\(\\theta_t = \\theta^{t - 1}\\) (with probability \\(1 - r\\)). the metropolis algorithm can thus be viewed as a stochastic version of a stepwise mode-finding algorithm, always accepting steps that increase the density but only sometimes accepting downward steps. to use the algorithm, we need to calculate the ratio \\(r\\) for every pair of \\((\\theta, \\theta^*)\\), and we also need to choose \\(\\theta\\) from the jumping distribution \\(j_t(\\theta^*|\\theta)\\) for all \\(\\theta\\) and \\(t\\). additionally, we need to generate a random number for step (\\(c\\)) in the process. even if the jump isn't accepted and \\(\\theta_t\\) equals \\(\\theta_{t-1}\\), it still counts as a step in the algorithm. example: bivariate unit normal density with normal jumping kernel for simplicity, we illustrate the metropolis algorithm with the simple example of the bivariate unit normal distribution. the target density is the bivariate unit normal, \\(p(\\theta|y) = \\text{n}(\\theta|0, i)\\). the jumping distribution is also bivariate normal, centered at the current iteration and scaled to \\(\\frac{1}{5}\\) the size: \\(j_t(\\theta^*|\\theta^{t−1}) = \\text{n}(\\theta^*|\\theta^{t−1}, 0.22\\cdot i)\\). at each step, it is easy to calculate the density ratio: \\[ r = \\frac{\\text{n}(\\theta^*|0, i)}{\\text{n}(\\theta^{t-1}|0, i)} \\] it is clear from the form of the normal distribution that the jumping rule is symmetric. figure 11.1 displays five simulation runs starting from different points. we have purposely set the scale of this jumping algorithm to be too small, relative to the target distribution, so that the algorithm will run inefficiently and its random-walk aspect will be obvious in the figure. why does the metropolis algorithm work? the proof that the sequence of iterations \\(\\theta_1, \\theta_2, \\cdots\\) converges to the target distribution has two steps: it is shown that the simulated sequence is a markov chain with a unique stationary distribution. it is shown that the stationary distribution equals the target distribution. except for trivial exceptions, the latter two conditions hold for a random walk on any proper distribution, and irreducibility holds as long as the jumping distributions jt is eventually be able to jump to all states with positive probability. to show (1) consider starting the algorithm at time \\(t − 1\\) with a draw \\(\\theta^{t−1}\\) from the target distribution \\(p(\\theta|y)\\). now consider any two such points \\(\\theta_a\\) and \\(\\theta_b\\), drawn from \\(p(\\theta|y)\\) and labeled so that \\(p(\\theta_b|y) \\geq p(\\theta_a|y)\\). the unconditional probability density of a transition from \\(\\theta_a\\) to \\(\\theta_b\\) is: \\begin{align} p(\\theta^{t - 1} = \\theta_a, \\theta^t = \\theta_b) = p(\\theta_a|y)j_t(\\theta_b|\\theta_a) \\end{align} where the acceptance probability is \\(1\\) because of our labeling of \\(a\\) and \\(b\\), and the unconditional probability density of a transition from \\(\\theta_b\\) to \\(\\theta_a\\) is: \\begin{align} p(\\theta^t = \\theta_a, \\theta^{t-1} = \\theta_b) = p(\\theta_b|y)j_t(\\theta_a|\\theta_b) \\left(\\frac{p(\\theta_a|y)}{p(\\theta_b|y)}\\right) \\end{align} \\begin{align} = p(\\theta_b|y)j_t(\\theta_a|\\theta_b) \\end{align} which is the same as the probability of a transition from \\(\\theta_a\\) to \\(\\theta_b\\), since we have required that \\(j_t(\\cdot|\\cdot)\\) be symmetric. since their joint distribution is symmetric, \\(\\theta^t\\) and \\(\\theta^{t−1}\\) have the same marginal distributions, and so \\(p(\\theta|y)\\) is the stationary distribution of the markov chain of \\(\\theta\\). the metropolis-hastings algorithm the metropolis-hastings algorithm generalizes the basic metropolis algorithm presented above in two ways. the jumping rules \\(j_t\\) need no longer be symmetric. to correct for the asymmetry in the jumping rule the ratio \\(r\\) is replaced by a ratio of ratios: \\begin{align} r = \\frac{\\frac{p(\\theta^*|y)}{j_t(\\theta^*|\\theta^{t-1})}}{\\frac{p(\\theta^{t-1}|y)}{j_t(\\theta^{t-1}|\\theta^*)}} \\end{align} allowing asymmetric jumping rules can be useful in increasing the speed of the random walk. relation between the jumping rule and efficiency of simulations the ideal metropolis-hastings jumping rule is simply to sample the proposal, \\(\\theta^*\\), from the target distribution; such that our jumping distribution is equal to the target distribution, \\(j(\\theta^*|\\theta) ≡ p(\\theta^*|y)\\). then the ratio \\(r\\) is always exactly \\(1\\), so we always choose the new sampled \\(\\theta^*\\) to update \\(\\theta^t\\) instead of remaining with \\(\\theta^{t-1}\\). a good jumping distribution has the following properties: for any \\(\\theta\\), it is easy to sample from \\(j(\\theta^*|\\theta)\\) it is easy to compute the ratio \\(r\\) each jump goes a reasonable distance in the parameter space (otherwise the random walk moves too slowly). the jumps are not rejected too frequently (otherwise the random walk wastes too much time standing still). $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/MBJ/index.html",
    "title": "Modelos Bayesianos Jerárquicos",
    "body": " index search search back modelos bayesianos jerárquicos introduccion a la inferencia bayesiana modelos jerarquicos constructing a parametrized prior distribution exchangeability and hierarchical models bayesian analysis of conjugate hierarchical models normal model with exchangeable parameters example: parallel experiments in eight schools hierarchical modeling applied to meta-analysis weakly informative priors evaluación y comparación de modelos measures of predictive accuracy information criteria and cross-validation model comparison based on predictive performance model comparison using bayes factors aspectos computacionales de la inferencia bayesiana gibbs sampler metropolis and metropolis-hastings algorithms using gibbs and metropolis as buliding blocks inference and assessing convergence effective number of simulation draws appendix t2 thanks to how little i understand this book i will use other sources in order to properly understand bayesian hierarchical modeling, the contents on the following chapter explains how hierarchical bayesian models came to be and its appeal. then on section 2 it lays out hierarchical nolmal modeling followed by an explanation on hierarchical beta-binomial modeling on section 3. bayesian hierarchical modeling introduction hierarchical normal modeling hierarchical beta-binomial modeling $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/MBJ/T2/02.html",
    "title": "Exchangeability and hierarchical models",
    "body": " index search search back exchangeability and hierarchical models let \\(e\\) be a set of experiments, such that \\(e_j = {y_i, \\theta_j}, j = 1, \\cdots, j\\) where \\(y_i\\) are the vector data, \\(\\theta_j\\) are the vector parameters and \\(p(y_j|\\theta_j)\\) is the likelihood function. exchangeability when we have no additional data on the parameters, we assume exchangeability between them, such that \\(p(\\theta_1, \\cdots, \\theta_j)\\) is invariant to permutation of the indexes. the simplest form of an exchangeable distribution has each of the parameters \\(\\theta_j\\) as an independent sample from a prior distribution governed by some unknown parameter vector \\(\\phi\\); thus: \\begin{align} p(\\theta|\\phi) = \\prod_{j = 1}^j p(\\theta_j|\\phi) \\end{align} in general, \\(\\phi\\) is unknown, so our distribution for \\(\\theta\\) must average over our uncertainty in \\(\\phi\\): \\begin{align} p(\\theta) = \\int_{\\phi} p(\\theta|\\phi)p(\\phi) d \\phi \\end{align} \\begin{align} = \\int_{\\phi} \\left(\\prod_{j = 1}^j p(\\theta_j|\\phi)\\right) p(\\phi) d \\phi \\end{align} this form, the mixture of independent identical distributions, is usually all that we need to capture exchangeability in practice. example we use a nonhierarchical example with exchangeability at the level of \\(y\\) rather than \\(\\theta\\). in this example, eight states in the united states were selected, and the divorce rate per \\(1000\\) population in each state in \\(1981\\) was recorded. since you have no information to distinguish any of the eight states from the others, you must model them exchangeably. however, you can't assign an exchangeable prior to the set of eight diverse states when there's specific information about one of them. for example, if we know that nevada differentiates itself from the others because it divorce rate is known to be unusually high, that lets us know before even seeing the data (observed values), that there's a strong reason to believe that nevada's divorce rate is higher than the other states. this means that in a bayesian analysis, the prior distribution should reflect this belief, assigning more probability mass to nevada having a higher divorce rate in comparison to the other states. exchangeability when additional information is available on the units sometimes obervations are partially or conditionally exchangeable. for example, when: in the case where observations can be grouped, a hierarchical model can be created. in this context, each group has unknown properties. the assumption of exchangeability allows for the use of a common prior distribution for these group properties, meaning that any group can be considered as a random sample of the same underlying population. if \\(y_i\\) has additional information \\(x_i\\) so that \\(y_i\\) are not exchangeable but \\((y_i, x_i)\\) still are exchangeable, then we can make a joint model for \\((y_i, x_i)\\) or a conditional model for \\(y_i|x_i\\). in general, the usual way to model exchangeability with covariates is through conditional independence: \\begin{align} p(\\theta_1, \\cdots, \\theta_j) = \\int \\left[ p(\\theta_j|\\phi,x_j)\\right]p(\\phi, x) d\\phi \\end{align} whith \\(x = [x_1, \\cdots, x_j]\\) example let's consider an example in the field of education where we want to analyze the test scores of students from different schools. we can view the test scores as observations that can be grouped by schools. let \\(y_{ij}\\) be the test score of the student \\(i\\) in school \\(j\\), where \\(i = 1, 2, \\cdots, n_j\\) and \\(j = 1, 2, \\cdots, j\\) and \\(n_j\\) are the number of students at school \\(j\\). assumptions each school \\(j\\) has an unknown mean test score \\(\\mu_j\\). the mean test scores \\(\\mu_j\\) are assumed to follow a common distribution. *exchangeability: the test scores within each school are exchangeable, implying that any school could be considered a random sample from the overall population of schools. common prior distribution: we assume a common prior distribution for the group mean test scores \\(\\mu_j\\) across schools. model formulation likelihood: the likelihood of the test scores given the group mean and variance \\begin{align} p(y_{ij}|\\mu_j, \\sigma^2) \\end{align} prior: common prior distribution for the group mean test scores \\begin{align} p(\\mu_j|\\theta) \\sim \\mathcal{n}(\\theta, \\tau^2) \\end{align} where \\(\\theta\\) represents the overall mean test score and \\(\\tau\\) is the variance parameter. hyperprior: prior distribution for the overall test score \\begin{align} p(\\theta) \\sim \\mathcal{n}(\\mu_0, \\sigma_0^2) \\end{align} where \\(\\mu_0\\) is the prior mean and \\(\\sigma_0^2\\) is the prior variance. bayesian inference the posterior distribution of the group mean test scores and the overall mean test score can be obtained using bayesian inference techniques, such as markov chain monte carlo (mcmc) sampling. objections to exchangeable models in statistical applications, it is common to raise objections to the assumption that different data or experiments are exchangeable. for example experiments may which may have been conducted at different times, with different subjects, and likely in different places. despite these differences, the text suggests that it might be acceptable to consider the data as if they were from the same distribution due to model ignorance. the full bayesian treatment of the hierarchical model the true 'hierarchical' part of the models is that some parameters are not known and thus have their own prior distributions, denoted as \\(p(\\phi)\\). the bayesian posterior distribution is of the vector \\((\\phi, \\theta)\\). the joint prior distribution is: \\begin{align} p(\\phi, \\theta) = p(\\phi)p(\\theta|\\phi) \\end{align} and the joint posterior distribution (after seeing the data \\(y\\)) is: \\begin{align} p(\\phi, \\theta|y) \\propto p(\\phi, \\theta)p(y|\\phi, \\theta) \\end{align} given that \\(p(y|\\phi, \\theta)\\) depends only on \\(\\theta\\): \\begin{align} = p(\\phi, \\theta)p(y|\\theta) \\end{align} in order to create a joint probability distribution for \\((\\phi, \\theta)\\), we must assign a prior distribution to \\(\\phi\\). it is often practical to start with a simple, relatively noninformative, prior distribution on \\(\\phi\\) and seek to add more prior information if there remains too much variation in the posterior distribution. posterior predictive distributions hierarchical models are characterized both by parameters \\(\\theta\\) and hyperparameters, \\(\\phi\\), that parametrize the prior distribution over \\(\\theta\\). there are two posterior predictive distributions that might be of interest: the distribution of future observations \\(\\tilde{y}\\) corresponding to an existing \\(j\\) \"group\" described by \\(\\theta_j\\). the distribution of future observations \\(\\tilde{y}\\) corresponding to future \\(\\theta_j\\) (a \"new group\"), denoted by \\(\\tilde{\\theta}\\), drawn from the superpopulation \\(p(\\theta|\\phi)\\). in the rat tumor example, future observations can be (1) additional rats from an existing experiment, or (2) results from a future experiment (explained by a different set of parameters \\(\\theta\\)). for (1) the posterior predictive draws \\(\\tilde{y}\\) are based on the posterior draws of \\(\\theta_j\\) (\\(p(\\theta_j|y)\\)) for the existing experiment. for (2) one must first draw \\(\\tilde{\\theta}\\) for the new experiment from the population distribution, given the posterior draws of \\(\\phi\\), and then draw \\(\\tilde{y}\\) given the simulated \\(\\tilde{\\theta}\\). $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/MBJ/T2/05_example_normal.html",
    "title": "Example: parallel experiments in eight schools",
    "body": " index search search back example: parallel experiments in eight schools a study was performed for the educational testing service to analyze the effects of special coaching programs on test scores in each of eigth schools. the outcome variable in each study was the score on a special administration of the sat-v. the scores can vary between \\(200\\) and \\(800\\), with mean about \\(500\\) and standard deviation about \\(100\\). also, there was no prior reason to believe that any of the eight programs was more effective than any other or that some were more similar in effect to each other than to any other. the results of the experiments are summarized in: inferences based on nonhierarchical models and their problems before fitting the hierarchical bayesian model, we first consider two simpler nonhierarchical methods—estimating the effects from the eight experiments independently (separate estimates), and complete pooling—and discuss why neither of these approaches is adequate for this example. consider \\(\\theta_1\\), the effect in school \\(a\\). the effect in school \\(a\\) is estimated as \\(28.4\\) with a standard error of \\(14.9\\) under the separate analysis, versus a pooled estimate of \\(7.7\\) with a standard error of \\(4.1\\) under the common-effect model. note: given a normal distribution (symmetrical with respect to it mean) the probability that an estimate takes a value under the mean is \\(\\frac{1}{2}\\) (cumulative density function), as the \\(\\mu\\) serves as the midpoint of a normal distribution such that half the area for the normal curve is contained under \\([0, \\mu]\\). the separate analyses of the eight schools imply the following posterior statement: 'the probability is \\(\\frac{1}{2}\\) that the true effect in \\(a\\) is more than \\(28.4\\)' a doubtful statement, considering the results for the other seven schools. on the other hand, the pooled model implies the following statement: 'the probability is \\(\\frac{1}{2}\\) that the true effect in a is less than \\(7.7\\),' which seems an inaccurate summary of our knowledge. as in the theoretical discussion of the previous section, neither estimate is fully satisfactory, and we would like a compromise that combines information from all eight experiments without assuming all the \\(\\theta_j\\)'s to be equal. the bayesian analysis under the hierarchical model provides exactly that. posterior simulation under the hierarchical model consequently, we compute the posterior distribution of \\(\\theta_1, \\cdots, \\theta_8\\), based on the normal model presented in section 4. we draw from the posterior distribution for the bayesian model by simulating the random variables \\(\\tau\\), \\(\\mu\\), and \\(\\theta\\), in that order, from their posterior distribution, as discussed at the end of the previous section. the sampling standard deviations, \\(\\sigma_j\\), are assumed known and equal to the values in table 5.2, and we assume independent uniform prior densities on \\(\\mu\\) and \\(\\tau\\). the marginal posterior density function, \\(p(\\tau|y)\\) from, is plotted in the next figure: values of \\(\\tau\\) near zero are mos plausible. in the normal hierarchical model, however, we learn a great deal by considering the conditional posterior distributions given \\(\\tau\\) (and averaged over \\(\\mu\\)), that is \\(\\mathbb{e}[\\theta_j|\\tau, y]\\), averaging over \\(\\mu\\). this is displayed on the following image: comparing with the previous figure, which has the same scale on the horizontal axis, we see that for most of the likely values of \\(\\tau\\), that is for \\(\\tau \\approx 0\\) the estimated effects for all the groups are relatively close together (when \\(\\tau = 0\\) you would guess they are clustered on the same point). however, as \\(\\tau\\) becomes larger, corresponding to more variability among schools, the estimates become more like the raw values shown on the first figure of this section. the lines in the following figure show the conditional standard deviations, \\(sd(\\theta_j|\\tau, y)\\), as a function of \\(\\tau\\). as \\(\\tau\\) increases, the population distribution allows the eight effects to be more different from each other, and hence the posterior uncertainty in each individual \\(\\tau_j\\) increases, approaching the standard deviations shown in the raw data in the limit of \\(\\tau \\rightarrow \\infty\\). contrary to what we saw with separate estimates and pooled estimates, for the likely values of \\(\\tau\\) (see figure for \\(p(\\tau|y)\\)), the estimates in all schools are substantially less than \\(28\\) points. for example, even at \\(\\tau = 0\\), the probability that the effect in school a is less than \\(28\\) points is \\(\\phi[(28 − 14.5)/9.1] = 93\\%\\), where \\(\\phi\\) is the standard normal cumulative distribution function. of substantial importance, we do not obtain an accurate summary of the data if we condition on the posterior mode of \\(\\tau\\) as it ignores the uncertainty associated with \\(\\tau\\) as conveyed by the full posterior distribution. in bayesian statistics, the posterior distribution encapsulates both the most likely values of parameters as well as the uncertainty or variability in those estimates. by only considering the mode (the peak or maximum) of the posterior distribution and neglecting its shape and spread, we may miss out on valuable information about the range of plausible values for τ and the associated uncertainty. discussion table 5.3 summarizes the \\(200\\) simulated effect estimates for all eight schools. the bayesian probability that the effect in school a is as large as \\(28\\) points is less than \\(10\\%\\), which is substantially less than the \\(50\\%\\) probability based on the separate estimate for school a. as an illustration of the simulation-based posterior results, \\(200\\) simulations of school a's effect are shown in figure 5.8a. having simulated the parameter \\(\\theta\\), it is easy to ask more complicated questions of this model. for example, what is the posterior distribution of \\(\\max(\\theta_j)\\), the effect of the most successful of the eight coaching programs? figure 5.8b displays a histogram of \\(200\\) values from this posterior distribution and shows that only \\(22\\) draws are larger than \\(28.4\\). for another example, we can estimate \\(pr(\\theta_1 > \\theta_3|y)\\), the posterior probability that the coaching program is more effective in school a than in school c, by the proportion of simulated draws of \\(\\theta\\) for which \\(\\theta_1 > \\theta_3\\); the result is \\(\\frac{141}{200} = 0.705\\). to sum up, the bayesian analysis of this example not only allows straightforward inferences about many parameters that may be of interest, but the hierarchical model is flexible enough to adapt to the data, thereby providing posterior inferences that account for the partial pooling as well as the uncertainty in the hyperparameters. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/MBJ/T2/06_hierarchical_meta_analysis.html",
    "title": "Hierarchical modeling applied to a meta-analysis",
    "body": " index search search back hierarchical modeling applied to a meta-analysis meta-analysis is an increasingly popular and important process of summarizing and integrating the findings of research studies in a particular area. the data in our medical example are displayed in the first three columns of the previous image, which summarize mortality after myocardial infarction in 22 clinical trials. the aim of a metaanalysis is to provide a combined analysis of the studies that indicates the overall strength of the evidence for a beneficial effect of the treatment under study. a normal approximation to the likelihood if clinical trial \\(j\\) (in the series to be considered for meta-analysis) involves the use of \\(n_{0j}\\) subjects in the control group and \\(n_{1j}\\) in the treatment group, giving rise to \\(y_{0j}\\) and \\(y_{1j}\\) deaths in control and treatment groups, respectively, then the usual sampling model involves two independent binomial distributions with probabilities of death \\(p_{0j}\\) and \\(p_{1j}\\), respectively. for each study \\(j\\), one can estimate \\(\\theta_j\\) by: \\begin{align} y_j = \\log\\left(\\frac{y_{1j}}{n_{1j} - y_{1j}}\\right) - \\log\\left(\\frac{y_{0j}}{n_{0j} - y_{0j}}\\right) \\end{align} with approximate sampling variance \\begin{align} \\sigma_j^2 = \\frac{1}{y_{1j}} + \\frac{1}{n_{1j} - y_{1j}} + \\frac{1}{y_{0j}} + \\frac{1}{n_{0j} - y_{0j}} \\end{align} based on empirical logits. the estimated log-odds ratios \\(y_j\\) and their estimated standard errors \\(\\sigma_j^2\\) are displayed as the fourth and fifth columns of table 5.4. goals of inference in meta-analysis our focus is on estimating meaningful parameters, and for this objective there appear to be three possibilities. complete pooling: we view the studies as identical replications of each other, in the sense we regard the individuals in all the studies as independent samples from a common population, with the same outcome measures and so on. separate estimates: the studies are so different that the results of any one study provide no information about the results of any of the others. bayesian analysis: we regard the studies as exchangeable but not necessarily either identical or completely unrelated. the first potential estimand of a meta-analysis, or a hierarchically structured problem in general, is the mean of the distribution of effect sizes, since this represents the overall ‘average’ effect across all studies that could be regarded as exchangeable with the observed studies. other possible estimands are the effect size in any of the observed studies and the effect size in another, comparable (exchangeable) unobserved study. what if exchangeability is inappropriate? what if other information (in addition to the data \\((n, y)\\)) is available to distinguish among the \\(j\\) studies in a meta-analysis, so that an exchangeable model is inappropriate? in this situation, we can expand the framework of the model to be exchangeable in the observed data and covariates. a hierarchical model let \\(y_j\\) represent generically the point estimate of the effect \\(\\theta_j\\) in the \\(j\\)th study, the sampling distribution is defined as: \\begin{align} y_j|\\theta_j, \\sigma_j \\sim \\text{n}(\\theta_j, \\sigma_j^2) \\end{align} where \\(\\sigma_j\\) represents the corresponding estimated standard error, which is assumed known without error. at the second stage of the hierarchy, we again use an exchangeable normal prior distribution, with mean \\(\\mu\\) and standard deviation \\(\\tau\\), which are unknown hyperparameters. \\begin{align} \\theta|\\mu, \\tau \\sim \\text{n}(\\mu, \\tau) \\end{align} finally, a hyperprior distribution is required for \\(\\mu\\) and \\(\\tau\\). for this problem, it is reasonable to assume a noninformative or locally uniform prior density for \\(\\mu\\). we also assume a locally uniform prior density for \\(\\tau\\). $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/MBJ/T2/01.html",
    "title": "Constructing a parametrized prior distribution",
    "body": " index search search back constructing a parametrized prior distribution to begin our description of hierarchical models, we consider the problem of estimating a parameter \\(\\theta\\) using data from a small experiment and a prior distribution constructed from similar previous experiments. example suppose the aim is to estimate \\(\\theta\\), the probability of tumor in a population of female laboratory rats of type \"f344\" that receive a zero dose of the drug (control group). it is natural to assume a binomial model for the number of tumors, given \\(\\theta\\). for convenience, we select a prior distribution for \\(\\theta\\) from the conjugate family, \\(\\theta \\sim beta(\\alpha, \\beta)\\) analysis with a fixed prior distribution from historical data, suppose we knew that the tumor probabilities \\(\\theta\\) among groups of female lab rats of type \"f344\" follow an approximate beta distribution, with known mean and standard deviation. the use of a fixed prior distribution from historical data allows for the construction of a parameterized prior distribution, which in turn influences the posterior distribution for the current experiment. then, assuming a \\(beta(\\alpha, \\beta)\\) prior distribution for \\(\\theta\\) yields a \\(beta(\\alpha + 4, \\beta + 10)\\) posterior distribution for \\(\\theta\\). approximate estimate of the population distribution using the historical data contrary to last section, typically, the mean and standard deviation of underlying tumor risks are not available, rather historical data is available from previous experiments on similar conditions. in the \\(j\\)th historical experiment, let the number of rats with tumors be \\(y_j\\) and the total number of rats be \\(n_j\\). we model the \\(y_j\\)'s (probability that \\(p\\) rats have tumor given a total of \\(n\\) rats) as independent binomial data, given sample sizes \\(n_j\\) and study-specific means \\(\\theta_j\\). we can display the hierarchical model schematically as follows: the observed sample mean and standard deviation of the 70 values \\(y_j\\), \\(n_j\\) are \\(0.136\\) and \\(0.103\\). if we set the mean and standard deviation of the population distribution to these values we can solve for \\(\\theta\\) and \\(\\beta\\). the resulting estimate for \\((\\alpha, \\beta)\\) is \\((1.4, 8.6)\\). this is not a bayesian calculation because it is not based on any specified full probability model. appendix binomial model: in probability theory and statistics, the binomial distribution with parameters \\(n\\) and \\(p\\) is the discrete probability distribution of the number of successes in a sequence of \\(n\\) independent experiments (binomial distribution) $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/MBJ/T2/12_hierarchical_normal_modeling.html",
    "title": "Hierarchical Normal Modeling",
    "body": " index search search back hierarchical normal modeling example: ratings of animation movies movielens is a website which provides personalized movie recommendations from users who create accounts and rate movies that they have seen. based on such information, movielens works to build a custom preference profile for each user and provide movie recommendations. a hierarchical normal model with random \\(\\sigma\\) in this situation it is reasonable to develop a model for the movie ratings where the grouping variable is the movie title. we index a rating by two subscripts, where \\(y_{ij}\\) denotes the \\(i\\)th rating for the \\(j\\)th movie title, with \\(j = 1, \\cdots, 8\\). since the ratings are continuous, it is reasonable to use the normal data model. for simplicity and ease of illustration, a common and shared unknown standard deviation \\(\\sigma\\) is assumed for all normal models (however it could also be modeled). therefore we define the sampling distribution as: \\begin{align} y_{ij} | \\mu_j, \\sigma \\sim \\text{normal}(\\mu_j, \\sigma) \\end{align} since these movies are all animations, it is reasonable to believe that the mean ratings are similar across movies. so one assigns each mean rating the same normal prior distribution at the first stage: \\begin{align} \\mu_j | \\mu, \\tau \\sim \\text{normal}(\\mu, \\tau) \\end{align} the hyperparameters \\(\\mu\\) and \\(\\tau\\) are treated as random since we are unsure about the degree of pooling of the eight sets of ratings. after observing data, inference is performed about \\(\\mu\\) and \\(\\tau\\) based on their posterior distributions. treating \\(\\mu\\) and \\(\\tau\\) as random, one arrives at the following hierarchical model: sampling for \\(j = 1, \\cdots, 8\\) and \\(i = 1, \\cdots, n_j\\): \\begin{align} y_{ij} | \\mu_j, \\sigma \\sim \\text{normal}(\\mu_j, \\sigma) \\end{align} prior for \\(\\mu_j\\), stage 1, \\(j = 1, \\cdots, 8\\): \\begin{align} \\mu_j | \\mu, \\tau \\sim \\text{normal}(\\mu, \\tau) \\end{align} prior for \\(\\mu_j\\), stage 2, the hyperprior: \\begin{align} \\mu, \\tau \\sim \\pi(\\mu, \\tau) \\end{align} to complete the model, one needs to specify a prior distribution for the standard deviation parameter, \\(\\sigma\\): \\begin{align} \\frac{1}{\\sigma^2} | a_{\\sigma}, b_{\\sigma} \\sim \\text{gamma}(a_{\\sigma}, b_{\\sigma}) \\end{align} one assigns a known gamma prior distribution for \\(\\frac{1}{\\sigma^2}\\), with fixed hyperparameter values \\(a_{\\sigma}\\) and \\(b_{\\sigma}\\). in some situations, one may consider the situation where \\(a_{\\sigma}\\) and \\(b_{\\sigma}\\) are random and assign hyperprior distributions for these unknown hyperparameters. it is helpful to contrast the two-stage prior distribution for \\(\\{\\mu_j\\}\\) and the one-stage prior distribution for \\(\\sigma\\). for the means \\(\\{\\mu_j\\}\\), we have discussed that specifying a common prior distribution for different \\(j\\) pools information across the movies. one is simultaneously estimating both a mean for each movie (the \\(\\mu_j\\)'s) and the variation among the movies (\\(\\mu\\) and \\(\\tau\\)). for the standard deviation, the hierarchical model also pools information across movies. however, all of the observations are combined in the estimation of \\(\\sigma\\). since separate values of \\(\\sigma_j\\), one cannot learn about the differences and similarities among the \\(\\sigma_j\\)'s. graphical representation of the hierarchical model an alternative way of expressing this hierarchical model uses the following graphical representation. in the middle section of the graph, \\(y_{ij}\\) represents the collection of random variables for all ratings of movie \\(j\\). the upper section of the graph focuses on the \\(\\mu_j\\)'s. all means follow the same prior, a normal distribution with mean \\(\\mu\\) and standard deviation \\(\\sigma\\). since \\(\\mu\\) and \\(\\tau\\) are random, these second-stage parameters are associated with the prior label \\(\\pi(\\mu, \\tau)\\). second-stage prior the hierarchical normal model presented in equations (10.6) through (10.9) has not specified the hyperprior distribution \\(\\pi(\\mu, \\tau)\\). how does one construct a prior on these second-stage hyperparameters? a typical approach for normal models is to assign two independent prior distributions — a normal distribution for the mean \\(\\mu\\) and a gamma distribution for the precision \\(\\frac{1}{\\tau^2}\\). such a specification facilitates the use of the gibbs sampling. using this approach, the density \\(\\pi(\\mu, \\tau)\\) is replaced by the two hyperprior distributions below: \\begin{align} \\mu | \\mu_0, \\gamma_0 \\sim \\text{normal}(\\mu_0, \\gamma_0) \\end{align} \\begin{align} \\frac{1}{\\tau^2} | a, b \\sim \\text{gamma}(a_{\\tau}, b_{\\tau}) \\end{align} the task of choosing a prior for \\((\\mu, \\tau)\\) reduces to the problem of choosing values for the four hyperparameters \\(\\mu_0, \\gamma_0, a_{\\tau}\\) and \\(b_{\\tau}\\). if one believes that \\(mu\\) is located around the value of \\(3\\) and she is not very confident of this choice, the set of values \\(\\mu_0 = 3\\) and \\(\\gamma_0 = 1\\) could be chosen. as for \\(\\tau\\), one chooses a weakly informative prior with \\(a_{\\tau} = b_{\\tau} = 1\\) as \\(\\text{gamma}(1, 1)\\). moreover, to choose a prior for \\(\\sigma\\), let \\(a_{\\sigma} = b_{\\sigma} = 1\\) to have the weakly informative \\(\\text{gamma}(1, 1)\\) prior. inference through mcmc with the specification of the prior, the complete hierarchical model is described as follows: sampling for \\(j = 1, \\cdots, 8\\) and \\(i = 1, \\cdots, n_j\\): \\begin{align} y_{ij} | \\mu_j, \\sigma \\sim \\text{normal}(\\mu_j, \\sigma) \\end{align} prior for \\(\\mu_j\\), stage 1, \\(j = 1, \\cdots, 8\\): \\begin{align} \\mu_j | \\mu, \\tau \\sim \\text{normal}(\\mu, \\tau) \\end{align} prior for \\(\\mu_j\\), stage 2: the hyperpriors: \\begin{align} \\mu \\sim \\text{normal}(3, 1) \\end{align} \\begin{align} \\frac{1}{\\tau^2} \\sim \\text{gamma}(1, 1) \\end{align} prior for \\(\\sigma\\) \\begin{align} \\frac{1}{\\sigma^2} \\sim \\text{gamma}(1, 1) \\end{align} describe the model by a script the first step in using the jags software is to write the following script defining the hierarchical model. the model is saved in the character string modelstring. modelstring <-\" model { ## sampling for (i in 1:n){ y[i] ~ dnorm(mu_j[movieindex[i]], invsigma2) } ## priors for (j in 1:j){ mu_j[j] ~ dnorm(mu, invtau2) } invsigma2 ~ dgamma(a_s, b_s) sigma <- sqrt(pow(invsigma2, -1)) ## hyperpriors mu ~ dnorm(mu0, g0) invtau2 ~ dgamma(a_t, b_t) tau <- sqrt(pow(invtau2, -1)) } \" in the sampling part of the script, note that the loop goes from 1 to n, where n is the number of observations with index i. however, because now n observations are grouped according to movies, indicated by j, one needs to create one vector, mu_j of length eight, and use movieindex[i] to grab the corresponding mu_j based on the movie index. in the priors part of the script, the loop goes from 1 to j, and j = 8 in the current example. inside the loop, the first line corresponds to the prior distribution for mu_j. due to a commonly shared sigma, invsigma2 follows dgamma(a_g, b_g) outside of the loop. in addition, sigma <- sqrt(pow(invsigma2, -1)) is added to help tracksigma directly. finally in the hyperpriors section of the script, one specifies the normal hyperprior for mu, a gamma hyperprior for invtau2. keep in mind that the arguments in the dnorm in jags are the mean and the precision (std). if one is interested instead in the standard deviation parameter tau, one could return it in the script by using tau <- sqrt(pow(invtau2, -1)), enabling the tracking of its mcmc chain in the posterior inferences. define the data and prior parameters after one has defined the model script, the next step is to provide the data and values for parameters of the prior. in the r script below, a list the_data contains the vector of observations, the vector of movie indices, the number of observations, and the number of movies. it also contains the normal hyperparameters mu0 and g0, and two sets of gamma hyperparameters (a_t and b_t) for invtau2, and (a_s and b_s) for invsigma2. y <- movieratings$rating movieindex <- movieratings$group_number n <- length(y) j <- length(unique(movieindex)) the_data <- list(\"y\" = y, \"movieindex\" = movieindex, \"n\" = n, \"j\" = j, \"mu0\" = 3, \"g0\" = 1, \"a_t\" = 1, \"b_t\" = 1, \"a_s\" = 1, \"b_s\" = 1) one uses the run.jags() function in the runjags r package to generate posterior samples by using the mcmc algorithms in jags. the script below runs one mcmc chain with \\(1000\\) iterations in the adapt period (preparing for mcmc), \\(5000\\) iterations of burn-in and an additional set of \\(5000\\) iterations to be run and collected for inference. by using monitor = c(\"mu\", \"tau\", \"mu_j\", \"sigma\"), one collects the values of all parameters in the model. in the end, the output variable posterior contains a matrix of simulated draws. posterior <- run.jags(modelstring, n.chains = 1, data = the_data, monitor = c(\"mu\", \"tau\", \"mu_j\", \"sigma\"), adapt = 1000, burnin = 5000, sample = 5000) mcmc diagnostics and summarization to perform some mcmc diagnostics in our example, one uses the plot() function, specifying the variable to be checked by the vars argument. for example, the script below returns four diagnostic plots (trace plot, empirical pdf, histogram, and autocorrelation plot) for the hyperparameter \\(\\tau\\). plot(posterior, vars = \"tau\") in practice mcmc diagnostics should be performed for all parameters to justify the overall mcmc convergence. in our example, the above diagnostics should be implemented for each of the eleven parameters in the model: \\(\\mu, \\tau, \\mu_1, \\cdots, \\mu_8\\) and \\(\\sigma\\). once diagnostics are done, one reports posterior summaries of the parameters using print(). note that these summaries are based on the 5000 iterations from the sample period, excluding the adapt and burn-in iterations. print(posterior, digits = 3) lower95 median upper95 mean sd mode mcerr mu 3.19 3.78 4.34 3.77 0.286 -- 0.00542 tau 0.357 0.638 1.08 0.677 0.2 -- 0.00365 mu_j[1] 2.96 3.47 3.99 3.47 0.262 -- 0.00376 mu_j[2] 3.38 3.81 4.25 3.82 0.221 -- 0.00313 mu_j[3] 3.07 3.91 4.75 3.91 0.425 -- 0.00677 mu_j[4] 3.21 3.74 4.31 3.74 0.285 -- 0.00428 mu_j[5] 3.09 4.15 5.43 4.18 0.588 -- 0.0115 mu_j[6] 2.7 3.84 4.99 3.85 0.576 -- 0.00915 mu_j[7] 2.74 3.53 4.27 3.51 0.388 -- 0.00595 mu_j[8] 3.58 4.12 4.66 4.12 0.276 -- 0.00423 sigma 0.763 0.92 1.12 0.93 0.0923 -- 0.00142 for example, the movies \"how to train your dragon\" (corresponding to \\(\\mu_1\\)) and \"megamind\" (corresponding to \\(\\mu_7\\)) have the lowest average ratings with short \\(90\\%\\) credible intervals, \\((2.96, 3.99)\\) and \\((2.74, 4.27)\\) respectively, whereas \"legend of the guardians: the owls of ga’hoole\" (corresponding to \\(μ_6\\)) also has a low average rating but with a wider \\(90\\%\\) credible interval \\((2.70, 4.99)\\). the differences in the width of the credible intervals stem from the sample sizes: there are eleven ratings for \"how to train your dragon\", four ratings for \"megamind\", and only a single rating for \"legend of the guardians: the owls of ga’hoole\". the smaller the sample size, the larger the variability in the inference, even if one pools information across groups. shrinkage recall that the two-stage prior specifies a shared prior normal \\((\\mu, \\tau)\\) for all \\(\\mu_j\\)'s which facilitates simultaneous estimation of the movie mean ratings (the \\(\\mu_j\\)'s), and estimation of the variation among the movie mean ratings through the parameters \\(\\mu\\) and \\(\\tau\\). the posterior mean of the rating for a particular movie \\(\\mu_j\\) shrinks the observed mean rating towards an average rating. the following figure displays a shrinkage plot which illustrates the movement of the observed sample mean ratings towards an average rating. the left side plots the sample movie rating means and lines connect the sample means to the corresponding posterior means (i.e. means of the posterior draws of \\(\\mu_j\\)). the shrinkage effect is obvious for the movie \"batman: under the red hood\" which corresponds to the dot at the value \\(5.0\\) on the left. this movie only received one rating of \\(5.0\\) and its mean rating \\(\\mu_5\\) shrinks to the value \\(4.178\\) on the right, which is still the highest posterior mean among the nine movie posterior means. a large shrinkage is desirable for a movie with a small number of ratings such as \"batman: under the red hood\". for a movie with a small sample size, information about other ratings of similar movies helps to produce a more reasonable estimate at the true average movie rating. the amount of shrinkage is more modest for movies with larger sample sizes. sources of variability we know that the prior distribution \\(\\text{normal}(\\mu, \\tau)\\) is shared among the means \\(\\mu_j\\)'s of all groups in a hierarchical normal model, and the hyperparameters \\(\\mu\\) and \\(\\tau\\) provide information about the population of \\(\\mu_j\\)'s. specifically, the standard deviation \\(\\tau\\) measures the variability among the \\(\\mu_j\\)'s. when the hierarchical model is estimated through mcmc, summaries from the simulation draws from the posterior of \\(\\tau\\) provide information about this source of variation after analyzing the data. there are actually two sources for the variability among the observed \\(y_{ij}\\)'s: sampling level: within-group variability: \\begin{align} y_{ij} \\sim \\text{normal}(\\mu_j, \\sigma) \\end{align} group level between-group variability: \\begin{align} \\mu_{j} | \\mu, \\tau \\sim \\text{normal}(\\mu, \\tau) \\end{align} when the hierarchical model is fit through mcmc, summaries from the marginal posterior distributions of \\(\\sigma\\) and \\(\\tau\\) provide information about the two sources of variability. the bayesian posterior inference in the hierarchical model is able to compare these two sources of variability, taking into account the prior belief and the information from the data. one initially provides prior beliefs about the values of the standard deviations \\(\\sigma\\) and \\(\\tau\\) through gamma distributions. what can be said about these two sources of variability after the estimation of the hierarchical model? as seen in the output of print(posterior, digits = 3), the \\(90\\%\\) credible interval for \\(\\sigma\\) is \\((0.763, 1.12)\\) and the \\(90\\%\\) credible interval for \\(\\tau\\) is \\((0.357, 1.08)\\). after observing the data, the within-group variability in the measurements is estimated to be larger than the between-group variability. to compare both variability sources we compute: \\begin{align} r = \\frac{\\tau^2}{\\tau^2 + \\sigma^2} \\end{align} it represents the fraction of the total variability in the movie ratings due to the differences between groups. if the value of \\(r\\) is close to \\(1\\), most of the total variability is attributed to the between-group variability. on the other side, if \\(r\\) is close to \\(0\\), most of the variation is within groups and there is little significant differences between groups. a \\(95\\%\\) credible interval for \\(r\\) is \\((0.149, 0.630)\\). since much of the posterior probability of \\(r\\) is located below the value \\(0.5\\), this confirms that the variation between the mean movie rating titles is smaller than the variation of the ratings within the movie titles in this example. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/MBJ/T2/11_introduction.html",
    "title": "Introduction",
    "body": " index search search back introduction as a new example, consider a study in which students' scores of a standardized test such as the sat are collected from five different senior high schools in a given year. it is inappropriate to use \\(y_{ij}\\) as the random variable for the sat score of student \\(i = 1, 2, \\cdots, n_j\\) in school \\(j = 1, \\cdots, 5\\). within school \\(j\\), one assumes that sat scores are i.i.d. from a normal data model with a mean and standard deviation depending on the school: \\begin{align} y_{ij} \\sim \\text{normal}(\\mu_j, \\sigma_j) \\end{align} separate estimates? one approach for handling this group estimation problem is find separate estimates for each school. one focuses on the observations in school \\(j\\), \\(\\{y_{1j}, \\cdots, y_{n_jj}\\}\\), choose a prior distribution \\(\\pi(\\mu_j, \\sigma_j)\\) for the mean and the standard deviation parameters. this \"separate estimates\" approach may be reasonable, especially if the researcher thinks the means and the standard deviations from the five normal models are completely unrelated to each other. that is, one’s prior beliefs about the parameters of the sat score distribution in one school are unrelated to the prior beliefs about the distribution parameters in another school. combined estimates? another way to handle this group estimation problem is to ignore the fact that there is a grouping variable and estimate the parameters in the combined sample. in our school example, one ignores the school variable and simply assumes that the sat scores \\(y_i\\)'s are distributed from a single normal population with mean \\(\\mu\\) and standard deviation \\(\\sigma\\) where \\(i = 1, \\cdots, n\\) is the total number of students from all five schools. using this approach, one is effectively ignoring any differences between the five schools. a two-stage prior is there an alternative approach that compromises between the separate and combined estimate methods? for simplicity of discussion it is assumed the standard deviation \\(\\sigma_j\\) of the \\(j\\)th school is known. consider the collection of five mean parameters, \\(\\{\\mu_1, \\mu_2, \\mu_3, \\mu_4, \\mu_5\\}\\) representing the means of the five schools' sat scores. one believes that the \\(\\mu_j\\)'s are distinct, because each \\(\\mu_j\\) depends on the characteristics of school \\(j\\). one wishes to construct a prior distribution for the five mean parameters that reflects the belief that \\(\\{\\mu_1, \\mu_2, \\mu_3, \\mu_4, \\mu_5\\}\\) are related or similar in size. the prior belief in similarity of the means is constructed in two stages: [stage 1] the prior distribution for the \\(j\\)th mean \\(\\mu_j\\) is normal, where the mean and standard deviation parameters are shared among all \\(\\mu_j\\): \\begin{align} \\mu_j | \\mu, \\tau \\sim \\text{normal}(\\mu, \\tau), j = 1, \\cdots, 5 \\end{align} [stage 2] in stage 1, the parameters \\(\\mu\\) and \\(\\tau\\) are unknown. so this stage assigns the parameters a prior density \\(\\pi\\) (hyperprior): \\begin{align} \\mu, \\tau \\sim \\pi(\\mu, \\tau) \\end{align} stage 1 indicates that the \\(\\mu_j\\)'s a priori are related and thus come from the same distribution. if one considers the limit of the stage 1 prior as the standard deviation \\(\\tau\\) approaches zero, the group means \\(\\mu_j\\) will be identical. then one is in the combined groups' situation where one is pooling the sat data to learn about a single population. at the other extreme, if one allows the standard deviation \\(\\tau\\) of the stage 1 prior to approach infinity, then one is saying that the group means are unrelated and that leads to the separate estimates situation. since \\(\\mu\\) and \\(\\tau\\) are parameters in the prior distribution, they are called hyperparameters. learning about \\(\\mu\\) and \\(\\tau\\) provides information about the population of \\(\\mu_j\\). in bayesian inference, one learns about \\(\\mu_j\\) and \\(\\tau\\) by specifying a hyperprior distribution and performing inference based on the posterior distribution. it will be seen that the hierarchical model posterior estimates for one school borrows information from other schools. this process is often called partial pooling information among groups. from the structural point of view, due to the two stages of the model, this approach is called hierarchical or multilevel modeling. in essence, hierarchical modeling takes into account information from multiple levels, acknowledging differences and similarities among groups. in the posterior analysis, one learns simultaneously about each group and learns about the population of groups by pooling information across groups. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/MBJ/T2/07_weakly_informative_priors.html",
    "title": "Weakly Informative Priors",
    "body": " index search search back weakly informative priors concepts relating to the choice of prior distribution improper limit of a prior distribution improper prior densities can, but do not necessarily, lead to proper posterior distributions. calibration posterior inferences can be evaluated using the concept of calibration of the posterior mean. for any parameter \\(\\theta\\), if we label the posterior mean as \\(\\hat{\\theta} = \\mathbb{e}[\\theta|y]\\), we can define the miscalibration of the posterior mean as \\(\\mathbb{e}[\\theta|\\hat{\\theta}] - \\hat{\\theta}\\). we can judge the accuracy of our conclusions from bayesian analysis by checking how close the average value we predict (the posterior mean) is to the true value. here's how it works: if we call our predicted average value \\(\\hat{\\theta}\\), and we calculate how far off it is from the true value \\(\\theta\\), that's what we call the miscalibration of the prediction. if our initial guesses (prior distribution) are accurate and our data matches those guesses, then our predictions will be right on target, meaning the miscalibration will be zero. these are models where the probabilities don't add up to \\(1\\), which makes it impossible to draw a parameter \\(\\theta\\) from them. so, we need to expand our theory to deal with this. to see if our predictions are accurate in these cases, we need to imagine a \"true\" prior distribution where \\(\\theta\\) comes from, and compare it to the \"inferential\" prior distribution we actually use for our bayesian analysis. let's take the example of the 8 schools model. here, we consider an improper uniform distribution on \\(\\tau\\) (a parameter in the model) as a limit of uniform distributions on a range (from \\(0\\) to a really large number \\(a\\), which is getting bigger and bigger). when we use this improper uniform distribution, our inferences tend to overestimate \\(\\tau\\). let's see why: if both the \"true\" and \"inferential\" prior distributions are uniform on \\((0, a)\\), our miscalibration is zero. this means our predictions are accurate. now, if we keep the \"true\" prior distribution as \\(u(0, a)\\) but let the \"inferential\" prior distribution go to \\(u(0, \\infty)\\), our predictions tend to increase (because now we're including more and more extreme values of \\(\\theta\\)), which leads to a positive miscalibration. classes of noninformative and weakly informative prior distributions for hierarchical variance parameters general considerations we view any noninformative or weakly informative prior distribution as inherently provisional—after the model has been fit, one should look at the posterior distribution and see if it makes sense. if the posterior distribution does not make sense, this implies that additional prior knowledge is available that has not been included in the model, and that contradicts the assumptions of the prior distribution that has been used uniform prior distributions when we're setting up our model, we often start with uniform priors. but we have to be careful about how we define the scale of this uniform distribution. one common situation is when we're dealing with parameters that must be positive, like variance parameters. using a uniform prior on the logarithm of these parameters (\\(\\log \\tau\\)) might seem like a good idea, but it can lead to problems because the resulting posterior distribution becomes improper (doesn't add up to 1). an alternative is trying to set up a range for our prior distribution, like \\([-a, a]\\) where \\(a\\) is a really large number. this seems like a good idea to keep things in check, but there's a catch: the posterior distribution (our updated belief after looking at the data) can end up heavily influenced by the lower bound, \\(-a\\), of our range. when we calculate the marginal likelihood \\(p(y|\\tau)\\) of our data given a certain parameter (\\(\\tau\\)), it ends up approaching a fixed, non-zero value as \\(\\tau\\) gets really close to \\(0\\). because when we calculate the likelihood of our data given a parameter (\\(\\tau\\)), it's like asking, \"how likely is it that we'd see this data if our parameter τ were true?\" now, imagine \\(\\tau\\) is getting really close to \\(0\\). in many situations, this means we're saying there's almost no variability in our data. but even if \\(\\tau\\) is very close to \\(0\\), the likelihood of observing our data isn't exactly \\(0\\). there's still some chance, even if it's tiny, that we'd see our data just by random chance, even with very little variability. so, as \\(\\tau\\) approaches \\(0\\), the likelihood doesn't drop to \\(0\\) as well. instead, it approaches a fixed, non-zero value. another option we can consider is using a uniform prior distribution directly on the parameter \\(\\tau\\) itself. this helps avoid some of the problems we discussed earlier because it keeps the total probability finite, especially near \\(\\tau = 0\\). however, there's a drawback to this approach. it tends to lean slightly towards positive values, because it allows for the possibility of very large values of \\(\\tau\\) as well. when we're dealing with just one or two groups (\\(j = 1\\) or \\(2\\)), using this uniform prior actually results in an improper posterior density. this means that our analysis essentially concludes that \\(\\tau\\) is infinite, and it doesn't do any pooling of data from different groups. in a way, this makes sense because it's hard to decide from just a few groups how much we should pool their data together. but from a bayesian perspective, it's a bit awkward because we're making this decision before even looking at the data. when we're dealing with these improper uniform prior distributions, we can think of them as being like the limit of certain types of weakly informative priors. for example, the uniform prior distribution on the logarithm of \\(\\tau\\) is basically like saying that \\(\\tau\\) follows a distribution where the probability decreases as \\(\\tau\\) gets bigger. sometimes, in bayesian statistics, people suggest using a uniform prior distribution directly on \\(\\tau^2\\). this means that every possible value for \\(\\tau^2\\) is considered equally likely. however, we don't recommend this approach. it tends to have a bigger issue with miscalibration towards higher values compared to the other approaches we discussed earlier. plus, using this uniform prior on τ squared requires us to have at least 4 groups for the analysis to work properly and give us a reasonable posterior distribution. inverse-gamma\\((\\epsilon, \\epsilon)\\) prior distributions in the schools model, the parameter \\(\\tau\\) doesn't have any simple family of prior distributions that work well because its likelihood depends on all the data from all the groups in a complex way. however, there's a kind of distribution called the inverse-gamma family that works well in this situation. this means that if we use an inverse-gamma distribution as a prior for \\(\\tau^2\\), then after we collect our data and update our beliefs, the conditional distribution for \\(\\tau^2\\), \\(p(\\tau^2|\\mu, \\theta, y)\\) that we get is still an inverse-gamma distribution. the inverse-gamma prior distribution is a way to set up our beliefs in a noninformative (or weakly informative) manner when we're dealing with certain types of data. we choose a parameter called alpha (\\(\\alpha\\)) to control how informative the prior is. now, here's the thing: if we set alpha to a very low value, like \\(1\\) or \\(0.01\\) or \\(0.001\\), it's supposed to mean we're not putting much prior information into our model. but there's a problem: when we make alpha too small, the posterior distribution (our updated beliefs after looking at the data) can end up being improper, which means it doesn't add up to \\(1\\). to avoid this, we need to set alpha to a reasonable value, not too small. half-cauchy prior distributions we're going to look at another type of distribution called the \\(t\\) family, specifically the \\(\\text{half}-t\\) because our scale parameter (\\(\\tau\\)) has to be positive. now, we're interested in the \\(t\\) family for this problem because it's pretty flexible and can cover a wide range of situations. plus, we can use a neat trick called reparameterization to express it as a prior distribution for our scale parameter (\\(\\tau\\)) in a way that works well with our model. here's why it's helpful: the half-cauchy distribution has a wide peak around zero and just one parameter that we can adjust, which we'll call \\(a\\). we can set \\(a\\) to be a large value, and as it gets bigger and bigger (approaching infinity), the half-cauchy distribution starts to look more like a uniform distribution on our parameter \\(\\tau\\). when we set \\(a\\) to a large but finite value, it means we're using a slightly informative prior distribution. even though it's not completely flat, it's still pretty gentle, especially in the tails. this means that even if we have some prior beliefs, the data we collect can still have a big influence on our final results, especially if the data is strong. so, we're going to use the half-cauchy distribution for situations where we're estimating variance parameters from just a few groups. in these cases, our choices about our prior beliefs can really affect our results, so we want to use a prior distribution that's flexible and doesn't have a strong influence unless the data really supports it. application to the 8-schools example we demonstrate the properties of some proposed noninformative prior densities on the eight-schools example of section 5. figure 5.9 displays the posterior distributions for the 8-schools model resulting from three different choices of prior distributions that are intended to be noninformative. the first histogram (on the left) shows what we think about the parameter \\(\\tau\\) when we use a uniform prior distribution. the data suggest that \\(\\tau\\) could be anywhere below \\(20\\), but there's a small chance it could be even larger. this makes sense because we only have data from \\(8\\) groups, and it's hard to be sure about large values of \\(\\tau\\) with that little data. now, look at the second histogram (in the middle). here, we've changed our prior to something called an \\(\\text{inverse-gamma}(1, 1)\\) distribution. this changes our conclusions. now, our estimate for \\(\\tau\\) is lower, and we're more confident in our estimates for the individual group parameters (\\(\\theta_j\\)'s). to understand why this happens, let's think about the shape of our prior distribution. with the inverse-gamma prior, it's concentrated in a narrow range, from \\(0.5\\) to \\(5\\). this means it's not giving much weight to really large or really small values of \\(\\tau\\). in comparison, the uniform prior seemed less informative, meaning it didn't strongly influence our conclusions. the last histogram (on the right) in figure 5.9 shows what happens when we use a different kind of prior distribution called \\(\\text{inverse-gamma}(0.001, 0.001)\\) for \\(\\tau\\) squared. this prior is very sharply peaked near zero, meaning it puts a lot of emphasis on very small values of \\(\\tau\\). because of this, our conclusions from the data get distorted. even though the data might suggest that \\(\\tau\\) could be larger, the prior is pulling our estimates towards smaller values. the reason this happens is because the likelihood for \\(\\tau\\), stays high near zero. so even though our data might suggest that larger values of \\(\\tau\\) are possible, the strong influence of the prior near zero pulls our estimates towards smaller values. in this example, we're not considering two other options: using a uniform prior distribution on the logarithm of \\(\\tau\\), which would result in an improper posterior density with a spike at \\(\\tau = 0\\), similar to the last histogram but even more pronounced. using a uniform prior distribution directly on \\(\\tau^2\\), which would result in a posterior distribution similar to the first histogram, but with a slightly higher tail on the right side. application for the 3-schools problem the uniform prior distribution seems fine for the 8-school analysis, but problems arise if the number of groups \\(j\\) is much smaller, in which case the data supply little information about the group-level variance, and a noninformative prior distribution can lead to a posterior distribution that is improper or is proper but unrealistically broad. figure 5.10 displays the inferences for \\(\\tau\\) based on two different priors. we start with a default uniform distribution, which means we're not favoring any particular values for our parameter \\(\\tau\\). this worked well when we had data from \\(8\\) groups (as seen in figure 5.9). but now, we're looking at a new dataset with only \\(3\\) groups. unfortunately, the resulting histogram (the left one in figure 5.10) shows that the posterior distribution for \\(\\tau\\) has a really long tail on the right side. this means it's suggesting values of \\(\\tau\\) that are way too high to be reasonable. this long tail is expected because we have such a small number of groups (if we had even fewer groups, the tail would be even longer, going on forever). using this kind of posterior distribution can be a problem because it means we're not pooling the estimates of the school effects (\\(\\theta_j\\)) as much as we should be. the last histogram (on the right) in figure 5.10 shows what happens when we use a different kind of prior distribution called a half-cauchy. we set the scale parameter (\\(a\\)) of this prior to \\(25\\). we chose this value to be a bit higher than what we expect for the standard deviation of the underlying \\(\\theta_j\\)'s in our educational testing example. this way, our model only weakly constrains the parameter \\(\\tau\\). on the graph, you'll see a line that represents this prior distribution. it's highest for values of \\(\\tau\\) less than \\(50\\) and gradually falls off beyond that. this means the prior puts more weight on smaller values of \\(\\tau\\) but still allows for larger values. this half-cauchy prior distribution would also perform well in the 8-schools problem; however it was unnecessary because the default uniform prior gave reasonable results. with only 3 schools, we went to the trouble of using a weakly informative prior, a distribution that was not intended to represent our actual prior state of knowledge about \\(\\tau\\) but rather to constrain the posterior distribution, to an extent allowed by the data. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/MBJ/T2/03.html",
    "title": "Bayesian analysis of conjugate hierarchical models",
    "body": " index search search back bayesian analysis of conjugate hierarchical models analytic derivation of conditional and marginal distributions hierarchical models involve multiple levels of parameters and dependencies between them, making the analysis more intricate. the following steps are necessary to disentangle the relationships between parameters at different levels of the hierarchy and to estimate their distributions accurately. joint posterior density: combines the prior information (hyperprior distribution \\(p(\\phi)\\)), the population distribution (\\(p(\\theta|\\phi)\\)), and the likelihood function \\(p(y|\\theta)\\) to form the joint posterior distribution. \\begin{align} p(\\theta, \\phi|y) \\propto p(y|\\theta)p(\\theta|\\phi)p(\\phi) \\end{align} conditional posterior density of the parameters: calculates the posterior distribution of \\(\\theta\\) given the hyperparameters \\(\\phi\\), allows us to understan how parameters interact and influence each other. this is usually done using a priori conjugate distributions. \\begin{align} p(\\theta|\\phi, y) \\end{align} hyperparameter estimation: estimating \\(\\phi\\) through the bayesian paradigm helps in updating our knowledge about the higher-level parameters based on the observed data. this step can be perfomed by integrating the joint posterior distribution over \\(\\theta\\) in to be able to marginalize \\(\\phi\\) conditionally on \\(y\\). \\begin{align} p(\\phi|y) = \\int p(\\theta, \\phi|y)d\\theta \\end{align} for many standard models the marginal posterior distribution of \\(\\phi\\) can be computed algebraically using the conditional probability formula: \\begin{align} p(\\phi|y) = \\frac{p(\\theta, \\phi|y)}{p(\\theta|\\phi, y)} \\end{align} drawing simulations from the posterior distribution the following strategy is useful for simulating a draw from the joint posterior distribution \\(p(\\theta, \\phi|y)\\) draw the vector of hyperparameters, \\(\\phi\\), from its marginal posterior distribution, \\(p(\\phi|y)\\). draw the parameter vector \\(\\theta\\) from its conditional posterior distribution, \\(p(\\theta|\\phi, y)\\). for the examples we consider in this chapter, the factorization \\(p(\\theta|\\phi, y) = \\prod_j p(\\theta_j|\\phi, y)\\) holds. if desired, draw predictive values \\(\\tilde{y}\\) from the posterior predictive distribution. the above steps are performed \\(l\\) times in order to obtain a set of \\(l\\) draws. from the joint posterior simulations of \\(\\theta\\) and \\(\\tilde{y}\\), we can compute the posterior distribution of any estimand or predictive quantity of interest. application to the model for rat tumors the data from experiments \\(j = 1, \\cdots, j\\), \\(j = 71\\), are assumed to follow independent binomial distributions: \\begin{align} y_j \\sim bin(n_j, \\theta_j) \\end{align} this models the probability of getting exactly \\(\\theta_j\\) successes in \\(n_j\\) independent bernoulli trials. with the number of rats \\(n_j\\) unknown. the parameters \\(\\theta_j\\) are assumed to be independent samples from a beta distribution: \\begin{align} \\theta_j \\sim beta(\\alpha, \\beta) \\end{align} and we shall assign a noninformative hyperprior distribution to reflect our ignorance about the unknown hyperparameters \\(\\alpha, \\beta\\). we defer the choice of noninformative hyperprior distribution, a relatively arbitrary and unimportant part of this particular analysis, until we inspect the integrability of the posterior density. joint, conditional, and marginal posterior distributions the joint posterior distribution of all the parameters is: \\begin{align} p(\\theta, \\alpha, \\beta|y) \\propto p(\\alpha, \\beta)p(\\theta|\\alpha,\\beta)p(y|\\theta, \\alpha, \\beta) \\end{align} where \\(p(\\alpha, \\beta)\\) is the hyperprior distribution (\\(p(\\phi)\\)). then \\(p(\\theta|\\alpha,\\beta)\\) is the population distribution (\\(p(\\theta|\\phi)\\)). the pdf of \\(x \\sim beta(\\alpha, \\beta)\\), ignoring the normalization constant, is given by: \\begin{align} p(\\theta|\\alpha, \\beta) \\propto \\frac{\\gamma(\\alpha + \\beta)}{\\gamma(\\alpha)\\gamma(\\beta)} x^{\\alpha - 1} (1- x)^{\\beta - 1} \\end{align} for \\(j = 1, \\cdots, j\\) i.i.d \\(\\theta_j \\sim beta(\\alpha, \\beta)\\): \\begin{align} p(\\theta|\\alpha, \\beta) \\propto \\prod_{j=1}^j \\theta_j^{\\alpha - 1} (1- \\theta_j)^{\\beta - 1} \\end{align} and \\(p(y|\\theta, \\alpha, \\beta)\\) is the likelihood (\\(p(y|\\theta)\\)). the pdf of \\(x \\sim bin(n, p)\\) is given by: \\begin{align} p(x = k|n, p) \\propto p^k (1 - p)^{n - k} \\end{align} for \\(j = 1, \\cdots, j\\) i.i.d \\(y_j \\sim bin(n_j, \\theta_j)\\): \\begin{align} p(y_j|n_j, \\theta_j) \\propto \\theta_j^{y_j} (1 - \\theta_j)^{n_j - y_j} \\end{align} therefore we obtain: \\begin{align} \\propto p(\\alpha, \\beta) \\left(\\prod_{j=1}^j \\frac{\\gamma(\\alpha + \\beta)}{\\gamma(\\alpha)\\gamma(\\beta)}\\theta_j^{\\alpha - 1}(1 - \\theta_j)^{\\beta - 1}\\right) \\left(\\prod_{j=1}^j \\theta_j^{y_j}(1 - \\theta_j)^{n_j - y_j}\\right) \\end{align} the conditional posterior density of \\(\\theta\\) given the hyperparameters is defined using a beta-binomial conjugate prior (page 7), therefore if: \\begin{align} y_i|n_j, \\theta_j \\sim bin(n_j, \\theta_j) \\end{align} \\begin{align} \\theta_j|\\alpha,\\beta \\sim beta(\\alpha, \\beta) \\end{align} then \\begin{align} \\theta_j|\\alpha, \\beta, y_j, n_j \\sim beta(\\alpha + y_j, \\beta + n_j - y_j) \\end{align} which gives us the following pdf for a beta distribution of i.i.d \\(\\theta\\): \\begin{align} p(\\theta|\\alpha, \\beta, y) = \\prod_{j=1}^j \\frac{\\gamma(\\alpha + y_j + \\beta + n_j - y_j)}{\\gamma(\\alpha + y_j)\\gamma(\\beta + n_j - y_j)}\\theta_j^{\\alpha + y_j - 1}(1-\\theta_j)^{\\beta + n_j - y_j - 1} \\end{align} \\begin{align} = \\prod_{j=1}^j \\frac{\\gamma(\\alpha + \\beta + n_j)}{\\gamma(\\alpha + y_j)\\gamma(\\beta + n_j - y_j)}\\theta_j^{\\alpha + y_j - 1}(1-\\theta_j)^{\\beta + n_j - y_j - 1} \\end{align} we can determine the marginal posterior distribution of the hyperparameters \\((\\alpha, \\beta)\\) by substituting on the previous equations on the following formula: \\begin{align} p(\\phi|y) = \\frac{p(\\theta, \\phi|y)}{p(\\theta|\\phi, y)} \\end{align} where \\(\\phi = (\\alpha, \\beta)\\), so: \\begin{align} p(\\alpha, \\beta|y) = \\frac{p(\\theta, \\alpha, \\beta|y)}{p(\\theta|\\alpha, \\beta, y)} \\end{align} \\begin{align} \\propto \\frac{p(\\alpha, \\beta) \\left(\\prod_{j=1}^j \\frac{\\gamma(\\alpha + \\beta)}{\\gamma(\\alpha)\\gamma(\\beta)}\\theta_j^{\\alpha - 1}(1 - \\theta_j)^{\\beta - 1}\\right) \\left(\\prod_{j=1}^j \\theta_j^{y_j}(1 - \\theta_j)^{n_j - y_j}\\right)}{\\prod_{j=1}^j \\frac{\\gamma(\\alpha + \\beta + n_j)}{\\gamma(\\alpha + y_j)\\gamma(\\beta + n_j - y_j)}\\theta_j^{\\alpha + y_j - 1}(1-\\theta_j)^{\\beta + n_j - y_j - 1}} \\end{align} \\begin{align} \\propto p(\\alpha, \\beta) \\frac{\\prod_{j=1}^j \\frac{\\gamma(\\alpha + \\beta)}{\\gamma(\\alpha)\\gamma(\\beta)}\\theta_j^{\\alpha - 1}(1 - \\theta_j)^{\\beta - 1} \\theta_j^{y_j}(1 - \\theta_j)^{n_j - y_j}}{\\prod_{j=1}^j \\frac{\\gamma(\\alpha + \\beta + n_j)}{\\gamma(\\alpha + y_j)\\gamma(\\beta + n_j - y_j)}\\theta_j^{\\alpha + y_j - 1}(1-\\theta_j)^{\\beta + n_j - y_j - 1}} \\end{align} \\begin{align} \\propto p(\\alpha, \\beta) \\prod_{j=1}^j \\frac{\\frac{\\gamma(\\alpha + \\beta)}{\\gamma(\\alpha)\\gamma(\\beta)}\\theta_j^{\\alpha - 1}(1 - \\theta_j)^{\\beta - 1} \\theta_j^{y_j}(1 - \\theta_j)^{n_j - y_j}}{\\frac{\\gamma(\\alpha + \\beta + n_j)}{\\gamma(\\alpha + y_j)\\gamma(\\beta + n_j - y_j)}\\theta_j^{\\alpha + y_j - 1}(1-\\theta_j)^{\\beta + n_j - y_j - 1}} \\end{align} \\begin{align} \\propto p(\\alpha, \\beta) \\prod_{j=1}^j \\left(\\frac{\\frac{\\gamma(\\alpha + \\beta)}{\\gamma(\\alpha)\\gamma(\\beta)}}{\\frac{\\gamma(\\alpha + \\beta + n_j)}{\\gamma(\\alpha + y_j)\\gamma(\\beta + n_j - y_j)}}\\frac{\\theta_j^{\\alpha - 1}(1 - \\theta_j)^{\\beta - 1} \\theta_j^{y_j}(1 - \\theta_j)^{n_j - y_j}}{\\theta_j^{\\alpha + y_j - 1}(1-\\theta_j)^{\\beta + n_j - y_j - 1}}\\right) \\end{align} \\begin{align} \\propto p(\\alpha, \\beta) \\prod_{j=1}^j \\left(\\frac{\\gamma(\\alpha + \\beta)\\gamma(\\alpha + y_j)\\gamma(\\beta + n_j - y_j)}{\\gamma(\\alpha)\\gamma(\\beta)\\gamma(\\alpha + \\beta + n_j)}\\theta_j^{\\alpha - 1 + y_j - \\alpha - y_j + 1}(1-\\theta_j)^{\\beta - 1 + n_j - y_j - \\beta - n_j + y_j + 1}\\right) \\end{align} \\begin{align} \\propto p(\\alpha, \\beta) \\prod_{j=1}^j \\left(\\frac{\\gamma(\\alpha + \\beta)\\gamma(\\alpha + y_j)\\gamma(\\beta + n_j - y_j)}{\\gamma(\\alpha)\\gamma(\\beta)\\gamma(\\alpha + \\beta + n_j)}\\theta_j^{0}(1-\\theta_j)^{0}\\right) \\end{align} \\begin{align} \\propto p(\\alpha, \\beta) \\prod_{j=1}^j \\frac{\\gamma(\\alpha + \\beta)\\gamma(\\alpha + y_j)\\gamma(\\beta + n_j - y_j)}{\\gamma(\\alpha)\\gamma(\\beta)\\gamma(\\alpha + \\beta + n_j)} \\end{align} choosing a standard parameterization and setting up a 'noninformative' hyperprior distribution because we have no immediately available information about the distribution of tumor rates in populations of rats, we seek a relatively diffuse hyperprior distribution for \\((\\alpha, \\beta)\\). by reparameterizing the hyperparameters, we transform them into a space that may have more intuitive or meaningful interpretations. in this case, \\(logit(\\frac{\\alpha}{\\alpha + \\beta}) = \\log(\\frac{\\alpha}{\\beta})\\) represents the log-odds of \\(\\alpha\\) relative to the total of \\(\\alpha\\) and \\(\\beta\\), providing a clear interpretation of the prior mean in the beta distribution for \\(\\theta\\). similarly, \\(\\log(\\alpha + \\beta)\\) captures the logarithm of the \"sample size,\" influencing the precision or spread of the distribution. also the logit transformation helps stabilize the numerical computations, especially when dealing with probabilities or proportions that are bounded between 0 and 1. by working in the logit space, we avoid issues related to extreme values or boundaries that can arise in the original parameter space. and transforming the hyperparameters can facilitate the specification of appropriate prior distributions. one reasonable choice of diffuse hyperprior density is uniform on \\((\\frac{\\alpha}{\\alpha + \\beta}, (\\alpha + \\beta)^{−1/2})\\), which when multiplied by the appropriate jacobian yields the following densities on the original scale, \\begin{align} p(\\alpha, \\beta) \\propto (\\alpha + \\beta)^{-5/2} \\end{align} and on the natural transformed scale: \\begin{align} p(\\log(\\frac{\\alpha}{\\beta}), \\log(\\alpha + \\beta)) \\propto \\alpha\\beta(\\alpha + \\beta)^{-5/2} \\end{align} computing the marginal posterior density of the hyperparameters now that we have established a full probability model for data and parameters, we compute the marginal posterior distribution of the hyperparameters. the next figure shows a contour plot of the unnormalized marginal posterior density on a grid of values of \\((\\log(\\frac{\\alpha}{\\beta}), \\log(\\alpha + \\beta))\\) to create the plot, we first compute the logarithm of the density function of \\(p(\\alpha, \\beta|y)\\) with prior density \\(p(\\alpha, \\beta) \\propto (\\alpha + \\beta)^{-5/2}\\), multiplying by the jacobian to obtain the density \\(p(\\log(\\frac{\\alpha}{\\beta}), \\log(\\alpha + \\beta)|y)\\) the most obvious features of the contour plot are (1) the mode is not far from the point estimate (as we would expect), and (2) important parts of the marginal posterior distribution lie outside the range of the graph. we recompute the previous pdf in a different range \\((\\log(\\frac{\\alpha}{\\beta}), \\log(\\alpha + \\beta)) \\in [-2.3, -1.3] \\times [1, 5]\\). figure \\(5.3b\\) displays \\(1000\\) random draws from the numerically computed posterior distribution. the graphs show that the marginal posterior distribution of the hyperparameters, under this transformation, is approximately symmetric about the mode, roughly \\((−1.75, 2.8)\\). this corresponds to approximate values of \\((\\alpha, \\beta) = (2.4, 14.0)\\), which differs somewhat from the crude estimate obtained earlier. having computed the relative posterior density at a grid that covers the effective range of \\((\\alpha, \\beta)\\), we normalize by approximating the distribution as a step function over the grid and setting the total probability in the grid to \\(1\\). sampling from the joint posterior distribution of parameters and hyperparameters we draw \\(1000\\) random samples from the joint posterior distribution of \\((\\alpha, \\beta, \\theta_1, \\cdots, \\theta_j)\\), as follows. simulate \\(1000\\) draws of \\((\\log(\\frac{\\alpha}{\\beta}), \\log(\\alpha + \\beta))\\) from their posterior distribution using the same discrete-grid sampling procedure used to draw \\((\\alpha, \\beta)\\) for figure \\(3.3b\\). for \\(l = 1, \\cdots, 1000\\): transform the \\(l\\)th draw of \\((\\log(\\frac{\\alpha}{\\beta}), \\log(\\alpha + \\beta))\\) to the scale \\((\\alpha, \\beta)\\) to yield a draw of the hyperparameters from their marginal posterior distribution. for each \\(j = 1, \\cdots, j\\), sample \\(\\theta_j\\) from its conditional posterior distribution, \\(\\theta_j|\\alpha, \\beta, y \\sim beta(\\alpha + y_j, \\beta + n_j − y_j)\\). displaying the results figure \\(5.4\\) shows posterior medians and \\(95\\%\\) intervals for the \\(\\theta_j\\)’s, computed by simulation. the results are superficially similar to what would be obtained based on a point estimate of the hyperparameters, which makes sense in this example, because of the fairly large number of experiments. but key differences remain, notably that posterior variability is higher in the full bayesian analysis, reflecting posterior uncertainty in the hyperparameters. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/MBJ/T2/04_normal_model.html",
    "title": "Normal model with exchangeable parameters",
    "body": " index search search back normal model with exchangeable parameters model definition we now present a full treatment of a simple hierarchical model based on the normal distribution, with different means for each \"group\" but with known observation variance and a normal population distribution for the group means. consider \\(j\\) independent experiments. the likelihood (sampling distribution) is defined as: \\begin{align} y_{ij} | \\theta_j \\sim \\text{n}(\\theta_j, \\sigma^2), \\text{ for } i = 1, \\cdots, n_j; j = 1, \\cdots, j. \\end{align} where we label the sample mean of each group \\(j\\) as: \\begin{align} \\overline{y}_j = \\frac{1}{n_j} \\sum_{i = 1}^{n_j} y_{ij} \\end{align} and the sampling variance as: \\begin{align} \\sigma^2_j = \\frac{\\sigma^2}{n_j} \\end{align} here we assume that \\(\\sigma\\) is a know value. we can then write the likelihood for each \\(\\theta_j\\) using the sufficient statistics, \\(\\overline{y}_j\\): \\begin{align} \\overline{y}_j | \\theta_j \\sim \\text{n}(\\theta_j, \\sigma_j^2) \\end{align} sufficient statistics are summary statistics of the data that capture all the information about the parameter of interest. in this case, the sufficient statistic \\(\\overline{y}_j\\) represents the data summary for experiment \\(j\\) that is used to estimate the parameter \\(\\theta_j\\). by using the sufficient statistic \\(\\overline{y}_j\\), the likelihood function for each \\(\\theta_j\\) is constructed based on the observed data in experiment \\(j\\). the prior distribution over \\(\\theta_j\\), assuming the prior to be normal for the sake of conjugacy is defined as: \\begin{align} \\theta_j|\\mu, \\tau \\sim \\text{n}(\\theta_j|\\mu, \\tau^2) \\end{align} assuming each \\(\\theta_j\\) to be independent we obtain the following joint distribution: \\begin{align} p(\\theta_1, \\cdots, \\theta_j|\\mu, \\tau) = \\prod_{j=1}^j \\text{n}(\\theta_j|\\mu, \\tau^2) \\end{align} and by process of marginalization: \\begin{align} p(\\theta_1, \\cdots, \\theta_j) = \\int \\left[\\prod_{j=1}^j \\text{n}(\\theta_j|\\mu, \\tau^2)\\right]p(\\mu, \\tau) d(\\mu, \\tau) \\end{align} the hyperprior over the parameters \\(\\mu\\) and \\(\\tau\\) is defined as a non-informative distribution (i.e. uniform density), such that: \\begin{align} p(\\mu, \\tau) = p(\\mu|\\tau)p(\\tau) \\propto p(\\tau) \\end{align} we define a prior distribution over \\(\\tau\\). for our illustrative analysis, we use the uniform prior distribution \\(p(\\tau) \\propto 1\\). once an initial analysis is performed using the noninformative 'uniform' prior density, a sensitivity analysis with a more realistic prior distribution is often desirable. inference joint posterior distribution this distribution combines prior information (hyperprior distribution \\(p(\\mu, \\tau)\\)) the population distribution \\(p(\\theta_j|\\mu, \\tau)\\) and the likelihood function \\(p(y_{ij}|\\theta_j)\\). we define it as follows: \\begin{align} p(\\theta, \\mu, \\tau|y) \\end{align} by bayes theorem (ignoring the normalization term): \\begin{align} \\propto p(y|\\theta) p(\\theta|\\mu, \\tau) p(\\mu, \\tau) \\end{align} here \\(p(y|\\theta)\\) is the likelihood function previously defined in terms of the sufficient statistics \\(\\overline{y}_j\\) \\begin{align} \\propto \\left[\\prod_{j=1}^j \\text{n}(\\overline{y}_j|\\theta_j, \\sigma_j^2)\\right] p(\\theta|\\mu, \\tau) p(\\mu, \\tau) \\end{align} and \\(p(\\theta|\\mu, \\tau)\\) is the prior, also previouly defined, such that: \\begin{align} \\propto \\left[\\prod_{j=1}^j \\text{n}(\\overline{y}_j|\\theta_j, \\sigma_j^2)\\right] \\left[\\prod_{j=1}^j \\text{n}(\\theta_j|\\mu, \\tau^2) p(y|\\theta)\\right] p(\\mu, \\tau) \\end{align} where we can ignore factors that depend only on \\(y\\) and the parameters \\(\\sigma_j\\), which are assumed known for this analysis. the conditional posterior distribution the conditional posterior distribution calculates the posterior distribution of \\(\\theta_j\\) given the hyperparameters \\(\\mu, \\tau\\). it allows us to understand how parameters intereact and influence each other. we define them for each \\(\\theta_j\\) as follows: \\begin{align} \\theta_j | \\mu, \\tau, y \\sim \\text{n}(\\hat{\\theta}_j, v_j) \\end{align} where: \\begin{align} \\hat{\\theta}_j = \\frac{\\frac{1}{\\sigma_j^2}\\overline{y}_j + \\frac{1}{\\tau^2}\\mu}{\\frac{1}{\\sigma_j^2} + \\frac{1}{\\tau^2}} \\end{align} and: \\begin{align} v_j = \\frac{1}{\\frac{1}{\\sigma_j^2} + \\frac{1}{\\tau^2}} \\end{align} the marginal posterior distribution this distribution allows us to estimate the hyperparameters \\(\\mu\\) and \\(\\tau\\) through the bayesian paradigm. by the conditional rule we obtain: \\begin{align} p(\\mu, \\tau|y) \\propto p(\\mu, \\tau)p(y|\\mu, \\tau) \\end{align} where: \\begin{align} \\overline{y}_j | \\mu, \\tau \\sim \\text{n}(\\mu, \\sigma_j^2 + \\tau^2) \\end{align} such that: \\begin{align} p(\\mu, \\tau|y) \\propto p(\\mu, \\tau) \\prod_{j=1}^j \\text{n}(\\overline{y}_j|\\mu, \\sigma^2_j + \\tau^2) \\end{align} posterior distribution of \\(\\mu\\) given \\(\\tau\\) we can further simplify by integrating over \\(\\mu\\), leaving a simple univariate numerical computation of \\(p(\\tau|y)\\), by the conditional rule: \\begin{align} p(\\mu, \\tau|y) = p(\\mu | \\tau, y) p(\\tau|y) \\end{align} where: \\begin{align} \\mu | \\tau, y \\sim \\text{n}(\\hat{\\mu}, v_\\mu) \\end{align} with: \\begin{align} \\hat{\\mu} = \\frac{\\sum_{j=1}^j \\frac{1}{\\sigma_j^2 + \\tau^2}\\overline{y}_j}{\\sum_{j=1}^j \\frac{1}{\\sigma_j^2 + \\tau^2}} \\end{align} and \\begin{align} v_{\\mu}^{-1} = \\sum_{j=1}^j \\frac{1}{\\sigma_j^2 + \\tau^2} \\end{align} posterior distribution \\(\\tau\\) we know from the previous section that: \\begin{align} p(\\mu, \\tau|y) = p(\\mu | \\tau, y) p(\\tau|y) \\end{align} such that: \\begin{align} p(\\tau|y) = \\frac{p(\\mu, \\tau|y)}{p(\\mu | \\tau, y)} \\end{align} we previously defined \\(\\mu | \\tau, y \\sim \\text{n}(\\hat{\\mu}, v_\\mu)\\), therefore: \\begin{align} p(\\tau|y) = \\frac{p(\\mu, \\tau|y)}{\\text{n}(\\hat{\\mu}, v_\\mu)} \\end{align} we also defined \\(p(\\mu, \\tau|y) \\propto p(\\mu, \\tau) \\prod_{j=1}^j \\text{n}(\\overline{y}_j|\\mu, \\sigma^2_j + \\tau^2)\\): \\begin{align} \\propto \\frac{p(\\tau) \\prod_{j=1}^j \\text{n}(\\overline{y}_j|\\mu, \\sigma^2_j + \\tau^2)}{\\text{n}(\\hat{\\mu}, v_\\mu)} \\end{align} simulation for this model, computation of the posterior distribution of θ is most conveniently performed via simulation, following the factorization: \\begin{align} p(\\theta, \\mu, \\tau|y) = p(\\theta|\\mu, \\tau, y) p(\\mu|\\tau, y) p(\\tau, y) \\end{align} posterior predictive distributions to obtain a draw from the posterior predictive distribution of new data \\(\\tilde{y}\\) from the current batch of parameters, \\(\\theta\\), first obtain a draw from \\(p(\\theta, \\mu, \\tau|y)\\) and then draw the predictive data \\(\\tilde{y}\\) from the sampling distribution: \\begin{align} y_{ij} | \\theta_j \\sim \\text{n}(\\theta_j, \\sigma^2), \\text{ for } i = 1, \\cdots, n_j; j = 1, \\cdots, j. \\end{align} to obtain posterior predictive simulations of new data \\(\\tilde{y}\\) for \\(\\tilde{j}\\) new groups, perform the following three steps: draw \\((\\mu, \\tau)\\) from their posterior distribution \\(p(\\mu, \\tau|y)\\) draw \\(\\tilde{j}\\) new parameters \\(\\tilde{\\theta} = \\tilde{\\theta}_1, \\cdots, \\tilde{\\theta}_{\\tilde{j}}\\) from the population distribution \\(p(\\tilde{\\theta}|\\mu, \\tau)\\). draw \\(\\tilde{y}\\) given \\(\\tilde{\\theta}\\) from the sampling distribution. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/MBJ/T2/13_hierarchical_beta_binomial_modeling.html",
    "title": "Hierarchical Beta-Binomial Modeling",
    "body": " index search search back hierarchical beta-binomial modeling example: deaths after heart attack the new york state (nys) department of health collects and releases data on mortality after a heart attack. we focus on 13 hospitals in manhattan, new york city, with the goal of learning about the percentages of resulted deaths from heart attack for hospitals in this sample. a hierarchical beta-binomial model treating “cases” as trials and “deaths” as successes, the binomial sampling model is a natural choice for this data, and the objective is to learn about the death probability \\(p\\) of the hospitals. if one creates thirteen separate binomial sampling models, one for each hospital, and conducts separate inferences, one loses the ability to use potential information about the death rate from hospital \\(i\\) when making inference about that of a different hospital \\(j\\). since these are all hospitals in manhattan, new york city, they may share attributes in common related to death rates from heart attack. therefore, one builds a hierarchical model based on a common beta distribution that generalizes the beta-binomial conjugate model described in chapter 7. let \\(y_i\\) denote the number of resulted deaths from heart attack, \\(n_i\\) the number of heart attack cases, and \\(p_i\\) the death rate for hospital \\(i\\). so the sampling and first stage of the prior of our model is written as follows: sampling for \\(i = 1, \\cdots, 13\\): \\begin{align} y_i \\sim \\text{binomial}(n_i, p_i) \\end{align} prior for \\(p_i\\), \\(i = 1, \\cdots, 13\\): \\begin{align} p_i \\sim \\text{beta}(a, b) \\end{align} note that the hyperparameters \\(a\\) and \\(b\\) are shared among all hospitals. if \\(a\\) and \\(b\\) are known values, then the posterior inference for \\(p_i\\) of hospital \\(i\\) is simply another beta distribution by conjugacy (refer to beta-binomial conjugate prior (page 7)): \\begin{align} p_i | y_i \\sim \\text{beta}(a + y_i, b + n_i - y_i) \\end{align} in the general situation where the hyperparameters \\(a\\) and \\(b\\) are unknown, a second stage of the prior \\(\\pi(a, b)\\) needs to specified for these hyperparameters, such that the model is now defined as: sampling for \\(i = 1, \\cdots, 13\\): \\begin{align} y_i \\sim \\text{binomial}(n_i, p_i) \\end{align} prior for \\(p_i\\), stage 1: \\(i = 1, \\cdots, 13\\): \\begin{align} p_i \\sim \\text{beta}(a, b) \\end{align} prior for \\(p_i\\), stage 2: the hyperprior: \\begin{align} a, b \\sim \\pi(a, b) \\end{align} when we start analyzing the new york state heart attack death rate dataset, the specification of this hyperprior distribution \\(\\pi(a, b)\\) will be described. graphical representation one sees that the upper section of the graph represents the sampling density, with the arrow directing from \\(p_i\\) to \\(y_i\\). here the start of the arrow is the parameter and the end of the arrow is the random variable. the lower section of the graph represents the prior, with arrows directing from \\(a\\) and \\(b\\) to \\(p_i\\). inference through mcmc second-stage prior for a \\(\\text{beta}(a, b)\\) prior distribution for a proportion \\(p\\), one considers the parameter \\(a\\) as the prior count of “successes”, the parameter \\(b\\) as the prior count of \"failures\", and the sum \\(a + b\\) represents the prior sample size. also the expectation is given by \\(\\frac{a}{a + b}\\). from these facts a more natural parametrization of the hyperprior distribution \\(\\pi(a, b)\\) is \\(\\pi(\\mu, \\eta)\\) where \\(\\mu = \\frac{a}{a + b}\\) is the hyperprior mean and \\(\\eta = a + b\\) is the hyperprior sample size. therefore: \\begin{align} \\mu, \\eta \\sim \\pi(\\mu, \\eta) \\end{align} where \\(a = \\mu\\eta\\) and \\(b = (1 - \\mu)\\eta\\). assume \\(\\mu\\) and \\(\\eta\\) are independent which means that one's beliefs about the prior mean are independent of the beliefs about the prior sample size. the hyperprior expectation \\(\\mu\\) is the mean measure for \\(p_i\\), the average death rate across \\(13\\) hospitals. if one has little prior knowledge about the expectation \\(\\mu\\), one assigns this parameter a uniform prior which is equivalent to a \\(\\text{beta}(1, 1)\\) prior. to motivate the prior choice for the hyperparameter sample size \\(\\eta\\), consider the case where the hyperparameter values are known. if \\(y^*\\) and \\(n^*\\) are respectively the number of deaths and number of cases for one hospital, then the posterior mean of death rate parameter \\(p^*\\) is given by (refer to the beta-binomial conjugate definition): \\begin{align} \\mathbb{e}[p^*|y^*] = \\frac{y^* + \\mu\\eta}{n^* + \\eta} \\end{align} with a little algebra, the posterior mean is rewritten as \\begin{align} \\mathbb{e}[p^*|y^*] = (1 - \\lambda)\\frac{y^*}{n^*} + \\lambda\\mu \\end{align} where \\(\\lambda\\) is the shrinkage fraction: \\begin{align} \\lambda = \\frac{\\eta}{n^* + \\eta} \\end{align} the parameter \\(\\lambda\\) falls in the interval \\((0, 1)\\) and represents the degree of shrinkage of the posterior mean away from the sample proportion \\(\\frac{y^*}{n^*}\\) towards the prior mean \\(\\mu\\). suppose one believes a priori that, for a representative sample size \\(n^*\\), the shrinkage \\(\\lambda\\) is uniformly distributed on \\((0, 1)\\). by performing a transformation, this implies that the prior density for the prior sample size \\(\\eta\\) has the form: \\begin{align} \\pi(\\eta) = \\frac{n^*}{(n^* + \\eta)^2}, \\eta > 0 \\end{align} equivalently, the logarithm of \\(\\eta\\), \\(\\theta = \\log(\\eta)\\), has a logistic distribution with location \\(\\log(n^*)\\) and scale \\(1\\). we represent this distribution as \\(logistic(\\log(n^*), 1)\\), with pdf: \\begin{align} \\pi(\\theta) = \\frac{e^{-(\\theta - \\log(n^*))}}{(1 + e^{-(\\theta - \\log(n^*))})^2} \\end{align} with this specification of the hyperparameter distribution, one writes down the complete hierarchical model as follows: sampling for \\(i = 1, \\cdots, 13\\): \\begin{align} y_i \\sim \\text{binomial}(n_i, p_i) \\end{align} prior for \\(p_i\\), stage 1: \\(i = 1, \\cdots, 13\\): \\begin{align} p_i \\sim \\text{beta}(a, b) \\end{align} prior for \\(p_i\\), stage 2: the hyperpriors: \\begin{align} \\mu, \\eta \\sim \\pi(\\mu, \\eta) \\end{align} \\begin{align} \\log \\eta \\sim \\text{logistic}(\\log n^*, 1) \\end{align} where \\(a = \\mu\\eta\\) and \\(b = (1 - \\mu)\\eta\\) mcmc diagnostics and summarization after the diagnostics are performed, one reports posterior summaries of the parameters: from the posterior output, one evaluates the effect of information pooling in the hierarchical model. see figure 10.6 displays a shrinkage plot showing how the sample proportions are shrunk towards the overall death rate. to compare the posterior densities of the different \\(p_i\\), one displays the density estimates in a single graph as in the following figure: $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/AAII/T3/01_introduccion.html",
    "title": "Introduccion",
    "body": " index search search back introduccion while the idea of combining classifiers is not new, there is still a lot of scope for developing new combination approaches, types of features and classifiers used, and novel applications. fumera et al. presented a theoretical and experimental analysis of multiple classifiers with a focus on linear combiners. the authors particularly focused on simple and weighted averaging. their analysis showed that the performance of linear combiners depends on the accuracy of the individual classifiers and the correlation between their outputs. they also showed that the weighted averaging rule outperforms simple averaging. in weighted averaging, finding the optimal weights for each classifier is still an open problem. further research areas can involve the use of meta-heuristic optimization approaches such as the bat algorithm and other related techniques. in [8], polikar discussed the idea of combining classifiers' output labels in comparison with combination using classifiers' continuous outputs as well as their application to ensemble based systems. in combining continuous outputs, the degrees of support given to each class, by the different classifiers, are used by the combination technique. this support is referred to as score in some literatures. the classifiers output labels are mainly combined using majority voting or its variants. the author primarily reviewed conditions for which ensemble based systems outperform individual classifiers. different combination techniques were analyzed in details. in conclusion, the author stated that no single ensemble generation algorithm or combination rule is universally better than others. while there are several review papers in the literature, this paper presents a more updated survey including more recent approaches introduced during the past few years. since the last major review paper [10], several novel techniques have been introduced. these include a signal strength based combining approach [11], a novel bayes voting strategy [12], a modified weighted averaging technique using graph-theoretical clustering [13], a neural network based approach for training the combination rules [14], weighted features combination [15], and hierarchical fuzzy stack generalization [16], among others. bibliography classifiers combination techniques: a comprehensive review [10] s. chitroub, \"classifier combination and score level fusion: concepts and practical aspects,\" int. j. image data fusion, vol. 1, no. 2, pp. 113–135, jun. 2010. [11] h. he and y. cao, \"ssc: a classifier combination method based on signal strength.,\" ieee trans. neural networks learn. syst., vol. 23, no. 7, pp. 1100–17, jul. 2012. [12] c. de stefano, f. fontanella, and a. s. di freca, \"a novel naive bayes voting strategy for combining classifiers.,\" in icfhr, 2012, pp. 467–472. [13] j. hou, z.-s. feng, and b.-p. zhang, \"a graph-theoretic approach to classifier combination,\" in acoustics, speech and signal processing (icassp), 2012 ieee international conference on, 2012, pp. 1017–1020. [14] y.-d. lan and l. gao, \"a new model of combining multiple classifiers based on neural network,\" 2013 fourth int. conf. emerg. intell. data web technol., no. 2, pp. 154–159, sep. 2013. [15] h. kuang, x. zhang, y.-j. li, l. l. h. chan, and h. yan, \"nighttime vehicle detection based on bio-inspired image enhancement and weighted score-level feature fusion,\" ieee trans. intell. transp. syst., vol. 18, no. 4, pp. 927–936, apr. 2017. [16] c. senaras, m. ozay, and f. t. yarman vural, \"building detection with decision fusion,\" 2013. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/AAII/T3/04_conclusion.html",
    "title": "Conclusiones",
    "body": " index search search back conclusiones while a large number of combination techniques have been proposed, the literature still lacks a comprehensive performance analysis of such techniques for a given application. the review showed that while one strategy (e.g. fusion at decision level) may outperform others for a given application, the results from such a strategy may not be the best for another application. however overall, it was shown that classifiers combinations in general improve performance significantly over individual classifiers for most problems. an important research direction relies on adding an enhancement stage (post processing) to the classifiers output before applying combination rules. this would improve the performance of individual classifiers before the combination stage. many classifiers combination techniques have performed well under certain restrictions which include independence assumption, gaussian distribution, linear process, limited class problem (mostly 2-class problem) and low dimensional feature space. thus, future work can reconsider relaxing some of these constraints another issue that needs to be further investigated is to explore the advantages of using different strategies for the fusion including probabilistic, learning, decision based, or evidence based techniques. the discussion on voting based approaches has shown that there is a scope for improving classification accuracy. this issue also offers numerous opportunities for developing optimization techniques to determine the weights. some of the approaches including ga, pso, and ant optimization techniques, among others, can be investigated. neural networks as well as similar models such as fuzzy networks, deep neural networks; svm, etc. also offer an excellent opportunity for developing adaptive techniques to combine individual classifiers outputs. for example, can individual classifiers be considered as layers of more general architectures. computational complexity is an important issue that needs further research especially when the different algorithms are deployed over mobile or low power platform an important issue which is still open is that of finding the optimal number of classifiers to be combined for a given application. additionally, for a given number of features, is there a way to distribute these among the different classifiers to be combined. finally, the use of hybrid approaches to integrate results from different combination techniques, offers further opportunities for solving more involved applications. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/AAII/T3/02_marco_general.html",
    "title": "Marco general para la combinacion de clasificadores",
    "body": " index search search back marco general para la combinacion de clasificadores the task is seen as a problem of finding a combination function which accepts \\(n\\)-dimensional score vectors from each of the \\(m\\) classifiers, then producing a single final classification score representing the selected class. given the \\(n\\) possible classes \\(\\{\\omega_1, \\omega_2, \\cdots, \\omega_n\\}\\) and a pattern \\(z\\) (that is a data sample), let \\(x_k\\) be the measurement vector (the numerical attributes of \\(z\\)) used by the \\(k\\)th classifier (different classifiers may use different attributes to discriminate). the probability density function of the measurement vector is represented by: \\begin{align} p(x_k|\\omega_n) \\end{align} while the prior probability of the occurrence of the class is denoted by \\(p(\\omega_n)\\). the bayesian framework aims to determine the class label for the pattern \\(z\\) by considering the information provided by all \\(m\\) classifiers. the final decision is based on the aposteriori probability, which is the probability of the pattern belonging to a specific class \\(j\\) given the measurement vectors from all classifiers \\(x_1, x_2, \\cdots, x_m\\). \\begin{align} p(\\theta = \\omega_j|x_1, x_2, \\cdots, x_m) = \\max_{k} p(\\theta = \\omega_k | x_1, x_2, \\cdots, x_m) \\end{align} so the pattern \\(z\\) is assigned to class \\(\\omega_j\\) which produces the maximum a posterior probability. where the aposteriori distribution is computed as follows: \\begin{align} p(\\theta = \\omega_j|x_1, x_2, \\cdots, x_m) = \\frac{p(x_1, x_2, \\cdots, x_m|\\theta = \\omega_j)p(\\theta=\\omega_j)}{p(x_1, x_2, \\cdots, x_m)} \\end{align} provided that each classifier provides independently a decision support obtained from \\(x_k\\), where \\(p(x_1, x_2, \\cdots, x_m)\\) is the joint pdf of the observations independently of class label. the important issue is that the individual classifiers should not make identical erroneous decisions on the same observation instances, they should provide complementary information. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/AAII/T3/03_estrategias.html",
    "title": "Estrategias para la combinación de clasificadores",
    "body": " index search search back estrategias para la combinación de clasificadores this section provides a detailed review of classifiers combination techniques first, we discuss the different levels at which combination is performed: sensors, features and decisions. we then expand on the concept of soft vs. hard combination techniques. finally, we discuss how the combination techniques can be grouped as either adaptive or non-adaptive. levels of classifiers combination classifiers combination can be carried out at three different levels: early combination at sensor data level: combination of data collected from two or more sensors before feature selection technique is applied. combination at feature level: it may simply involve basic concatenation of feature vectors with equal or different weights (might result in high dimensonal vectors, whose dimension has to be reduced). late combination at the decision level: they are based on one of three approaches: abstract, rank, and score: abstract-based: a single output label from each individual classifier is used as input to the combination scheme. rank-based: each classifier yields several labels ranked from the most likely to the least likely. this information is then used by the combination scheme to reach the final decision. score-based: each classifier outputs the \\(n\\) best labels together with their confidence scores. the combination can be density-based, transformation-based or classifier-based score fusion. hard and soft level classifier combination another way to categorize combination algorithms is whether hard thresholding or soft scoring is used with each of the classifiers. hard-level combination: uses the output of the classifier after it is hard thresholded. soft-level combination: uses estimates of the aposteriori probability of the class. the sum, product, max, min rules, etc., fall under the soft level combiners as they use the output aposteriori probability of the classifier or a score. sum rule: the class with the highest sum of probabilities is chosen as the final prediction. product rule: the class with the highest product of probabilities is chosen as the final prediction. max rule: the class with the highest posterior probability among all classifications made by individual classifiers is selected as the final prediction. min rule: the class with the lowest posterior probability among all classifications made by individual classifiers is selected as the final prediction. majority voting is a typical example of hard-level combiners and has found widespread use in the literature. there are three different versions of voting: unanimous voting. more than half voting. highest number of votes. considering the output label vector of the \\(i\\)th classifier as: \\begin{align} [d_{i, 1}, \\cdots, d_{i, n}]^t \\in [0, 1]^n \\end{align} where \\(i = 1, 2, \\cdots, m\\) and \\(d_{i, j} = 1\\) if the classifier \\(d_i\\) labels the \\(i\\)th instance as class \\(\\omega_j\\) and \\(0\\) otherwise. the majority vote results in a decision for class \\(\\omega_k\\) if: \\begin{align} \\sum_{i = 1}^m d_{i, k} = \\max_{j = 1}^n \\sum_{i = 1}^m d_{i, j} \\end{align} where \\(m\\) is the total number of classifiers and \\(n\\) is total number of classes. such that class \\(\\omega_k\\) is the most \"selected\" on all the classifier. the accuracy of the combination scheme is given as: \\begin{align} p_{maj} = \\sum_{m = \\frac{m}{2} + 1}^m \\binom{m}{m} p^m (1-p)^{m - m} \\end{align} where \\(p\\) is the probability of correct classification. majority voting provides an accurate class label when at least \\(\\frac{m}{2} + 1\\) classifiers give correct classifications, it also requires participating classifiers to have comparable accuracies. weighted majority voting weighted majority voting is used when the classifiers' accuracies are not similar, so it is reasonable to assign more weight to the most accurate classifier. now the decision rule becomes: \\begin{align} \\sum_{i = 1}^m b_i d_{i, k} = \\max_{j = 1}^n \\sum_{i = 1}^m b_i d_{i, j} \\end{align} where \\(b_i\\) is the weight associated with classifier \\(d_i\\). for the sake of convenience, it is a good practice to normalize the weights such that the sum is one. the weight selection is very important in determining the overall accuracy of the classifier combinations. therefore, to minimize the classification error of the combination, the weights are assigned as follows: \\begin{align} b_i \\propto \\log\\left(\\frac{p_i}{1 - p_i}\\right) \\end{align} where \\(p_i, \\cdots, p_m\\) are the individual accuracies for each independent classifier. dynamic weighted consult-and-vote in [30], muhlbaier et al. introduced a method for combining ensembles of classifiers using a dynamic weighted consult-and-vote approach for incremental learning of new classes. the proposed technique focuses on incremental learning, specifically for incorporating new classes into the classification system. the consult-and-vote strategy involves a dynamic process where individual classifiers within the ensemble consult with each other to determine their respective voting weights for classifying test instances. the voting weights assigned to each classifier are determined based on their relative performance on the training data. the method proposed by muhlbaier et al. represents an enhancement over a previous approach developed by the authors. the previous approach may have encountered the \"out-voting\" problem, where certain classifiers dominate the decision-making process, potentially leading to biased or inaccurate results. divide and conquer another modification of majority voting, involving a divide and conquer strategy, is described in [31]. it aims to enhance the majority voting approach by breaking down the classification task into smaller, more manageable sub-problems. each sub-problem is then addressed independently, with dedicated classifiers or classification algorithms focusing on solving the specific challenges within that subset of data. after solving each of the smaller sub-problems individually, the results or decisions from these segments are combined using a majority voting scheme. majority voting involves aggregating the outputs of the classifiers or algorithms involved in solving the sub-problems and selecting the class label that receives the most votes as the final decision. quality based combination techniques the quality-based combination approach, as referenced in [32], focuses on assigning higher weights to more reliable classifiers based on specific quality measures. quality measures used to assess the performance of classifiers may vary depending on the application domain and specific requirements. feature combination the challenge of increasing dimensionality resulting from the simple combination of features from different datasets is addressed through innovative approaches to decision-level combination, as discussed in [33]. combining features from diverse datasets can lead to a significant increase in the dimensionality of the data. the study proposed an effective approach for decision-level combination by leveraging spectral reflectance and its higher-order derivatives to classify hyperspectral land images. spectral reflectance and its derivatives provide valuable information about the characteristics of the land surface, which can aid in classification tasks. the study conducted experiments under two scenarios to address the curse of dimensionality: scenario 1 - lda-based dimensionality reduction: linear discriminant analysis (lda) was employed for dimensionality reduction. scenario 2 - multiple classifiers decision fusion (mcdf): multiple classifiers were utilized for decision fusion to enhance classification performance. critic classifier in the study referenced as [34], the authors introduced an innovative approach that focuses specifically on addressing two-class classification problems. the key feature of this approach is the incorporation of a classifier critic associated with each individual classifier, aimed at predicting the error rate of the classifier. the role of the classifier critic is to forecast the potential error or misclassification rate of its associated classifier. the approach relies on classical standard voting techniques for combining the outputs of multiple classifiers. adaptative voting technique in the study referenced as [35], the authors introduced an adaptive approach to voting techniques. the key innovation in this approach is the dynamic weighting of classifiers based on their estimated recognition performance. different model combination in [36], the authors explored the combination of three distinct classifiers - naive bayes, j48 decision tree, and decision table - using various voting techniques to enhance classification accuracy. the classifiers were combined using different voting strategies, including simple voting (where each classifier has equal weight), weighted voting (assigning different weights to classifiers based on their performance), and probability-based voting (considering the confidence or probability estimates of classifiers). the study reported that the ensemble of classifiers using weighted and probability-based voting techniques outperformed simple majority voting. in addition to classifier combination and voting strategies, the study applied a supervised dimensionality reduction algorithm to further enhance performance. dimensionality reduction techniques aim to reduce the complexity of the feature space while preserving relevant information, thereby improving classification accuracy and efficiency. in [38], a voting strategy was employed for land cover classification of remotely sensed images by utilizing an ensemble of six different classifiers. common voting techniques include simple majority voting, weighted voting, or probability-based voting, where the combined decision is based on the collective predictions of the ensemble members. in the study referenced as [39], researchers proposed an approach that combines artificial neural network (ann) and k-nearest neighbors (knn) based classifiers using a majority voting scheme. this method was specifically designed to enhance accuracy in scenarios where sensor data is prone to drift. the researchers employed a majority voting scheme to combine the predictions of the ann and knn classifiers. in this approach, each classifier in the ensemble provides a prediction, and the final decision is made based on the majority vote of the individual classifier outputs. the primary goal of the study was to leverage the complementary strengths of ann and knn classifiers to address the challenge of sensor data drift. ann models are known for their ability to learn complex patterns from data, while knn is a non-parametric method based on instance-based learning that can be effective in classification tasks. by combining multiple knn classifiers using majority voting and employing median voting for the ann classifiers, the researchers observed a substantial improvement in classification performance. the ensemble of ann and knn classifiers demonstrated enhanced accuracy in classifying sensor data, showcasing the effectiveness of the majority voting scheme in mitigating the impact of data drift on classification outcomes. dynamic entropy based combination technique in [37], the authors introduced a novel dynamic entropy-based technique for combining classifiers. the key idea behind the combination scheme is to assign weights to individual classifiers based on their confidence levels in making decisions. classifiers that exhibit high confidence in their predictions are assigned larger weights, while those with lower confidence receive smaller weights. assuming linear dependency between predictors in [40], the authors considered linear dependency of both classifiers and features. to address this, they proposed a new approach that models the dependencies between features without making any assumptions about the distribution of features (independency) or classifiers. the researchers introduced two key models as part of their framework: linear classifier dependency modelling (lcdm): this model focuses on capturing dependencies between the classifiers themselves, exploring how the outputs of different classifiers may be linearly related. linear feature dependency modelling (lfdm) : this model is designed to identify and model dependencies between the features used by the classifiers, allowing for a more comprehensive understanding of the relationships within the feature space. the results of the study demonstrated that the proposed approach outperformed existing methods in scenarios where linear dependencies between features and classifiers play a significant role. by explicitly modeling these dependencies, the framework was able to capture more complex relationships within the data and improve classification accuracy. runtime weighted opinion pool in [45], introduces a novel classifiers combination approach known as the runtime weighted opinion pool (rwop). this approach dynamically assigns weights to the classifiers during runtime based on their local performance, leading to an adaptive and context-aware combination strategy. unlike traditional weighted sum-based approaches, rwop utilizes an intuitive runtime strategy to determine the weights for combining classifier outputs. the dynamic weight assignment in rwop allows the system to adapt to changing conditions and varying input patterns, leading to more robust and accurate classification outcomes. using hidden markov models in the study referenced as [46], the authors introduce a novel approach for combining classifiers specifically designed for hidden markov model (hmm) based classifiers. unlike traditional methods where the combination typically occurs at the decision level, this new approach operates at a more elementary level within the hmm framework. assigning weights to classes in the study referenced as [12], a novel weighted majority voting approach was proposed for classifiers combination. this approach differs from traditional methods by assigning weights to different classes rather than individual base classifiers. the weights are determined by estimating the joint probability distribution of each class using the scores provided by all classifiers in the combination pool. the joint probability distribution is computed using the naïve bayes probabilistic model. combination rules in the context of multiple classifiers combination, the way individual classifiers handle input patterns can vary. some classifiers may use the same representation of the input pattern, while others may employ their own unique representations. the effectiveness of combining these classifiers using different strategies has been explored in various studies, including those referenced as [41], [42], and [43]. simple sum rule: despite being developed under restrictive assumptions, the simple sum rule was found to outperform other combination rules in certain scenarios. majority voting: the experimental results indicated that the majority voting approach was the most effective combination rule for the specific dataset used in the study. assesment fixed rule-based combination techniques in the context of multiple classifiers do not require a training stage and rely on class labels, distances, or confidences provided by individual classifiers. the efficiency of fixed rule techniques is influenced by various factors, as discussed in reference [44]. according to reference [44], fixed rule techniques are most efficient under specific conditions: availability of large training sets: adequate training data is essential for reliable performance. generation of reliable confidences: individual classifiers should provide accurate and trustworthy confidence values. training on different feature spaces: base classifiers should be trained on diverse feature representations to capture varied aspects of the data. in scenarios where the strict conditions for fixed rule techniques are not met, a trained combination rule may yield better results. adaptative and non-adaptative combiners adaptative combiners adaptive techniques for classifiers combination are mainly based on evolution or artificial intelligence algorithms. they include neural networks combination strategies and genetic algorithms as well as fuzzy set theory. techniques under these categories are summarized on the following figure: artificial neural networks are usually used as a base classifier [29], however, it has also found wide use in combination of classifiers. ad and cm combination in [48], the author introduces two innovative approaches for combining classifiers to enhance robustness and fault tolerance: the attractor dynamics (ad) algorithm and the classifier masking (cm) algorithm. the cm algorithm is described as a non-neural version of the ad algorithm, inspired by modeling properties of sensory integration in the central nervous system. both approaches are designed to promote consensus among individual classifiers and improve the overall performance of the combined system by discarding corrupted classifier outputs. ann vs svm combination in [49], the authors conducted a comparative analysis of combining the outputs of an ensemble of artificial neural networks (anns) with support vector machine (svm) classifiers for processing remotely sensed data. they employed an multi-layer perceptron (mlp) module to facilitate the non-linear combination of the outputs generated by the networks. the researchers explored two distinct approaches for optimizing coefficient selection: the bayesian method and the error correlation matrix. through experimental evaluation, the authors found that the mlp-based combination scheme yielded the most favorable results compared to the svm classifiers. combination through ann in [50], the authors proposed a novel approach where they utilized an artificial neural network (ann) as a model for combining classifiers. instead of combining the outputs of different classifiers, they integrated various training sets with distinct classifiers to train a unified combination rule within a three-layer ann architecture. in this setup, each classifier represented a unit in the hidden layer of the ann. incorporating a priori knowledge in [51], the authors delved into the significance of leveraging a priori knowledge within existing classifiers combination techniques, specifically exploring the application of the behavior knowledge space and the dempster-shafer (d-s) theory. this investigation aimed to elucidate how incorporating prior knowledge can enhance the performance of classifiers combination, particularly when dealing with strongly correlated classifiers. the study also highlighted the utilization of adaptive combiners, encompassing strategies such as adaptive weighting, associative switching, mixture of local experts (mle), and hierarchical mle combining combination strategies dynamically in [57] an adaptive approach to combining classifiers was introduced. the proposed approach dynamically selects between two different combination strategies based on the belief values obtained from each strategy. specifically, the study compared the performance of a bayesian classifiers combination approach and product and max rule combination strategy. in the bayesian method, the combination of classifiers is based on probabilistic principles, where the posterior probabilities of class labels are calculated using bayes' theorem. the product rule combines the outputs of individual classifiers by multiplying their probabilities or scores for each class. the max rule operates by selecting the class label that receives the highest score or confidence level among all the individual classifiers in the ensemble. modifying majority voting in [58] the authors introduced various modifications to the traditional majority voting rule by incorporating a bayesian framework and a genetic algorithm (ga) to determine the weights assigned to different classifiers in the ensemble. the bayesian framework allowed for the probabilistic modeling of the weights, while the ga provided an optimization technique to search for the best combination of weights that maximized the ensemble performance. the results of the study indicated that the modified majority voting rule, when combined with the bayesian framework and ga for weight optimization, achieved significant improvements in accuracy. specifically, the optimal accuracies obtained were \\(94.3\\%\\) for the majority vote, \\(95.4\\%\\) for the genetic algorithm, and 95.95% for the bayesian approach. based on genetic theory in the study referenced as [22], the authors introduced an innovative approach that involved the simultaneous extraction and selection of features and classifiers to improve the performance of gender and age classification using speech signals collected from a typical korean home environment. the authors employed a genetic algorithm to simultaneously select features and classifiers. ga is a metaheuristic optimization technique inspired by the process of natural selection and genetics, used to search for the optimal combination of features and classifiers for the classification task. the outputs of the selected classifiers were combined using the dempster-shafer theory, a mathematical theory for combining evidence from different sources to make decisions under uncertainty. in [59] a novel approach based on genetic algorithm (ga) with self-configuration capabilities was developed for classifier combination. the researchers employed a pool of twelve expert classifiers that were already trained on the task of character recognition, including both printed and handwritten characters. these expert classifiers likely had different strengths and weaknesses, making them suitable candidates for ensemble learning. the ga was integrated into the system to optimize the combination of outputs from the expert classifiers. by using the evolutionary principles of genetic algorithms, the system could iteratively adjust the weights assigned to each classifier in the ensemble to maximize the overall accuracy of the system. fuzzy based in the study referenced as [16], the authors introduced a novel approach known as fuzzy stacked generalization (fsg) to combine the outputs of multiple classifiers. fsg operates within a hierarchical framework where multiple base-layer classifiers are utilized to make individual predictions on the input data. in fsg, the decisions made by the base-layer classifiers are aggregated to form a decision vector. this decision vector is then fed into a meta-layer classifier, which combines the outputs of the base-layer classifiers to make the final decision. in [53], the authors proposed a classifiers combination technique using fuzzy templates (ft). an object is labeled with the class whose fuzzy template is closest to the objects' decision profile. the authors obtained an improved performance over majority, min, max and product rules, and unweighted average combination techniques in [54], an adaptive fuzzy integral was used to combine multiple classifiers. the parameter \\(\\lambda\\)-fuzzy, which measures performance, is adaptively adjusted depending upon the interaction among the classifiers. the essence of the parameter is to search for the maximum degree of agreement between the conflicting and complementary sources of evidence. in [55], a fuzzy decision rule was employed to combine the outputs of multiple classifiers without the need for a training stage. each classifier was independently applied to the input data, but no final decision was made based on their outputs at this stage. these classifiers are pre-existing models that have been trained on labeled data to make predictions or classifications. the results from the classifiers were aggregated using a fuzzy decision rule. this rule considered the membership degrees of the classes assigned by each classifier and selected the class with the highest membership degree (the confidence or certainty with which each classifier assigns a data point to a specific class) as the correct class. two measures of accuracy, namely information reliability and global accuracy, were utilized in the combination rule to assess the performance of the combined classifiers. in [56] the authors introduced a first-order takagi-sugeno-kang (tsk) fuzzy model for combining multiple classifiers. unlike conventional linear combination methods that assign different weights to pairs of classifiers and classes, the proposed tsk fuzzy model assigns weights to each individual classifier, class, and region of the classifier output space (decision boundary). this finer granularity in weight assignment allows for a more nuanced and adaptive combination of classifier outputs. the tsk fuzzy model is utilized to integrate the outputs of multiple classifiers. this model leverages fuzzy logic to combine the predictions of individual classifiers in a way that considers the uncertainty and variability in the classifier outputs. the study demonstrated improved accuracy compared to using individual classifiers alone. while the tsk fuzzy model showed promising results in enhancing classification accuracy, the authors did not explicitly address the potential bias and variance reduction that could arise from using a linear model for combining classifiers. non-adaptative combiners the highest confidence approach is an example of nonadaptive combination techniques. it involves ranking the individual classifiers based on their confidence then selecting the decision of the top ranked one. the borda count technique is also an example of nonadaptive methods. it is based on the principle of single winner classifier in which the individual classifiers provide a ranked list of the classes. it is a more sophisticated alternative to majority voting [60] based on ranking level [9]. it does not require training, just like averaging, sum, and voting rules [52]. conclusion in summary, adaptive combiners tend to do better than the non-adaptive types. this is due to the fact that adaptive combiners update the weights given to the individual classifier dynamically before making the final decision. given the fact that the performance of the individual classifiers can vary over input patterns, such a dynamic combination provides an edge over its non-adaptive counterpart especially when the data space is wide and diverse. classification based on the number of classifiers the most commonly used techniques for ensemble based combinations are displayed in the following figure: bagging is one of the most intuitive and simple techniques used for ensemble based combination. however, unlike bagging, in boosting, the individual classifiers are trained hierarchically to discriminate more complex regions in the feature space. adaboost is a variation of the boosting technique. it is an adaptive boosting meta-algorithm that combines outputs of weak classifiers into a weighted sum that represents the final decision. however, the technique is sensitive to noisy data and outliers. in [66], the authors used adaboost to enhance the performance of a hybrid hidden markov model (hmm) and neural network (nn) speech recognition system. hmms are commonly used for modeling sequential data like speech signals, while nns are effective in capturing complex patterns in data. the researchers evaluated the performance of the hybrid hmm/nn system with and without the adaboost algorithm under noisy environments. noise in speech signals can introduce distortions and affect the accuracy of the recognition system. by applying adaboost, the system was expected to adapt better to noisy conditions and enhance its robustness. the results of the study demonstrated that incorporating adaboost into the hybrid hmm/nn speech recognition system led to improved performance, even in the presence of noise. adaboost's ability to focus on difficult instances and adjust the weights of the classifiers based on their performance contributed to the system's ability to handle noisy environments and enhance overall recognition accuracy. in [67] the researchers explored a combination approach at the feature level using support vector machine (svm) classifiers and a global adaboost classifier. the study focused on combining features extracted from different datasets at the feature level. by utilizing svm classifiers and a global adaboost classifier, the researchers aimed to leverage the strengths of both classifiers in integrating information from multiple datasets to improve classification performance. one significant drawback identified in the study regarding feature-level combination is the issue of high dimensionality. combining features from multiple datasets can result in a large number of features, which can lead to challenges such as increased computational complexity, overfitting, and reduced interpretability of the model. other combination techniques in [68] the researchers introduced a novel classifiers combination technique based on an svm active learning algorithm. the study proposed a method that leverages support vector machine (svm) classifiers in conjunction with an active learning algorithm. active learning refers to a machine learning approach where the algorithm can select the most informative data points for labeling, thereby improving the learning process iteratively. the researchers developed a strategy where an initial classifier, likely an svm model, is used to generate class aposteriori probabilities. these probabilities serve as inputs to the classifiers-combiner, which is based on the svm active learning algorithm. the approach outperforms traditional classifiers combination rules when considering class labeling cost and classification accuracy. in [70] and [71] the researchers introduced a novel approach using eigenclassifiers for combining correlated classifiers. the proposed method involves utilizing principal component analysis (pca) projection to create eigenclassifiers from a set of initially correlated classifiers. by applying pca, the goal is to transform the correlated classifiers into uncorrelated eigen-classifiers. this transformation process aims to enhance the diversity and independence of the classifiers, enabling them to complement each other effectively during the combination stage. the results of the study indicated that the pca-based eigenclassifiers technique provided better or comparable accuracy with a reduced number of classifiers compared to bagging and adaboost. this suggests that the uncorrelation process facilitated by pca enhanced the performance of the combined classifiers, leading to improved classification results with fewer individual classifiers. similarly, in [72] the researchers explored methods to address linear and non-linear correlations among the outputs of individual classifiers by leveraging principal component analysis (pca) and a generalized kernel-based pca approach. initially, the authors identified linear correlations among the outputs of individual classifiers. to mitigate these linear correlations, the researchers applied a simple pca approach. building on the success of addressing linear correlations, the authors extended their approach to consider non-linear dependencies among the outputs of individual classifiers. o handle these non-linear dependencies, the researchers proposed a generalized kernel-based pca approach. the results of the experiments demonstrated that the generalized kernel-based pca approach outperformed alternative methods in improving classification accuracy. in [73] the researchers introduced a novel classifier combination technique that focused on extracting class boundaries and utilizing a set of local linear combination rules. the proposed technique involved extracting class boundaries, which are the decision boundaries that separate different classes in the dataset. the researchers employed a set of local linear combination rules to combine the outputs of individual classifiers. these rules likely involved linear combinations of classifier outputs within specific regions of the feature space, allowing for adaptive and context-aware decision-making. the experimental results demonstrated that the classifier combination technique based on class boundaries and local linear combination rules achieved better accuracy compared to other methods such as linear combination, voting, and decision templates. in [13], the researchers proposed a weighted averaging approach that incorporated graph-theoretical clustering and a support vector machine (svm) classifier for classifier combination. the researchers utilized graph-theoretical clustering techniques as part of the weighted averaging approach. graph theory provides a framework for analyzing relationships between data points, and clustering algorithms can group similar data points together based on certain criteria. by incorporating graph-theoretical clustering, the approach likely aimed to identify clusters of data points with similar characteristics for more effective combination of classifier outputs. in addition to clustering, the approach involved the use of an svm classifier. svms are powerful machine learning models commonly used for classification tasks. by integrating an svm classifier into the weighted averaging process, the researchers likely leveraged its ability to create optimal decision boundaries between classes in the feature space. the results obtained from the experiments indicated that the proposed approach, despite its simplicity and intuitive nature, performed comparably to more sophisticated methods. in [74], the researchers employed three different techniques - highest rank (hr), borda count (bc), and logistic regression (lr) - for combining decisions in a multi-classifier system. the decisions produced by each individual classifier were ranked based on their confidence or accuracy. the hr, bc, and lr techniques were then applied to either reduce the set of possible classes or re-rank them during the combination process. the results obtained from the experiments demonstrated a substantial improvement in the performance of the multi-classifier system. similarly, in [75] a new combination technique called mixed group rank (mgr) was introduced as a novel approach to balancing between preference and confidence in a multi-classifier system. this technique aimed to generalize the principles of highest rank (hr), borda count (bc), and logistic regression (lr) by incorporating elements of both preference-based ranking and confidence-based decision-making. in [76], the authors introduced an innovative approach that involves dynamically switching between classifier combination and classifier selection based on the characteristics of different regions in the feature space. the authors further introduced a hybrid combination scheme that integrates clustering-and-selection (cs) techniques with decision template (dt) methods. this hybrid approach likely combines the benefits of clustering for identifying regions of dominance and selection of the most appropriate classifier, along with decision templates for combining classifier outputs in a structured manner. the authors discussed the tradeoff between selecting the best classifier and combining classifiers. this tradeoff likely involves considerations of the strengths and weaknesses of individual classifiers versus the potential benefits of combining multiple classifiers. in [77], the authors introduced a method based on classifier selection that focused on identifying the most suitable candidate through confidence evaluation of distance-based classifiers. the method aimed to select the most precise candidate from a set of distance-based classifiers by evaluating their confidence levels. this process likely involved assessing the certainty or reliability of each classifier's decision-making based on the distances between data points in the feature space. the authors likely defined specific rules or criteria for selecting the precise candidate based on the confidence evaluations of the distance-based classifiers. these rules may have considered factors such as the proximity of data points to decision boundaries, the consistency of classifier outputs, or the overall confidence levels of individual classifiers. the experiments conducted in the study likely utilized distance metrics such as euclidean distance and city block distance for recognizing handwritten characters. in [78], the author used information from the confusion matrix to merge multiple classifiers using a class ranking borda type reconciliation method. the class ranking borda type reconciliation method is a technique that combines the outputs of multiple classifiers by ranking the classes based on their performance and then using a borda count approach to reconcile the rankings. the results obtained from this method were compared with three other classifier combination techniques: majority voting, sum rule, and median rule. the comparison was done using three types of confusion matrices: deterministic, uniform, and stochastic. the apborda (aposteriori borda count) and sum rule gave the overall best improvement, except in the case of a stochastic confusion matrix and disparate combination (where classifiers had a \\(10\\%\\) accuracy difference from each other). this means that in most cases, the apborda and sum rule performed better in combining the classifiers, but there were specific scenarios where they did not perform as well. in [79] a combination technique based on the f-measure was proposed for recognizing human emotions using an svm (support vector machine) classifier. in this technique, the f-measure was used to form a decision matrix to determine the final emotion. in [80], the authors proposed an approach for detecting vacant parking spaces by combining two different systems. the first system was based on analyzing image data, while the second system relied on sensor data. the experiments conducted by the authors demonstrated that combining the outputs of these two different systems resulted in a reduced error in detecting vacant parking spaces. in summary, several classifiers combination techniques have been proposed in the literature with each technique having its own strengths and weaknesses. recent techniques mostly involve hybridization or modification of previous techniques to achieve better accuracy or to remove an associated constraint on which a particular technique was built on. some of these constraints include the issue of correlated classifiers, gaussian distribution, and iid. there is still a need to develop classifiers combination strategies which are not constrained to specific distributions. references [12] c. de stefano, f. fontanella, and a. s. di freca, \"a novel naive bayes voting strategy for combining classifiers.,\" in icfhr, 2012, pp. 467–472. [16] c. senaras, m. ozay, and f. t. yarman vural, “building detection with decision fusion,” 2013. [22] y. zhan, h. leung, k.-c. kwak, and h. yoon, “automated speaker recognition for home service robots using genetic algorithm and dempster--shafer fusion technique,” instrum. meas. ieee trans., vol. 58, no. 9, pp. 3058–3068, 2009. [29] l. i. kuncheva, combining pattern classifiers: methods and algorithms. john wiley & sons, 2004. [32] n. poh and j. kittler, \"a unified framework for biometric expert fusion incorporating quality measures,\" pattern anal. mach. intell. ieee trans., vol. 34, no. 1, pp. 3–18, 2012. [33] h. r. kalluri, s. prasad, and l. m. bruce, \"decision-level fusion of spectral reflectance and derivative information for robust hyperspectral land cover classification,\" geosci. remote sensing, ieee trans., vol. 48, no. 11, pp. 4047–4058, 2010. [34] d. j. miller and l. yan, \"ensemble classification by critic-driven combining,\" in acoustics, speech, and signal processing, 1999. proceedings., 1999 ieee international conference on, 1999, vol. 2, pp. 1029–1032 [35] f. mattern, t. rohlfing, and j. denzler, \"adaptive performancebased classifier combination for generic object recognition,\" in proc. of international fall workshop vision, modeling and visualization (vmv), 2005, pp. 139–146 [36] g. jain, a. ginwala, and y. a. aslandogan, \"an approach to text classification using dimensionality reduction and combination of classifiers,\" in information reuse and integration, 2004. iri 2004. proceedings of the 2004 ieee international conference on, 2004, pp. 564–569. [37] m. magimai-doss, d. hakkani-tur, o. cetin, e. shriberg, j. fung, and n. mirghafori, \"entropy based classifier combination for sentence segmentation,\" in acoustics, speech and signal processing, 2007. icassp 2007. ieee international conference on, 2007, vol. 4, p. iv--189 [39] s. adhikari and s. saha, \"multiple classifier combination technique for sensor drift compensation using ann & knn,\" in advance computing conference (iacc), 2014 ieee international, 2014, pp. 1184–1189. [40] a. j. ma, p. c. yuen, and j.-h. lai, \"linear dependency modeling for classifier fusion and feature combination,\" pattern anal. mach. intell. ieee trans., vol. 35, no. 5, pp. 1135–1148, 2013. [43] z. wu, c.-h. li, and v. cheng, \"large margin maximum entropy machines for classifier combination,\" in wavelet analysis and pattern recognition, 2008. icwapr’08. international conference on, 2008, vol. 1, pp. 378–383 [44] r. p. w. duin, \"the combining classifier: to train or not to train?,\" in pattern recognition, 2002. proceedings. 16th international conference on, 2002, vol. 2, pp. 765–770. [45] w. wang, a. brakensiek, and g. rigoll, \"combination of multiple classifiers for handwritten word recognition,\" in frontiers in handwriting recognition, 2002. proceedings. eighth international workshop on, 2002, pp. 117–122. [48] a. v bogdanov, \"neuroinspired architecture for robust classifier fusion of multisensor imagery,\" geosci. remote sensing, ieee trans., vol. 46, no. 5, pp. 1467–1487, 2008. [49] g. pasquariello, n. ancona, p. blonda, c. tarantino, g. satalino, and a. d’addabbo, \"neural network ensemble and support vector machine classifiers for the analysis of remotely sensed data: a comparison,\" in geoscience and remote sensing symposium, 2002. igarss’02. 2002 ieee international, 2002, vol. 1, pp. 509–511. [50] y.-d. lan and l. gao, \"a new model of combining multiple classifiers based on neural network,\" in emerging intelligent data and web technologies (eidwt), 2013 fourth international conference on, 2013, pp. 154–159. [51] v. di lecce, g. dimauro, a. guerriero, s. impedovo, g. pirlo, and a. salzo, \"knowledge-based methods for classifier combination: an experimental investigation,\" in image analysis and processing, 1999. proceedings. international conference on, 1999, pp. 562–565. [52] a. k. jain, r. p. w. duin, and j. mao, “statistical pattern recognition: a review,” pattern anal. mach. intell. ieee trans., vol. 22, no. 1, pp. 4–37, 2000. [53] l. i. kuncheva, j. c. bezdek, and m. a. sutton, “on combining multiple classifiers by fuzzy templates,” in fuzzy information processing society-nafips, 1998 conference of the north american, 1998, pp. 193–197 [54] t. d. pham, “combination of multiple classifiers using adaptive fuzzy integral,” in artificial intelligence systems, 2002.(icais 2002). 2002 ieee international conference on, 2002, pp. 50–55. [55] m. fauvel, j. chanussot, and j. a. benediktsson, “decision fusion for the classification of urban remote sensing images,” geosci. remote sensing, ieee trans., vol. 44, no. 10, pp. 2828–2838, 2006. [56] m. cococcioni, b. lazzerini, and f. marcelloni, “a tsk fuzzy model for combining outputs of multiple classifiers,” in fuzzy information, 2004. processing nafips’04. ieee annual meeting of the, 2004, vol. 2, pp. 871–876. [57] y. yaslan and z. cataltepe, “co-training with adaptive bayesian classifier combination,” in computer and information sciences, 2008. iscis’08. 23rd international symposium on, 2008, pp. 1–4. [58] l. lam and c. y. suen, “optimal combinations of pattern classifiers,” pattern recognit. lett., vol. 16, no. 9, pp. 945–954, 1995. [59] k. sirlantzis and m. c. fairhurst, “optimisation of multiple classifier systems using genetic algorithms,” in image processing, 2001. proceedings. 2001 international conference on, 2001, vol. 1, pp. 1094–1097 [66] h. schwenk, “using boosting to improve a hybrid hmm/neural network speech recognizer,” in acoustics, speech, and signal processing, 1999. proceedings., 1999 ieee international conference on, 1999, vol. 2, pp. 1009–1012. [67] j. hu and y. chen, “offline signature verification using real adaboost classifier combination of pseudo-dynamic features,” in document analysis and recognition (icdar), 2013 12th international conference on, 2013, pp. 1345–1349 [68] x. yi, z. kou, and c. zhang, “classifier combination based on active learning,” in pattern recognition, 2004. icpr 2004. proceedings of the 17th international conference on, 2004, vol. 1, pp. 184–187. [69] j. kremer, k. steenstrup pedersen, and c. igel, “active learning with support vector machines,” wiley interdiscip. rev. data min. knowl. discov., vol. 4, no. 4, pp. 313–326, jul. 2014. [70] a. ulaş, o. t. yıldız, and e. alpaydın, “eigenclassifiers for combining correlated classifiers,” inf. sci. (ny)., vol. 187, pp. 109– 120, 2012. [71] e. ulaş, a., semerci, m., yıldız, o. t., & alpaydın, “incremental construction of classifier and discriminant ensembles,” inf. sci. (ny)., vol. 179, no. 9, pp. 1298–1318, 2009 [72] u. ekmekci and z. cataltepe, “classifier combination with kernelized eigenclassifiers,” in information fusion (fusion), 2013 16th international conference on, 2013, pp. 743–749. [73] m. liu, k. li, and r. zhao, “a boundary based classifier combination method,” in control and decision conference, 2009. ccdc’09. chinese, 2009, pp. 3777–3782 [74] t. k. ho, j. j. hull, and s. n. srihari, “decision combination in multiple classifier systems,” pattern anal. mach. intell. ieee trans., vol. 16, no. 1, pp. 66–75, 1994. [75] o. melnik, y. vardi, and c.-h. zhang, “mixed group ranks: preference and confidence in classifier combination,” pattern anal. mach. intell. ieee trans., vol. 26, no. 8, pp. 973–981, 2004. [76] l. i. kuncheva, “switching between selection and fusion in combining classifiers: an experiment,” syst. man, cybern. part b cybern. ieee trans., vol. 32, no. 2, pp. 146–156, 2002. [77] c.-l. liu and m. nakagawa, “precise candidate selection for large character set recognition by confidence evaluation,” pattern anal. mach. intell. ieee trans., vol. 22, no. 6, pp. 636–641, 2000. [78] j. r. parker, “combining multiple non-homogeneous classifiers: an empirical approach,” in cognitive informatics, ieee international conference on, 2002, p. 288. [79] a. agrawal and n. k. mishra, “fusion based emotion recognition system,” in 2016 international conference on computational science and computational intelligence (csci), 2016, pp. 727–732 [80] junzhao, l., mohandes, m., deriche, m., “a multi-classifier image based vacant parking detection system”, ieee international conference on electronics, circuits, and systems icesc, pp. 933-936, abu dhabi, uae, dec 8-11, 2013 $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/AAII/T4/01_introduction.html",
    "title": "Introduction",
    "body": " index search search back introduction in this chapter we address unsupervised learning. in this case one has a set of \\(n\\) observations \\((x_1,x_2, \\cdots ,x_n)\\) of a random vector \\(x\\) having joint density \\(\\text{pr}(x)\\). the goal is to directly infer the properties of this probability density without the help of a supervisor or teacher providing correct answers or degree-of-error for each observation. principal components, multidimensional scaling, self-organizing maps, and principal curves try to find simpler patterns in complex data. they look for lower-dimensional structures in the data that capture where most of the data points lie. by doing this, they help us understand how variables are related to each other and if they can be thought of as being controlled by a smaller group of underlying factors. cluster analysis looks for groups or clusters in the data that are like little \"bumps\" or \"peaks\" where the data is most concentrated, that is convex regios of the \\(x\\)-space that contain modes of \\(\\text{pr}(x)\\). it helps us see if the data can be divided into different types or categories. mixture modeling aims for the same thing. association rules try to find simple rules or patterns that describe where the data is most concentrated, especially when dealing with data that has many features and is either present or absent (binary-valued). in unsupervised learning, where we don't have clear outcomes to compare against. we often have to rely on guesswork and intuition to decide if the results make sense or not. this uncertainty has led to many different methods being proposed, but ultimately, it's hard to know for sure which one is the best since there's no straightforward way to check their effectiveness. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/AAII/T4/03_evaluation_metrics.html",
    "title": "Evaluation Metrics",
    "body": " index search search back evaluation metrics formal limitations of clustering jon kleinberg proposes three axioms that highlight the characteristics that a grouping problem should exhibit and can be considered \"good\". scale invariance: indicates that a clustering algorithm should not modify its results when all distances between points are scaled by the factor determined by a constant \\(\\alpha\\). richness: the clustering function must be flexible enough to produce any arbitrary partition/clustering of the input data set. consistency: the clustering results do not change if the distances within clusters decrease and/or the distances between clusters increase. given the above three axioms, kleinberg proves the following theorem: for every \\(n \\geq 2\\), there is no clustering function \\(f\\) that satisfies scale invariance, richness, and consistency. since the three axioms cannot hold simultaneously, clustering algorithms can be designed to violate one of the axioms while sarisfying the other two. \\(k\\)-cluster stopping condition: stop merging clusters when we have \\(k\\) clusters (violates the richness axiom). distance \\(r\\) stopping condition: stop merging clusters when the nearest pair of clusters are farther than \\(r \\) (violates scale invariance). scale-\\(\\epsilon\\) stopping condition: stop merging clusters when the nearest pair of clusters are farther than a fraction \\(\\epsilon\\) the maximum pairwise distance \\(\\delta\\). (consistency is violated). methods for clustering evaluation when analyzing clustering results, several aspects must be taken into account for the validation of the algorithm results: determining the clustering tendency in the data (i.e. whether non-random structure really exists). determining the correct number of clusters. assessing the quality of the clustering results without external information. comparing the results obtained with external information. comparing two sets of clusters to determine which one is better. the first three issues are addressed by internal or unsupervised validation, because there is no use of external information. the fourth issue is resolved by external or supervised validation. finally, the last issue can be addressed by both supervised and unsupervised validation techniques. null hypothesis testing one of the desirable characteristics of a clustering process is to show whether data exhibits some tendency to form actual clusters. in this case, the null hypothesis \\(h_0\\) is the randomness of data and, when the null hypothesis is rejected, we assume that the data is significantly unlikely to be random. one of the difficulties of null hypothesis testing in this context is determining the statistical distribution under which the randomness hypothesis can be rejected. jain and dubes propose three alternatives: random plot hypothesis \\(h_0\\): all proximity matrices of order \\(n \\times n\\) are equally likely. random label hypothesis \\(h_0\\): all permutations of labels of \\(n\\) objects are equally likely. randon position hypothesis \\(h_0\\): all sets of \\(n\\) locations is some region of a \\(d\\)-dimensional space are equally likely. internal validation internal validation methods (or internal indices) make it possible to establish the quality of the clustering structure without having access to external information. in general, two types of internal validation metrics can be combined: cohesion measures: evaluates how closely the elements of the same cluster are to each other. separation measures: quantify the level of separation between clusters. internal indices are usually employed in conjunction with two clustering algorithm families: hierarchical clustering algorithms and partitional algorithms. for partitional algorithms, metrics based on the proximity matrix, as well as metrics of cohesion and separation, such as the silhouette coefficient, are often used. for hierarchical algorithms, the cophenetic coefficient is the most common. partitional methods in general, the internal validation value of a set of \\(k\\) clusters can be decomposed as the sum of the validation values for each cluster: \\begin{align} \\text{general validity} = \\sum_{i=1}^k w_i \\text{validity}(c_i) \\end{align} this measure of validity can be cohesion, separation, or some combination of both. quite often, the weights that appear in the previous expression correspond to cluster size. the individual measures of cohesion and separation are defined as follows: \\begin{align} \\text{cohesion}(c_i) = \\sum_{x \\in c_i, y \\in c_i} \\text{proximity}(x, y) \\end{align} \\begin{align} \\text{separation}(c_i, c_j) = \\sum_{x \\in c_i, y \\in c_j} \\text{proximity}(x, y) \\end{align} it should be noted that the cohesion metric defined above is equivalent to the cluster sse [sum of squared errors]: \\begin{align} sse(c_i) = \\sum_{x \\in c_i} d(c_i, x)^2 = \\frac{1}{2m_i} \\sum_{x \\in c_i} \\sum_{y \\in c_i} d(x, y)^2 \\end{align} likewise, we can maximize the distance between clusters using a separation metric. this approach leads to the between group sum of squares, or ssb: \\begin{align} ssb = \\sum_{i = 1}^k m_i d(c_i, c)^2 = \\frac{1}{2k} \\sum_{i=1}^k \\sum_{j = 1}^k \\frac{m}{k} d(c_i, c_j)^2 \\end{align} where \\(c_i\\) is the mean of the \\(i\\)th cluster and \\(c\\) is the overall mean. instead of dealing with separate metrics for cohesion and separation, there are several metrics that try to quantify the level of separation and cohesion in a single measure: the calisnki-harabasz coefficient: it is a measure based on the internal dispersion of clusters and the dispersion between clusters. we would choose the number of clusters that maximizes the ch. \\begin{align} ch = \\frac{\\frac{ssb_m}{m - 1}}{\\frac{sse_m}{m}} \\end{align} the dunn index is the ratio of the smallest distance between data from different clusters and the largest distance between clusters. again, this ratio should be maximized: \\begin{align} d = \\min_{1 < i < k} \\left\\{\\min_{1 < j < k, i\\neq j} \\left\\{\\frac{\\delta (c_i, c_j)}{\\max_{1 < l < k} \\{\\delta (c_l)\\}}\\right\\}\\right\\} \\end{align} the xie-beni score was designed for fuzzy clustering, but it can applied to hard clustering. it is a ratio whose numerator estimates the level of compaction of the data within the same cluster and whose denominator estimates the level of separation of the data from different clusters: \\begin{align} xb = \\frac{\\sum_{i=1}^n \\sum_{k=1}^m u^2_{ik} ||x_i - c_k||^2}{n_{t \\neq s} \\min (||c_t - c_s||^2)} \\end{align} the ball-hall index is a dispersion measure based on the quadratic distances of the cluster points with respect to their centroid \\begin{align} bh = \\frac{sse_m}{m} \\end{align} the hartigan index is based on the logarithmic relationship between the sum of squares within the cluster and the sum of squares between clusters: \\begin{align} h = \\log \\left(\\frac{ssb_m}{sse_m}\\right) \\end{align} the xu coefficient takes into account the dimensionality \\(d\\) of the data, the number \\(n\\) of data examples, and the sum of squared errors \\(sse_m\\) form \\(m\\) clusters: \\begin{align} x_u = d \\log_2 \\left(\\sqrt{\\frac{sse_m}{dn^2}}\\right) + \\log m \\end{align} the silhouette coefficient is the most common way to combine the metrics of cohesion and separation in a single measure. its computation is divided into four steps: compute the average intracluster distance for each example \\(i\\): \\(a(i) = \\frac{1}{|c_a|} \\sum_{j \\in c_a, i \\neq j} d(i, j)\\) compute the minimum intercluster distance for each example \\(i\\): \\(b(i) = \\min_{c_b \\neq c_a} \\frac{1}{|c_b|} \\sum_{j \\in c_b} d(i, j)\\) compute the silhouette coefficient for each example \\(i\\): \\(s(i) = \\frac{b(i) - a(i)}{max(a(i), b(i))}\\) compute the silhouette puntuation as the average of the silhouette coefficients: \\(s = \\frac{1}{n} \\sum_{i = 1}^n s(i)\\) the silhouette is defined in the interval \\([-1, 1]\\). positive values indicate a high separation between clusters, negative values are an indication that the clusters are mixed with each other. when the silhouette coefficient is zero, it is an an indication that the data are uniformly distributed throughout the euclidean space. unfortunately, one of the main drawbacks of the silhouette coefficient is its high computational complexity. cohesion and separation metrics are not the only validation method available for partitional clustering techniques. in fact, cohesion and separation metrics do not perform well when it comes to analyzing results obtained by algorithms based on density analysis. one way to validate clustering is by comparing the actual proximity matrix with an ideal version based on the provided clustering by the algorithm. if we reorder rows and columns so that all examples of the same cluster appear together, the ideal proximity matrix has a block diagonal structure. high correlation between the actual and ideal proximity matrices indicates that examples in the same cluster are close to each other, although it may not be a good measure for density-based clustering. imagine you have a table where each row and column represents a data point, and the cells contain numbers indicating how similar or close those data points are to each other. now, if you group similar data points together into clusters, you can rearrange the rows and columns of the table so that all the data points within each cluster are together. when you do this, the table will have a diagonal pattern where each cluster forms a block of closely related data points. this diagonal pattern is what we mean by a \"block diagonal structure\" in the context of a proximity matrix. unfortunately, the mere construction of the whole proximity matrix is computationally expensive. hierarchical methods cophenetic correlation coefficient the cophenetic distance between two examples is the proximity at which an agglomerative hierarchical clustering algorithm puts the examples in the same cluster for the first time. the cophenetic correlation coefficient (cpcc) is defined as he correlation between the entries of the cophenetic matrix \\(p_c\\) containing cophenetic distances, and the proximity matrix \\(p\\), containing similarities. the cophenetic correlation coefficient is then defined as: \\begin{align} \\text{cpcc} = \\frac{\\sum_{i < j} (d_{ij} - \\overline{d})(d_{ij}^* - \\overline{d}^*)}{\\sqrt{\\sum_{i < j} (d_{ij} - \\overline{d})^2 \\sum_{i < j}(d_{ij}^* - \\overline{d}^*)}} \\end{align} where \\(d_{ij}\\) is the distance between the example pair \\((i, j)\\), \\(d_{ij}^*\\) is their cophenetic distance, \\(\\overline{d}\\) is the average of the distances in the proximity matrix and \\(d_{ij}^*\\) is the average of the cophenetic distances in the cophenetic matrix. \\begin{align} \\overline{d} = \\frac{\\sum_{i < j} d_{ij}}{2(n^2 - n)} \\end{align} \\begin{align} \\overline{d}^* = \\sqrt{\\frac{\\sum_{i < j} (d_{ij} - d_{ij}^*)^2}{\\sum_{i < j} (d_{ij}^*)^2}} \\end{align} the cophenetic correlation coefficient is a value in the interval \\([−1, 1]\\). high cpcc values indicate a high level of similarity between the two matrices, an indication that the clustering algorithm has been able to identify the underlying structure of its input data. hubert statistic first, concordance are discordance are defined for pairs of examples. a pair \\((i, j)\\) is concordant when \\(((v_{p_i} < v_{c_i}) \\& (v_{p_j} < v_{c_j}))\\) or \\(((v_{p_i} > v_{c_i}) \\& (v_{p_j} > v_{c_j}))\\). and it is said to be discordant when \\(((v_{p_i} < v_{c_i}) \\& (v_{p_j} > v_{c_j}))\\) or \\(((v_{p_i} > v_{c_i}) \\& (v_{p_j} < v_{c_j}))\\). therefore, a pair is neither concordant nor discordant if \\(v_{p_i} = v_{c_i}\\) or \\(v_{p_j} = v_{c_j}\\). let \\(s_+\\) and \\(s_-\\) be the number of concordant and discordant pairs, respectively. then, the hubert coefficient is defined as: \\begin{align} \\gamma = \\frac{s_+ - s_-}{s_+ + s_-} \\end{align} the hubert statistic is between \\(-1\\) and \\(1\\). it has been mainly used to compare the results of two hierarchical clustering algorithms. a higher hubert \\(\\gamma\\) value corresponds to a better clustering of data. external validation external validation proceeds by incorporating additional information in the clustering validation process, i.e. external class labels for the training examples. we want to compare the result of a clustering algorithm \\(c = \\{c_1, c_2, \\cdots, c_m\\}\\) to a potentially different partition of data \\(p = \\{p_1, p_2, \\cdots, p_s\\}\\) which might represent the expert knowledge of the analyst (his experience or intuition), prior knowledge of the data in the form of class labels, the results obtained by another clustering algorithm, or simply a grouping considered to be \"correct\". in order to carry out this analysis, a contingency matrix must be built to evaluate the clusters detected by the algorithm that encompasses the following data: \\(tp\\): the number of data pairs found in the same cluster, both in \\(c\\) and in \\(p\\). \\(fp\\): the number of data pairs found in the same cluster in \\(c\\) but in different clusters in \\(p\\). \\(fn\\): the number of data pairs found in different clusters in \\(c\\) but in the same cluster in \\(p\\). \\(tn\\): the number of data pairs found in different clusters, both in \\(c\\) and in \\(p\\). matching sets several measures can be defined to measure the similarity between the clusters in \\(c\\), obtained by the clustering algorithm, and the clusters if \\(p\\), corresponding to our prior (external) knowledge: precision: \\(pr = \\frac{tp}{tp + fp}\\) recall: \\(r = \\frac{tp}{tp + fn}\\) f-measure: \\(f_{\\alpha} = \\frac{1 + \\alpha}{\\frac{1}{pr} + \\frac{\\alpha}{r}}\\) quite often, precision and recall are evenly combined with an unweighted harmonic mean (\\(\\alpha = 1\\)): \\begin{align} f = \\frac{2 \\cdot pr \\cdot r}{pr + r} \\end{align} purity: evaluates whether each cluster contains only examples from the same class: \\begin{align} u = \\sum_{i} p_i (\\max_j \\frac{p_{ij}}{p_i}) \\end{align} where \\(p_i = \\frac{n_i}{n}\\), \\(p_j = \\frac{n_j}{n}\\) and \\(p_{ij} = \\frac{n_{ij}}{n}\\). where \\(n_{ij}\\) are the number of examples belonging to the class \\(i\\) found in the cluster \\(j\\) and \\(n_i\\) is the number of examples in the cluster \\(i\\). peer-to-peer correlation a second family of measures for external validation are based on the correlation between pairs, i.e. they seek to measure the similarity between two partitions under equal conditions, such as the result of a grouping process for the same set, but by means of two different methods \\(c\\) and \\(p\\). the jaccard coefficient: \\(j = \\frac{tp}{tp + fp + fn}\\) the rand coefficient: \\(rand = \\frac{tp + tn}{m}\\) the folkes and mallows coefficient: \\(fm = \\sqrt{\\frac{tp}{tp + fp} \\cdot \\frac{tp}{tp + fn}}\\) the hubert statistical coefficient: \\(\\gamma = \\frac{1}{m} \\sum_{i=1}^{n - 1} \\sum_{j = i + 1}^{n} x_{ij} y_{ij}\\) where \\(n_{ij}\\) are the number of examples belonging to the class \\(i\\) found in the cluster \\(j\\) and \\(n_i\\) is the number of examples in the cluster \\(i\\). measures based on information theory this family includes basic measures such as entropy and mutual information, as well as their respective normalized variants. entropy: \\(h = - \\sum_{i} p_i \\left(\\sum_{j} \\frac{p_{ij}}{p_i} \\log \\frac{p_{ij}}{p_i}\\right)\\) mutual information: \\(mi = \\sum_{i} \\sum_{j} p_{ij} \\log \\frac{p_{ij}}{p_i p_j}\\) where \\(p_{ij} = \\frac{n_{ij}}{n}\\) and \\(p_i = \\frac{n_i}{n}\\). hyperparameter tuning even though external validation metrics can help us evaluate whether the obtained clusters closely match the underlying categories in the training data, which the clustering algorithm tries to identify without externally-provided class labels, those metrics cannot address other issues such as the right number of clusters for our current data set. hyperparameter tuning tries to determine, for the different possible values of the parameters in \\(p_{alg}\\) , which set of parameter values is the most suitable for our particular clustering problem. we could proceed in the following way: when the algorithm does not include the number of clusters \\(n_c\\) among its parameters, we run the algorithm with different values for its parameters so that we can determine their largest range for which \\(n_c\\) remains constant. later, we choose as parameter values the values in the middle of this range. when the algorithm parameters palg include the desired number of clusters \\(n_c\\), we run the algorithm for a range of values for \\(n_c\\). for each value of \\(n_c\\), we run the algorithm multiple times using different sets of values (i.e. starting from different initial conditions) and choose the value that optimizes our desired validation metric. when we just want to determine the “right” number of clusters, \\(n_c\\), plotting the validation results for different values of \\(n_c\\) can sometimes show a relevant change in the validation metric, commonly referred to as a \"knee\" or \"elbow\". hyperparameter tuning can then be seen as a combinatorial optimization problem using different strategies: grid search: is based on a systematic exploration of the hyperparameter space. random search: chooses parameter configurations at random. smart search techniques try to optimize the problem of searching for hyperparameter values. different strategies can be implemented, such as bayesian optimization using gaussian processes and evolutionary optimization using genetic algorithms or evolution strategies. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/AAII/T4/02_cluster_analysis.html",
    "title": "Cluster Analysis",
    "body": " index search search back cluster analysis cluster analysis, also called data segmentation, has a variety of goals. all relate to grouping or segmenting a collection of objects into subsets or \"clusters\", such that those within each cluster are more closely related to one another than objects assigned to different clusters. the method we use to group these objects depends on what we consider to be similar, and that decision usually comes from what we know about the subject we're studying. an object can be described by a set of measurements, or by its relation to other objects. proximity matrices sometimes the data is represented directly in terms of the proximity (alikeness or affinity) between pairs of objects. this type of data can be represented by an \\(n \\times n\\) matrix \\(d\\), where \\(n\\) is the number of objects, and each element \\(d_{ij}\\) records the proximity between the \\(j\\)th and \\(j\\)th objects. this matrix is then provided as input to the clustering algorithm. most algorithms assume symmetric dissimilarity matrices, so if the original matrix \\(d\\) is not symmetric it must be replaced by \\(\\frac{(d + d^t)}{2}\\). dissimilarities based on attributes since most of the popular clustering algorithms take a dissimilarity matrix as their input, we must first construct pairwise dissimilarities between the observations. by far the most common choice is squared distance: \\begin{align} d_j(x_{ij}, x_{i'j}) = (x_{ij} - x_{i'j})^2 \\end{align} where \\(j\\) denotes the attribute and \\(i, i'\\) denotes the instance. we first discuss alternatives in terms of the attribute type: quantitative variables measurements of this type of variable or attribute are represented by continuous real-valued numbers. one way to do this is by looking at the absolute difference between them: \\begin{align} d(x_i, x_{i'}) = l(|x_i - x_{i'}|) \\end{align} alternatively, clustering can be based on the correlation \\begin{align} \\rho (x_i, x_{i'}) = \\frac{\\sum_{j} (x_{ij} - \\overline{x}_i)(x_{ij} - \\overline{x}_i)}{\\sqrt{\\sum_{j} (x_{ij} - \\overline{x}_i)^2 \\sum_j(x_{ij} - \\overline{x}_i)^2}} \\end{align} ordinal variables error measures for ordinal variables are generally defined by replacing their \\(m\\) original values with: \\begin{align} \\frac{i - \\frac{1}{2}}{m}, i = 1, \\cdots, m \\end{align} in the prescribed order of their original values. they are then treated as quantitative variables on this scale. categorical variables if the variable assumes \\(m\\) distinct values, these can be arranged in a symmetric \\(m \\times m\\) matrix with elements: \\begin{align} m_{ij} = \\begin{cases} 0 & x_{i} = x_{j} \\\\ 1 & x_{i} \\neq x_{j} \\\\ \\end{cases} \\end{align} object dissimilarity next we define a procedure for combining the \\(p\\)-individual attribute dissimilarities \\(d_j(x_{ij},x_{i'j}), j = 1,2, \\cdots, p\\) into a single overall measure of dissimilarity \\(d(x_i, x_i')\\). this is nearly always done by means of a weighted average: \\begin{align} d(x_i, x_{i'}) = \\sum_{j=1}^p w_j d_j(x_{ij}, x_{i'j}) \\end{align} where: \\begin{align} \\sum_{j=1}^p w_j = 1 \\end{align} here \\(w_j\\) is a weight assigned to the \\(j\\)th attribute regulating the relative influence of that variable in determining the overall dissimilarity between objects. if the goal is to discover natural groupings in the data, some attributes may exhibit more of a grouping tendency than others. variables that are more relevant in separating the groups should be assigned a higher influence in defining object dissimilarity. giving all attributes equal influence in this case will tend to obscure the groups to the point where a clustering algorithm cannot uncover them. specifying an appropriate dissimilarity measure is far more important in obtaining success with clustering than choice of clustering algorithm. clustering algorithms clustering algorithms fall into three distinct types: combinatorial algorithms: work directly on the observed data with no direct reference to an underlying probability model. mixture modeling: supposes that the data is an i.i.d sample from some population described by a probability density function. mode seeking: take a nonparametric perspective, attempting to directly estimate distinct modes of the probability density function combinatorial algorithms each observation is uniquely labeled by an integer \\(i \\in {1, \\cdots, n}\\). one seeks the particular encoder \\(c^*(i)\\) that assigns the \\(i\\)th observation to the \\(k\\)th cluster that satisfies the required goal based on the dissimilarities \\(d(x_i, x_{i'})\\). the \"parameters\" of the procedure are the individual cluster assignments for each of the \\(n\\) observations. these are adjusted so as to minimize a \"loss\" function. since the goal is to assign close points to the same cluster, a natural loss function would be: \\begin{align} w(c) = \\frac{1}{2} \\sum_{k=1}^k \\sum_{c(i) = k}\\sum_{c(i') = k} d(x_i, d_{i'}) \\end{align} this measure tells us how close together the things in the same group are. it is sometimes referred to as the \"within cluster\" point scatter. the total point scatter is given by: \\begin{align} t = \\frac{1}{2} \\sum_{i=1}^n\\sum_{i'=1}^n d_{ii'} = \\frac{1}{2}\\sum_{k=1}^k\\sum_{c(i) = k} \\left(\\sum_{c(i') = k} d_{ii'} + \\sum_{c(i') \\neq k} d_{ii'}\\right) \\end{align} this basically divides, for each \\(i\\)th instance on cluster \\(k\\), so \\(c(i) = k\\), the distances into two categories, distances to instances on the same cluster \\(\\sum_{c(i') = k} d_{ii'}\\), and distances to instances on a different cluster \\(\\sum_{c(i') \\neq k} d_{ii'}\\). that is: \\begin{align} t = w(c) + b(c) \\end{align} where \\(b(c)\\) is the between-cluster point scatter: \\begin{align} b(c) = \\frac{1}{2} \\sum_{k=1}^k \\sum_{c(i) = k} \\sum_{c(i')\\neq k} d_{ii'} \\end{align} so, minimizing \\(w(c)\\) is equivalent to maximizing \\(b(c)\\) given \\(w(c) = t - b(c)\\). cluster analysis by combinatorial optimization is straightforward in principle. one simply minimizes \\(w\\) or equivalently maximizes \\(b\\) over all possible assignments of the \\(n\\) data points to \\(k\\) clusters. unfortunately, such optimization by complete enumeration is feasible only for very small data sets. for this reason, practical clustering algorithms are able to examine only a very small fraction of all possible encoders \\(k = c(i)\\). the goal is to identify a small subset that is likely to contain the optimal one, or at least a good suboptimal partition. such feasible strategies are based on iterative greedy descent. an initial partition is specified. at each iterative step, the cluster assignments are changed in such a way that the value of the criterion is improved from its previous value. clustering algorithms of this type differ in their prescriptions for modifying the cluster assignments at each iteration. when the prescription is unable to provide an improvement, the algorithm terminates with the current assignments as its solution. however, these algorithms converge to local optima which may be highly suboptimal when compared to the global optimum. k-means the k-means algorithm is one of the most popular iterative descent clustering methods, which uses the squared euclidean distance. so the within point-scatter can be written as: \\begin{align} w(c) = \\frac{1}{2} \\sum_{k=1}^k\\sum_{c(i) = k}\\sum_{c(i')=k} ||x_i - x_{i'}||^2 \\end{align} \\begin{align} = \\sum_{k=1}^k n_k \\sum_{c(i) = k} ||x_i - \\overline{x}_k||^2 \\end{align} where \\(\\overline{x}_k\\) is the mean vector associated with the \\(k\\)th cluster and \\(n_k = \\sum_{i=1}^n i(c(i) = k)\\) is the number of instances on the \\(k\\)th cluster. therefore the goal is to group the \\(n\\) observations into \\(k\\) clusters in a way that minimizes the average difference between each observation and the mean of its cluster. \\begin{align} c^* \\min_{c} \\sum_{k=1}^k n_k \\sum_{c(i) = k} ||x_i - \\overline{x}_k||^2 \\end{align} can be obtained by noting that for any set of observations \\(s\\): \\begin{align} \\overline{x}_s = \\arg \\min_{m} \\sum_{i \\in s} ||x_i - m||^2 \\end{align} that is we defined the centroid for \\(s\\) as the point \\(m\\) that minimizes the sum of distances for each instance on \\(s\\). hence we can obtain \\(c^*\\) by solving the enlarged optimization problem: \\begin{align} \\min_{\\{c, m_k\\}^k_1} \\sum_{k=1}^k n_k \\sum_{c(i) = k} ||x_i - m_k||^2 \\end{align} where for each cluster \\(k\\), we search for the encoder \\(c\\) and the optimal centroid \\(m_k\\). thus the optmimization process can be performed in two steps as seen in algorithm 14.1. on (1) we obtain the optimal centroids \\(m_i, i = 1, \\cdots, k\\), and on (2) we try to find the best encoder \\(c\\) given the set of centroids \\(\\{m_1, \\cdots, m_k\\}\\). gaussian mixtures as soft k-means clustering the k-means clustering procedure is closely related to the em algorithm for estimating a certain gaussian mixture model. the e-step of the em algorithm assigns \"responsibilities\" for each data point based in its relative density under each mixture component (cluster). while the m-step recomputes the component density parameters based on the current responsibilities. where the relative density is a monotone function of the euclidean distance between the data point and the mixture center. hence in this setup em is a \"soft\" version of k-means clustering, making probabilistic (rather than deterministic) assignments of points to cluster centers. as \\(\\sigma^2\\) tends to \\(1\\), these probabilities become \\(0\\) and \\(1\\), and the two methods coincide: vector quantization vector quantization (vq) is a technique used in data compression, particularly in the compression of digital signals or images. it involves representing a large set of data points (vectors) by a smaller set of representative values, called codewords or centroids. these centroids are selected from the original data set and are used to approximate the original data. by replacing groups of similar data points with these representative values, vector quantization can significantly reduce the amount of data needed to represent the information while minimizing the loss of quality. in this example of vector quantization, given an image of \\(1024\\times 1024\\) pixels we start by dividing the image into small blocks of \\(2\\times 2\\). each block, which contains four pixels, is treated like a tiny picture of its own. each of the \\(512 \\times 512\\) blocks of four numbers is regarded as vector in \\(\\mathbb{r}^4\\). then, using k-means clustering, we group these blocks together based on their similarity. the clustering process is called the encoding step, and the collection of centroids is called the codebook. why do we expect vq to work at all? the reason is that for typical everyday images like photographs, many of the blocks look the same. what we have described is known as lossy compression, since our images are degraded versions of the original. k-medoids the k-means algorithm can be generalized for use with arbitrarily defined dissimilarities \\(d(x_i, x_{i'})\\). the process of finding the centers of the clusters stays similar, but the way we measure similarity can change. this makes the algorithm versatile and applicable to various types of data. this gives way to the k-medoids algorithm: practical issues in order to apply k-means or k-medoids one must select the number of clusters \\(k^*\\) and an initialization. the latter can be defined by specifying an initial set of centers \\(\\{m_1,\\cdots,m_k\\}\\) or \\(\\{i_1, \\cdots,i_k\\}\\) or an initial encoder \\(c(i)\\). a choice for the number of clusters \\(k\\) depends on the goal. for data segmentation \\(k\\) is usually defined as part of the problem. data-based methods for estimating \\(k^*\\) typically examine the withincluster dissimilarity \\(w_k\\) as a function of the number of clusters \\(k\\). the corresponding values generally decrease with increasing \\(k\\). thus cross-validation techniques, so useful for model selection in supervised learning, cannot be utilized in this context. as we increase the number of clusters, the solution quality will improve because more natural groups will be captured separately. so, if we keep adding more clusters beyond the true number (\\(k > k^*\\)), some estimated clusters will start to split the real groups. however, splitting a group that's already close together won't improve the solution as much as properly separating two distinct groups. to the extent this scenario is realized, there will be a sharp decrease in successive differences in criterion value, \\(w_k − w_{k+1}\\), at \\(k = k^*\\). that is, \\(\\{w_k − w_{k+1} |k < k^*\\} \\geq \\{w_k − w_{k+1} |k \\geq k^*\\}\\). an estimate \\(\\hat{k}*\\) for \\(k^*\\) is then obtained by identifying a “kink” in the plot of \\(w_k\\) as a function of \\(k\\). the recently proposed gap statistic compares the shape of a curve based on our data to a curve we'd get if the data were spread out evenly. we're looking for a point where there's a big gap between these two curves. this point tells us the best number of clusters for our data. if \\(g(k)\\) is the gap curve at \\(k\\) clusters, the formal rule for estimating \\(k^*\\) is: \\begin{align} k^* = \\text{argmin}_{k} \\{k | g(k) \\geq g(k + 1 - s'_{k + 1}) \\} \\end{align} where \\(s_k\\) is the standard deviation. the following figure shows and example on how to choose the optimal number of clusters: hierarchical clustering as the name suggests, they produce hierarchical representations in which the clusters at each level of the hierarchy are created by merging clusters at the next lower level. at the lowest level, each cluster contains a single observation. at the highest level there is only one cluster containing all of the data. strategies for hierarchical clustering divide into two basic paradigms: agglomerative (bottom-up) and divisive (top-down). each level of the hierarchy represents a particular grouping of the data into disjoint clusters of observations. the entire hierarchy represents an ordered sequence of such groupings. it is up to the user to decide which level (if any) actually represents a \"natural\" clustering a dendrogram provides a highly interpretable complete description of the hierarchical clustering in a graphical format. cutting the dendrogram horizontally at a particular height partitions the data into disjoint clusters represented by the vertical lines that intersect it. the height at which we cut represents the level of similarity required to form a cluster. generally, groups that merge at higher levels in the dendrogram are considered more significant clusters. however, it's essential to be cautious when interpreting dendrograms because different clustering methods or slight changes in the data can lead to different dendrogram structures. also, dendrogram interpretations are only valid if the data truly exhibits the hierarchical structure imposed by the clustering algorithm. this can be assesed using the cophenetic correlation coefficient, it measures the correlation between the cophenetic dissimilarities \\(c_{ii'}\\) and the distances between observations in the original data \\(d_{ii'}\\). the cophenetic dissimilarity \\(c_{ii'}\\) between two observations \\((i, i')\\) is the intergroup dissimilarity at which observations \\(i\\) and \\(i'\\) are first joined together in the same cluster. agglomerative clustering agglomerative clustering starts with each observation as its own cluster. then, at each step, it merges the two closest clusters together until there's only one big cluster left. to measure dissimilarity between two clusters, let's call them \\(g\\) and \\(h\\). we look at all the pairs of observations, one from \\(g\\) and one from \\(h\\), and find the dissimilarity between them. single linkage (sl) or nearest neighbour agglomerative clustering chooses the closest pair of observations between the two clusters as the measure of dissimilarity between the clusters: \\begin{align} d_{sl}(g, h) = \\min_{i \\in g, i' \\in h} d_{ii'} \\end{align} complete linkage (cl) or furthest-neighbor technique agglomerative clustering measures the dissimilarity between two clusters as the distance the pair of observations that are the farthest apart. \\begin{align} d_{cl}(g, h) = \\max_{i \\in g, i' \\in h} d_{ii'} \\end{align} group average (ga) clustering uses the average dissimilarity between the groups: \\begin{align} d_{ga}(g, h) = \\frac{1}{n_g n_h} \\sum_{i \\in g} \\sum_{i \\in h} d_{ii'} \\end{align} where \\(n_g\\) and \\(n_h\\) are the respective number of observations in each group. if the data shows clear clusters that are close together and distinct from each other, all three methods—single linkage, complete linkage, and average linkage—will give similar results. however, if the data doesn't exhibit this pattern, the results of the three methods will differ. single linkage tends to join clusters even if just one pair of observations is close together, which can lead to long chains of connections between clusters. this phenomenon is known as chaining. complete linkage will tend to produce compact clusters with small diameters because it considers two groups close only if all the observations in their combined set are similar. sometimes it may violate the rule that observations within a cluster should be closer to each other than to observations in other clusters. group average clustering strikes a balance between single and complete linkage. it tries to make clusters compact while keeping them relatively far apart. however, its outcome can be affected by how the dissimilarities between observations are measured. changing the measurement scale can change the clustering result. in contrast, single and complete linkage methods are not affected by such changes in scale. divisive clustering divisive clustering starts with the entire dataset as one cluster and then splits it into smaller clusters step by step. this method isn't as widely studied as agglomerative clustering, but it has been explored, especially in engineering contexts like compression. one potential advantage of divisive clustering is when you want to divide the data into only a few clusters. divisive methods can be used recursively with techniques like k-means or k-medoids to split clusters into smaller ones. however the way you begin the splitting process at each step can influence the final outcome. a method has been developed to overcome this limitations. the divisive algorithm, proposed by macnaughton smith et al. (1965), is defined as: puts all observations in one big cluster called \\(g\\). it picks the observation that's farthest on average from all the others and makes it the first member of a new cluster called \\(h\\). at each successive step that observation in \\(g\\) whose average distance from those in \\(h\\), minus that for the remaining observations in \\(g\\) is largest, is transferred to \\(h\\). this continues until there are no more observations in \\(g\\) that are closer to those in \\(h\\). this splitting procedure is repeated for each new cluster formed at the previous level, creating a hierarchical structure. kaufman and rousseeuw (1990) suggest choosing the cluster with the largest diameter for splitting at each level, but another option is to pick the one with the largest average dissimilarity among its members. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/AAII/index.html",
    "title": "Aprendizaje Automático II",
    "body": " index search search back aprendizaje automático ii tema 1. random forests bias/variance tradeoff bootstrapping bagging random forests tema 2. intensificación (boosting) boosting ada boost boosting trees gradient boosting interpretability examples practice tema 3. otras combinaciones de modelos introducción marco general para la combinación de clasificadores estrategias para la combinación de clasificadores conclusión tema 4. aprendizaje no supervisado introducción cluster analysis evaluation metrics $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/AAII/T1/01_bias_variance_tradeoff.html",
    "title": "Bias/Variance Tradeoff",
    "body": " index search search back bias/variance tradeoff test error, also referred to as generalization error, is the prediction error over an independent test sample: \\begin{align} err_{\\mathcal{t}} = \\mathbb{e}[l(y | \\hat{f}(x)) | \\mathcal{t}] \\end{align} where \\(l\\) is the loss function. a related quantity is the expected prediction error (or expected test error): \\begin{align} err = \\mathbb{e}[err_{\\mathcal{t}}] \\end{align} where \\(err_{\\mathcal{t}}\\) is the test error. the error can always be decomposed into the sum of three fundamental quantities: the variance of \\(\\hat{f}(x_0)\\) the squared bias of \\(\\hat{f}(x_0)\\) the variance of the error terms \\(\\epsilon\\). that is, \\begin{align} \\mathbb{e}[\\left(y_0 - \\hat{f}(x_0)\\right)^2] = \\mathbb{v}[\\hat{f}(x_0)] + [bias(\\hat{f}(x_0))]^2 + \\mathbb{v}[\\epsilon] \\end{align} this amount is derived from: \\begin{align} err(x_0) = \\mathbb{e}[(y - \\hat{f}(x_0))^2] = \\mathbb{e}[y^2 + \\hat{f}(x_0)^2 - 2y\\hat{f}(x_0)] \\end{align} \\begin{align} = \\mathbb{e}[y^2] + \\mathbb{e}[\\hat{f}(x_0)^2] -2\\mathbb{e}[y]\\mathbb{e}[\\hat{f}(x_0)] \\end{align} we know that \\(\\mathbb{v}[x] = \\mathbb{e}[(x - \\mathbb{e}[x])^2] = \\mathbb{e}[x^2] - \\mathbb{e}[x]^2\\), such that: \\begin{align} = \\mathbb{v}[y] + \\mathbb{e}[y]^2 + \\mathbb{v}[\\hat{f}(x_0)] + \\mathbb{e}[\\hat{f}(x_0)]^2 -2\\mathbb{e}[y]\\mathbb{e}[\\hat{f}(x_0)] \\end{align} \\begin{align} = \\mathbb{e}[(y - \\mathbb{e}[y])^2] + \\mathbb{e}[y]^2 + \\mathbb{e}[(\\hat{f}(x_0) - \\mathbb{e}[\\hat{f}(x_0)])^2] + \\mathbb{e}[\\hat{f}(x_0)]^2 -2\\mathbb{e}[y]\\mathbb{e}[\\hat{f}(x_0)] \\end{align} note that, \\(y = f(x_0) + \\epsilon[/\\)], donde [\\(]\\mathbb{e}[\\epsilon] = 0\\), thus it follows: \\begin{align} = \\mathbb{e}[(y - \\mathbb{e}[y])^2] + (\\mathbb{e}[f(x_0)] + \\mathbb{e}[\\epsilon])^2 + \\mathbb{e}[(\\hat{f}(x_0) - \\mathbb{e}[\\hat{f}(x_0)])^2] + \\mathbb{e}[\\hat{f}(x_0)]^2 -2(\\mathbb{e}[f(x_0)] + \\mathbb{e}[\\epsilon])\\mathbb{e}[\\hat{f}(x_0)] \\end{align} \\begin{align} = \\mathbb{e}[(y - \\mathbb{e}[y])^2] + \\mathbb{e}[f(x_0)]^2 + \\mathbb{e}[(\\hat{f}(x_0) - \\mathbb{e}[\\hat{f}(x_0)])^2] + \\mathbb{e}[\\hat{f}(x_0)]^2 -2\\mathbb{e}[f(x_0)]\\mathbb{e}[\\hat{f}(x_0)] \\end{align} we know that \\((a + b)^2 = a^2 + b^2 + 2ab\\) and that \\(\\mathbb{e}[f(x_0)] = f(x_0)\\), such that: \\begin{align} = \\mathbb{e}[(y - \\mathbb{e}[y])^2] + \\mathbb{e}[(\\hat{f}(x_0) - \\mathbb{e}[\\hat{f}(x_0)])^2] + f(x_0)^2 + \\mathbb{e}[\\hat{f}(x_0)]^2 -2f(x_0)\\mathbb{e}[\\hat{f}(x_0)] \\end{align} \\begin{align} = \\mathbb{e}[(y - \\mathbb{e}[y])^2] + \\mathbb{e}[(\\hat{f}(x_0) - \\mathbb{e}[\\hat{f}(x_0)])^2] + \\left(\\mathbb{e}[\\hat{f}(x_0)] - f(x_0)\\right)^2 \\end{align} here the notation \\(\\mathbb{e}[\\left(y_0 - \\hat{f}(x_0)\\right)^2]\\) defines the expected test mse, and refers expected to the average test mse that we would obtain if we repeatedly \\(f\\) using a large number of training sets, and tested each at \\(x_0\\). the overall expected test mse can be computed by averaging \\(\\mathbb{e}[\\left(y_0 - \\hat{f}(x_0)\\right)^2]\\) over all possible values of \\(x_0\\) in the test set. the previous equation tells us that in order to minimize the expected test error, we need to select a statistical learning method that simultaneously achieves low variance and low bias. note that variance is inherently a nonnegative quantity, and squared bias is also nonnegative. hence, we see that the expected test mse can never lie below \\(\\mathbb{v}[\\epsilon]\\), the irreducible error. the variance of the error terms, \\(\\mathbb{v}[\\epsilon]\\), is the variance of the target around its true mean \\(f(x_0)\\), and cannot be avoided no matter how well we estimate \\(f(x_0)\\), unless \\(\\sigma^2 = 0\\). variance refers to the amount by which \\(\\hat{f}\\) would change if we estimated it using a different training data set. ideally the estimate for \\(f\\) should not vary too much between training sets. this is computed as the expected squared deviation of \\(\\hat{f}(x_0)\\) around its mean. bias refers to the error that is introduced by approximating a real-life problem by a simpler model. this quentifies the amount by which the average of our estimate differs from the true mean. as a general rule, as we use more flexible methods, the variance will increase and the bias will decrease. as we increase the flexibility, the bias tends to initially decrease faster than the variance increases. consequently, the expected test mse declines. at some point increasing flexibility has little impact on the bias but starts to significantly increase the variance. in a real-life situation in which \\(f\\) is unobserved, it is generally not possible to explicitly compute the test mse, bias, or variance for a statistical learning method. training error consistently decreases with model complexity, typically dropping to zero if we increase the model complexity enough. a model with zero training error is overfit to the training dat and will typically generalize poorly. it is important to note that there are in fact two separate goals: model selection: estimating the performance of different models in order to choose the best model. model assessment: having chosen a final model, estimating its prediction error (generalization error) on new data. the training set is used to fit the models. the validation set is used to estimate prediction error for model selection. the test set is used for assessment of the generalization error $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/AAII/T1/04_random_forests.html",
    "title": "Random Forests",
    "body": " index search search back random forests definition the idea in random forests (ilustrated on the image below) is to improve the variance reduction of bagging by reducing the correlation between the trees, without increasing the variance too much. this is achieved in the tree-growing process through random selection of the input variables. an average of \\(b\\) i.i.d. random variables, each with variance \\(\\sigma^2\\), has variance \\(\\frac{1}{b}\\sigma^2\\). if the variables are simply i.d. (identically distributed, but not necessarily independent) with positive pairwise correlation ρ, the variance of the average is: \\begin{align} \\rho\\sigma^2 + \\frac{1 - \\rho}{b}\\sigma^2 \\end{align} as \\(b\\) increases, the second term disappears, but the first remains, and hence the size of the correlation of pairs of bagged trees limits the benefits of averaging. when growing a tree on a bootstrapped dataset before each split, select \\(m \\leq p\\) of the input variables at random as candidates for splitting. after \\(b\\) such trees \\(\\{t(x; \\theta_b)\\}_1^b\\) are grown, the random forest (regression) predictor is: \\begin{align} \\hat{f}_{rf}^b(x) = \\frac{1}{b}\\sum_{b=1}^b t(x; \\theta_b) \\end{align} where \\(\\theta_b\\) characterizes the bth random forest tree in terms of split variables, cutpoints at each node, and terminal-node values. intuitively, reducing \\(m\\) will reduce the correlation between any pair of trees in the ensemble. details of random forests for classification, the default value for \\(m\\) is \\(\\lfloor \\sqrt{p} \\rfloor\\) and the minimum node size is one. for regression, the default value for \\(m\\) is \\(\\lfloor \\frac{p}{3} \\rfloor\\) and the minimum node size is five. in practice the best values for these parameters will depend on the problem, and they should be treated as tuning parameters (hyperparamters). variable importance at each split in each tree, the improvement in the split-criterion is the importance measure attributed to the splitting variable, and is accumulated over all the trees in the forest separately for each variable. random forests also use the oob samples to construct a different variable importance measure. when the bth tree is grown, the oob samples are passed down the tree, and the prediction accuracy is recorded. then the values for the jth variable are randomly permuted in the oob samples, and the accuracy is again computed. the decrease in accuracy as a result of this permuting is averaged over all trees, and is used as a measure of the importance of variable \\(j\\) in the random forest. proximity plots in growing a random forest, an \\(n \\times n\\) proximity matrix is accumulated for the training data. such that the entry \\(ij\\) contains the number of trees for which the oob sample \\(x_i\\) and the oob sample \\(x_j\\) are on the same terminal node. this proximity matrix is then represented in two dimensions using multidimensional scaling like the following example: the proximity plot gives an indication of which observations are effectively close together in the eyes of the random forest classifier. random forests and overfitting when the number of variables \\(p\\) is large, but the fraction of relevant variables small, random forests are likely to perform poorly with small \\(m\\). at each split the chance can be small that the relevant variables will be selected. another claim is that random forests “cannot overfit” the data. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/AAII/T1/03_bagging.html",
    "title": "Bagging",
    "body": " index search search back bagging introduction the decision trees discussed suffer from high variance. in contrast, a procedure with low variance will yield similar results if applied repeatedly to distinct data sets. bootstrap aggregation, or bagging, is a procedure for reducing the variance of a statistical learning method. recall that given a set of \\(n\\) independent observations \\(z_1, \\cdots, z_n\\) each with variance \\(\\sigma^2\\), the variance of the mean \\(\\overline{z}\\) of the observations is given by \\(\\frac{\\sigma^2}{n}\\). so, averaging a set of observations reduces variance. thus, to reduce the variance and increase the prediction accuracy of a statistical learning method is to take many training sets from the population, build a separate prediction model using each training set, and average the resulting predictions. using \\(b\\) separate training sets, and average them in order to obtain a single low-variance statistical learning model, given by: \\begin{align} \\hat{f}_{avg}(x) = \\frac{1}{b}\\sum_{b=1}^b \\hat{f}^b(x) \\end{align} for each bootstrap sample \\(z^{*b}, b = 1, 2, \\cdots, b\\), we fit our model, giving prediction \\(\\hat{f}^{*b}(x)\\). the bagging estimate is defined by: \\begin{align} \\hat{f}_{bag}(x) = \\frac{1}{b}\\sum_{b=1}^b \\hat{f}^{*b}(x) \\end{align} bagging on regression trees to apply bagging to regression trees, we simply construct \\(b\\) regression trees using \\(b\\) bootstrapped training sets, and average the resulting predictions. these trees are grown deep, and are not pruned. hence each individual tree has high variance, but low bias. averaging these b trees reduces the variance. bagging on decision trees how can bagging be extended to a classification problem where y is qualitative? for a given test observation, we can record the class predicted by each of the \\(b\\) trees, and take a majority vote. suppose our tree produces a classifier \\(\\hat{g}(x)\\) for a \\(k\\)-class response. then the bagged estimate \\(\\hat{f}_{bag}(x)\\) is a \\(k\\)-vector \\([p_1(x), p_2(x), \\cdots, p_k(x)]\\), with \\(p_k(x)\\) equal to the proportion of trees predicting class \\(k\\) at \\(x\\). the bagged classifier selects the class with the most votes from the \\(b\\) trees, \\(\\hat{g}_{bag}(x) = \\arg \\max_k \\hat{f}_{bag}(x)\\). often we require the class-probability estimates at \\(x\\). for many classifiers \\(\\hat{g}(x)\\) there is already an underlying function \\(\\hat{f}(x)\\) that estimates the class probabilities at \\(x\\) (for trees, the class proportions in the terminal node). an alternative bagging strategy is to average these instead. the number of trees \\(b\\) is not a critical parameter with bagging; using a very large value of \\(b\\) will not lead to overfitting. in practice we use a value of \\(b\\) sufficiently large that the error has settled down. note that bagging a good classifier can make it better, but bagging a bad classifier can make it worse. out-of-bag error estimation there is a very straightforward way to estimate the test error of a bagged model one can show that on average, each bagged tree makes use of around two-thirds of the observations. the observations not used to fit a given bagged tree are referred to as the out-of-bag (oob) observations. an oob prediction can be obtained for each of the \\(n\\) observations on the oob observation set, from which the overall oob mse (for a regression problem) or classification error (for a classification problem) can be computed. the resulting oob error is a valid estimate of the test error for the bagged model. variable importance measures although the collection of bagged trees is much more difficult to interpret than a single tree, one can obtain an overall summary of the importance of each predictor using the rss (for bagging regression trees) or the gini index (for bagging classification trees) in the case of bagging regression trees, we can record the total amount that the rss is decreased due to splits over a given predictor, averaged over all \\(b\\) trees. for classification trees, we can add up the total amount that the gini index is decreased by splits over a given predictor, averaged over all \\(b\\) trees. advantages of ensemble models performance: it improves single models' perfomance. robustness: reduces predictions' variance. so it also improves the equilibrium between bias and variance. how to generate diversity manipulating instances: selecting a different subset of instances for each model. manipulating features: selecting a different subset of features for each model. manipulating models' definition: selecting different hyperparameters, optimization algorithm for ach model. hybridation: mix any of the previous practices. ensemble algorithms bagging models are trained concurrently with different data sets generated using bootstrapping. boosting construye múltiples modelos (típicamente modelos del mismo tipo) secuenciales, cada uno de los cuales aprende a corregir los errores de predicción de un modelo anterior en la cadena. el objetivo es desarrollar un modelo fuerte a partir de muchos modelos débiles especialmente diseñados que se combinan mediante votación simple o promediando. staking construye múltiples modelos sobre el mismo conjunto de datos, típicamente modelos de diferentes tipos (modelos de nivel 0); y un modelo supervisado o meta modelo (modelo de nivel 1) que aprende cómo combinar mejor las predicciones de los modelos primarios. model of experts podemos dividir el espacio de características de entrada en subespacios según algún conocimiento de dominio del problema. luego se puede entrenar un modelo en cada subespacio del problema, convirtiéndose de hecho en un experto en el subproblema específico. luego, un modelo aprende a qué experto recurrir para predecir nuevos ejemplos en el futuro. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/AAII/T1/02_bootstrapping.html",
    "title": "Bootstrapping",
    "body": " index search search back bootstrapping bootstrapping is a resampling technique used in statistics to estimate the sampling distribution of a statistic by sampling with replacement from the original dataset. the method is particularly useful when analytical methods for deriving the sampling distribution are complex or unavailable. here's a breakdown of the bootstrapping process: sampling with replacement: from the original dataset, randomly draw \\(n\\) samples with replacement. this means that each observation has an equal chance of being selected for the sample, and an observation may be selected multiple times. sample statistics: calculate the statistic of interest (e.g., mean, median, standard deviation, regression coefficient) on each bootstrapped sample. repeat: repeat steps \\(2\\) and \\(3\\) a large number of times to generate multiple bootstrap samples and their corresponding statistics. estimate sampling distribution: with the collection of bootstrap statistics, you can estimate the sampling distribution of the statistic of interest. this empirical distribution approximates the true sampling distribution of the statistic, providing information about its variability and uncertainty. inference: use the estimated sampling distribution to make inferences about the population parameter or to construct confidence intervals. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/AAII/T2/04_gradient_boosting.html",
    "title": "Gradient Boosting",
    "body": " index search search back gradient boosting numerical optimization via gradient imagine you have a machine learning model that makes predictions, but it's not perfect. gradient boosting is like a smart way to teach this model to make better predictions over time. instead of trying to fix all the prediction errors at once, gradient boosting focuses on correcting one error at a time. it does this by looking at the direction where the error is the steepest and making adjustments to improve the prediction in that direction. by repeating this process step by step, the model gradually gets better at making predictions, leading to more accurate results. so if you have the following function you want to optimize: \\begin{align} l(f) = \\sum_{i=1}^n l(y_i, f(x_i)) \\end{align} where \\(f \\in \\mathbb{r}^n\\) is the prediction function and its evaluation at each instance \\(x_i\\) are the parameteres we want to optimize: \\begin{align} f = \\{f(x_1), \\cdots, f(x_i), \\cdots, f(x_n)\\} \\end{align} therefore the optimization problem with respect to \\(f\\) can be summarized as follows: \\begin{align} \\hat{f} = \\arg \\min_f l(f) \\end{align} solving this entire problem at once may be challenging. to make it easier, numerical optimization procedures break down this big problem into smaller pieces, represented by component vectors. each component vector addresses a specific aspect of the problem. so: \\begin{align} f_{m} = \\sum_{m = 0}^m h_m, h_m \\in \\mathbb{r}^n \\end{align} where \\(f_m\\) represents the final model or prediction function obtained after m iterations or steps of the boosting algorithm. here \\(f_m\\) represents the model at iteration \\(m\\), whereas \\(h_m\\) represents the increment to the model at iteration \\(m\\) it is the component vector added to the current model to move towards the optimized solution. each \\(h_m\\) is induced based on the current parameter vector \\(f_{m-1}\\) and contributes to the overall model improvement. here is a simple layout of how the algorithm optimizes: at the beginning of the gradient boosting process, the initial model \\(f_0\\) is set to an initial guess. as the algorithm progresses through iterations (\\(m = 1, 2, \\cdots, m\\)), each step involves updating the model based on the gradient information to reduce errors in predictions. numerical optimization methods differ in their prescriptions for computing each increment vector \\(h_m\\). steepest descent steepest descent is a method used in optimization to find the minimum value of a function. this method chooses \\(h_m = \\rho_m g_m\\) where \\(\\rho_m\\) is a scalar and \\(g_m\\) is the gradient of \\(l(f_{m-1})\\), that is, the cost function evaluated at values predicted by the \"previous model\". the components of the gradient \\(g_m\\) are defined as follows: \\begin{align} g_{im} = \\left[\\frac{\\delta l(y_i, f(x_i))}{\\delta f(x_i)}\\right]_{f_m(x_i) = f_{m-1}(x_i)} \\end{align} the step length (kinda like the learning rate): \\begin{align} \\rho_m = \\arg \\min_{\\rho} l(f_{m-1} - \\rho g_m) \\end{align} thus, at each step, the predictor is updated as follows: \\begin{align} f_m = f_{m - 1} - \\rho_m g_m \\in \\mathbb{r}^n \\end{align} this updates \\(f_m\\) towards the direction of maximum descent at \\(l(f_{m-1})\\), which is why this is often interpreted as a greedy algorithm. gradient boosting gradient boosting aims to create a strong predictive model by combining multiple weak models. it starts with a simple model and gradually enhances it to minimize errors. at each iteration, a new tree model is fit to the negative gradient of the loss function. the predictions from these trees guide the model towards better predictions. using squared error to measure closeness, this leads us to: \\begin{align} \\tilde{\\theta}_m = \\arg \\min_{\\theta} \\sum_{i=1}^n (-g_{im} - t(x_i; \\theta))^2 \\end{align} this measures how close each prediction \\(t(x_i; \\theta)\\) is to the gradient \\(-g_{im}\\). the negative gradient of the loss function represents the direction in which the model's predictions need to be adjusted to reduce errors. by fitting a new tree to this negative gradient, the model learns how to correct its predictions to move closer to the actual target values. that is at each iteration, the new tree model focuses on capturing the errors or residuals of the current ensemble model. while the exact regions where the new tree makes corrections may not match perfectly with the original model's regions, they are close enough to serve the same purpose of improving the model's accuracy. here the original model is the ensemble model. the following figure summarizes the gradients for commonly used loss functions: implementations of gradient boosting algorithm \\(10.3\\) presents the generic gradient tree-boosting algorithm for regression. specific algorithms are obtained by inserting different loss criteria \\(l(y,f(x))\\). start with an initial model \\(f_0(x)\\) that minimizes the loss function \\(l(y, f(x))\\). for each boosting round \\(m = 1, \\cdots, m\\): calculate the negative gradient for each data point \\begin{align} r_{im} = -\\left[\\frac{\\delta l(y_i, f(x_i))}{\\delta f(x_i)}\\right]_{f(x_i) = f_{m-1}(x_i)} \\end{align} fit a regression tree to the gradients \\(r_{im}\\), which gives us the regions \\(r_{jm}, j = 1, 2, \\cdots, j_m\\) the step length \\(\\gamma\\) is determined by minimizing the loss using the previous model (\\(f_{m-1}\\)): \\begin{align} \\gamma_{jm} = \\arg \\min_{\\gamma} \\sum_{x_i \\in r_{jm}} l(y_i, f_{m-1}(x_i) + \\gamma) \\end{align} update the model by adding a new tree to the ensemble \\(f_m(x) = f_{m-1}(x) + \\gamma t(x; \\theta_m)\\), where \\(t(x; \\theta)\\) is the new tree model with parameters \\(\\theta_m\\) that corrects the errors in the previous model. the output of the ensemble model is defined as \\(\\hat{f}(x) = f_m(x)\\), that is as the sum of the weaker models. step length the step length \\(\\gamma\\) is crucial in determining how much each new tree should contribute to the ensemble model. it controls the impact of the new tree on the overall model's predictions. the line search aims to find the value of γ that minimizes the loss function: \\begin{align} l(f_{m-1} - \\gamma g_m) \\end{align} this means finding the optimal step length that results in the smallest possible loss when updating the model with the new tree. by minimizing the loss function with respect to \\(\\gamma\\), the algorithm is essentially performing a form of gradient descent. characteristics two basic tuning parameters are the number of iterations \\(m\\) and the sizes of each of the constituent trees \\(j_m, m = 1, 2, \\cdots, m\\). the original implementation of this algorithm was called mart for \"multiple additive regression trees\". $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/AAII/T2/07_practice.html",
    "title": "Practice",
    "body": " index search search back practice boosting just like random forest, gbm is an ensemble method. imagine a data set just \\(10\\) examples and two numeric predictor variables, and we are trying to learn to distinguish between two possible classes: circle or cross. the very simplest decision tree we can make has just one node; i will represent it with a straight line in the following diagrams. it scored \\(60\\%\\): six right, four wrong. what we do now is train another very simple tree, but first we modify the training data to give the four rows it got wrong a higher weight. how much of a higher weight? that is where the \"gradient\" bit of gbm comes in. in the next figure the circles and crosses for the wrong items are bigger, and our next tree pays more attention to them. it got a different three items wrong so it still scores \\(60\\%\\). so, for our third tree, we tell it those four are more important; the one it has got wrong twice in a row is the biggest of all. if we stop training here, we end up with three weak models that scored \\(60\\%\\), \\(60\\%\\), and \\(80\\%\\), respectively. however, at least one of each of those three trees got every training row correct. you can see how they can work together to cover each other's weaknesses. gbm naturally focuses attention on the difficult rows in your training data, the ones that are hard to learn. that is good, but it can also be bad. if there is one outlier that each tree keeps getting wrong it is going to get boosted and boosted until it is bigger than the whole universe. this is bad when the data is a mistake instead of an outlier, as it distorts the model's accuracy. the mysterious? well, unlike (simple) decision trees, which can be really good at explaining their thinking, it becomes a bit of a black box. parameters n_trees: how many trees to make. max_depth: how deep are the trees allowed to be. learn_rate: controls the speed at which the model learns learn_rate_annealing: allows you to have the learn_rate start high, then gradually get lower as trees are added. min_rows: how many examples are needed to make a leaf node. low number might lead to overfitting. min_split_improvement: controls how much error improvement must be to perform a split. histogram_type: what type of histogram to use for finding optimal split points. nbins: for numerical columns, build a histogram of (at least) this many bins, then split at the best point. nbins_cat: for categorical columns, build a histogram of (at most) this many bins, then split at the best point. build_tree_one_node: run on one node only. building energy efficiency: default gbm this data set deals with the heating/cooling costs of various house designs. from h2o.estimators.gbm import h2ogradientboostingestimator m = h2ogradientboostingestimator(model_id=\"gbm_defaults\", nfolds=10) m.train(x, y, train) fifty trees were made, each of depth \\(5\\). on cross-validation data, the mse (mean squared error) is \\(2.462\\), and \\(r^2\\) is \\(0.962\\). under “variable importances” (shown next), which can be seen with h2o.varimp(m) you will see it is giving x5 way more importance than any of the others; this is typical for gbm models. how about on the unseen data? m.model_performance(test) is saying mse is \\(2.318\\), better than on the training data. building energy efficiency: tuned gbm i decided to start, this time, with a big random grid search. the hyperparameters tuned are the following: max_depth: the default is \\(5\\), and we tried \\(5,10,15,20,25,30,40,50,60,75,90\\). the ninth best model was max_depth=75, so high values may not be bad, as such, but they don’t appear to help. min_rows sample_rate col_sample_rate nbins what about ntrees? instead of trying to tune it, we set it high (\\(1000\\)) and used early stopping. more model results just confirmed the first impression: min_rows of \\(1\\) (or \\(2\\)) is effective with max_depth of \\(5\\), but really poor with higher values. min_rows of \\(10\\) is effective with any value of max_depth, but possibly \\(10\\) to \\(20\\) is best. curiously min_rows of \\(5\\) is mediocre. a sample_rate of \\(0.9\\) or \\(0.95\\) looks best, while there is still no clarity for col_sample_rate or nbins. let's see how it does on the test data, we obtain a mse of \\(1.640\\). this is way better than the default gbm’s 2.462, and also way better than the best tuned random forest model from the previous chapter. mnist: default gbm it is a multinomial classification, trying to look at the \\(784\\) pixels of a handwritten digit, and say which of \\(0\\) to \\(9\\) it is. m = h2o.estimators.h2ogradientboostingestimator(model_id=\"gbm_defaults\") m.train(x, y, train, validation_frame=valid) the confusion matrix on the training data (h2o.confusionmatrix(m)) shows an error rate of \\(2.08\\%\\), while on the validation data it is a bit higher at \\(4.82\\%\\). mse is \\(0.028\\) and \\(0.044\\), respectively. so we have a bit of overfitting on the training data, but not too much. on the test data the error this time is \\(4.44\\%\\) (mse is \\(0.048\\)); in other words, the validation and test sets are giving us similar numbers, which is good. mnist: tuned gbm as usual, the first thing i want to do is switch to using early stopping, so i can then give it lots of trees to work with, with the following parameters: stopping_tolerance = 0.001, stopping_rounds = 3, score_tree_interval = 10, ntrees = 400 just using this, with all other default settings, had some interesting properties training classification score was perfect after 140 trees. validation score was down to \\(2.83\\%\\). the mse and logloss of both the training data and validation data continued to fall, and so did the validation classification score. relative runtime kept increasing. that is, each new tree is taking longer. it finished up with 360 trees, with a very respectable \\(2.17\\%\\) error on the validation data. how can we improve that further? we know there is a lot of examples and variables, so we expect that lower sample ratios will be more effective. in terms of the learn_rate we know low is slower, but better… and we have a lot of data. so we use a high (quick) learn_rate for the first grid or two, then lower it later on, once we start to home in on the best parameters. this is going to be a random grid search, because we are going to use a lot of parameters. the first discovery was that a high max_depth was very slow and no better than a shallow one. also min_rows=1 seemed poor. we also found that max_depth=20 was distinctly worse than max_depth=5. we also noticed that min_rows=10 seemed to be doing best, though it was less clear. reducing the three sample rates to \\(1\\) did seem to help, though there was not enough data to draw a confident conclusion. so, another try. we'll leave max_depth and min_rows at their defaults, and just concentrate on testing sampling rates. there was not that much clarity in the parameters, but the best two had col_sample_rate of \\(0.8\\) and sample_rate of \\(0.95\\), whereas sample_rate=0.5 was only chosen once, but was the worst of the nine. the default model with just early stopping added, would have come second best in the grid measured on classification error, but fourth on mse, and seventh on logloss, whereas the “tuned” model is top on all metrics, so we have more confidence in selecting it. as a final step, we ran the chosen model on the test data and got an error rate of \\(2.33\\%\\). this compares to \\(4.44\\%\\) with the default settings. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/AAII/T2/06_examples.html",
    "title": "Examples",
    "body": " index search search back examples california housing the dataset consists of information from \\(20,460\\) neighborhoods in california. the target variable (\\(y\\)) is the median house value in each neighborhood. predictor variables include demographic factors like median income (medinc), housing density (house), average occupancy (aveoccup), location coordinates (longitude and latitude), and house attributes like average number of rooms (averooms) and bedrooms (avebedrms). there are thus a total of eight predictors, all numeric. we fit a gradient boosting model using the mart procedure, with \\(j = 6\\) terminal nodes. the test error is seen to decrease monotonically with increasing \\(m\\), more rapidly during the early stages and then leveling off to being nearly constant as iterations increase. thus, the choice of a particular value of \\(m\\) is not critical, as long as it is not too small. the next figure displays the relative variable importances for each of the eight predictor variables. not surprisingly, median income in the neighborhood is the most relevant predictor. longitude, latitude, and average occupancy all have roughly half the relevance of income, whereas the others are somewhat less influential on the following graphs we show single-variable partial dependence plots on the most relevant nonlocation predictors. note that the plots are not strictly smooth as a consequence of using tree-based models. the hash marks at the base of each plot delineate the deciles of the data distribution of the corresponding variables. so for example, \\(90%\\) of the data have a medinc value of less than \\(6\\). the partial dependence of median house value on median income is monotonic increasing. house value is generally monotonic decreasing with increasing average occupancy, except perhaps for average occupancy rates less than one. median house value is seen to have a very weak partial dependence on house age that is inconsistent with its importance ranking. this suggests that this weak main effect may be masking stronger interaction effects with other variables. the next graph shows the two-variable partial dependence of the fitted model on joint values of longitude and latitude: there is a very strong dependence of median house value on the neighborhood location in california. it can be viewed as representing an extra premium one pays for location. this premium is seen to be relatively large near the pacific coast especially in the bay area and los angeles–san diego. in the northern, central valley, and southeastern desert regions of california, location costs considerably less. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/AAII/T2/03_boosting_trees.html",
    "title": "Boosting Trees",
    "body": " index search search back boosting trees variable space partitioning partitioning the predictor variable space into regions in boosting trees involves recursively splitting the data based on predictor variables to create distinct regions with associated constant values for making predictions. starting point: entire predictor variable space is considered as one large region, \\(r_1\\). decision making: at each step, a decision tree algorithm finds the best split based on a predictor variable \\(x_j\\) and a split point \\(s\\) that minimizes a certain criterion. this split divides region \\(r_j\\) into two subregions \\(r_{left}\\) and \\(r_{right}\\). splitting criteria: it can be represented as \\((j, s) = arg \\min_{j, s} [\\sum_{x_i \\in r_{left}} l(y_i, f(x_i)) + \\sum_{x_i \\in r_{right}} l(y_i, f(x_i)]\\) recursive process: this process is repeated recursively for each resulting subregion until a stopping criterion is met. terminal nodes: the final regions, or terminal nodes, are denoted as \\(r_j\\) and are assigned constant values \\(\\gamma_j\\) representing the prediction for data points falling into that region. constant assigment: each terminal node is associated with a constant value, resulting in a piecewise constant function, such that each tree can be denoted as: \\(t(x; \\theta) = \\sum_{j=1}^j \\gamma_j i(x \\in r_j)\\) where \\(i(\\cdot)\\) is the indication function and \\(\\theta = \\{r_j, \\gamma_j\\}_1^j\\) are the parameters. prediction: when making predictions for new data points, the algorithm determines the region \\(r_j\\) that the data point belongs to based on the predictor variables. the prediction for that data point is then based on the constant value \\(\\gamma_j\\) assigned to the corresponding region. optimization problem so as we have seen the optimization problem is defined, on a simplified manner, as follows: \\begin{align} \\hat{\\theta} = \\arg \\min_{\\theta} \\sum_{j=1}^j \\sum_{x_i \\in r_j} l(y_i, \\gamma_j) \\end{align} this is a combinatorial problem that we usually aproximate using suboptimal solutions. finding \\(\\gamma_j\\) given \\(r_j\\): we usually define \\(\\hat{\\gamma}_j = \\overline{y}_j\\) for regression problems. finding \\(r_j\\): this is the difficult part. we usually resort to a greedy, top-down recursive partitioning algorithm to find \\(r_j\\). boosting trees in boosting trees, terminal-node trees refer to the individual decision trees that make up the ensemble model. each terminal-node tree is denoted as \\(t(x; \\theta_m)\\) where \\(\\theta_m = \\{r_{jm}, \\gamma_{jm}\\}_1^{j_m}\\). the boosted tree model is an additive model, where each tree is added sequentially to improve the overall prediction. the model can be expressed as \\begin{align} f_m(x) = \\sum_{m=1}^m t(x; \\theta_m) \\end{align} where \\(m\\) represents the total number of trees in the ensemble. optimization problem the optimization problem for boosting trees involves finding the optimal regions and constants for each tree in the ensemble model. optimization objective the goal is to minimize the empirical risk: \\begin{align} \\hat{\\theta} = arg \\min_{\\theta} \\sum_{x_i \\in r_j} l(y_i, \\gamma_j) \\end{align} where \\(l(y_i, \\gamma_i)\\) represents the loss incurred for pedicting the target value \\(y_i\\) with constant \\(\\gamma_j\\) in region \\(r_j\\). finding optimal consants given the regions \\(r_{jm}\\) finding the optimal constant in \\(\\gamma_j\\) in each regions involves minimizing the loss function for the data points within that region: \\begin{align} \\hat{\\gamma}_{jm} = arg \\min_{\\gamma_{jm}} \\sum_{x_i \\in r_{jm}} l(y_i, f_{m - 1}(x_i) + \\gamma_{jm}) \\end{align} \\begin{align} \\hat{\\gamma}_{jm} = arg \\min_{\\gamma_{jm}} \\sum_{x \\in r_{jm}} l(y_i, f_{m - 1}(x_i) + t(x_i; \\theta_m)) \\end{align} finding the regions is difficult, and even more difficult than for a single tree. solution for regression trees for regressions trees the solution for boosted trees consists on choosing the regression tree that best predicts the current residuals \\(y_i - f_{m-1}(x_i)\\) and \\(\\hat{\\gamma}_{jm}\\) solution for classification trees for two-class classification and exponential loss, it gives rise to the adaboost method. it can be showin that given \\(r_{jm}\\) the solution is: \\begin{align} \\hat{\\gamma}_{jm} = \\log \\frac{\\sum_{x_i \\in r_{jm}} w_i^{(m)} i(y_i = 1)}{\\sum_{x_i \\in r_{jm}} w_i^{(m)} i(y_i = -1)} \\end{align} appendix greedy top-down recurisve partitioning algorithm a greedy, top-down recursive partitioning algorithm is a method used in decision tree construction to recursively split the predictor variable space into regions in a step-by-step manner. greedy approach: at each step, it makes the best split based on the available data without considering the impact of future splits. top down process: starts at the top with the entire predictor variable space considered as one region. it then recursively divides this space into smaller regions recursive partitioning: at each step the predictor variable space is divided into two or more subregions based on a splitting criterion. this process continues recursively for each resulting subregion until a stopping criterion is met. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/AAII/T2/01_boosting.html",
    "title": "Boosting",
    "body": " index search search back boosting in machine learning, boosting is an ensemble meta-algorithm for primarily reducing bias, variance in supervised learning. a weak learner is defined to be a classifier that is only slightly correlated with the true classification (it can label examples better than random guessing). in contrast, a strong learner is a classifier that is arbitrarily well-correlated with the true classification. before training each weak classifier, the data is sampled based on a distribution. this distribution initially assigns equal weight to each training example. after training, the weak classifier's accuracy on the training data is evaluated. the accuracy of the weak classifier determines its importance in the final model. higher accuracy leads to greater influence. re-weighting: after adding a weak learner, the data weights are adjusted, giving more weight to misclassified examples and reducing the weight of correctly classified ones. re-weighting helps subsequent weak learners to focus more on the examples that previous weak learners struggled with. regression trees boosting regression trees, often referred to as gradient boosting machines: what is the idea behind this procedure? given the current model, we fit a decision tree to the residuals \\(r_i\\) from the model rather than the outcome \\(y\\). each of these trees can be rather small, with just a few terminal nodes, determined by the parameter \\(d\\). by fitting small trees to the residuals, we slowly improve \\(\\hat{f}\\) in areas where it does not perform well. the shrinkage parameter \\(\\lambda\\) slows the process down even further. boosting has three tuning parameters: the number of trees \\(b\\): boosting can overfit if \\(b\\) is too large. the shrinkage parameter \\(\\lambda\\): this controls the rate at which boosting learns. the number \\(d\\) of splits in each tree, which controls the complexity of the ensemble. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/AAII/T2/05_interpretability.html",
    "title": "Interpretability",
    "body": " index search search back interpretability importance of predictor variables we attempt to discuss the relevance of predictor variables in a statistical modeling technique called boosting. decision trees we define the following as a measure of relevance for each predictor variable \\(x_{\\mathcal{l}}\\): \\begin{align} i_{\\mathcal{l}}^2(t) = \\sum_{t = 1}^{j - 1} \\hat{i}^2_t i(v(t) = \\mathcal{l}) \\end{align} this equation calculates the relevance of each predictor variable based on the squared improvements in error risk within the internal nodes of the tree. let's split each part of the equation: the term \\(\\hat{i}^2_t\\) represents the squared improvement in error risk at node \\(t\\) when splitting on the \\(x_{\\mathcal{l}}\\) predictor variable. the variable \\(v(t)\\) indicates which predictor variable is used for the split at node \\(t\\). each improvement is weighted by the indicator function \\(i(v(t) = \\mathcal{l})\\), which checks if the splitting variable at node \\(t\\) is the predictor variable of interest \\(x_{\\mathcal{l}}\\). this weighting ensures that only the improvements related to the predictor variable \\(x_{\\mathcal{l}}\\) are considered in the calculation. we sum these improvements over the \\(j - 1\\) internal nodes on the tree, which are not terminal nodes. additive models this importance measure is easily generalized to additive tree expansions: \\begin{align} i_{\\mathcal{l}}^2 = \\frac{1}{m}\\sum_{m = 1}^{m} i_{\\mathcal{l}}^2(t_m) \\end{align} due to the stabilizing effect of averaging, this measure turns out to be more reliable than the measure computed only over one tree. partial dependence plots partial dependence functions, by isolating the effects of selected variables, provides an interpretable analysis of their impact on the model's predictions, overcoming the challenges of information overload in high-dimensional spaces. let's define the partial dependency of \\(f(x)\\) on \\(x_s\\), \\begin{align} f_s(x_s) = \\mathbb{e}_{x_c}[f(x_s, x_c)] \\end{align} where: \\(x_s\\) is the subset of variables we want to study. \\(x_c\\) is the complement set, that is the rest of variables. \\(e_{x_c}\\) denotes the expectation operator with respect to the variables in the complement set \\(x_c\\). it averages the model's output over the variables in the complement set. \\(f\\) represents the model. \\(f_s(x_s)\\) represents the relationship between the subset of variables \\(x_s\\) and the model's output. the average can be estimated as follows: \\begin{align} \\overline{f}_s(x_s) = \\frac{1}{n} \\sum_{i=1}^n f(x_s, x_{i\\mathcal{c}}) \\end{align} we simply iterate over every data point on the training set, such that \\(x_{i\\mathcal{c}}\\) refers to the values of the variables in the complement set \\(x_c\\) for the \\(i\\)th data point. previously we measured the effects of \\(x_s\\) after accounting for the effects of the other variables \\(x_c\\) on \\(f(x)\\), they were not the effect of \\(x_s\\) on \\(f(x)\\) ignoring the effects of \\(x_c\\), that is given by: \\begin{align} \\tilde{f}_s(x_s) = \\mathbb{e}(f(x_s, x_c)|x_s) \\end{align} thus \\(\\tilde{f}_s(x_s) = \\overline{f}_s(x_s)\\) only if \\(x_s\\) and \\(x_c\\) are independent. example if we assume a purely additive effect, where the overall prediction is the sum of two components: \\begin{align} f(x) = h_1(x_s) + h_2(x_c) \\end{align} this implies that the effect of \\(x_s\\) on the prediction is independent of the other variables in \\(x_c\\). however if the prediction is defined as: \\begin{align} f(x) = h_1(x_s) \\cdot h_2(x_c) \\end{align} then this implies that the effect of \\(x_s\\) on the prediction is dependent on the values of the variables in \\(x_c\\). representation owing to the limitations of computer graphics, and human perception, the size of the subsets \\(x_s\\) must be small (\\(l \\approx 1, 2, 3\\)). $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/AAII/T2/02_ada_boost.html",
    "title": "Ada Boost",
    "body": " index search search back ada boost definition adaboost, also known as adaptive boosting, is a machine learning algorithm that combines multiple weak classifiers to create a strong classifier. let's break down the adaboost algorithm using the pseudocode shown in: initialization: adaboost starts by initializing the weights of all training examples equally \\(d_1(i) = \\frac{1}{n}\\) for \\(i = 1, 2, \\cdots, n\\). iterative process for \\(t = 1, \\cdots, t\\): adaboost iterates through rounds, where each round involves training a weak classifier \\(h_t: \\mathcal{x} \\rightarrow \\{-1, +1\\}\\) on the data \\(d_t\\). the algorithm adjusts the weights of the training examples based on the performance of the weak classifier: \\(d_{t+1} = \\frac{d_t(i) \\cdot e^{-\\alpha_ty_th_t(x_t)}}{z_t}\\), where \\(z_t\\) is a regularization term and \\(\\alpha_t\\) is the weight of \\(h_t\\) on the final ensemble model based on its accuracy. combining classifiers: after multiple rounds, adaboost combines all the weak classifiers into a final strong classifier. the final classifier makes predictions based on a weighted voting system using the predictions of the individual weak classifiers: \\(h(x) = sign(\\sum_{t=1}^t \\alpha_t h_t(x))\\) predictions: when making predictions on new data, adaboost uses the combined classifier to predict the class label based on the weighted votes of the weak classifiers characteristics the weak learning assumption means that we assume each weak classifier makes errors that are not too close to random guessing. so the the error \\(\\epsilon_t\\) is at most \\(\\frac{1}{2} - \\gamma\\) for some small positive constant \\(\\gamma\\). it can be proven that the training error of the c ombined classifier drops exponentially fas as a function of the number of weak classifiers combined, but it says nothing about the behaviour of its generalization error computed over the test data. toy example to illustrate how adaboost works, let us look at the tiny toy learning problem shown in the following picture: round 1 on round \\(1\\), we assign equal weights to all the examples. so \\(d1_(i) = \\frac{1}{n} = \\frac{1}{10}\\). the hypothesis \\(h_1\\) classifies incorrectly three points, so its error is \\(\\epsilon_1 = 0.3\\), so it follows that the weight assigned to this first model is \\(\\alpha_1 = 0.42\\). round 2 when constructing \\(d_2\\) we increment the weight of the three points misclassified by \\(h_1\\). and we define a new hypothesis \\(h_2\\) over this data, where we can see that it classifies correctly the three points misclassified by \\(h_1\\) however it still classifies incorrectly three other points. the error of this model is \\(\\epsilon_2 = 0.21\\) and thus the weight of this model is defined as \\(\\alpha_2 = 0.65\\). round 3 we modify the weights of the data taking into account the three points previously misclassified, augmenting their weight and decresing the weight of those correctly classified. this classifier misses none of the points misclassified by \\(h_1\\) and \\(h_2\\). final round the combined classifier \\(h\\) is defiend as a weigthed vote between \\(h_1\\), \\(h_2\\) and \\(h_3\\) where the weights are given by \\(\\alpha_1\\), \\(\\alpha_2\\) and \\(\\alpha_3\\). $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/DL/04_cnn.html",
    "title": "Redes Neuronales Convolucionales en Visión Artificial",
    "body": " index search search back redes neuronales convolucionales en visión artificial clasificación de imágenes una cnn para clasificación de imágenes está conformada por dos bloques: conjunto de capas que llevan a cabo la extracción de caracterísitcas clasificador que toma como entrada las características extraídas por la red neuronal este tipo de redes necesita una gran cantidad de datos. en caso de no poseer un volumen elevado de datos se puede hacer uso de técnicas como el aumento de muestras y el uso de redes pre-entrenadas. aumento de muestras consiste en crear nuevas muestras a partir de muestras existentes utilizando transformaciones aleatorias: rotaciones y translaciones. recorte o zoom. voltear horizontalmente (si no hay suposiciones de simetría horizontal). añadir pequeñas cantidades de ruido. en keras esto se puede llevar a cabo utilizando imagedatagenerator. redes pre-entrenadas si la red ha sido entrenada sobre un conjunto de datos lo suficientemente grande y general entonces, entonces podemos utilizarlo sobre clases no utilizadas en el entrenamiento original. existen dos técnicas: extracción de de características: utiliza la red pre-entrenada para extraer características de los nuevos datos. con las nuevas características se entrena un clasificador desde cero. ajuste fino: utiliza unas cuantas capas de la red pre-entrenada y las entrena conjuntamente con el nuevo clasificador. extracción de características se puede hacer de dos maneras: aplicar la base convolutiva sobre el conjunto de datos y utlizarla para entrenar el clasificador. no permite el aumento de datos extender la base convolutiva con un nuevo clasificador y entrenar todo el conjunto. es mucho más lenta per permite el aumento de datos ajuste fino se lleva a cabo como sigue: se añade la nueva red sobre la cnn pre-entrenada se bloquea la red pre-entrenada, de manera que sus pesos no cambian se entrena la nueva red se desbloquean algunas capas superior (que extraer las características de más alto nivel), tal que sus pesos sí se pueden entrenar entrenar estas capas y la nueva red detección de objetos un sistema de detección de objetos debe producir el nombre de la clase asignada a la imagen, una caja de abarque (bounding box) y generalmente la probabilidad de que el objeto pertenezca a la clase. se presentan los siguientes retos a la hora de llevar a cabo la detección: oclusiones, cambios de puntos de vista y tamaños, objetos no rígidos y desenfoque por movimiento métodos antes del desarrollo de las redes neuronales se empleaban las cascadas de haar, que extraer características por convolución con kernels suma de píxeles en negro menos en blanco que seguidamente se pasan a un clasificador entrenado. por otra parte, tenemos la detección basada en cnn que consiste en modificar nuestras redes cnn para no sólo clasificar, si no también obtener la caja de abarque y la forma del objeto. dentro de estes distinguimos dos tipos: detectores de dos etapas, como por ejemeplo region cnn. son letos y no permiten su aplicación en tiempo real. detectore de una etapa, como por ejemplo single shot multibox detector. sí que permiten su aplicación en tiempo real. regioncnn se generan una serie de propuestas de caja de abarque a distintas escalas. se procesan las cajas utilizando una cnn pre-entrenada se clasifican utilizando un clasificador como svm se procesan las cajas utilizando regresión lineal para ajustar las coordenadas segmentación semántica en la segmentación clásica el objetivo consiste en agrupar píxeles contiguos de una categoría similar. la segmentación semántica se distingue de la segmentación clásica en que intenta particionar la imagen en partes con significado y clasificarlas. métodos se utiliza una especie de gan, ya que tienen una red codificadora pre-entrenada seguida de una red decodificadora: la red codificadora aprende características distintivas a baja resolución la red decodificadora proyecta semánticamente las características en el espacio de píxeles (alta resolución) aplicaciones aprendizaje de similaridad. subtitulado de imágenes. generación de imágenes. seguimiento en secuencias de imágenes. todo lo comentado aplicado a vídeo y a imagen 3d. robots: odometría y localización y creación de mapas (slam) usando cámaras. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/DL/01_foundation.html",
    "title": "T1. Fundamentos de las Redes Neuronales Profundas",
    "body": " index search search back t1. fundamentos de las redes neuronales profundas deep networks we could define deep learning as a class of machine learning techniques, where information is processed in hierarchical layers to understand representations and features from data in increasing levels of complexity. in practice, all deep learning algorithms are neural networks. with that in mind, let's look at the main classes of neural networks. the following list is not exhaustive, but it represents the vast majority of algorithms in use today: multi-layer perceptrons (mlps) convolutional neural networks (cnns) recurrent networks autoencoders training deep networks we can use different algorithms to train a neural network. but in practice, we almost always use stochastic gradient descent (sgd) and backpropagation. in the following section, we'll introduce momentum, the weight update rule is defined as follows: \\begin{align} w \\rightarrow w - \\lambda \\nabla (j(w)) \\end{align} where \\(\\lambda\\) is the learning rate. first we calculate the weight update value \\begin{align} \\delta w \\rightarrow \\mu\\delta w - \\lambda (\\nabla j(w)) \\end{align} we see that the first component, \\(\\mu\\delta w\\), is the momentum. the \\(\\delta w\\) represents the previous value of the weight update and \\(\\mu\\) is the coefficient, which wil determine how much the new value depends on the previous ones. then we update the weight: \\begin{align} w \\rightarrow w + \\delta w \\end{align} you may encounter other gradient descent optimizations, such as: nesterov momentum adadelta rmsprops adam the reasons for deep learning's popularity the first reason is, today, we have a lot more data than in the past. the second reason is the increased computing power. this is most visible in the drastically increased processing capacity of graphical processing units (gpus). neural networks are organized in such a way as to take advantage of the gpu's parallel architecture. introducing popular open source libraries the basic unit for data storage is the tensor. a tensor is a generalization of a matrix to higher dimensions. neural networks are represented as a computational graph of operations. the nodes of the graph represent the operations (weighted sum, activation function, and so on). the edges represent the flow of data. some common libraries: tensorflow keras: is a high-level neural net python library that runs on top of tensorflow, cntk or theano. pytorch: is a deep learning library based on torch. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/DL/05_rnn.html",
    "title": "Redes Neuronales Recurrentes",
    "body": " index search search back redes neuronales recurrentes introducción a las aplicaciones del deep learning para el nlp comparación entre enfoques clásico y de deep learning enfoque clásico el enfoque clásico se compone de los siguientes pasos: detección de idioma pre-procesado tokenizado etiquetado gramatical (pos) eliminación de stop-words etc. modelado extracción de características (entidades (ner), categorías (pos) ...) aplicación de algoritmos de ml etc. salida análisis de sentimientos clasificación de textos traducción etc enfoque deep learning mientas que el enfoque basado en deep learning se compone de los siguientes pasos: pre-procesado tokenizado etiquetado gramatical (pos) eliminación de stop-words etc. representaciones distribuidas (word embeddings): transformación de palabras/secuencias en vectores que es la entrada que aceptan las redes neuronales. para ello se distinguen métodos como: word2vec, glove, etc. procesamiento en capas ocultas: no permite generar representación comprimida de la entradas. capa de salida análisis de sentimientos clasificación de textos traducción etc arquitecturas para llevar a cabo natural languague processing (nlp) con deep learning podemos utilizar las siguientes arquitecturas: redes recurrentes (rnn) lstm (long short term memory) gru (gated recurrent units) redes convolucionales (cnn) autoencoders ejemplos de deep learning para natural language processing clasificación de textos para la clasificación de texto se define la siguiente estructura: capa de embedding: que transforma la secuencia de palabras en una tabla de vectores capturando la semántica de las mismas. componente de representación profunda: se utiliza rnn o cnn para obtener una representación comprimida de la entrada. parte totalmente conectada: transforma la representación comprimida en clases o puntuaciones para cada clase. ver el capítulo text classification using lstm de hands-on natural language processing with python. generación de textos se utilizan rnns para crear modelos generativos, tal que la generación se puede llevar a cabo en base a caracteres o a palabras. estas son capaces de aprender dependencias a largo plazo. ver el capítulo text generation and summarization using grus de hands-on natural language processing with python. resumen de textos distinguimos entre dos tipos: extractivos: se extraen frases o palabras clave. son simples y robustos y no permiten la paráfrasis. abstractivos: la salida contiene texto no contenido en el original manteniendo el significado. ver el cap. text generation and summarization using grus de hands-on natural language processing with python. traducción distinguimos distintos sistemas que efectúan la traducción automática: sistemas expertos: se definen reglas lingüísticas y sintácticas. traducción estadística: se aprenden reglas estadísticamente a partir de un gran conjunto de datos bilingüe. tal que define un modelo de traducción que mapea textos de un lenguaje a otro. solo funciona bien traduciendo textos similares a los de entrenamiento y necesita gran cantidad de datos traducción con redes neuronales: utilizan un sólo modelo que trabaja sobre segmentos de texto, no sólo sobre palabras o frases. ver el cap. machine translation using the attention-based model de hands-on natural language processing with python. búsqueda y eliminación de duplicados se puede conseguir utilizando una cnn basada en caracteres, que proporciona la flexibilidad para entrenar modelos con caracteres desconocidos y ofrece mayor capacidad de generalición que los embeddings a nivel de palabra. ver el capítulo searching and deduplicating using cnns de hands-on natural language processing with python. otras aplicaciones preguntas-respuestas y chatbots reconocimiento de voz texto a voz $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/DL/02/01_conv_nets.html",
    "title": "Convolutional Nets",
    "body": " index search search back convolutional nets deep convolutional neural network a deep convolutional neural network (dcnn) consists of many neural network layers. two different types of layers, convolutional and pooling, are typically alternated local receptive fields if we want to preserve spatial information, we represent each image with a matrix of pixels. convolution operation: to encode the local structure is to connect a submatrix of adjacent input neurons (pixels) into one single hidden neuron belonging to the next layer. that single hidden neuron represents one local receptive field. we can encode more information by having overlapping submatrices. a feature map is the result of applying the convolution on the input data, on the previous example the matrix on the right would be one feature map. the kernel size is the size of each the submatrices, in the previous example \\(3 \\times 3\\). the stride is the number of elements between each submatrix. with a stide of \\(1\\) we obtain the following result: this convolutional layer is usually followed by a non-linear activation function (e.g. relu). shared weights and bias to detect the same feature independently from its location on the input we define the same weights for all the neurons on a layer. this way we force the neural net to search for relevant features everywhere on the input data, instead of searching for features on specific places on the input image. pooling layer it consists on using the spatial contiguity of the output from a single feature map and aggregate the values into a single output. on the following image max pooling is being performed. other common pooling operation is average pooling. an example of dcnn — lenet it is a family of convnets trained for recognizing mnist handwritten characters with robustness to simple geometric transformations and to distortion. it is defined as follows: on the low-layers we alternate convolution operations with max-pooling operations. (using carefully chosen local receptive fields and and shared weights). on higher levels are fully connected layers based on a traditional mlp with hidden layers and softmax as the output layer. understanding the power of deep learning deep networks always outperform the simple network and the gap is bigger when the number of examples provided for training is progressively reduced. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/DL/02/02_rnn.html",
    "title": "Recurrent Neural Nets",
    "body": " index search search back recurrent neural nets a recurrent neural network (rnn) is a class of neural networks that exploit the sequential nature of their input. such inputs could be text, speech, time series, and anything else where the occurrence of an element in the sequence is dependent on the elements that appeared before it. simplernn cells rnn cells incorporate this dependence by having a hidden state, or memory. the value of the hidden state is a function of the value of the hidden state at the previous time step and the value of the input at the current time step. \\begin{align} h_t = \\phi(h_{t-1}, x_t) \\end{align} where \\(h_t\\) and \\(h_{t-1}\\) are the values of the hidden states at the time steps \\(t\\) and \\(t-1\\) and \\(x_t\\) is the values of the input at time \\(t\\). note that the equation is recursive at time \\(t\\) the cell has an input \\(x_t\\) and an output \\(y_t\\). part of the output \\(y_t\\) (the hidden state \\(h_t\\)) is fed back into the cell for use at a later time step \\(t+1\\). on the previous image we show the behaviour of a single cell unrolled. notice that the weight matrices \\(u\\), \\(v\\), and \\(w\\) are shared across the steps. we can also describe the computations within an rnn in terms of equations: \\begin{align} h_t = tanh(wh_{t-1} + ux_t) \\end{align} \\begin{align} y_t = sofmax(vh_t) \\end{align} rnn topologies rnns can be arranged in many ways to solve specific problems. in the basic topology, all input sequences are of the same length and an output is produced at each time step. another example of a many to many rnn could be a machine translation network shown on the many-to-many topology. these take in a sequence and produces another sequence. for example, the input could be a sequence in english and the output could be the translation in spanish. other variants are the one-to-many network, an example of which could be an image captioning network, where the input is an image and the output a sequence of words. similarly, an example of a many-to-one network could be a network that does sentiment analysis of sentences, where the input is a sequence of words and the output is a positive or negative sentiment. vanishing and exploding gradients training the rnn involves backpropagation, where the gradient at each output depends not only on the current time step, but also on the previous ones, this process is called backpropagation through time (bptt). during backpropagation (shown by dotted lines), the gradients of the loss with respect to the parameters \\(u\\), \\(v\\), and \\(w\\) are computed at each time step and the parameters are updated with the sum of the gradients. the following equation shows the gradient of the loss with respect to \\(w\\): \\begin{align} \\frac{\\delta l}{\\delta w} = \\sum_t \\frac{\\delta l_t}{\\delta w} \\end{align} let us now look at what happens to the gradient of the loss at the last time step (\\(t=3\\)) \\begin{align} \\frac{\\delta l_3}{\\delta w} = \\frac{\\delta l_3}{\\delta y_3} \\frac{\\delta y_3}{\\delta h_2} \\frac{\\delta h_2}{\\delta_w} \\end{align} the previous equation is simply deriving by applying the chain rule, where: the loss function \\(l_3\\) is defined as a function of \\(y_3\\), then \\(y_3 = softmax(vh_2)\\) and finally \\(h_2 = tanh(wh_1 + ux_1)\\) the gradient of the hidden state \\(h_2\\) with respect to \\(w\\) can be further decomposed as the sum of the gradient of each hidden state with respect to the previous one. \\begin{align} \\frac{\\delta l_3}{\\delta w} = \\sum_{t=0}^2 \\frac{\\delta l_3}{\\delta y_3} \\frac{\\delta y_3}{\\delta h_2} \\frac{\\delta h_2}{\\delta h_t}\\frac{\\delta h_t}{\\delta_w} \\end{align} finally, each gradient of the hidden state with respect to the previous one can be further decomposed as the product of gradients of the current hidden state against the previous one. \\begin{align} \\frac{\\delta l_3}{\\delta w} = \\sum_{t=0}^2 \\frac{\\delta l_3}{\\delta y_3} \\frac{\\delta y_3}{\\delta h_2} \\left(\\prod_{j=t+1}^2 \\frac{\\delta h_j}{\\delta h_{j-1}}\\right)\\frac{\\delta h_t}{\\delta_w} \\end{align} for example for \\(t = 3\\): \\begin{align} \\frac{\\delta l_4}{\\delta w} = \\frac{\\delta l_4}{\\delta y_4} \\frac{\\delta y_4}{\\delta h_3} \\left(\\prod_{j=4}^2 \\frac{\\delta h_j}{\\delta h_{j-1}}\\right)\\frac{\\delta h_4}{\\delta_w} \\end{align} \\begin{align} \\frac{\\delta l_4}{\\delta w} = \\frac{\\delta l_4}{\\delta y_4} \\frac{\\delta y_4}{\\delta h_3} \\left(\\frac{\\delta h_4}{\\delta h_3}\\frac{\\delta h_3}{\\delta h_2}\\frac{\\delta h_2}{\\delta h_1}\\right)\\frac{\\delta h_4}{\\delta_w} \\end{align} on general: \\begin{align} \\frac{\\delta l_i}{\\delta w} = \\sum_{t=0}^i \\frac{\\delta l_i}{\\delta y_i} \\frac{\\delta y_i}{\\delta h_{i-1}} \\left(\\prod_{j=t+1}^i \\frac{\\delta h_j}{\\delta h_{j-1}}\\right)\\frac{\\delta h_i}{\\delta_w} \\end{align} consider the case where the individual gradients of a hidden state with respect to the previous one is less than one. as we backpropagate across multiple time steps, the product of gradients get smaller and smaller, leading to the problem of vanishing gradients. similarly, if the gradients are larger than one, the products get larger and larger, leading to the problem of exploding gradients. the effect of vanishing gradients is that the gradients from steps that are far away do not contribute anything to the learning process, so the rnn ends up not learning long range dependencies. while there are a few approaches to minimize the problem of vanishing gradients, such as: proper initialization of the \\(w\\) matrix using a relu instead of tanh layers pre-training the layers using unsupervised methods the most popular solution is to use the lstm or gru architectures. long short term memory — lstm the lstm is a variant of rnn that is capable of learning long term dependencies. the line across the top of the diagram is the cell state c, and represents the internal memory of the unit. the line across the bottom is the hidden state. also, \\(i\\), \\(f\\), and \\(o\\) are the input, forget, and output gates. the forget gate defines how much of the previous state \\(h_{t-1}\\) you want to allow to pass through. the input gate defines how much of the newly computed state for the current input \\(x_t\\) you want to let through. the output gate defines how much of the internal state you want to expose to the next layer. the internal hidden state \\(g\\) is computed based on the current input \\(x_t\\) and the previous hidden state \\(h_{t-1}\\). such that: \\begin{align} i = \\sigma(w_ih_{t-1} + u_ix_t) \\end{align} \\begin{align} f = \\sigma(w_fh_{t-1} + u_fx_t) \\end{align} \\begin{align} o = \\sigma(w_oh_{t-1} + u_ox_t) \\end{align} \\begin{align} g = \\tanh(w_gh_{t-1} + u_gx_t) \\end{align} \\begin{align} c_t = (c_{t-1} \\otimes f) \\oplus (g \\otimes i) \\end{align} \\begin{align} h_t = tanh(c_t) \\otimes o \\end{align} one thing to realize is that an lstm is a drop-in replacement for a simplernn on the recurrent neural network. gated recurrent unit — gru this type of cell has two gates, an update gate \\(z\\), and a reset gate \\(r\\). the update gate defines how much previous memory to keep around. the reset gate defines how to combine the new input with the previous memory. the following equations define the gating mechanism in a gru: \\begin{align} z = \\sigma(w_zh_{t-1} + u_z x_t) \\end{align} \\begin{align} r = \\sigma(w_rh_{t-1} + u_r x_t) \\end{align} \\begin{align} c_t = tanh(w_c(h_{t-1} \\otimes r) + u_cx_t) \\end{align} \\begin{align} h_t = (z \\otimes c) \\oplus ((1 - z) \\otimes h_{t-1}) \\end{align} gru and lstm have comparable performance, while grus are faster to train and need less data to generalize in situations where there is enough data, an lstm's greater expressive power may lead to better results. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/DL/02/04_autoencoders.html",
    "title": "Autoencoders",
    "body": " index search search back autoencoders autoencoders an autoencoder is a type of artificial neural network used to learn efficient codings of unlabeled data (unsupervised learning). an autoencoder learns two functions: an encoding function that transforms the input data a decoding function that recreates the input data from the encoded representation. the autoencoder learns dense representations (encoding) for a set of data. we can force the network to learn useful features adding different types of constraints, for example: defining the dense representation such that is has a lower dimensionality than the input data. adding noise to the input data (denoising autoencoders). the number of neurons in the output layer must be equal to the number of inputs. the outputs are often called the reconstructions because the cost function contains a reconstruction loss that penalizes the model when the reconstructions are different from the inputs. undercomplete autoencoder: the internal representation has a lower dimensionality than the input data. overcomplete autoencoder: the internal representation has a higher dimensionality than the input data. stacked autoencoders stacked autoencoders are said to be autoencoders that have multiple hidden layers. tying weights an autoencoder with tied weights has decoder weights that are the transpose of the encoder weights this reduces the number of parameters of the model, thus speeds up training and limits the risk of overfitting. convolutional autoencoders used with image data. the encoder is a regular cnn composed of convolutional layers and pooling layers. it reduces the spatial dimensionality of the inputs (i.e., height and width) while increasing the depth (i.e., the number of feature maps). the decoder must do the reverse (upscale the image and reduce its depth back to the original dimensions). recurrent autoencoders used with sequential data. the encoder is typically a sequence-to-vector rnn, which compresses the input sequence down to a single vector. the decoder is a vector-to-sequence rnn that does the reverse denoising autoencoders we want to add noise to the input data, and then train the network to be able to recover the original noise-free inputs. the noise can be pure gaussian noise added to the inputs, or it can be randomly switched-off inputs, just like in dropout. sparse autoencoders a sparse autoencoder is an autoencoder whose training criterion involves a sparsity penalty. in most cases, we would construct our loss function by penalizing activations of hidden layers so that only a few nodes are encouraged to activate when a single sample is fed into the network. variational autoencoders they are probabilistic autoencoders as well as generative models. instead of directly producing a coding for a given input, the encoder produces a mean coding \\(\\mu\\) and a standard deviation \\(\\sigma\\). the actual coding is then sampled randomly from a gaussian distribution with mean \\(\\mu\\) and standard deviation \\(\\sigma\\). after that the decoder decodes the sampled coding normally. generative adversarial networks gans are composed of two neural networks: a generator that tries to generate data that looks similar to the training data a discriminator that tries to tell real data from fake data. takes either a fake image from the generator or a real image from the training set as input, and must guess whether the input image is fake or real. each training iteration is divided into two phases: we train the discriminator. a batch of data where half are real real images and the other half are fake images produced by the generator. the labels are set to \\(0\\) for fake images and \\(1\\) for real images, and the discriminator is trained on this labeled batch for one step. backpropagation only optimizes the weights of the discriminator. we train the generator: we only add fake images to the data, and all the labels are set to \\(1\\) (real). we want the generator to produce images that the discriminator will believe to be real. backpropagation only affects the weights of the generator. the generator and the discriminator compete against each other during training. the difficulties of traning gans it has been demonstrated that a gan can only reach a single nash equilibrium (we assume the training process to be finished): that’s when the generator produces perfectly realistic images, and the discriminator is forced to guess (\\(50\\%\\) real, \\(50\\%\\) fake). nothing guarantees that the equilibrium will ever be reached. the biggest difficulty is called mode collapse: this is when the generator’s outputs gradually become less diverse. such that the generator gets very good at generating data of a concrete kind, good enough to fool the discriminator, however it progressively start representing data of another kind and then forgets about the previous class of data. moreover, because the generator and the discriminator are constantly pushing against each other, their parameters may end up oscillating and becoming unstable. and since many factors affect these complex dynamics, gans are very sensitive to the hyperparameters. there are some techniques that aim to avoid this behaviour like: experience replay and mini-batch discrimination. experience replay: stores images on a buffer and the discriminator uses the images on this buffer as input for fake images. old images are then progressively replaces by newer images. mini-batch discrimination: it measures how similar are images on the batch, the discriminator uses this statistic to decide whether to reject the whole batch or not. deep convolutional gans these are gans based on deeper convolutional nets for larger images. progressive growing of gans it begins by generating images at low resolution, such as \\(4 \\times 4\\) pixels. the model is first trained on low-resolution images. once training stabilizes at this resolution, additional layers are added to the generator and discriminator to allow for the generation of higher-resolution images. after adding new layers, there is usually a transition phase where the model is trained on a mixture of images at the old and new resolutions. this gradual transition allows the model to adapt to the increased resolution without destabilizing the training process. once the training stabilizes at the new resolution, the transition phase ends, and the model continues to train exclusively on images at the higher resolution. increasing the resolution progressively allows the model to learn to capture both global and local features of the images more effectively. style gans what sets stylegans apart is the introduction of \"style\" into the generation process. in traditional gans, the generator takes random noise as input and directly generates images. in stylegans, the generator learns to separate the \"content\" of the image (e.g., facial features) from the \"style\" (e.g., lighting, color, texture). this allows for more fine-grained control over the generated images. the stylegan generator and discriminator models are trained using the progressive growing gan training method. stylegans consist of two main components: a mapping network and a synthesis network. the mapping network takes as input a latent vector (random noise) and maps it to an intermediate latent space, which controls the style of the generated image. the synthesis network then takes the intermediate latent representation and generates the final image. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/DL/02/03_boltzmann.html",
    "title": "Boltzmann Based Networks",
    "body": " index search search back boltzmann based networks boltzmann machines they are fully connected artificial neural networks, but they are based on stochastic neurons. the working of boltzmann machine is mainly inspired by the boltzmann distribution which says that the current state of the system depends on the energy of the system and the temperature at which it is currently operating. these neurons output \\(1\\) with some probability, given by the following equation: \\begin{align} p(s_i^{\\text{next step}} = 1) \\sigma\\left(\\frac{\\sum_{j=1}^n w_{i,j}s_j + b_i}{t}\\right) \\end{align} where: \\(s_j\\) is the \\(j\\)th neuron's state (\\(0\\) or \\(1\\)). \\(w_{i,j}\\) is the connection weight between the \\(i\\)th and \\(j\\)th neurons. note that \\(w_{i,i}\\) = 0. \\(b_i\\) is the ith neuron’s bias term. \\(n\\) is the number of neurons in the network. \\(t\\) is a number called the network’s temperature; the higher the temperature, the more random the output. \\(\\sigma\\) is the logistic function. hence to implement these as neural networks, we use the energy models. the energy term was equivalent to the deviation from the actual answer. the higher the energy, the more the deviation. it has been thus important to train the model until it reaches a low-energy point. the nodes in boltzmann machines are simply categorized as visible and hidden nodes. the visible nodes take in the input. the same nodes which take in the input will return back the reconstructed input as the output. the energy function of the boltzmann machine is defined as follows: \\begin{aligned} e(v, h) = - \\sum_{i} v_ib_i - \\sum_k h_kb_k - \\sum_{i, j}v_iv_jw_{i,j} \\sum_{i,k}v_ih_kw_{i, k} - \\sum_{k,l}h_kh_kw_{k,l} \\end{aligned} where \\(v\\) are the visible units, \\(h\\) as the hidden units \\(b\\) is the bias and \\(w_{i, j}\\) are the weights between units \\(i\\) and \\(j\\). the probability of a joint configuration over both the visible unit and the hidden unit is as follows: \\begin{aligned} p(v,h) = \\frac{e^{-e(v,h)}}{\\sum_{m, n} e^{-e(m, n)}} \\end{aligned} and, for example, the probability distribution of visible units is obtained by marginalizing out hidden units: \\begin{aligned} p(v) = \\frac{\\sum_h e^{-e(v,h)}}{\\sum_{m, n} e^{-e(m, n)}} \\end{aligned} this can now be utilized to sample visible units. training a boltzmann machine means finding the parameters that will make the network approximate the training set’s probability distribution. so we have to obtain the parameters tha maximize the likelihood of the observed data. the traning algorithm runs as described: obtain the log likelihood function of visible units, by marginalizing the hidden units: \\begin{align} l(v|w) = \\log p(v|w) = \\log \\sum_h e^{-e_{v, h}} - \\log \\sum_{m, n} e^{-e_{m, n}} \\end{align} take the derivative of the log likelihood function as a function of \\(w\\): \\begin{align} \\frac{\\delta l(v|w)}{\\delta w} = \\frac{\\delta \\log \\sum_h e^{-e_{v, h}}}{\\delta \\sum_h e^{-e_{v, h}}} \\cdot \\frac{\\delta \\sum_h e^{-e_{v, h}}}{\\delta w} - \\frac{\\delta \\log \\sum_h e^{-e_{v, h}}}{\\delta \\sum_{m,n} e^{-e_{m, n}}} \\cdot \\frac{\\delta \\sum_̣{m,n} e^{-e_{m, n}}}{\\delta w} \\end{align} \\begin{align} = \\frac{1}{\\sum_h e^{-e_{v, h}}} \\cdot \\sum_h \\frac{\\delta e^{-e_{v,h}}}{\\delta w} - \\frac{1}{\\sum_{m,n} e^{-e_{m, n}}} \\cdot \\sum_{m,n} \\frac{\\delta e^{-e_{m,m}}}{\\delta w} \\end{align} \\begin{align} = \\frac{1}{\\sum_h e^{-e_{v, h}}} \\cdot \\sum_h -e^{-e_{v,h}} \\frac{\\delta e_{v,h}}{\\delta w} - \\frac{1}{\\sum_{m,n} e^{-e_{m, n}}} \\cdot \\sum_{m,n} -e^{e_{m,m}} \\frac{\\delta e_{m,m}}{\\delta w} \\end{align} \\begin{align} = -\\sum_h \\frac{e^{-e_{v,h}}}{\\sum_h e^{-e_{v, h}}} \\frac{\\delta e_{v,h}}{\\delta w} + \\sum_{m,n} \\frac{e^{e_{m,m}}}{\\sum_{m,n} e^{-e_{m, n}}} \\frac{\\delta e_{m,m}}{\\delta w} \\end{align} we know that: \\begin{align} p(h|v) = \\frac{p(v, h)}{p(v)} = \\frac{\\frac{e^{-e_{v, h}}}{\\sum_{m,n} e^{-e_{m, n}}}}{\\frac{\\sum_h e^{-e_{v, h}}}{\\sum_{m,n} e^{-e_{m, n}}}} \\end{align} by removing both \\(\\sum_{m,n} e^{-e_{m, n}}\\), we obtain: \\begin{align} = \\frac{e^{-e_{v, h}}}{\\sum_h e^{-e_{v, h}}} \\end{align} such that: \\begin{align} = -\\sum_h p(h|v) \\frac{\\delta e_{v,h}}{\\delta w} + \\sum_{m,n} p(m,n) \\frac{\\delta e_{m,m}}{\\delta w} \\end{align} and by de definition of the expected value \\(\\mathbb{e}(x) = \\sum_x x p(x)\\): \\begin{align} = - \\mathbb{e}_{p(h|v)}[\\frac{\\delta e_{v,h}}{\\delta w}] + \\mathbb{e}_̣{p(m,n)}[\\frac{\\delta e_{m,m}}{\\delta w}] \\end{align} computing these expectations is in general an intractable problem. he general approach for solving this problem is to use markov chain monte carlo (mcmc) to approximate these quantities: \\begin{align} \\frac{\\delta l(v|w)}{\\delta w} = - <s_i, s_j>_{p(h_{data}|v_{data})} + <s_i, s_j>_{p(h_{model}|v_{model})} \\end{align} here \\(<\\cdot, \\cdot>\\) denotes the expectation. restricted boltzmann machines an rbm is a boltzmann machine that only has connections between visible and hidden units. the energy function of the rbm is defined as follows: \\begin{align} e(v, h) = - \\sum_i v_ib_i - \\sum_k h_kb_k - \\sum_{i,k} v_i h_k w_{i,k} \\end{align} contrastive divergence this is a very efficient training algorithm for boltzmann machines. here is how it works: for each training instance \\(x\\), the algorithm starts by feeding it to the network by setting the state of the visible units to \\(x_1, \\cdots, x_n\\). compute the state of the hidden units by applying the output formula for a hidden neuron (see ), which gives us the vector \\(h\\), where \\(h_i\\) is the output of the ith neuron. next you compute the state of the visible units, by applying the same stochastic equation, which gives you vector \\(x'\\). once again you compute the state of the hidden units, which gives you a vector \\(h'\\). now you can update each connection weight by applying: \\begin{align} w_{i, j} = w_{i, j} + \\eta (xh^t - x'h'^t) \\end{align} the great benefit of this algorithm is that it does not require waiting for the network to reach thermal equilibrium. deep belief nets a deep belief net is an rbm where several layers of rbms can be stacked. such that the hidden units of the first-level rbm serve as the visible units for the second-layer rbm. you can train dbns one layer at a time using contrastive divergence, starting with the lower layers. their lower layers learn low-level features in the input data, while higher layers learn high-level features. thus it learns information in a hierarchical way. just like rbms, dbns are fundamentally unsupervised, but you can also train them in a semi-supervised manner by adding some visible units to represent the labels. the following describes the training process: rbm 1 is trained without supervision. rbm 2 is trained with rbm 1’s hidden units as inputs without supervision rbm 3 is trained using rbm 2’s hidden units as inputs, as well as extra visible units used to represent the target labels one advantage of this semisupervised approach is that you don't need much labeled training data. dbns can also work in reverse. if you activate one of the label units, the signal will propagate up to the hidden units of rbm 3, then down to rbm 2, and then rbm 1, and a new instance will be output by the visible units of rbm 1. this generative capability of dbns is quite powerful. for example, it has been used to automatically generate captions for images, and vice versa: first a dbn is trained (without supervision) to learn features in images, and another dbn is trained (again without supervision) to learn features in sets of captions (e.g., \"car\" often comes with \"automobile\"). then an rbm is stacked on top of both dbns and trained with a set of images along with their captions; it learns to associate high-level features in images with high-level features in captions. next, if you feed the image dbn an image of a car, the signal will propagate through the network, up to the top-level rbm, and back down to the bottom of the caption dbn, producing a caption. due to the stochastic nature of rbms and dbns, the caption will keep changing randomly a dbn, however, suffers from the following problems: inference in dbns is a problem because of the \"explaining away\" effect a dbn can only use greedy retraining and no joint optimization over all layers deep boltzmann machines the distinction between dbm and dbn from the previous section is that dbm information flows on bidirectional connections in the bottom layers. you can also train a dbm using contrastive divergence. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/DL/index.html",
    "title": "Deep Learning",
    "body": " index search search back deep learning fundamentos de las redes neuronales profundas tipologías de las redes neuronales profundas convolutional nets recurrent neural networks boltzmann based networks autoencoders herramientas y estrategias de programación e implemetación de redes neuronales frameworks computación acelerada proveedores redes neuronales convolucionales en visión artificial redes neuronales recurrentes servicios y proveedores de deep learning en la nube $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/DL/03/03_proveedores.html",
    "title": "Proveedores",
    "body": " index search search back proveedores hay básicamente dos tipos de proveedores: locales: scikit-learn,tensorflow, deeplearning4j, pio, h2o, hadoop/spark, etc. orientados a la nube: abm, bigml, google ml, amazonml ,azureml , watson ibm, etc. arquitectura: deep cognition se trata de una plataforma que incorpora un ide visual que permite definir una red neuronal. se puede utilizar: en la nube en local en una máquina virtual en una máquina de azure h2o.ai su arquitecture se detalla en la siguiente imagen: en la parte superior vemos los lenguajes que soporta: seguidamente tenemos un bloque de tradcutores (rapids en c++ y scala en java): a continuación tenemos los algoritmos definidos así como la herramienta de predcción para h2o: en la siguiente imagen tenemos la parte de la gestión de la computación que se lleva a cabo encima de clusters spark/hadoop o sobre la distribución standalone de h2o: auto ml permite evaluar modelos dado un conjunto de datos en base a una serie de métricas: driverless ai permite desarrollar el pipeline completo de h2o de forma visual, tal que permite automatizar tareas. big ml se trata de una empresa española. define algoritmos de clasificación, regresión, análisis de clusters, detección de anomalías, descubrimiento de asociación y modelado. destaca sobretodo en el preprocesamiento de datos, visualización y en la evaluación de modelo. no soporta ni cnn (no soporta capas de convolución ni de pooling) ni rnn. los parámetros soportados son los siguientes: $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/DL/03/01_frameworks.html",
    "title": "Frameworks para Deep Learning",
    "body": " index search search back frameworks para deep learning los frameworks principales son los siguientes: tensorflow torch/pytorch keras caffe theano (está aquí por motivos históricos) una diferencia entre los distinos frameworks radica en la forma de especificar los modelos: a través de ficheros de configuración (caffe, distbelief, cntk) a través de código (torch/pytoch, theano, tensorflow) tensorflow arquitectura tensorflow presenta un núcleo de bajo nivel (c++/cuda). además se define un api python sencillo para definir el gráfico computacional, así como apis de alto nivel (tf-learn, keras, etc) tensorflow vs numpy numpy no dispone de funciones/métodos para la creación de funciones de tensores y no computa automáticamente sus derivadas. numpy no tiene soporte para gpu. modelo computacional de tensorflow tensorflow construye grafos donde cada nodo es un tensor y cada arista es una operación entre los tensores. de tal manera que, como vemos en la figura inferior, se pueden repartir las computaciones entre distintas gpus. lazy evaluation este grafo sólo encompasa la definición de las operaciones, de tal manera que no requiere de su ejecución. si no que la ejecución sólo se produce durante el entrenamiento. tensorflow hub se trata de un repositorio de modelo pre-entrenados. operaciones a continuación mostramos una serie de operaciones soportadas por tensorflow: theano se trata de otro framework, pionero en el uso de grafos computacionales. es una herramienta generalista, tal que podemos implementar cualquier tipo de algoirtmo sobre el framework. además se puede especificar como backend a utilizar en keras, en lugar de tensorflow. sin embargo, finalizó su desarrollo a partir de la versión 1.0. librerías que usan theano keras blocks lasagne sklearn-theano pymc 3 theano-rnn morb además presenta las siguientes características: permite la evaluación lazy del grafo (precursor de esta ténica). da soporte para gpu's. permite la diferenciación simbólica. keras keras puede ser utilizado con tensorflow o también como una librería adicional. además presenta las siguientes ventajas: sencilla para comenzar, y sencilla para avanzar se ejecuta sobre theano y tensorflow disponibilidad de herramientas de visualización (tensorboard) escrita de forma modular: fácil de expandir suficientemente potente para escribir modelos serios pero también presenta las siguiente desventajas: menos flexible menos tipos: no hay modelos rbm, por ejemplo. menos proyectos disponibles online que caffe soporte multi-gpu no del 100% la idea general para la creación de modelos/algoritmos sigue el siguiente esquema: preparar los tensores de entrada y salida crear la primera capa (layer) para manejar el tensor de entrada crear la última capa (layer) para manejar el tensor de salida (targets) construir virtualmente cualquier modelo entre estas dos capas (hidden layers) las definiciones de los modelos pueden ser guardados y recuperados en formato json y en formato yaml. los parámetros también pueden ser guardados y recuperados en formato h5. tipos de modelos keras soporta dos tipos de modelos: modelo secuencial api funcional: se usa para definir modelos complejos: modelos multi-output, grafos acíclicos dirigidos (graph) o modelos con capa compartidas grafo (deprecado) caffe construido sobre c++, cuda. presenta una gran cantidad de modelos pre-entrenados la definición de modelos de hace de forma declarativa: cuáles son sus aplicaciones? object detection pixelwise prediction torch su backend está basado en c y en cuda. su frontend está escrito sobre lua. pytorch torch en python. fast.ai es muy similar a keras, fast.ai permite generar herramientas y modelos pre-entranados de manera muy sencilla. aplicaciones de dl visión speech recognition nlp $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/DL/03/02_computacion_acelerada.html",
    "title": "Computación Acelerada",
    "body": " index search search back computación acelerada diferencias cpu/gpu una cpu tiene un número limitado de cores, mientras que una gpu tiene un número muy elevado de cores. una gpu tiene procesadores menos potentes (menos operaciones por ciclo), sin embargo tiene muchas más unidades lógicas-aritméticas (alu), por lo que tiene más capacidad de cálculo a coste de tener menos capacidad de manejo de almacenamiento. proveedores nvidia: se basa en la arquitecture compute unified device architecture (cuda). amd: se basa en una arquitectura más abierta, heterogeneous system architecture (hsa), que es multiplataforma. su arquitectura se puede utilizar con distintos proveedores, p.ej. nvidia. flujo de procesamiento en cuda plataformas tpu diseñado por google especialmente diseñado para operaciones matriciales y tensores. su uso fundamental es en el entrenamiento de redes neuronales y la inferencia. por qué utilizar tpus? según google: son 30x más rápidos que gpus y cpus. presentan una gran eficiencia energética. las nn desarrolladas con tensorflow requieren muy pocas líneas de código. requieren menos tiempo -> menos dinero. cuándo deberíamos utilizar una tpu? versiones hay dos versiones: v2: hbm de 8 gb/tpu core. 1mxu (128x128) por core. tpu pod, hasta 512 cores (4tb de memoria) v3: hbm de 16 gb/tpu core. 2 mxu (128x128) por core. tpu pod, hasta 2048 cores (32 tb de memoria) flujo de ejecución de tpus $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/2C_2C/DL/06_cloud_services.html",
    "title": "Servicios y Proveedores de Deep Learning en la Nube",
    "body": " index search search back servicios y proveedores de deep learning en la nube no se trata de una tecnología, si no que es un servicio. se definen tres capas distintas de servicio: algunos ejemplos son: modelos de despliegue google cloud platform: machine learning engine aws machine learning microsoft azure: machine learning studio ibm watson machine learning y data studio características it services catalog global network access instant elasticity chargeback common it-resouces pool capacidades saas (software as a service): se utiliza/alquila un servicio concreto, p.ej. one drive. paas (platform as a service): permite tener entornos preconfigurados para poder ejecutar ciertos conjuntos de aplicaciones. iaas (infraestructure as a service): se da acceso a la infraestructura, tal que te permite utilizarla para ejecutar los servicios que tu convengas. modelos de despliegue como modelos de despliegue tenemos: private cloud: se cierra el acceso para que sólo la propia infraestructura tenga acceso. community cloud: conjunto de nubes públicas que comparten recursos. hybrid cloud: tiene parte pública y tiene parte a la que se restringe el acceso. public cloud: permite el acceso desde la nube pública de internet. google cloud platform a continuación mostramos el ciclo completo de desarrollo de soluciones ml, y las herramientas de gcp asociadas y disponibles para cada una de ellas: en la fase de desarrollo se definen varias herramientas: data labeling service: se encarga del etiquetamiento correcto de los datos de forma semiautomática. deep learning vm image: proporciona imágenes virtuales sobre las cuales llevar a cabo el procesamiento. api platform notebook awm machine learning la estructura se divide en tres bloques, de menor a mayor abstracción: infraestructura plataformas servicios how to use amazon sagemaker $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/Master/index.html",
    "title": "Data Science Master",
    "body": " index search search back data science master 2c 2c aprendizaje automático ii deep learning modelos bayesianos jerárquicos $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/DataScience/index.html",
    "title": "Data Science",
    "body": " index search search back data science master machine learning stanford coursera artificial intelligence in robotics online training mobile robotics standalone topics ukf $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/index.html",
    "title": "Notes",
    "body": " index search search back notes math computer science data science other $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/CG/RTGW/02.html",
    "title": "Rendering",
    "body": " index search search back rendering webgl rendering pipeline webgl runs on the gpu on your computer. as such, you need to provide code that runs on that gpu. this code is comprised by two functions called vertex shader and fragment shader, written in a very strictly-typed c/c++-like language called glsl, gl shader language. together, they are called a program. a vertex shader's job is to compute vertex attributes, it outputs values that can be used to rasterize various kinds of primitives, including points, lines, and triangles. a fragment shader's job is to compute a color for each pixel of the primitive currently being drawn. let's examine what webgl's rendering pipeline. the following is a diagram of a simplified version of webgl's rendering pipeline: vertex buffer objects (vbos) vbos contain the data that is used to describe the geometry to be rendered. vertex coordinates, are usually stored and processed in webgl as vbos. index buffer objects (ibos) ibos contain information about the relationship of the vertices. it uses the index of each vertex in the vertex buffer as a value. vertex shader the vertex shader is called on each vertex. the shader manipulates per-vertex data. fragment shader each surface element (pixel) is called a fragment. the main goal of the fragment shader is to calculate the color of individual pixels. framebuffer the framebuffer is a two-dimensional buffer contains the fragments that have been processed by the fragment shader. attributes attributes are input variables that are used in the vertex shader. for example, you may put three dimensional \\(32\\)-bit vectors in a buffer. you would tell a particular attribute which buffer to pull the vectors out of, what type of data it should pull out (\\(3\\)-component, \\(32\\)-bit floating point numbers), what offset in the buffer the positions start at, and how many bytes to get from one position to the next. uniform uniforms are input variables that are available to both the vertex shader and the fragment shader. unlike attributes, uniforms are constant during a rendering cycle. textures textures are arrays of data that can be accessed in your shader program. image data is the most common thing to put in a texture. varyings varyings are used to pass data from the vertex shader to the fragment shader. the values set on a varying by a vertex shader will be interpolated while executing the fragment shader. rendering in webgl there are two data types that are fundamental: vertices and indices. vertices are the points that define the corners of 3d objects. each vertex is represented by three floating-point numbers that correspond to the x, y, and z coordinates of the vertex. indices are numeric labels for the vertices in a given 3d scene. indices allow us to tell webgl how to connect vertices in order to produce a surface. both vertices and indices are stored on a javascript array and passed to webgl's rendering pipeline. defining a geometry using javascript arrays as you can see from the preceding illustration, we have placed the coordinates sequentially in the vertex array and then indicated how these coordinates are used to draw the trapezoid in the index array. triangles in the index array are usually, but not necessarily, defined in counter-clockwise order. it's important to pick one approach and keep it consistent because programs may use the clockwise/counter-clockwise order to determine whether a face is facing forward or backward for culling and rendering purposes. in computer graphics, back-face culling determines whether a polygon of a graphical object is visible. creating webgl buffers let's render a square. we define the vertices, and create the respective buffer. these vertices are defined in clipspace coordinates, because webgl only deals with clipspace coordinates. clipspace coordinates always go from \\(-1\\) to \\(+1\\). const vertices = [ -0.5, 0.5, 0, -0.5, -0.5, 0, 0.5, -0.5, 0, 0.5, 0.5, 0 ]; const positionbuffer = gl.createbuffer(); now, when positionbuffer is made the currently-bound webgl buffer any subsequent buffer operation will be executed on this buffer until it is unbound, or another buffer is made the current one. gl.bindbuffer(gl.array_buffer, positionbuffer); the first parameter is the type of buffer we are creating: gl.array_buffer: vertex data gl.element_array_buffer: index data once we have bound a buffer, we need to pass along its contents. gl.bufferdata(gl.array_buffer, new float32array(vertices), gl.static_draw); the last argument is the type, which is a performance hint for webgl. the accepted values for type are as follows: static_draw: data in the buffer will not be changed (specified once and used many times) dynamic_draw: data will be changed frequently (specified many times and used many times) stream_draw: data will change on every rendering cycle (specified once and used once) webgl requires javascript typed array so that the buffer data can be processed in its native binary form with the objective of speeding up geometryprocessing performance. the typed arrays used by webgl include int8array, uint8array, int16array, uint16array, int32array, uint32array, float32array, and float64array. it's important to note that vertex coordinates can be float, but indices are always integers. finally, it is a good practice to unbind the buffer. gl.bindbuffer(gl.array_buffer, null); all this same process applies for the index buffer. associating attributes to vbos once we have created the vbos, we need to associate these buffers to vertex shader attributes. each vertex shader attribute will refer to one and only one buffer. we can achieve this by following these steps: bind a vbo gl.bindbuffer(gl.array_buffer, mybuffer); point an attribute to the currently-bound vbo gl.vertexattribpointer(index, size, type, normalize, stride, offset); index: attribute's index that we are bounding the currently-bound buffer to (i.e. avertexposition) size: number of values per vertex that are stored in the currently-bound buffer. type: data type of the values stored in the current buffer (fixed, byte, unsigned_byte, float, short, unsigned_short) normalize: beyond scope (set to false) stride: if stride is 0, then we are indicating that elements are stored sequentially in the buffer. offset: the position in the buffer from which we will start reading values for the corresponding attribute. generally \\(0\\). enable the attribute gl.enablevertexattribarray(positionattributelocation); unbind gl.bindbuffer(gl.array_buffer, null); rendering drawing functions the drawarrays and drawelements functions are used for writing to the framebuffer. drawarrays uses vertex data in the order in which it is defined in the buffer to create the geometry. in contrast, drawelements uses indices to access the vertex data buffers and create the geometry. both drawarrays and drawelements will only use enabled arrays. using drawarrays we will call drawarrays when information about indices is not available. in most cases, drawarrays is used when the geometry is simple enough that defining indices is overkill. when we want to render a triangle or a rectangle. in that case, webgl will create the geometry in the order in which the vertex coordinates are defined in the vbo. if you have contiguous triangles (as we did in the trapezoid example), you will have to repeat these coordinates in the vbo. if you need to repeat many vertices to create the geometry, drawarrays is not the optimal method. the more vertex data you duplicate, the more calls you will have on the vertex shader, one per vertex. the signature for drawarrays is as follows: gl.drawarrays(mode, first, count) where: mode: the type of primitive that we are going to render: gl.points, gl.line_strip, gl.line_loop, gl.lines, gl.triangle_strip, gl.triangle_fan, and gl.triangles. first: the starting element in the enabled arrays. count: the number of elements rendered. using drawelements drawelements allows us to use the ibo to tell webgl how to render the geometry. therefore, vertices are only processed once, and can be used as many times as they are defined in the ibo. this feature reduces both the memory and processing required on the gpu. when we use drawelements, we need at least two buffers: a vbo and an ibo. as the vertex shader gets executed on each vertex, the rendering pipeline assembles the geometry into triangles using the ibo. the signature for drawelements is as follows: gl.drawelements(mode, count, type, offset) where: mode: the type of primitive that we are going to render: gl.points, gl.line_strip, gl.line_loop, gl.lines, gl.triangle_strip, gl.triangle_fan, and gl.triangles. count: the number of elements rendered. type: the type of the values in indices: unsigned_byte or unsigned_short. offset: which element in the buffer will be the starting point for rendering. rendering a square we first, compile each shader as follows: /** * compiles the vertex or fragment shader */ export const compileshader = ( gl: webgl2renderingcontext, type: program_type, source: string ) => { let shader; if (type === program_type.vertex) { shader = gl.createshader(gl.vertex_shader); } else { shader = gl.createshader(gl.fragment_shader); } if (!shader) return; gl.shadersource(shader, source); gl.compileshader(shader); if (!gl.getshaderparameter(shader, gl.compile_status)) { console.error(gl.getshaderinfolog(shader)); return null; } return shader; }; we use this utility function to create the program: /** * creates a program that is made up of a vertex shader and a fragment shader */ export const createprogram = ( gl: webgl2renderingcontext, vertexshadersource: string, fragmentshadersource: string ) => { // obtain the shaders const vertexshader = compileshader( gl, program_type.vertex, vertexshadersource ); const fragmentshader = compileshader( gl, program_type.fragment, fragmentshadersource ); // create a program const program = gl.createprogram(); if (!program || !vertexshader || !fragmentshader) { throw \"could no create program\"; } // attach the shaders to this program gl.attachshader(program, vertexshader); gl.attachshader(program, fragmentshader); gl.linkprogram(program); if (!gl.getprogramparameter(program, gl.link_status)) { throw \"could not initialize shaders\"; } // use this program instance gl.useprogram(program); return program; }; once the program has been created, we populate our buffers: /** draws square on center of clipspace x in (-1, 1), y in (-1, 1) * 0->(-0.5, 0.5) 3->(0.5, 0.5) * +-------------+ * | / | * | / | * | / | * | / | * +-------------+ * 1->(-0.5, -0.5) 2->(0.5, -0.5) * */ // define vertices for position on space: the depth (z) is not important for now const vertices = [-0.5, 0.5, 0, -0.5, -0.5, 0, 0.5, -0.5, 0, 0.5, 0.5, 0]; // define indices for identifying triangles that make up the geometry // using counter-clock wise order // first triangle is made up from the vertices 0, 1, and 2, the second triangle // is made up of vertices 1, 2 and 3 indices = [0, 1, 3, 1, 2, 3]; // set up vbo verticesbuffer = gl.createbuffer(); gl.bindbuffer(gl.array_buffer, verticesbuffer); gl.bufferdata(gl.array_buffer, new float32array(vertices), gl.static_draw); // set up ibo indicesbuffer = gl.createbuffer(); gl.bindbuffer(gl.element_array_buffer, indicesbuffer); gl.bufferdata( gl.element_array_buffer, new uint16array(indices), gl.static_draw ); // unbind buffers gl.bindbuffer(gl.array_buffer, null); gl.bindbuffer(gl.element_array_buffer, null); now, in order to draw, we bind our buffers again and the we bind and enable the attributes: // clear the scene gl.clear(gl.color_buffer_bit | gl.depth_buffer_bit); gl.viewport(0, 0, gl.canvas.width, gl.canvas.height); // bind the vertex buffer with an attribute gl.bindbuffer(gl.array_buffer, verticesbuffer); // obtain attribute instance const vertexpositionattr = gl.getattriblocation(program, \"avertexposition\"); // bind attibute to buffer and set some metadata gl.vertexattribpointer(vertexpositionattr, 3, gl.float, false, 0, 0); // enable attribute gl.enablevertexattribarray(vertexpositionattr); // bind ibo gl.bindbuffer(gl.element_array_buffer, indicesbuffer); // draw to the scene using triangle primitives gl.drawelements(gl.triangles, indices.length, gl.unsigned_short, 0); // unbind buffers gl.bindbuffer(gl.array_buffer, null); gl.bindbuffer(gl.element_array_buffer, null); vertex array objects vertex array objects (vaos) allow you to store all of the vertex/index binding information for a set of buffers in a single, easy to manage object. this is an important feature that should always be used, since it significantly reduces rendering times. when not using vaos, all attributes data is in global webgl state, which means that calling functions such as gl.vertexattribpointer, gl.enablevertexattribarray, and gl.bindbuffer(gl.element_array_buffer, buffer) manipulates the global state. this leads to performance loss, because before any draw call, we would need to set up all vertex attributes and set the element_array_buffer where indexed data is being used. with vaos, we would set up all attributes during our application's initialization and simply bind the data at render, yielding much better performance. so how would we use a vao. there are two steps that change, firstly when we populate our data we create a vao object alongside our vbo and ibo. and we also create create and enable here our vertex attributes. // define vertices for position on space: the depth (z) is not important for now const vertices = [-0.5, 0.5, 0, -0.5, -0.5, 0, 0.5, -0.5, 0, 0.5, 0.5, 0]; // define indices for identifying triangles that make up the geometry // using counter-clock wise order // first triangle is made up from the vertices 0, 1, and 2, the second triangle // is made up of vertices 1, 2 and 3 indices = [0, 1, 3, 1, 2, 3]; // set up vao vao = gl.createvertexarray(); gl.bindvertexarray(vao); // set up vbo (used inside vao) const verticesbuffer = gl.createbuffer(); gl.bindbuffer(gl.array_buffer, verticesbuffer); gl.bufferdata(gl.array_buffer, new float32array(vertices), gl.static_draw); // tell vao how to use the current bound buffer (vertices buffer!) // refer to 01_square.html and see how now the definition of how the data should // be retrived is done now on initialization instead of on render. // obtain attribute instance const vertexpositionattr = gl.getattriblocation(program, \"avertexposition\"); gl.enablevertexattribarray(vertexpositionattr); gl.vertexattribpointer(vertexpositionattr, 3, gl.float, false, 0, 0); // set up ibo indicesbuffer = gl.createbuffer(); gl.bindbuffer(gl.element_array_buffer, indicesbuffer); gl.bufferdata( gl.element_array_buffer, new uint16array(indices), gl.static_draw ); // unbind buffers gl.bindvertexarray(null); gl.bindbuffer(gl.array_buffer, null); gl.bindbuffer(gl.element_array_buffer, null); and, in order to draw we simply bind our vao and our ibo to be used with drawelements. // clear the scene gl.clear(gl.color_buffer_bit | gl.depth_buffer_bit); gl.viewport(0, 0, gl.canvas.width, gl.canvas.height); // bind vao gl.bindvertexarray(vao); // bind ibo gl.bindbuffer(gl.element_array_buffer, indicesbuffer); // draw to the scene using triangle primitives gl.drawelements(gl.triangles, indices.length, gl.unsigned_short, 0); // unbind buffers gl.bindvertexarray(null); gl.bindbuffer(gl.element_array_buffer, null); drawelements modes triangles: webgl will use the first three indices defined in your ibo to construct the first triangle, the next three to construct the second triangle, and so on. lines: will instruct webgl to take each consecutive pair of indices defined in the ibo and draw lines by taking the coordinates of the corresponding vertices. points: webgl will not generate surfaces. instead, it will render the vertices that we had defined using the index array. lines_loop: draws a closed loop connecting the vertices defined in the ibo to the next one. line_strip: is similar to line_loop. the difference is that webgl does not connect the last vertex to the first one. triangle_strip: draws connected triangles. every vertex is specified after the first three. triangle_fan: fan creates triangles in a similar way to triangle_strip. however, the first vertex defined in the ibo is taken as the origin of the fan (the only shared vertex among consecutive triangles). webgl as a state machine: buffer manipulation when dealing with buffers for the getparameter, getbufferparameter, and isbuffer functions, new information about the state of the rendering pipeline becomes available to us. getparameter(parameter), we use parameter to retrieve a reference to the currently-bound vbo (parameter=array_buffer_binding) or to retrieve a reference to the currently-bound ibo (parameter=element_array_buffer_bindings). we can also query the size and the usage of the currently-bound vbo and ibo using getbufferparameter(type, parameter), where type can have the following values: array_buffer: to refer to the currently-bound vbo element_array_buffer: to refer to the currently-bound ibo and parameter can have the following values: buffer_size: returns the size of the requested buffer buffer_usage: returns the usage of the requested buffer finally, isbuffer(object) will return true if the object is a webgl buffer, or false with an error when the buffer is invalid. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/CG/RTGW/01.html",
    "title": "Getting Started",
    "body": " index search search back getting started webgl is a 3d graphics library that enables modern web browsers to render 3d scenes in a standard and efficient manner. software and hardware based rendering the first distinction we should make is whether we are using any special graphics hardware. on one hand, we can talk about software-based rendering for cases where all required calculations to render 3d scenes are performed using the computer's central processing unit (cpu). on the other hand, as is the case with webgl, we use the term hardware-based rendering for scenarios where there is a gpu performing 3d graphics computations. hardware-based rendering is much more efficient than software-based rendering, because the former involves dedicated hardware handling the necessary operations. server and client based rendering the second distinction to make is whether the rendering process is happening locally or remotely. when the image that needs to be rendered is too complex, the render will most likely occur remotely. we call this server-based rendering. the opposite of this approach takes place when rendering occurs locally. we call this client-based rendering. webgl offers a client-based rendering approach: the processing required to obtain an image is all performed locally using the client's graphics hardware. webgl presents several advantages javascript programming automatic memory management pervasiveness performance zero compilation retained and immediate mode rendering in th retained-mode the graphics library maintains a scene model in memory, to change what is rendered, the application issues a command to update the scene. in the inmediate-mode each time a new frame is drawn the application issues all drawing commands required to describe the entire scene. retained-mode rendering can be simpler to use, because the api does more of the work for you, such as initialization, state maintenance, and cleanup. however, it is often less flexible since the api forces its own particular scene model; it can also have higher memory prerequisites. immediate-mode rendering, on the other hand, as offered with webgl, is much more flexible and can implement targeted optimizations. elements in a webgl application some of these common elements include: canvas: the placeholder where our scene is rendered. objects: the 3d entities that make up the scene. lights camera accessing the webgl context a webgl context is an object through which we can access webgl functions and attributes. <script type=\"text/javascript\"> 'use strict'; function init() { const canvas = document.getelementbyid('webgl-canvas'); // ensure we have a canvas if (!canvas) { console.error('sorry! no html5 canvas was found on this page'); return; } const gl = canvas.getcontext('webgl2'); } // call init once the document has loaded window.onload = init; </script> a webgl context can be understood as a state machine: once you modify attributes, the modifications persist until later modifications. for example: const color = gl.getparameter(gl.color_clear_value); here gl.color_clear_value is one of the webgl context attributes. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/CG/RTGW/index.html",
    "title": "Real-Time 3D Graphics with WebGL 2",
    "body": " index search search back real-time 3d graphics with webgl 2 getting started rendering $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/index.html",
    "title": "Computer Science",
    "body": " index search search back computer science computer architecture the elements of computer systems computer graphics real-time 3d graphics with webgl 2 web webdev $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/CA/ECS/04.html",
    "title": "Machine Language",
    "body": " index search search back machine language overview hardware elements a machine language can be viewed as an agreed-upon formalism designed to manipulate a memory using a processor and a set of registers. memory: refers to the collection of hardware devices that store data and instructions. it is a continuous sequence of cells, also referred to as locations or memory registers, each having a unique address. processor: the processor, central processing unit, or cpu, is a device capable of performing a fixed set of primitive operations: arithmetic, locical operation, memory access operations and control (branching) operations. it consists of an alu, a set of registers, and gate logic that enables it to parse and execute binary instructions. registers: moving data from the memory to the processor is relatively slow. for this reason, processors are normally equipped with several onboard registers inside the processor's chip that serves as high-speed local memory. these registers fall into two categories: data registers, which hold data values, and address registers, which hold values that can be interpreted either as data values or as memory addresses. languages machine language programs can be written in two ways: binary and symbolic. symbolic machine languages are called assembly languages, and the programs that translate them into binary code are called assemblers. the syntax of an assembly language is tightly related to the low-level details of the target hardware: the available alu operations, number and type of registers, memory size, and so on. instructions arithmetic and logical operations: every machine language features instructions for performing basic arithmetic operations: memory access: every machine language features means for accessing and manipulating selected memory locations. this is typically done using an address register, \\(a\\). for example, suppose we wish to set memory location \\(17\\) to the value \\(1\\). we can decide to do so using the two instructions load a,17 followed by load m,1, where, by convention, \\(m\\) stands for the memory register selected by \\(a\\). flow control: to facilitate branching actions, machine languages feature several variants of conditional and unconditional goto instructions, as well as label declaration statements that mark the goto destinations (see figure 4.1). symbols: code that uses symbolic references is much easier to write, debug and maintain. also low-level code that mentions no physical addresses is said to be relocatable. the hack machine language background hack is a \\(16\\)-bit computer, meaning that the cpu and the memory units are designed to process, move, and store, chunks of \\(16\\)-bit values. memory: the hack platform uses two distinct memory units: a data memory and an instruction memory. the data memory (which we also call ram) is a read/write device. so hack instructions can read data from, and write data to, selected ram registers. the current data register is referred as \\(m\\). the instruction memory (which we also call rom) is a read-only device, and programs are loaded into it. the current instruction register is referred as the current instruction. registers: hack instructions are designed to manipulate three \\(16\\)-bit registers: a data register, denoted d, an address register, denoted a, and a selected data memory register, denoted m. addresing: the hack instruction @xxx sets the a register to the value xxx. this has two side effects: it makes the ram register whose address is xxx the selected memory register it makes the value of the rom register whose address is xxx the selected instruction which action to pursue is determined by the subsequent hack instruction. branching: for example jo jump to instruction number \\(29\\) we would use these two instructions: @29, 0;jmp. the first instruction selects the rom[29] register and the second one realizes an unconditional jump to execute said instruction. the hack language also features conditional branching. variables: the xxx in the hack instruction @xxx can be either a constant or a symbol. the use of symbols endows hack assembly programs with the ability to use variables. for example let x = 17 translates to: @17 d=a @x which basically selects the ram register whose address is the value that is bound to the symbol x, and set this register to \\(17\\). we assume that there is an agent who knows how to bind the symbols to addresses (the assembler). on the following figure the show an example of the tranlation of pseudocode to our assembly language: the hack language specification the hack machine language consists of two instructions, specified in figure 4.5. the a-instruction the a-instruction sets the a register to some \\(15\\)-bit value. the binary version consists of two fields: an operation code (op-code), which is \\(0\\), followed by fifteen bits that code a nonnegative binary number. the a-instruction is used for three different purposes: it's the only way to enter a constant into the computer. sets the stage for a subsequent c-instruction that manipulates a selected ram register. sets the stage for a subsequent c-instruction that specifies a jump. the c-instruction the c-instruction answers three questions: what to compute (an alu operation, denoted comp) where to store the computed value (dest) what to do next (jump) in the binary version, the leftmost bit is the c-instruction’s op-code, which is \\(1\\). the next two bits are not used, and are set by convention to \\(1\\). computation specification (comp) the computed function is specified by the a-bit and the six c-bits comprising the instruction's comp field. this \\(7\\)-bit pattern can potentially code \\(128\\) different calculations, of which only the twenty-eight listed in figure 4.5. in the alu the first input feeds from the d register, while the second alu input feeds either from the a register (when the a-bit is \\(0\\)) or from m, the selected data memory register (when the a-bit is \\(1\\)). destination specification (dest) the alu output can be stored in zero, one, two, or three possible destinations, simultaneously. the first and second d-bits code whether to store the computed value in the a register and in the d register, respectively. the third d-bit codes whether to store the computed value in m, the currently selected memory register. jump directive (jump) the jump field of the c-instruction specifies what to do next. there are two possibilities: fetch and execute the next instruction in the program, the default. fetch and execute some other instruction. in the latter case, we assume that the a register was already set to the address of the target instruction. whether or not to jump is determined jointly by the three j-bits. this gives eight possible jump conditions, listed on figure 4.5. symbols assembly instructions can specify memory locations (addresses) using either constants or symbols. predefined symbols r0, r1, …, r15: bound to the values \\(0\\) to \\(15\\). sp, lcl, arg, this, that: bound to the values \\(0\\), \\(1\\), \\(2\\), \\(3\\), and \\(4\\), respectively screen, kbd: bound, respectively, to the values \\(16384\\) and \\(24576\\). which are the base addresses of the screen memory map and the keyboard memory map. layer symbols the syntax (xxx) binds the symbol xxx to the address of the next instruction in the program. variable symbols any symbol xxx appearing in a hack assembly program that is not predefined and is not declared elsewhere using (xxx) is treated as a variable and is bound to a unique running number starting at \\(16\\). input/output handling the hack hardware platform can be connected to two peripheral i/o devices: a screen and a keyboard. screen: the computer interacts with a black-and-white screen organized as \\(256\\) rows of \\(512\\) pixels per row. so it is associated to a memory map stored in an \\(8\\)k memory block of \\(16\\)-bit words, starting at ram address \\(16384\\). each row in the physical screen, starting at the screen's top-left corner, is represented in the ram by \\(32\\) consecutive \\(16\\)-bit words. note that we cannot access individual pixels/bits directly, we must fetch a complete \\(16\\)-bit word (\\(16\\) pixels). keyboard: the computer can interact with a standard physical keyboard via a single-word memory map located at ram address \\(24576\\). when a key is pressed on the physical keyboard, its \\(16\\)-bit character code appears at ram[kbd]. when no key is pressed, the code \\(0\\) appears. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/CA/ECS/02.html",
    "title": "Boolean Arithmetic",
    "body": " index search search back boolean arithmetic general-purpose computer systems are required to perform at least the following arithmetic operations on signed integers: addition sign conversion subtraction comparison multiplication division inside computers, everything is represented using binary codes. word size is a hardware term used for specifying the number of bits that computers use for representing a basic chunk of information. the fixed word size implies that there is a limit on the number of values that these registers can represent. for example, suppose we use 8-bit registers for representing integers. this representation can code \\(2^8 = 256\\). to represent numbers greater than, or less than, the maximal and minimal values permitted by the fixed register size is typically implemented by lashing together as many \\(n\\)-bit registers as necessary. binary addition a pair of binary numbers can be added bitwise from right to left by adding the two rightmost bits (lest significant bits or lsb). next, we add the resulting carry bit to the sum of the next pair of bits. we continue until the two left most significan bits (msb) are added. if the most significant bitwise addition generates a carry of 1, we have what is known as overflow. signed binary numbers we use two's complement (also known as radix complement) for representing signed numbers in binary code. given a word size of \\(n\\) bits, the two's complement for negative \\(x\\) is given by the binary code of \\(2^n - x\\). the two’s complement representation has the following attractive properties: the system codes signed numbers, ranging from \\(-(2^{n-1})\\) to \\(2^{n-1} - 1\\) the code of any nonnegative number begins with a \\(0\\). the code of any negative number begins with a \\(1\\). to obtain the binary code of \\(-x\\) flip all the bits of x and add 1 to the result. subtraction is handled as a special case of addition. adders half adders: adds two bits, outputs two bits. full adder: adds three bits, outputs two bits. adder: adds two \\(n\\)-bit numbers. incrementer: adds \\(1\\) to a given number (spoiler: this will enable fetching the next instruction from memory, after executing the current one). the arithmetic logic unit an arithmetic logic unit is a chip designed to compute a set of arithmetic and logic operations. exactly which operations an alu should feature is a design decision. this alu design is unique to the computer built in nand to tetris, named hack. as seen in figure 2.5a, the hack alu operates on two \\(16\\)-bit two's complement integers, denoted \\(x\\) and \\(y\\), and on six \\(1\\)-bit inputs, called control bits. these control bits tell the alu which function to compute. the exact specification is given in figure 2.5b. note that each one of the six control bits is associated with a standalone, conditional micro-action. the six directives are to be performed in order: we either set the \\(x\\) and \\(y\\) inputs to \\(0\\), or not we either negate the resulting values, or not we compute either \\(+\\) or \\(\\&\\) on the preprocessed values we either negate the resulting value, or not. all these settings, negations, additions, and conjunctions are \\(16\\)-bit operations. note that the alu actually computes a total of sixty-four functions, since six control bits code that many possibilities. we’ve decided to focus on, and document, only eighteen of these possibilities, since these will suffice for supporting the instruction set of our target computer system $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/CA/ECS/01.html",
    "title": "Boolean Logic",
    "body": " index search search back boolean logic boolean algebra boolean algebra manipulates two-state binary values. on figure 1.1 we present three commonly used boolean functions, also known as boolean operators. these functions are named and, or, and not. figure 1.2 begs the question: what makes and, or, and not more interesting? a deeper answer is that various subsets of logical operators can be used for expressing any boolean function, and {and, or, not} is one such subset. also, any one of these three basic operators can be expressed using nand gates only. every boolean function can be defined using two alternative representations: truth tables or boolean expressions. given a boolean function of n variables represented by a boolean expression, we can always construct from it the function’s truth table and vice-versa. note that every boolean function can be represented by many different yet equivalent boolean expressions. so the ability to simplify a boolean expression is the first step toward hardware optimization. logic gates a gate is a physical device that implements a simple boolean function. gates can be realized with any alternative technology permitting switching and conducting capabilities. many hardware implementations of boolean functions were created, including magnetic, optical, biological, hydraulic, pneumatic, quantum-based, and even domino-based mechanisms. today, gates are typically implemented as transistors etched in silicon, packaged as chips. this means computer scientists don't have to worry about physical artifacts and can be content with the abstract notions of boolean algebra and gate logic, trusting blissfully that someone else will realize them in hardware. primitive and composite gates since all logic gates have the same input and output data types (0's and 1's), they can be combined, creating composite gates of arbitrary complexity. the right side of figure 1.5 gives the gate's internal architecture, or implementation, whereas the left side shows its interface. note that the interface of any given gate is unique, however it can be realized in many different ways. from an efficiency standpoint, the general rule is to try to use as few gates as possible. to sum up, the art of logic design can be described as follows: given a gate abstraction (also referred to as specification, or interface), find an efficient way to implement it using other gates that were already implemented. hardware construction today, hardware designers design the chip architecture using a formalism called hardware description language, or hdl by writing an hdl program. while the tests are carried out using computer simulation. the hardware designer will typically be interested in a variety of parameters such as speed of computation, energy consumption and the overall cost implied by the implementation. all these parameters can be simulated. after all tests and optimizations have been performed the final version of the hdl program can become the blueprint for the physical chip. figure 1.7, shows brief introduction to hdl, using an xor gate example. specification not: this gate outputs the opposite value of its input's value. and: returns 1 when both its inputs are 1, and 0 otherwise or: returns 1 when at least one of its inputs is 1, and 0 otherwise xor: also known as exclusive or, this gate returns 1 when exactly one of its inputs is 1, and 0 otherwise nand: realizes the following boolean function: multiplexer: a multiplexer is a three-input gate (see figure 1.9). the multiplexer uses sel to select and output the value of either \\(a\\) or \\(b\\). demultiplexer: takes a single input value and routes it to one of two possible outputs, according to a selector bit (see figure 1.10). multi-bit versions of basic gates computer hardware is often designed to process multi-bit values—for example 16-bit inputs. multi-bit not: an n-bit not gate applies the boolean operation not to every one of the bits in its n-bit input. multi-bit and: an n-bit and gate applies the boolean operation and to every respective pair in its two n-bit inputs multi-bit or: an n-bit or gate applies the boolean operation or to every respective pair in its two n-bit inputs multi-bit multiplexer: an n-bit multiplexer operates exactly the same as a basic multiplexer, except that its inputs and output are n-bits wide multi-way versions of basic gates these are logic gates that can operate on more than two inputs, for example: multi-way or: an m-way or gate outputs 1 when at least one of its m input bits is 1, and 0 otherwise. multi-way/multi-bit multiplexer: an \\(m\\)-way \\(n\\)-bit multiplexer selects one of its \\(m\\) \\(n\\)-bit inputs, and outputs it to its \\(n\\)-bit output. the selection is specified by a set of \\(k\\) selection bits, where \\(k = \\log_2 m\\). for example, a \\(4\\)-way multiplexer is shown on the following image: $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/CA/ECS/index.html",
    "title": "The Elements of Computer Systems",
    "body": " index search search back the elements of computer systems hardware boolean logic boolean arithmetic memory machine language $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/CA/ECS/03.html",
    "title": "Memory",
    "body": " index search search back memory so far, all the chips were time independent, that is combinatorial. we introduce sequential chips, that depend not only on the inputs in the current time but also on inputs and outputs that have been processed previously. we model the progression of time using a clock that generates an ongoing train of binary signals that we call tick and tock. the time between the beginning of a tick and the end of the subsequent tock is called a cycle. memory devices a data flip flop (dff) is a time-dependent logic gate that can flip and flop between two stable states: representing \\(0\\) and \\(1\\). dffs are used as low-level chip-parts embedded deep within other memory devices (see figure 3.1.). dffs can be used to create \\(1\\)-bit registers and \\(n\\) such registers can be lashed together to create an \\(n\\)-bit register. next, a ram device is constructed using an arbitrary number of such registers. sequential logic on any operation outputs are always delayed, due to at least two reasons: the signal that represent the inputs travel from the outputs of other chips, which takes time. the computations that chips perform also take time. thus, time is an issue we must deal with. as seen at the top of figure 3.2, time is viewed as an arrow that progresses relentlessly forward. this progression is taken to be continuous: between every two time-points there is another time-point, and changes in the world can be infinitesimally small. instead of viewing time as a continuous progression, we break it into fixed-length intervals, cycles. where cycles are atomic and indivisible: changes in the world occur only during cycle transitions; within cycles, the world stands still. this discrete view of time serves two design objectives: it can be used for neutralizing the randomness associated with communications and computation time delays. second, it can be used for synchronizing the operations of different chips across the system. let's focus on the bottom part of figure 3.2, which tracks how a not gate (used as an example) responds to arbitrarily chosen inputs. when we feed the gate with \\(1\\), it takes a while before the gate's output stabilizes on \\(0\\). however, since the cycle duration is—by design—longer than the time delay, when we reach the cycle's end, the gate output has already stabilized on \\(0\\). therefore the cycle's length must be longer than the maximal time delays that can occur in the system. in practice, we design our hardware such that the cycle is sufficiently long to contain any possible time delay taking into acount that, the shorter the cycle, the faster the computer. to sum up, the cycle length is chosen to be slightly longer than the maximal time delay in any chip in the system. typically, the cycles are realized by an oscillator that alternates continuously between two phases labeled \\(0\\)−\\(1\\), low-high, or ticktock. using the hardware’s circuitry, the same master clock signal is simultaneously broadcast to every memory chip in the system. in every such chip, the clock input is funneled to the lower-level dff gates. flip-flops the low-level devices that facilitate the memory/storage abstraction are named flip-flop gates, in our case, data flip-flop or dff, whose interface includes a single-bit data input and a single-bit data output. in addition, the dff has a clock input that feeds from the master clock’s signal. taken together, the data input and the clock input enable the dff to implement the following behaviour \\(out(t) = in(t - 1)\\) combinational and sequential logic the most fundamental sequential gate is the dff, and any chip that includes it is also said to be sequential. as shown in figure 3.4, these sequential chips may also interact with combinational chips. in combinational chips, the introduction of feedback loops is problematic, because the output would depend on itself. however, if the feedback loop goes through a dff gate: the dff introduces an inherent time delay so that the output at time \\(t\\) does not depend on itself but rather on the output at time \\(t - 1\\). the time dependency of sequential chips has an important side effect that serves to synchronize the overall computer architecture. suppose we instruct the alu to compute \\(x + y\\), because of physical constraints the electric signals representing \\(x\\) and \\(y\\) will likely arrive at the alu at different times. it will take some time before the alu’s output stabilizes to the correct result. until then, the alu will generate garbage. random access memory a direct-access memory unit, also called random access memory, or ram, is an aggregate of \\(n\\) register chips (see figure 3.7). counter the counter is a chip that knows how to increment its value by 1 each time unit, aslo known as program counter or pc (see figure 3.8). $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/NodeJS/events_info.html",
    "title": "Events",
    "body": " index search search back events in node.js it the event-driven approach to programming is very commonly used. meaning the flow of our program is in part controlled by events. event emitter all objects which emit events are instances of eventemitter, which is accessible from the events module: const eventemitter = require('events') const customemitter = new eventemitter() customemitter.on('response', () => { console.log('some other logic here') }) customemitter.emit('response') here we can see that we create an eventemitter object and we listen for the response event with customemitter.on(). the latter function takes the name of the event as its first argument and the callback as its second. in order to emit a concrete event we use customemitter.emit(), which takes the event name as its argument. more listeners we can have more than one listener: const eventemitter = require('events') const customemitter = new eventemitter() customemitter.on('response', (name, id) => { console.log(`data recieved user ${name} with id:${id}`) }) customemitter.on('response', () => { console.log('some other logic here') }) customemitter.emit('response', 'john', 34) where the second listener define a callback that takes name and id as arguments. so when emitting the event we can pass those arguments to the emit function. take into account that the functions' order matter, if you emit and event before you listen for it, the event will never be registered. http events because http.server extends net.server which then extends eventemitter, we can use the methods discussed above. so we can listen for the event request to handle requests from the browser. const http = require('http') // using event emitter api const server = http.createserver() // emits request event // subcribe to it / listen for it / respond to it server.on('request', (req, res) => { res.end('welcome') }) server.listen(5000) $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/NodeJS/json.html",
    "title": "JSON",
    "body": " index search search back json the method res.json() allows us to return a array of objects as the body of the http response: const express = require('express') const app = express() app.get('/', (req, res) => { res.json([{name: 'john'}, {name: 'susan'}]) }) app.listen(5000, () => { console.log('server is listening on port 5000....') }) we can also pass a json file to res.json(): const express = require('express') const app = express() const { products } = require('./data') app.get('/', (req, res) => { res.json(products) }) app.listen(5000, () => { console.log('server is listening on port 5000....') }) where data.js contains: const products = [ { id: 1, name: 'albany sofa', image: 'product-3.jpg', price: 39.95, desc: `i'm baby direct trade farm-to-table hell of`, }] module.exports = products $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/NodeJS/globals.html",
    "title": "Globals",
    "body": " index search search back globals some global variables available __dirname: path of current directory __filename require: function to use modules module: info about current module process: info about the environment where the program is bein executed note that in node there is no window object like in javascript. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/NodeJS/npm.html",
    "title": "NPM",
    "body": " index search search back npm the node package manager allows us to: reuse our own code in other projects use code written by other developers and share our own solutions. this tool is installed along node. npm calls the reusable code a package (also modules or dependencies), that is basically a folder that contains some js code. note that there is no quality control applied to the packages that are published, so it is the developer's responsibility to check whether the package is secure or not. installing packages you can install a package locally within your project as a local dependency: $ nmp i <packagename> or you can install the package globally, so it can be accessed from any project: $ npm install -g <packagename> if you want to specify a version for the package: $ npm install <packagename>@1.0.0 package.json this file stores important information about the project and the packages, it can be conceived as a manifest file. there are two ways to create it: manually: create package.json in the root folder of the project and define the properties of the project/packages. using npm following the guide (add -y to skip the questions of the guide): \t \t $ npm init \t when the project is initialized, the package.json file is as follows: { \"name\": \"08_project\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"test\": \"echo \\\"error: no test specified\\\" && exit 1\" }, \"keywords\": [], \"author\": \"\", \"license\": \"isc\" } where all those properties are set up during the guide of npm init or set as default with the flag -y. after installing a dependency $ npm i lodash the following property is added: \"dependencies\": { \"lodash\": \"^4.17.21\" } and npm creates the folder node_modules, if it does not already exist, which stores the dependencies code. also, in case of wanting to install dependencies needed only during the development process: $ npm i <package> -d $ npm i <package> --save-dev and so, the property devdependencies is created in pakage.json. scripts the object scripts, which is a property of package.json, can contain the definition of different actions, for example: \"scripts\": { \"start\": \"node app.js\" } so when running npm start our app.js will be executed. for some commands you will need to specify run and the command name as follows: $ npm run dev nodemon this is a package that lets you hot reload your project without having to execute your app constantly. for that, after installing nodemon as a local or global dependency, we specify on package.json: \"scripts\": { \"dev\": \"nodemon app.js\" } if we want to run it: $ npm run dev package-lock.json this file stores the dependencies version of the packages installed as dependencies, as to avoid installing newer version that can be the cause of bugs. because within the package.json only our project's dependencies' versions are specified. uninstalling packages in order to uninstall the package we have a command, that follows the syntax: $ npm uninstall <package> we can also remove it from the dependencies object within package.json. so when you remove package-lock.json and the node_modules folder if you run $ npm install the package that was removed will not be installed. git when using git or other version control tool, it is desirable to create a .gitignore and to specify to avoid the node_modules folder, since its size can get big very easily. so, by just pushing the source code, including package.json, if we want to install all of the project's dependencies' again, on the root folder we run: $ npm install $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/NodeJS/api_ssr.html",
    "title": "API vs SSR",
    "body": " index search search back api vs ssr in express when we talk about apis we are talking about http interfaces to interact our data. the main differences between apis and server side rendering (ssr) are:   api ssr content type json template what is sent send data send template method res.json() res.render() $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/NodeJS/http_basics.html",
    "title": "HTTP Basics",
    "body": " index search search back http basics when answering to a request, node requires a method to signal to the server that all of the response headers and body have been sent, and so the server can consider the message complete. that method is res.end() const http = require('http') const server = http.createserver((req, res) => { res.end('home page') }) server.listen(5000) we create a server with http.createserver. this method takes a callback as an argument, which is called every time a user hits the server. next we specify the port on which the server will be listening for requests. the value of this port is somewhat irrelevant in the development environment. headers if we want to provide the metadata about the response we have to provide headers: const http = require('http') const server = http.createserver((req, res) => { res.writehead(200, { 'content-type': 'text/html' }) res.write('<h1>home page</h1>') res.end() }) server.listen(5000) with writehead we specify the headers, in our case we specify the status code (200: ok) and the content type of the response (text/html). the later are called mime-types or media types. then we specify the body of the response with write and finally we finalize the message with end. request object the request object that is an argument of the createserver method has several attributes: req.method: allows you to obtain the method of the user's request, i.e. get, post, put, etc. req.url: contains the url of the user's request. html file as we have seen the method write allows us to define the content of the body as html. however we do not need to write the html code inside the method we can also pass a file as input and the method will serve it's content to the response. const http = require('http') const { readfilesync } = require('fs') const homepage = readfilesync('./index.html') const server = http.createserver((req, res) => { res.writehead(200, { 'content-type': 'text/html' }) res.write(homepage) res.end() }) server.listen(5000) observe that we user readfilesync, we do so because, for one this is an example, and also the file is only read once when the server is created, not every time the user hits the server. external resources when adding external resources to a given html file we also need to handle the request to those resources in our server. const http = require('http') const { readfilesync } = require('fs') const homepage = readfilesync('./index.html') const homestyles = readfilesync('./styles.css') const homeimage = readfilesync('./logo.svg') const server = http.createserver((req, res) => { // home page if (url === '/') { res.writehead(200, { 'content-type': 'text/html' }) res.write(homepage) res.end() } \t// styles else if (url === '/styles.css') { res.writehead(200, { 'content-type': 'text/css' }) res.write(homestyles) res.end() } \t// image/logo else if (url === '/logo.svg') { res.writehead(200, { 'content-type': 'image/svg+xml' }) res.write(homeimage) res.end() } }) note that the content types differ every time, with css we use text/css, with images we use image/svg+xml. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/NodeJS/async_patterns.html",
    "title": "Asynchronous Patterns",
    "body": " index search search back asynchronous patterns blocking code imagine we have the following piece of code: const http = require('http') const server = http.createserver((req, res) => { if (req.url === '/') { res.end('home page') } if (req.url === '/about') { // blocking code for (let i = 0; i < 1000; i++) { for (let j = 0; j < 1000; j++) { console.log(`${i} ${j}`) } } res.end('about page') } res.end('error page') }) server.listen(5000, () => { console.log('server listening on port : 5000....') }) because inside the second conditional we have a nested for loop which is computationally expensive, when a user accesses the about page, the server is blocked, and so it prevents other users from loading any other page. that is essentially because javascript is single threaded, so by running the nested conditional, the thread is occupied for a period of time, during which the server will not be able to answer to any other request until it is freed. promises a promise is an object that represents the eventual completion (or failure) of an asynchronous operation and its resulting value. so, we can wrap the asynchronous readfile function with a promise: const { readfile, writefile } = require('fs') const gettext = (path) => { return new promise((resolve, reject) => { readfile(path, 'utf8', (err, data) => { if (err) { reject(err) } else { resolve(data) } }) }) } the result of a promise can be accessed as follows: gettext('./content/first.txt') .then((result) => console.log(result)) .catch((err) => console.log(err)) and then, we can define an asynchronous function start that will wait for the execution of gettext: const start = async () => { try { const first = await gettext('./content/first.txt') const second = await gettext('./content/second.txt') console.log(first, second) } catch (error) { console.log(error) } } where you can see that we surround the call with a try-catch statement, which allows us to have more control over the execution flow node's native promises we can use the utils module in order to wrap functions with the promise object: const { readfile, writefile } = require('fs') const util = require('util') const readfilepromise = util.promisify(readfile) const writefilepromise = util.promisify(writefile) const start = async () => { try { const first = await readfilepromise('./content/first.txt', 'utf8') const second = await readfilepromise('./content/second.txt', 'utf8') \t\tawait writefilepromise( './content/result-mind-grenade.txt', `this is awesome : ${first} ${second}`, { flag: 'a' } ) console.log(first, second) } catch (error) { console.log(error) } } but, we can also avoid importing the utils module, by adding .promises when importing the asynchronous functions: const { readfile, writefile } = require('fs').promises const start = async () => { try { const first = await readfile('./content/first.txt', 'utf8') const second = await readfile('./content/second.txt', 'utf8') await writefile( './content/result-mind-grenade.txt', `this is awesome : ${first} ${second}`, { flag: 'a' } ) console.log(first, second) } catch (error) { console.log(error) } } start() $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/NodeJS/mongodb.html",
    "title": "MongoDB",
    "body": " index search search back mongodb intro it is a nosql which is structured in collections, where each collection would be used to store a particular type of data in the form of documents: blog collection blog document blog document blog document here each document represent a single item of data, for example, each blog document represents one blog. the data is contained inside the documents in a very similar fashion to json objects, so the documents consist of key-value pairs like so: { \"id\": objectid(12345), \"title\": \"opening party\", \"snippet\": \"all about...\", \"body\": \"lorem ipsum\" } set up we can either install mongodb locally or we can use a cloud database which is already hosted for us. for the latter we will use mongodb atlas. there we create a cluster and inside this new cluster we create a new collection called blog. then we create a user accessing the security -> database access section. once we have our user created, we specify a way to connect to the database, by heading to clusters -> connect your application. we then copy the connection string that we will use as the database uri. observe that this uri needs you to input your password. mongoose now we need to actually connect to the database, we could use the mongodb api package and use the mongodb api, however we will use mongoose that makes it easier to interact with the database. mongoose is a odm (object document mapping) library, which means that it maps the standard mongodb api providing a much easier way to connect to and interact with the database. it does this by allowing us to create simple data models which have query methods to create, get, delete and update database documents. for that we first have to create a schema for the document which define the structure of a type of data or document. for example: blog schema: - title(string), required - snippet(string), required - body(string), required next, what we do is to create a model based on that schema, the model is what actually allows us to communicate with a particular database collection. each model has static methods get, save, delete, etc, that allow us to manage the data. installing $ npm install mongoose connect to mongodb so, now, we import the mongoose package and we use our database uri to connect to it, remember to change password and cluster_name to the values you specified for your database. const express = require('express'); const morgan = require('morgan'); const mongoose = require('mongoose'); // express app const app = express(); // connect to mongodb & listen for requests const dburi = \"mongodb+srv://user:<password>@test.mongodb.net/<cluster_name> mongoose.connect(dburi, { usenewurlparser: true, useunifiedtopology: true }) .then(result => app.listen(3000)) .catch(err => console.log(err)); the connect method is an asynchronous function, so it will execute a callback function when it finished connecting, or an error if the connection failed. in our case, we proceed to start our server when the database is ready. create models & schemas once we have successfully connected to our database, we will create our blog schema. for that, we first create a folder called models and inside it we create blog.js that will contain the following code: const mongoose = require('mongoose'); const schema = mongoose.schema; const blogschema = new schema({ title: { type: string, required: true, }, snippet: { type: string, required: true, }, body: { type: string, required: true }, }, { timestamps: true }); const blog = mongoose.model('blog', blogschema); module.exports = blog; as you can see, we first import mongoose and the schema object that we use to define the blog schema. in order to create a new blog schema we create a new schema object and we specify the different properties and restrictions. we also set and object of options, where we specify that we want mongodb to save the timestamps of updates, creations, etc. next we created a model that is based in the schema we just created with the function model and we pass it the model name (this name is then pluralized, as to then look up the collection that matches it) and the schema instance. getting/saving data in order to work we data, we must import the model we just created. const express = require('express'); const morgan = require('morgan'); const mongoose = require('mongoose'); const blog = require('./models/blog'); // express app const app = express(); // connect to mongodb & listen for requests const dburi = \"mongodb+srv://user:<password>@test.mongodb.net/<cluster_name> mongoose.connect(dburi, { usenewurlparser: true, useunifiedtopology: true }) .then(result => app.listen(3000)) .catch(err => console.log(err)); app.get('/blogs', (req, res) => { blog.find() .then(result => { res.send(result); }) .catch(err => { console.log(err); }); }); app.get('/blogs/:id', (req, res) => { const id = req.params.id; blog.findbyid(id) .then(result => { res.send(result); }) .catch(err => { console.log(err); }); }); here we use the find and findbyid methods to interact with our database. in order to create or delete new blogs: app.post('/blogs', (req, res) => { const blog = new blog(req.body); blog.save() .then(result => { res.redirect('/blogs'); }) .catch(err => { console.log(err); }); }); app.delete('/blogs/:id', (req, res) => { const id = req.params.id; blog.findbyidanddelete(id) .then(result => { res.json({ redirect: '/blogs' }); }) .catch(err => { console.log(err); }); }); in the post method we create a new blog object using the objects from the request body, and then we save it in our database. on the other hand, in order to delete a blog we pass the id as a parameter, we search for it on the database and we delete it. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/NodeJS/routes.html",
    "title": "Routes",
    "body": " index search search back routes set up in order to set up the routes for our project, we first create a folder called routes that will contain all the javascript files that control routing functionality. in this example we create two files within routes, people.js and auth.js. once we have created them, we include them as middleware to the specific endpoints (/api/people for people.js and /login for auth.js), as follows: const express = require('express') const app = express() const people = require('./routes/people') const auth = require('./routes/auth') app.use('/api/people', people) app.use('/login', auth) app.listen(5000, () => { console.log('server is listening on port 5000....') }) router let's focus now on people.js than controls the routing of /api/people. for that we import the controller of this endpoint and we specify the functions to execute for the different http methods and for the different routes. /: this is the default endpoint /api/people there we specify that the logic for a get request is contained in the getpeople function. /:d: this endpoint allows for specifying an id as a parameter. const express = require('express') const router = express.router() const { getpeople, createperson, createpersonpostman, updateperson, deleteperson, } = require('../controllers/people') router.route('/').get(getpeople).post(createperson) router.route('/:id').put(updateperson).delete(deleteperson) module.exports = router controller the people controller contains: let { people } = require('../data') const getpeople = (req, res) => { res.status(200).json({ success: true, data: people }) } const createperson = (req, res) => { const { name } = req.body if (!name) { return res .status(400) .json({ success: false, msg: 'please provide name value' }) } res.status(201).send({ success: true, person: name }) } const createpersonpostman = (req, res) => { const { name } = req.body if (!name) { return res .status(400) .json({ success: false, msg: 'please provide name value' }) } res.status(201).send({ success: true, data: [...people, name] }) } const updateperson = (req, res) => { const { id } = req.params const { name } = req.body const person = people.find((person) => person.id === number(id)) if (!person) { return res .status(404) .json({ success: false, msg: `no person with id ${id}` }) } const newpeople = people.map((person) => { if (person.id === number(id)) { person.name = name } return person }) res.status(200).json({ success: true, data: newpeople }) } const deleteperson = (req, res) => { const person = people.find((person) => person.id === number(req.params.id)) if (!person) { return res .status(404) .json({ success: false, msg: `no person with id ${req.params.id}` }) } const newpeople = people.filter( (person) => person.id !== number(req.params.id) ) return res.status(200).json({ success: true, data: newpeople }) } module.exports = { getpeople, createperson, createpersonpostman, updateperson, deleteperson, } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/NodeJS/index.html",
    "title": "Node.js",
    "body": " index search search back node.js node.js intro globals modules npm event loop asynchronus patterns events streams http express http basics express api vs ssr json route params query strings middleware http methods routes view engines mongodb mock mongodb environment variables json web tokens projects books directory basic users system real-time chat application collaborative drawing app email sender video streaming platform web scraper $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/NodeJS/http.html",
    "title": "HTTP",
    "body": " index search search back http http messages request message: what the user sends response message: what the server sends the messages have the following parts: info about the request: request url, request method (get is the default method), status code, etc. headers: meta information about the request/response, (e.g. \"content type: application/json\" tells the browser that the body is json) body: which is the request payload, or the content of the response. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/NodeJS/middleware.html",
    "title": "Middleware",
    "body": " index search search back middleware when we are talking about middleware we are typically talking about any type of code and function between getting a certain request and sending the corresponding respond. express allows us to pass middleware as an argument to the app methods. note that middleware runs from top to bottom in our server, so order does matter when specifying middleware. const express = require('express') const app = express() const logger = (req, res, next) => { const method = req.method const url = req.url const time = new date().getfullyear() console.log(method, url, time) next() } app.get('/', logger, (req, res) => { res.send('home') }) app.get('/about', logger, (req, res) => { res.send('about') }) app.listen(5000, () => { console.log('server is listening on port 5000....') }) here we have defined a logger function that tells us some information about the request made. this function is passed as an argument to the app.get() method, and then express passes req, res and next as arguments for the middleware. the next argument is a function that is needed in order to pass the flow to the next middleware and it always has to be invoked, unless the current middleware sends a response and so finishes the message. in any other case, if the next method is not invoked then the browser will be stuck loading because the program flow was halted by not calling the next middleware. the middleware functions that we can use can be ones we code ourselves, express functions or third party software. apply middleware with app.use in order to apply a certain middleware to all the routes we first save the logger on a separate file named logger.js, then we import it into our main app, and we specify its usage as a middleware by app.use. const express = require('express') const logger = require('./logger') const app = express() app.use(logger) with this our logger will be executed every time the user accesses our server. we can also specify an argument like so: const express = require('express') const logger = require('./logger') const app = express() app.use('/api/', logger) this tells express to only use the middleware for the /api route and all its subdomains (i.e. /api/*). apply multiple middleware we now define a new middleware function, that goes by the name of authorize.js, we import it into our app.js and we add it as middleware by using an array. const express = require('express') const logger = require('./logger') const authorize = require('./authorize') const app = express() app.use([logger,authorize]) note that the order matters, meaning the first middleware executed is logger, in this instance, and then the control flow is passed to authorize. we can also define more than one middleware function on one concrete end-point: app.get('/api', [logger, authorize], (req, res) => { res.send('api home page') }) as we can see, we have specified two middleware functions, namely logger and authorize by using an array. example const authorize = (req, res, next) => { // de-structure user object const { user } = req.query if(user == 'alice'){ req.user = { name: 'alice', id: 3 } // yield control flow next() \t} else{ res.status(401).send('unauthorized') } } as you can see the authorize middleware function creates a new object within the request object, which can be accessed from the next middleware, or from the server. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/NodeJS/modules.html",
    "title": "Modules",
    "body": " index search search back modules encapsulated code, as to only share what we want. node uses commonjs so every file is treated as a module by default. in any .js file we have the global object module: console.log(module) module { id: '.', path: '/home/alba/desktop/nodejs', exports: {}, filename: '/home/alba/desktop/nodejs/02_constants.js', loaded: false, children: [], paths: [ '/home/alba/desktop/nodejs/node_modules', '/home/alba/desktop/node_modules', '/home/alba/node_modules', '/home/node_modules', '/node_modules' ] } exporting so we can treat the attribute exports as an object and pass it whatever values we would like to show to other app that import our module: module.exports = { value1: 'value1', value2: 'value2' } where value1 is the key of the attribute and 'value1' is its value, e.g.: const name = 'john' const surname = 'tuckey' module.exports = { name: name, surname: surname } also, if we only export one object it is sufficient to type: const name = 'john' module.exports = name another way to export is to define explicitly the name of the attributes to export: module.exports.items = ['item1', 'item2'] const person = { name: 'bob' } module.exports.singleperson = person importing now, a module can be imported with the keyword require as follows: const externalmodule = require('./module') console.log(externalmodule) { name: 'john', surname: 'tukey' } another type of syntax could be unrolling the attributes of the export object: const { name, surname } = require('./module') built-in modules some built-in modules are: os path fs (filesystem) http even though there are several more built-in modules. os to import the os built-in module we do: const os = require('os') and we call it by: console.log(`the system uptime is ${os.uptime()} seconds`) fs we can also interact with the file system via the fs module. there are two ways to do so: asynchronously, which is non-blocking synchronously, that is blocking synchronous to exemply both setups, we first de-structure the read and write synchronous methods from the fs module, and then we read and write files. const { readfilesync, writefilesync } = require('fs') // read file with a given path and the corresponding encoding const first = readfilesync('./file.txt', 'utf8') const second = readfilesync('./file2.txt', 'utf8') // write to a file given a path, the content is overwritten writefilesync('./writefile', 'this content will be written') // write to a file given a path, the content is appended writefilesync('./writefile', 'this content will be written', {flag: 'a'}) asynchronous now, in order to access the file system asynchronously, we need a callback, and so we do: const { readfilesync, writefilesync } = require('fs') readfile('./file', 'utf8', (error, result) => { if(error){ console.log(error) return } else{ console.log(result) const first = result // here we can add another read call } }) writefile('./file', 'this is the content', (error, result) => { if(error){ console.log(error) return }else{ console.log(result) } }) where we specify a callback function with the es6 syntax. its first parameter is the error parameter and the second is the result of the operation. the problem with synchronous calls is that they can be very time consuming and they halt the execution, which can be critical when working on time sensitive tasks or when several user call upon these type of functions at a time. http to show the bare basics, we will set up a server: const http = require('http') const server = http.createserver((request, response) => { response.write('this is the index!') response.end() }) // define the port server.listen(5000) that can be accessed on localhost:5000. next, we can code something a little more complex, where the content handed as a response depends on the request: const http = require('http') const server = http.createserver((request, response) => { if(request.url === '/'){ response.end('this is the index') }else if(request.url === '/about'){ response.end('this is the about') }else{ response.end('404') } }) // define the port server.listen(5000) $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/NodeJS/intro.html",
    "title": "NodeJS",
    "body": " index search search back nodejs nodejs in an environment to run javascript outside of the browser that was build on top of chrome's v8 js engine. it allows for easy development of full stack apps, since both the frontend and the backend are build in the same language, javascript. differences between to the browser and nodejs browser nodejs dom no dom window no window interactive apps server side apps no filesystem filesystem fragmentation versions es6 modules commonjs how to get node to evaluate our code repl (read, eval, print loop) $ node welcome to node.js v16.9.1. type \".help\" for more information. > cli executable $ node 00_app.js large number hey it is my first node app $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/NodeJS/view_engines.html",
    "title": "View Engines",
    "body": " index search search back view engines we have different options: pug ejs (embedded javascript) express handlebars ejs installing we will use ejs in this example. first we download it: $ npm install ejs set up now we specify in our application that we want to use it: const express = require('express') const app = express() // specify view engine and settings app.set('view engine', 'ejs') app.set('views', './views') we use the function set() that is used to specify app settings. there we define ejs as our view engine and then we indicate that the folder where our views are located is /views, which is the default folder. this means we could have omitted that last line and the functionality would remain the same. rendering inside our root folder, we create the folder views and the file index.ejs which has the same syntax as html: <html lang=\"en\"> <head> <meta charset=\"utf-8\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>blog ninja | <%= title %></title> </head> <body> <div class=\"blogs content\"> <h2>all blogs</h2> <% if (blogs.length > 0) { %> <% blogs.foreach(blog => { %> <h3 class=\"title\"><%= blog.title %></h3> <p class=\"snippet\"><%= blog.snippet %></p> <% }) %> <% } else { %> <p>there are no blogs to display...</p> <% } %> </div> </body> </html> so in order to send this template as a response we do: app.get('/', (req, res) => { const blogs = [ {title: 'yoshi finds eggs', snippet: 'lorem ipsum dolor sit amet consectetur'}, {title: 'mario finds stars', snippet: 'lorem ipsum dolor sit amet consectetur'}, {title: 'how to defeat bowser', snippet: 'lorem ipsum dolor sit amet consectetur'}, ]; res.render('index', { title: 'home', blogs }); }); note that we define an array of blog objects, and we pass them as an argument to the template. which then iterates over them to visualize each item. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/NodeJS/http_methods.html",
    "title": "HTTP Methods",
    "body": " index search search back http methods in this section we will show a few examples of the different http methods in express, take into account that we are not using a database. get app.get('/api/people', (res, req) => { res.status(200).json({ success: true, data: people }) }) post observe that we use a middleware provided by express that lets us parse incoming requests with urlencoded payload, and another middleware function to parse json. app.use(express.urlencoded({ extended: false })) app.use(express.json()) app.post('/api/people', (res, req) => { const { name } = req.body if(!name){ return res .status(400) .json({ success: false, msg: 'please provide a name'}) } // send array of people adding the new person (this is not permanent) res.status(201).json({ success: true, data: [...data, { name, id: data.length + 1}] }) }) put app.put('/api/people/:id', (res, req) => { // de-structure params const { id } = req.params const { name } = req.body const person = people.find((person) => person.id === number(id)) // the person does not exist if(!person){ return res .status(400) .json({ success: false, msg: `no person with id: ${id}`}) } // update the person data const newpeople = people.map((person) => { if(person.id === number(id)){ person.name = name } return person }) res.status(200).json({ success: true, data: newpeople }) }) delete app.delete('/api/people/:id', (res, req) => { // de-structure params const { id } = req.params const { name } = req.body const person = people.find((person) => person.id === number(id)) // the person does not exist if(!person){ return res .status(400) .json({ success: false, msg: `no person with id: ${id}`}) } // filter the person data const newpeople = people.filter((person) => person.id !== id) res.status(200).json({ success: true, data: newpeople }) }) $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/NodeJS/env.html",
    "title": "Environment Variables",
    "body": " index search search back environment variables installing in order to pass environment variables, like mongodb credentials, to our app we can use a third party package called cross-env: $ npm install --save-dev cross-env and then we can pass environment variables as arguments to our node application like so: npx cross-env node_env=development node app.js and the environment variables can be accessed from our app as follows: console.log(process.env.node_env) command to make it easier we can modify our package.json scripts to pass these variables for us: { \"name\": \"project\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"app.js\", \"scripts\": { \"dev\": \"npx cross-env node_env=development node app\" }, \"keywords\": [], \"author\": \"\", \"license\": \"isc\" } and we start the application with: $ npm dev file another way to do it is using a .env file: node_env=development port=3000 host=localhost to pass those variables to node.js we use the eval command: $ eval $(cat .env) node app and we can also include it to package.json. { \"name\": \"project\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"app.js\", \"scripts\": { \"dev\": \"eval $(cat .env) node app\" }, \"keywords\": [], \"author\": \"\", \"license\": \"isc\" } dotenv in case of not wanting to use commands that are exclusive to our operative system, we can use the package dotenv $ npm install --save-dev dotenv and in our app we do: require('dotenv').config() $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/NodeJS/express.html",
    "title": "Express",
    "body": " index search search back express express is a minimal and flexible node.js web app framework that allows us to develop and design web sites and apis much faster. to install: $ npm install express --save they suggest including the flag --save because in earlier versions of express if it was not specified the package would not be saved as a dependency on package.json. initializing express app in order to do so we import the express module, and the we create the instance, more or less like we did with our http servers: const express = require('express') const app = express() app methods the app instance we just created has several methods, we now list the most common: app.get: http method to read data. app.get('/', (req, res) => { res.status(200).send('home page') }) app.post: http method to insert data. app.put: http method to update data. app.delete: http method to delete data. app.all: usually used to respond when we cannot locate a resource on the server. app.all('*', (req, res) => { res.status(404).send('<h1>resource not found</h1>') }) app.use: it is responsible for the middleware. app.listen: this method listens for any requests made to the server. app.listen(5000, () => { console.log('server is listening on port 5000...') }) send html files to send html files as a response instead of plain text we have to use the sendfile method: const express = require('express') const path = require('path') const app = express() app.get('/', (req, res) => { res.sendfile(path.resolve(__dirname, './index.html')) }) app.listen(5000, () => { console.log('server is listening on port 5000...') }) now, we have to import the external resources needed by the html file: const express = require('express') const path = require('path') const app = express() app.use(express.static('./public')) app.get('/', (req, res) => { res.sendfile(path.resolve(__dirname, './index.html')) }) app.listen(5000, () => { console.log('server is listening on port 5000...') }) so we invoke app.use as to tell the server that there are static resources stored in the public folder. however, because in this case index.html is also a static file we can remove the sendfile method if we store index.html inside the public folder: const express = require('express') const path = require('path') const app = express() app.use(express.static('./public')) app.listen(5000, () => { console.log('server is listening on port 5000...') }) $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/NodeJS/route_params.html",
    "title": "Route Params",
    "body": " index search search back route params if, for example, we have a list of products, and we want to get a certain product by its id, we use route params. they can have any name, and are specified by :param. this is then stored in the request object. app.get('/api/products/:productid', (req, res) => { \t // de-structure param const { productid } = req.params // filter products by id const singleproduct = products.find( (product) => product.id === number(productid) ) \t // if it does not exist if (!singleproduct) { return res.status(404).send('product does not exist') } return res.json(singleproduct) }) note that the route params are always strings, in our case we had to convert it to a number. we can also have more that one route parameter like so: app.get('/api/products/:productid/reviews/:reviewid', (req, res) => { res.send('hello world') }) where we define productid and reviewid as route parameters, and can, therefore, filter by them. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/NodeJS/streams.html",
    "title": "Streams",
    "body": " index search search back streams streams are used to read or write sequentially. there are different types: writeable readable duplex: for both writing and reading. transform: to modify data while writing or reading. they are used in order to read files which are too big to store on variables, as it would pose an error. const { createreadstream } = require('fs') const stream = createreadstream('./content/big.txt') stream.on('data', (result) => { console.log(result) }) when logging result when listening on the data event we get the amount of data that is being read, as streams read data chunk by chunk, whose default value is 64kb. in order to modify this value we specify, on the options object, the property highwatermark: const { createreadstream } = require('fs') const stream = createreadstream('./content/big.txt', { highwatermark: 90000 }) stream.on('data', (result) => { console.log(result) }) stream.on('error', (err) => console.log(err)) so, now we are reading 90kb chunks of data. in order to read the data, we specify the encoding of the file: const { createreadstream } = require('fs') const stream = createreadstream('./content/big.txt', { encoding: 'utf8' }) stream.on('data', (result) => { console.log(result) }) in order to listen for errors: const { createreadstream } = require('fs') const stream = createreadstream('./content/big.txt') stream.on('error', (err) => console.log(err)) streams on the web when reading and writing files on servers, it is highly advisable to use chunks instead of the hole file, like so: var http = require('http') var fs = require('fs') http .createserver(function (req, res) { const text = fs.readfilesync('./content/big.txt', 'utf8') res.end(text) }) .listen(5000) instead of this approach, we use streams, both for reading and for writing: var http = require('http') var fs = require('fs') http .createserver(function (req, res) { const filestream = fs.createreadstream('./content/big.txt', 'utf8') filestream.on('open', () => { filestream.pipe(res) }) filestream.on('error', (err) => { res.end(err) }) }) .listen(5000) here, we see that we use the on method to listen for the open event. and then, we use pipe to write on the stream. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/NodeJS/mock_mongo.html",
    "title": "Mocking MongoDB",
    "body": " index search search back mocking mongodb we will now use the node library mongomemoryserver in order to mock our mongodb database using node.js inside a docker container. mongomemoryserver as we have mentioned we need mongomemoryserver, so we install it as a development depencendy. for that we head to our node app's root folder and we execute: $ npm install mongodb-memory-server-core --save-dev docker so, now we create our dockerfile, which holds our app source code, and where we install mongodb: from alpine:latest maintainer albamr09 # install dependencies run apk add --no-cache nodejs npm # install mongodb run echo 'http://dl-cdn.alpinelinux.org/alpine/v3.6/main' >> /etc/apk/repositories run echo 'http://dl-cdn.alpinelinux.org/alpine/v3.6/community' >> /etc/apk/repositories run apk update run apk add mongodb run apk add mongodb-tools run mkdir -p /data/db/ run chmod -r 777 /data/db # add common user run adduser -d user #run useradd --create-home --shell /bin/bash user # create app directory workdir /home/user/src/ # change permissions run chown -r user:user /home/user/src/ run chmod -r 755 /home/user/src/ user user # copy with user as owner copy --chown=user:user ./package*.json ./ # install app dependencies run npm install # copy and override src folder copy . . note that this version of mongodb is 3.4.4, mainly because we are using the alpine image. this version may not coincide with our mongodb docker image, and is not desirable. so make sure (or force) that you are installing the save versions. mongomemoryserver configuration also, we only need to install it for those images that are not supported by mongodb. furthermore, if instead of the package mongo-memory-server-core we install mongo-memory-server, the latter will include a post-install hook that will install mongodb if it is not already installed on the system. in case of manually installing mongodb we have to let know mongomemoryserver where the binary lays. so, within our package.json file we add: \"config\": { \"mongodbmemoryserver\": { \"systembinary\": \"/usr/bin/mongod\", \"version\": \"3.4.4\" } example of usage we, now, exemplify how to mock our database in our tests: const { mongomemoryserver } = require('mongodb-memory-server-core'); const mongoose = require('mongoose'); const usermodel = require('../../models/user'); const userdata = { 'name': 'test', 'email': 'test@test.com', 'password': 'test1234', 'username': 'testname' }; describe('user model tests', ()=> { let mongoserver; beforeall(async () => { mongoserver = await mongomemoryserver.create(); await mongoose.connect(mongoserver.geturi(), { usenewurlparser: true, useunifiedtopology: true, }).catch(error => console.log(error)); }); afterall(async () => { await mongoserver.stop(); await mongoose.connection.close(); }); aftereach(() => { mongoose.connection.collections['users'].drop( function() {}); }); it('create a new user', async ()=> { const user = new usermodel(userdata); const saveduser = await user.save(); expect(saveduser._id).tobedefined(); expect(saveduser.name).tobe(userdata.name); expect(saveduser.email).tobe(userdata.email); expect(saveduser.password).tobe(userdata.password); expect(saveduser.username).tobe(userdata.username); }) it('create a user with invalid fields', async ()=> { var invaliduserdata = {...userdata}; delete invaliduserdata.email; const user = new usermodel(invaliduserdata); let error; try{ const saveduser = await user.save(); error = saveduser; }catch(err){ error = err; } expect(error).tobeinstanceof(mongoose.error.validationerror); expect(error.errors.email).tobedefined(); }) it('create user that already exists', async ()=>{ await new usermodel(userdata).save(); let error; try{ const repeateduser = new usermodel(userdata); await repeateduser.save(); }catch(err){ error = err; } expect(error).tobedefined(); expect(error.code).tobe(11000); }) it('create user with undefined fields', async ()=>{ var newuserdata = {...userdata}; delete newuserdata.name; const user = new usermodel(newuserdata); await user.save(); expect(user._id).tobedefined(); expect(user.name).tobeundefined(); }) } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/NodeJS/jwt.html",
    "title": "JSON Web Tokens",
    "body": " index search search back json web tokens installation $ npm install jsonwebtoken example of usage we first create our express application and so, we import express and jsonwebtoken. and then we start the server. const express = require(\"express\"); const jwt = require(\"jsonwebtoken\"); const app = express(); app.listen(3000, () => { console.log(\"nodejs app running...\"); }); now, we define two new endpoints: /api and /api/login. app.get(\"/api\", (req , res) => { res.json({ mensaje: \"nodejs and jwt\" }); }); app.post(\"/api/login\", (req , res) => { const user = { id: 1, nombre : \"henry\", email: \"henry@email.com\" } jwt.sign({user}, 'secretkey', {expiresin: '32s'}, (err, token) => { res.json({ token }); }); }); where we use the sign method to create a new token. so, if we want to define an endpoint that requires authentication we do: // middleware function verifytoken(req, res, next){ const bearerheader = req.headers['authorization']; if(typeof bearerheader !== 'undefined'){ const bearertoken = bearerheader.split(\" \")[1]; req.token = bearertoken; next(); }else{ res.sendstatus(403); } } app.post(\"/api/posts\", verifytoken, (req , res) => { jwt.verify(req.token, 'secretkey', (error, authdata) => { if(error){ res.sendstatus(403); }else{ res.json({ mensaje: \"post fue creado\", authdata }); } }); }); where verifytoken is a middleware function that gets the token from the header, and then we use the verify method to check if the token is valid. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/NodeJS/query_strings.html",
    "title": "Query Strings",
    "body": " index search search back query strings we can use the query attribute from the request object in order to further filter our data. so whenever the user types localhost:5000/whateverendpoint?name=john, the request object passed as an argument of the callback defined for whateverendpoint will have the object {name: 'john'} stored in request.query. app.get('/whateverendpoint', (req, res) => { console.log(req.query) }) now we code the way to filter by the keywords search and limit: app.get('/api/v1/query', (req, res) => { \t \t// de-structure keys const { search, limit } = req.query // get a copy of the products let sortedproducts = [...products] // if search was specified if (search) { \t // return only the products whose name start with sortedproducts = sortedproducts.filter((product) => { return product.name.startswith(search) }) } // if limit was specified if (limit) { // return as many products as the limit specified sortedproducts = sortedproducts.slice(0, number(limit)) } // if no product matched the search if (sortedproducts.length < 1) { return res.status(200).json({ sucess: true, data: [] }) } \t // return the products filtered res.status(200).json(sortedproducts) }) so now, if we go to localhost:5000/api/v1/query?search=a&limit=2 the server will return a json object that contains at most 2 products whose name start with an \"a\". observe, that in order to avoid error for sending more than one response (note that we have two res.json() in our function), we must add the return keyword after sending each response, then the method exits. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/NodeJS/event_loop.html",
    "title": "Event Loop",
    "body": " index search search back event loop it is what allows node.js to perform non-blocking i/o operations, despite the fact that javascript is single-threaded- by offloading operations to the system kernel whenever possible. the event loop follows the next steps: an asynchronous request is made by a user the event loop registers the callback of the request when the request is completed and we are ready to execute the callback the event loop stores the callback at the end of the execution line, meaning, once the immediate tasks are done (i.e. synchronous code) the callback is executed for example, we have the following code: const { readfile, writefile } = require('fs') console.log('started a first task') readfile('./content/first.txt', 'utf8', (err, result) => { if (err) { console.log(err) return } console.log(result) console.log('completed first task') }) console.log('starting next task') which outputs: started first task starting next task hello this is first text file completed first task so we can see that the synchronous code is run first, and then the callback of the asynchronous function readfile is called upon finishing reading the file. in the next example: // started operating system process console.log('first') settimeout(() => { console.log('second') }, 0) console.log('third') // completed and exited operating system process which outputs: first third second so even though the timeout is initialized to 0, because it is an asynchronous function it is offloaded and so it is put to the end of the execution line, and then it is executed after the synchronous code. it is important to note that the listen function of the http module is also asynchronous. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/XML configuration file.html",
    "title": "Configure Spring Container with an XML file",
    "body": " index search search back configure spring container with an xml file first we create the config file <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/xmlschema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemalocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"> <!-- define your beans here --> <bean id=\"mycoach\" class=\"com.luv2code.springdemo.trackcoach\"> </bean> </beans> then we create the spring container in our application: package com.springdemo; /* class to create a spring container using xml files */ import org.springframework.context.support.classpathxmlapplicationcontext; public class myapp { \tpublic static void main(string[] args) { \t\t// load the spring configuration file \t\tclasspathxmlapplicationcontext context = \t\t\t\tnew classpathxmlapplicationcontext(\"applicationcontext.xml\"); \t\t\t\t \t\t// retrieve bean from spring container by its id \t\tcoach thecoach = context.getbean(\"mycoach\", coach.class); \t\t \t\t// call methods on the bean \t\tsystem.out.println(thecoach.getdailyworkout()); \t\t \t\t// close the context \t\tcontext.close(); \t} } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/IoC/Inversion of Control.html",
    "title": "Inversion of Control",
    "body": " index search search back inversion of control the spring container (generally known as applicationcontext) has two main functions: create and manage objects (inversion of control) inject object's dependencies (dependency injection) so inversion control is externalizing the construction and management of objects which will be handled by and object factory. this is illustrated in the following image: myapp has the main method myapp asks spring to retrieve the appropiate object based on a configuration file or an annotation, instead of having to code it manually like: package com.springdemo; public class myapp { \tpublic static void main(string[] args) { \t\tcoach thecoach = new trackcoach(); \t\t \t\t// call methods on the bean \t\tsystem.out.println(thecoach.getdailyworkout()); \t} } where we have defined an interface coach that is implemented by both trackcoach and baseballcoach package com.springdemo; public interface coach { \tpublic string getdailyworkout(); \t } package com.springdemo; public class trackcoach implements coach { \t@override \tpublic string getdailyworkout() { \t\treturn \"run a hard 5k\"; \t} } to avoid this approach we create a spring container. to configure a spring container we can use: xml configuration file (legacy) java annotations java source code however what is a spring bean? a \"spring bean\" is simply a java object. when java objects are created by the spring container, then spring refers to them as \"spring beans\". spring beans are created from normal java classes just like java objects. why do we specify the coach interface in getbean()? when we pass the interface to the method, behind the scenes spring will cast the object for you. context.getbean(\"mycoach\", coach.class) however, there are some slight differences than normal casting. behaves the same as getbean(string), but provides a measure of type safety by throwing a beannotofrequiredtypeexception if the bean is not of the required type. this means that classcastexception can't be thrown on casting the result correctly, as can happen with getbean(string). $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/MVC/View.html",
    "title": "View",
    "body": " index search search back view create view inside web-inf/view we create a file main-menu.jsp: <!doctype> <html> <body> <h2>spring mvc demo - home page</h2> </body> </html> $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/MVC/Configuration.html",
    "title": "Configuration",
    "body": " index search search back configuration add configurations to file: web-inf/web.xml configure spring mvc dispatcher servlet set up url mappings to spring mvc dispatcher servlet add configurations to spring configuration file: web-inf/spring-mvc-demo-servlet.xml add support for spring component scanning add support for conversion, formatting and validation configure spring mvc view resolver configuration on web.xml we have to add an entry for our front controller: dispatcherservlet <?xml version=\"1.0\" encoding=\"utf-8\"?> <web-app xmlns:xsi=\"http://www.w3.org/2001/xmlschema-instance\" \txmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" \txsi:schemalocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\" \tid=\"webapp_id\" version=\"3.1\"> \t<display-name>spring-mvc-demo</display-name> \t<absolute-ordering /> \t<!-- step 1: configure spring mvc dispatcher servlet --> \t<servlet> \t\t<!-- name to reference this servlet --> \t\t<servlet-name>dispatcher</servlet-name> \t\t<servlet-class>org.springframework.web.servlet.dispatcherservlet</servlet-class> \t\t<!-- file of configuration of spring application --> \t\t<init-param> \t\t\t<param-name>contextconfiglocation</param-name> \t\t\t<param-value>/web-inf/spring-mvc-demo-servlet.xml</param-value> \t\t</init-param> \t\t<load-on-startup>1</load-on-startup> \t</servlet> \t<!-- step 2: set up url mapping for spring mvc dispatcher servlet --> \t<servlet-mapping> \t\t<servlet-name>dispatcher</servlet-name> \t\t<!-- for any url that comes in pass it to the \"dispatcher\" servlet --> \t\t<url-pattern>/</url-pattern> \t</servlet-mapping> </web-app> configuration on spring-mvc-demo-servlet.xml <?xml version=\"1.0\" encoding=\"utf-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" \txmlns:xsi=\"http://www.w3.org/2001/xmlschema-instance\" \txmlns:context=\"http://www.springframework.org/schema/context\" \txmlns:mvc=\"http://www.springframework.org/schema/mvc\" \txsi:schemalocation=\" \t\thttp://www.springframework.org/schema/beans \thttp://www.springframework.org/schema/beans/spring-beans.xsd \thttp://www.springframework.org/schema/context \thttp://www.springframework.org/schema/context/spring-context.xsd \thttp://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"> \t<!-- step 3: add support for component scanning --> \t<context:component-scan base-package=\"com.springdemo\" /> \t<!-- step 4: add support for conversion, formatting and validation support --> \t<mvc:annotation-driven/> \t<!-- step 5: define spring mvc view resolver --> \t<bean \t\tclass=\"org.springframework.web.servlet.view.internalresourceviewresolver\"> \t\t<!-- specify where to look for view files --> \t\t<property name=\"prefix\" value=\"/web-inf/view/\" /> \t\t<property name=\"suffix\" value=\".jsp\" /> \t</bean> </beans> $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/MVC/Radio Buttons.html",
    "title": "Radio Buttons",
    "body": " index search search back radio buttons to pass and bind data from radio buttons to controllers an another views we use the form tag form:radiobutton which is surrounded by a form:form: controller add a model to the controller method for the form and create the model attribute, that holds the data and performs data binding package com.springdemo.mvc; import org.springframework.stereotype.controller; import org.springframework.ui.model; import org.springframework.web.bind.annotation.modelattribute; import org.springframework.web.bind.annotation.requestmapping; @controller @requestmapping(\"/student\") public class studentcontroller { \t \t// request to show the view that contains the form \t@requestmapping(\"/showform\") \tpublic string showform(model themodel) { \t\t \t\t// create a student object \t\tstudent thestudent = new student(); \t\t \t\t// add student object to the model \t\tthemodel.addattribute(\"student\", thestudent); \t\t \t\treturn \"student-form\"; \t} \t \t// process the submit event on the form \t@requestmapping(\"/processform\") \t// we obtain the model attribute with the following annotation \tpublic string processform(@modelattribute(\"student\") student thestudent) { \t\t \t\t// now we can retrieve the updated information from the form \t\tsystem.out.println(\"thestudent: \" + thestudent.getfirstname() \t\t\t\t\t\t\t+ \" \" + thestudent.getlastname()); \t\t \t\treturn \"student-confirmation\"; \t} } view setting the html for data binding: for student-form.jsp: <%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %> <!doctype html> <html> <head> \t<title>student registration form</title> </head> <body> \t<form:form action=\"processform\" modelattribute=\"student\"> \t\tfirst name: <form:input path=\"firstname\" /> \t\t<br><br> \t\tlast name: <form:input path=\"lastname\" /> \t\t<br><br> \t\tcountry: \t\t<!-- drop down list of country options --> \t\t<!-- we specify the variable where we store the selected value in the student object: which is country --> \t\t<form:select path=\"country\"> \t\t\t<!-- this is a list that was populated when we created the student object --> \t\t\t<!-- remember spring calls student.getcountryoptions() --> \t\t\t<form:options items=\"${student.countryoptions}\" /> \t\t</form:select> \t\t<br><br> \t\t<br><br> \t\tfavorite language: \t\t \t\t<!-- the \"path\" specifies the name of the property we are going to bind the radiobutton to, in this case \"favoritelanguage\" --> \t\t<!-- note these can also be populated from the student class or using a properties file --> \t\tjava <form:radiobutton path=\"favoritelanguage\" value=\"java\" /> \t\tc# <form:radiobutton path=\"favoritelanguage\" value=\"c#\" /> \t\tphp <form:radiobutton path=\"favoritelanguage\" value=\"php\" /> \t\truby <form:radiobutton path=\"favoritelanguage\" value=\"ruby\" /> \t\t<br><br> \t\t<input type=\"submit\" value=\"submit\" /> \t</form:form> </body> </html> for student-confirmation.jsp: <%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %> <!doctype html> <html> <head> \t<title>student confirmation</title> </head> <body> \tthe student is confirmed: ${student.firstname} ${student.lastname} \t<br><br> \tselected coutry: ${student.country} ${student.lastname} \t<br><br> \t<!-- obtain the value using the binded variable inside the student object --> \tfavorite language: ${student.favoritelanguage} </body> </html> model the model attribute \"student\" is populated with an instance of the following student class: package com.springdemo.mvc; import java.util.linkedhashmap; public class student { \tprivate string firstname; \tprivate string lastname; \t \tprivate string country; \t \tprivate linkedhashmap<string, string> countryoptions; \t \t// property we are going to bind to the radio buttons \tprivate string favoritelanguage; \t \tpublic student() { \t\t \t\t// populate country options: used iso country code \t\tcountryoptions = new linkedhashmap<>(); \t\t \t\tcountryoptions.put(\"br\", \"brazil\"); \t\tcountryoptions.put(\"fr\", \"france\"); \t\tcountryoptions.put(\"de\", \"germany\"); \t\tcountryoptions.put(\"in\", \"india\"); \t\tcountryoptions.put(\"us\", \"united states of america\");\t\t \t\t \t\t// we can also populate the favoritelanguage options from here \t\t// in the same manner we did with the country options \t} \tpublic string getfirstname() { \t\treturn firstname; \t} \tpublic void setfirstname(string firstname) { \t\tthis.firstname = firstname; \t} \tpublic string getlastname() { \t\treturn lastname; \t} \tpublic void setlastname(string lastname) { \t\tthis.lastname = lastname; \t} \tpublic string getcountry() { \t\treturn country; \t} \tpublic void setcountry(string country) { \t\tthis.country = country; \t} \tpublic linkedhashmap<string, string> getcountryoptions() { \t\treturn countryoptions; \t} \t \t// setter and getter handlers for the new binded attribute \tpublic string getfavoritelanguage() { \t\treturn favoritelanguage; \t} \tpublic void setfavoritelanguage(string favoritelanguage) { \t\tthis.favoritelanguage = favoritelanguage; \t} } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/MVC/Controller.html",
    "title": "Controller",
    "body": " index search search back controller create controller class package com.springdemo.mvc; import org.springframework.stereotype.controller; import org.springframework.web.bind.annotation.requestmapping; // add controller annotation @controller public class homecontroller { \t \t// add request mapping: this method controls the request coming to this url \t@requestmapping(\"/\") \tpublic string showpage() { \t // name of the view that is returned: note they are stored in web-inf/view/ \t\treturn \"main-menu\"; \t} } now, we create the view $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/MVC/Resources.html",
    "title": "Add CSS and JS",
    "body": " index search search back add css and js here are the steps on how to access static resources in a spring mvc. for example, you can use this to access images, css, javascript files etc. you can configure references to static resources in the spring-mvc-demo-servlet.xml. add the following entry to your spring mvc configuration file: spring-mvc-demo-servlet.xml <mvc:resources mapping=\"/resources/**\" location=\"/resources/\"></mvc:resources> now in your view pages, you can access the static files using this syntax: <img src=\"${pagecontext.request.contextpath}/resources/images/spring-logo.png\"> $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/MVC/Form Tags.html",
    "title": "Form Tags",
    "body": " index search search back form tags form tags are configurable an reusable: they can make use of data binding (you can automatically set and retrieve data from a java object) you can mix them in with you html web page some examples are: reference spring mvc form tags to use these tags in your web page you have to specify the spring namespace at the beginning of the jsp file: <!-- reference to the namespace --> <%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %> <!doctype html> <html> <head></head> <body> </body> </html> text fields drop down lists radio buttons checkbox $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/MVC/Text Fields.html",
    "title": "Text Fields",
    "body": " index search search back text fields to pass and bind data from input text fields to controllers an another views we use the form tag form:input along with form:form: controller add a model to the controller method for the form and create the model attribute, that holds the data and perfoms data binding package com.springdemo.mvc; import org.springframework.stereotype.controller; import org.springframework.ui.model; import org.springframework.web.bind.annotation.modelattribute; import org.springframework.web.bind.annotation.requestmapping; @controller @requestmapping(\"/student\") public class studentcontroller { \t \t// request to show the view that contains the form \t@requestmapping(\"/showform\") \tpublic string showform(model themodel) { \t\t \t\t// create a student object \t\tstudent thestudent = new student(); \t\t \t\t// add student object to the model \t\tthemodel.addattribute(\"student\", thestudent); \t\t \t\treturn \"student-form\"; \t} \t \t// process the submit event on the form \t@requestmapping(\"/processform\") \t// we obtain the model attribute with the following annotation \tpublic string processform(@modelattribute(\"student\") student thestudent) { \t\t \t\t// now we can retrieve the updated information from the form \t\tsystem.out.println(\"thestudent: \" + thestudent.getfirstname() \t\t\t\t\t\t\t+ \" \" + thestudent.getlastname()); \t\t \t\treturn \"student-confirmation\"; \t} } view setting the html for data binding: for student-form.jsp: <%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %> <!doctype html> <html> <head> \t<title>student registration form</title> </head> <body> \t<!-- note the modelattribute equals the attribute we added to the model in the controller--> \t<form:form action=\"processform\" modelattribute=\"student\"> \t\t<!-- to retrieve the data this maps to student.getfirstname() --> \t\tfirst name: <form:input path=\"firstname\" /> \t\t<br><br> \t\tlast name: <form:input path=\"lastname\" /> \t\t<br><br> \t\t<input type=\"submit\" value=\"submit\" /> \t</form:form> </body> </html> when we submit spring will call student.setfirstname() and student.setlastname() to save the data in the student object, so we can retrieve it from our controller method. for student-confirmation.jsp: <%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %> <!doctype html> <html> <head> \t<title>student confirmation</title> </head> <body> \t<!-- obtain data from the model: note we use the attribute's name (i.e. student) to access the object --> \tthe student is confirmed: ${student.firstname} ${student.lastname} </body> </html> model the model attribute \"student\" is populated with an instance of the following student class: package com.springdemo.mvc; import java.util.linkedhashmap; public class student { \tprivate string firstname; \tprivate string lastname; \t\t \tpublic student() {} \tpublic string getfirstname() { \t\treturn firstname; \t} \tpublic void setfirstname(string firstname) { \t\tthis.firstname = firstname; \t} \tpublic string getlastname() { \t\treturn lastname; \t} \tpublic void setlastname(string lastname) { \t\tthis.lastname = lastname; \t} } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/MVC/Adding Data.html",
    "title": "Model",
    "body": " index search search back model the model is a container for the application data. so in your controller you can put anything in the model (strings, objects, info from db, etc). and then you view page (jsp) can access data from the model. example controller package com.springdemo.mvc; import javax.servlet.http.httpservletrequest; import org.springframework.stereotype.controller; import org.springframework.ui.model; import org.springframework.web.bind.annotation.requestmapping; @controller public class helloworldcontroller { // new a controller method to read form data and // add data to the model @requestmapping(\"/processformversiontwo\")\t // the httpservletrequest allows you to retrieve information from the request (like the parameters of a form) // the model is our model where we will store data public string parsestring(httpservletrequest request, model model) { // read the request parameter from the html form string thename = request.getparameter(\"studentname\"); // convert the data to all caps thename = thename.touppercase(); // create the message string result = \"yo! \" + thename; // add message attribute to the model model.addattribute(\"message\", result); \t\t return \"helloworld\"; } } view now, on the view, we can access the model data: <!doctype html> <html> <body> hello world of spring! <br><br> student name: ${param.studentname} <br><br> <!-- access model data by the attribute's name--> the message: ${message} </body> </html> $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/MVC/Number Validation.html",
    "title": "Number Range Validation",
    "body": " index search search back number range validation in this section we will show how to perform a number range validation. add validation rule to bean we create a customer class, whose freepasses variable must be a number between 0 and 10. public class customer { \tprivate string firstname; \t \t@notnull(message=\"is required\") \t@size(min=1, message=\"is required\") \tprivate string lastname; \t// minimum value we will expect \t@min(value=0, message=\"must be greater than or equal to zero\") \t// maximum value we will expect \t@max(value=10, message=\"must be less than or equal to 10\") \tprivate int freepasses; \t \t... perform validation in the controller we also package com.springdemo.mvc; import javax.validation.valid; import org.springframework.beans.propertyeditors.stringtrimmereditor; import org.springframework.stereotype.controller; import org.springframework.ui.model; import org.springframework.validation.bindingresult; import org.springframework.web.bind.webdatabinder; import org.springframework.web.bind.annotation.initbinder; import org.springframework.web.bind.annotation.modelattribute; import org.springframework.web.bind.annotation.requestmapping; @controller @requestmapping(\"/customer\") public class customercontroller { \t// add an initbinder ... to convert trim input strings \t// remove leading and trailing whitespace \t// resolve issue for our validation \t \t@initbinder \t//@initbinder annotation works as a pre-processor \t// it will pre-process each web request to our controller \tpublic void initbinder(webdatabinder databinder) { \t\t \t\t// trim strings (true: empty strings to null) \t\tstringtrimmereditor stringtrimmereditor = new stringtrimmereditor(true); \t \t\t// for every string class apply the trim editor \t\tdatabinder.registercustomeditor(string.class, stringtrimmereditor); \t} \t \t \t@requestmapping(\"/showform\") \tpublic string showform(model themodel) { \t\t \t\tthemodel.addattribute(\"customer\", new customer()); \t\t \t\treturn \"customer-form\"; \t} \t \t@requestmapping(\"/processform\") \t// @valid: tells spring to perform validation on the customer object \t// bindingresult: results of the validation will be placed in bindingresult \tpublic string processform( \t\t\t@valid @modelattribute(\"customer\") customer thecustomer, \t\t\tbindingresult thebindingresult) { \t\t \t\tsystem.out.println(\"last name: |\" + thecustomer.getlastname() + \"|\"); \t\t \t\t// check if validation was sucessfull \t\tif (thebindingresult.haserrors()) { \t\t\t// if not sucessfull send back \t\t\treturn \"customer-form\"; \t\t} \t\telse { \t\t\t// if sucessfull \t\t\treturn \"customer-confirmation\"; \t\t} \t} } when performing spring mvc validation, the location of the bindingresult parameter is very important. in the method signature, the bindingresult parameter must appear immediately after the model attribute. display error on html <%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %> <html> <head> \t<title>customer registration form</title> \t \t<style> \t\t.error {color:red} \t</style> </head> <body> <i>fill out the form. asterisk (*) means required.</i> <br><br> \t<form:form action=\"processform\" modelattribute=\"customer\"> \t\tfirst name: <form:input path=\"firstname\" /> \t\t<br><br> \t\tlast name (*): <form:input path=\"lastname\" /> <!-- the message shown equals the messages from both of the validation annotations defined for the lastname attribute in the customer class --> \t\t<form:errors path=\"lastname\" cssclass=\"error\" /> \t\t<br><br> \t\tfree passes: <form:input path=\"freepasses\" /> <!-- the message shown equals the messages from both of the validation annotations defined for the freepasses attribute in the customer class --> \t\t<form:errors path=\"freepasses\" cssclass=\"error\" /> \t\t<br><br> \t\t<input type=\"submit\" value=\"submit\" /> \t</form:form> </body> </html> $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/MVC/Read HTML Form Data.html",
    "title": "Read HTML Form Data",
    "body": " index search search back read html form data the flow of our example will be the following: when the user accesses the url /showform, the browser will send a request to our controller, and our controller will return the corresponding view when the user hits submit on the form the action /processform is passed to the browser that will send a request to our controller, and our controller will process the request controller package com.springdemo.mvc; import org.springframework.stereotype.controller; import org.springframework.web.bind.annotation.requestmapping; @controller public class helloworldcontroller { \t// need a controller method to show the initial html form \t@requestmapping(\"/showform\") // the method name can be anything \tpublic string showform() { \t\treturn \"helloworld-form\"; \t} \t\t \t// need a controller method to process the html form \t@requestmapping(\"/processform\") \tpublic string processform() { \t\treturn \"helloworld\"; \t} \t\t } view we create web-inf/view/helloworld-form.jsp <!doctype html> <html> <head> \t<title>hello world - input form</title> </head> <body> <!-- the action is the request url --> \t<form action=\"processform\" method=\"get\"> \t\t<input type=\"text\" name=\"studentname\" \t\t\tplaceholder=\"what's your name?\" /> \t\t<input type=\"submit\" /> \t</form> </body> </html> and we create web-inf/view/helloworld-form.jsp <!doctype html> <html> <body> hello world of spring! <br><br> <!-- name of html form field from previous jsp view --> student name: ${param.studentname} </body> </html> $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/MVC/index.html",
    "title": "Spring MVC",
    "body": " index search search back spring mvc spring mvc is a framework for building web applications in java based on the model-view-controller design patter. the front controller is known as dispatcherservlet: it is part of the spring framework pre-processes and delegates requests from the web browser to your controllers the mvc pattern is made up of: model objects: contains the data view templates: ui of the app that displays data (most common templates: jsp + jslt) controller classes: business logic (handle request, access db, etc.) it includes the features of the core spring framework (inversion of control and dependency injection) $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/MVC/Drop Down Lists.html",
    "title": "Drop Down Lists",
    "body": " index search search back drop down lists to pass and bind data from drop down lists to controllers an another views we use the form tags form:select that encloses a set of options represented with form:option tags. and all these are surrounded by a form:form: controller add a model to the controller method for the form and create the model attribute, that holds the data and performs data binding package com.springdemo.mvc; import org.springframework.stereotype.controller; import org.springframework.ui.model; import org.springframework.web.bind.annotation.modelattribute; import org.springframework.web.bind.annotation.requestmapping; @controller @requestmapping(\"/student\") public class studentcontroller { \t \t// request to show the view that contains the form \t@requestmapping(\"/showform\") \tpublic string showform(model themodel) { \t\t \t\t// create a student object \t\tstudent thestudent = new student(); \t\t \t\t// add student object to the model \t\tthemodel.addattribute(\"student\", thestudent); \t\t \t\treturn \"student-form\"; \t} \t \t// process the submit event on the form \t@requestmapping(\"/processform\") \t// we obtain the model attribute with the following annotation \tpublic string processform(@modelattribute(\"student\") student thestudent) { \t\t \t\t// now we can retrieve the updated information from the form \t\tsystem.out.println(\"thestudent: \" + thestudent.getfirstname() \t\t\t\t\t\t\t+ \" \" + thestudent.getlastname()); \t\t \t\treturn \"student-confirmation\"; \t} } view setting the html for data binding: for student-form.jsp: <%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %> <!doctype html> <html> <head> \t<title>student registration form</title> </head> <body> \t<form:form action=\"processform\" modelattribute=\"student\"> \t\tfirst name: <form:input path=\"firstname\" /> \t\t<br><br> \t\tlast name: <form:input path=\"lastname\" /> \t\t<br><br> \t\tcountry: \t\t<!-- drop down list of country options --> \t\t<!-- we specify the variable where we store the selected value in the student object: which is country --> \t\t<form:select path=\"country\"> \t\t\t<!-- this is a list that was populated when we created the student object --> \t\t\t<!-- remember spring calls student.getcountryoptions() --> \t\t\t<form:options items=\"${student.countryoptions}\" /> \t\t</form:select> \t\t<br><br> \t\t<input type=\"submit\" value=\"submit\" /> \t</form:form> </body> </html> for student-confirmation.jsp: <%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %> <!doctype html> <html> <head> \t<title>student confirmation</title> </head> <body> \tthe student is confirmed: ${student.firstname} ${student.lastname} \t<!-- obtain the value saved in the coutry variable inside the student's object (corresponds to the selected value) --> \tselected coutry: ${student.country} ${student.lastname} </body> </html> model the model attribute \"student\" is populated with an instance of the following student class: package com.springdemo.mvc; import java.util.linkedhashmap; public class student { \tprivate string firstname; \tprivate string lastname; \t \tprivate string country; \t \tprivate linkedhashmap<string, string> countryoptions; \t \tpublic student() { \t\t \t\t// populate country options: used iso country code \t\tcountryoptions = new linkedhashmap<>(); \t\t \t\tcountryoptions.put(\"br\", \"brazil\"); \t\tcountryoptions.put(\"fr\", \"france\"); \t\tcountryoptions.put(\"de\", \"germany\"); \t\tcountryoptions.put(\"in\", \"india\"); \t\tcountryoptions.put(\"us\", \"united states of america\");\t\t \t} \tpublic string getfirstname() { \t\treturn firstname; \t} \tpublic void setfirstname(string firstname) { \t\tthis.firstname = firstname; \t} \tpublic string getlastname() { \t\treturn lastname; \t} \tpublic void setlastname(string lastname) { \t\tthis.lastname = lastname; \t} \tpublic string getcountry() { \t\treturn country; \t} \t// setter and getter handlers for the new binded attribute \tpublic void setcountry(string country) { \t\tthis.country = country; \t} \tpublic linkedhashmap<string, string> getcountryoptions() { \t\treturn countryoptions; \t} } country options from a properties file we create web-inf/countries.properties: br=brazil fr=france co=colombia in=india update configuration's file spring-mvc-dmo-servlet.xml header (to use a new set of spring tags: utils): <?xml version=\"1.0\" encoding=\"utf-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:util=\"http://www.springframework.org/schema/util\" xmlns:xsi=\"http://www.w3.org/2001/xmlschema-instance\" xsi:schemalocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd\"> load the country options properties file in the spring configuration file, with a bean id equal to \"countryoptions\": <util:properties id=\"countryoptions\" location=\"classpath:../countries.properties\" /> inject properties inside our controller: @value(\"#{countryoptions}\") private map<string, string> countryoptions; add countryoptions as an attribute of the model inside the controller method: @requestmapping(\"/showform\") public string showform(model themodel) { // create a student object student student thestudent = new student(); // add student object to the model themodel.addattribute(\"student\", thestudent); // add the country options to the model themodel.addattribute(\"thecountryoptions\", countryoptions); return \"student-form\"; } update the view as follows: <form:select path=\"country\"> <form:options items=\"${thecountryoptions}\" /> </form:select> $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/MVC/CheckBox.html",
    "title": "Check Box",
    "body": " index search search back check box to pass and bind data from check boxes to controllers an another views we use the form tag form:checkbox which is surrounded by a form:form: controller add a model to the controller method for the form and create the model attribute, that holds the data and performs data binding package com.springdemo.mvc; import org.springframework.stereotype.controller; import org.springframework.ui.model; import org.springframework.web.bind.annotation.modelattribute; import org.springframework.web.bind.annotation.requestmapping; @controller @requestmapping(\"/student\") public class studentcontroller { \t \t// request to show the view that contains the form \t@requestmapping(\"/showform\") \tpublic string showform(model themodel) { \t\t \t\t// create a student object \t\tstudent thestudent = new student(); \t\t \t\t// add student object to the model \t\tthemodel.addattribute(\"student\", thestudent); \t\t \t\treturn \"student-form\"; \t} \t \t// process the submit event on the form \t@requestmapping(\"/processform\") \t// we obtain the model attribute with the following annotation \tpublic string processform(@modelattribute(\"student\") student thestudent) { \t\t \t\t// now we can retrieve the updated information from the form \t\tsystem.out.println(\"thestudent: \" + thestudent.getfirstname() \t\t\t\t\t\t\t+ \" \" + thestudent.getlastname()); \t\t \t\treturn \"student-confirmation\"; \t} } view setting the html for data binding: for student-form.jsp: <%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %> <!doctype html> <html> <head> \t<title>student registration form</title> </head> <body> \t<form:form action=\"processform\" modelattribute=\"student\"> \t\tfirst name: <form:input path=\"firstname\" /> \t\t<br><br> \t\tlast name: <form:input path=\"lastname\" /> \t\t<br><br> \t\tcountry: \t\t<!-- drop down list of country options --> \t\t<!-- we specify the variable where we store the selected value in the student object: which is country --> \t\t<form:select path=\"country\"> \t\t\t<!-- this is a list that was populated when we created the student object --> \t\t\t<!-- remember spring calls student.getcountryoptions() --> \t\t\t<form:options items=\"${student.countryoptions}\" /> \t\t</form:select> \t\t<br><br> \t\t<br><br> \t\tfavorite language: \t\t \t\tjava <form:radiobutton path=\"favoritelanguage\" value=\"java\" /> \t\tc# <form:radiobutton path=\"favoritelanguage\" value=\"c#\" /> \t\tphp <form:radiobutton path=\"favoritelanguage\" value=\"php\" /> \t\truby <form:radiobutton path=\"favoritelanguage\" value=\"ruby\" /> \t\t<br><br> \t\toperating systems: \t\t \t\t<!-- the \"path\" specifies the name of the property we are going to bind the radiobutton to, in this case \"operatingsystems\" --> \t\t<!-- note these can also be populated from the student class or using a properties file --> \t\tlinux <form:checkbox path=\"operatingsystems\" value=\"linux\" /> \t\tmac os <form:checkbox path=\"operatingsystems\" value=\"mac os\" /> \t\tms windows <form:checkbox path=\"operatingsystems\" value=\"ms window\" />\t \t\t<br><br> \t\t<input type=\"submit\" value=\"submit\" /> \t</form:form> </body> </html> for student-confirmation.jsp: <%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\" %> <!doctype html> <html> <head> \t<title>student confirmation</title> </head> <body> \tthe student is confirmed: ${student.firstname} ${student.lastname} \t<br><br> \tselected coutry: ${student.country} ${student.lastname} \t<br><br> \t<!-- obtain the value using the binded variable inside the student object --> \tfavorite language: ${student.favoritelanguage} \t<br><br> \toperating systems: \t<!-- create an unordered list of the selected values in the checkbox --> \t\t<ul> \t\t\t<c:foreach var=\"temp\" items=\"${student.operatingsystems}\"> \t\t\t\t<li> ${temp} </li> \t\t\t</c:foreach> \t\t</ul> </body> </html> model the model attribute \"student\" is populated with an instance of the following student class: package com.springdemo.mvc; import java.util.linkedhashmap; public class student { \tprivate string firstname; \tprivate string lastname; \t \tprivate string country; \t \tprivate linkedhashmap<string, string> countryoptions; \t \tprivate string favoritelanguage; // attribute bound to the checkbox (multiple options so it is an array) private string[] operatingsystems; \t \tpublic student() { \t\t \t\t// populate country options: used iso country code \t\tcountryoptions = new linkedhashmap<>(); \t\t \t\tcountryoptions.put(\"br\", \"brazil\"); \t\tcountryoptions.put(\"fr\", \"france\"); \t\tcountryoptions.put(\"de\", \"germany\"); \t\tcountryoptions.put(\"in\", \"india\"); \t\tcountryoptions.put(\"us\", \"united states of america\");\t\t \t\t \t\t// we can also populate the favoritelanguage options from here \t\t// in the same manner we did with the country options \t} \tpublic string getfirstname() { \t\treturn firstname; \t} \tpublic void setfirstname(string firstname) { \t\tthis.firstname = firstname; \t} \tpublic string getlastname() { \t\treturn lastname; \t} \tpublic void setlastname(string lastname) { \t\tthis.lastname = lastname; \t} \tpublic string getcountry() { \t\treturn country; \t} \tpublic void setcountry(string country) { \t\tthis.country = country; \t} \tpublic linkedhashmap<string, string> getcountryoptions() { \t\treturn countryoptions; \t} \t \tpublic string getfavoritelanguage() { \t\treturn favoritelanguage; \t} \tpublic void setfavoritelanguage(string favoritelanguage) { \t\tthis.favoritelanguage = favoritelanguage; \t} \t// setter and getter handlers for the new bound attribute public string[] getoperatingsystems() { \t\treturn operatingsystems; \t} \tpublic void setoperatingsystems(string[] operatingsystems) { \t\tthis.operatingsystems = operatingsystems; \t} } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/MVC/Validation with Regular Expressions.html",
    "title": "Validation with Regular Expressions",
    "body": " index search search back validation with regular expressions in this section we will show how to perform a validation with regular expressions. add validation rule to bean we create a customer class, whose freepasses variable must be a number between 0 and 10. public class customer { \tprivate string firstname; \t \t@notnull(message=\"is required\") \t@size(min=1, message=\"is required\") \tprivate string lastname; \t@min(value=0, message=\"must be greater than or equal to zero\") \t@max(value=10, message=\"must be less than or equal to 10\") \tprivate int freepasses; // define the regular expression for the postalcode attribute @pattern(regexp=\"^[a-za-z0-9]{5}\", message=\"only 5 chars/digits\") \tprivate string postalcode; \t \t... perform validation in the controller we also package com.springdemo.mvc; import javax.validation.valid; import org.springframework.beans.propertyeditors.stringtrimmereditor; import org.springframework.stereotype.controller; import org.springframework.ui.model; import org.springframework.validation.bindingresult; import org.springframework.web.bind.webdatabinder; import org.springframework.web.bind.annotation.initbinder; import org.springframework.web.bind.annotation.modelattribute; import org.springframework.web.bind.annotation.requestmapping; @controller @requestmapping(\"/customer\") public class customercontroller { \t// add an initbinder ... to convert trim input strings \t// remove leading and trailing whitespace \t// resolve issue for our validation \t \t@initbinder \t//@initbinder annotation works as a pre-processor \t// it will pre-process each web request to our controller \tpublic void initbinder(webdatabinder databinder) { \t\t \t\t// trim strings (true: empty strings to null) \t\tstringtrimmereditor stringtrimmereditor = new stringtrimmereditor(true); \t \t\t// for every string class apply the trim editor \t\tdatabinder.registercustomeditor(string.class, stringtrimmereditor); \t} \t \t \t@requestmapping(\"/showform\") \tpublic string showform(model themodel) { \t\t \t\tthemodel.addattribute(\"customer\", new customer()); \t\t \t\treturn \"customer-form\"; \t} \t \t@requestmapping(\"/processform\") \t// @valid: tells spring to perform validation on the customer object \t// bindingresult: results of the validation will be placed in bindingresult \tpublic string processform( \t\t\t@valid @modelattribute(\"customer\") customer thecustomer, \t\t\tbindingresult thebindingresult) { \t\t \t\tsystem.out.println(\"last name: |\" + thecustomer.getlastname() + \"|\"); \t\t \t\t// check if validation was sucessfull \t\tif (thebindingresult.haserrors()) { \t\t\t// if not sucessfull send back \t\t\treturn \"customer-form\"; \t\t} \t\telse { \t\t\t// if sucessfull \t\t\treturn \"customer-confirmation\"; \t\t} \t} } when performing spring mvc validation, the location of the bindingresult parameter is very important. in the method signature, the bindingresult parameter must appear immediately after the model attribute. display error on html <%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %> <html> <head> \t<title>customer registration form</title> \t \t<style> \t\t.error {color:red} \t</style> </head> <body> <i>fill out the form. asterisk (*) means required.</i> <br><br> \t<form:form action=\"processform\" modelattribute=\"customer\"> \t\tfirst name: <form:input path=\"firstname\" /> \t\t<br><br> \t\tlast name (*): <form:input path=\"lastname\" /> \t\t<form:errors path=\"lastname\" cssclass=\"error\" /> \t\t<br><br> \t\tfree passes: <form:input path=\"freepasses\" /> \t\t<form:errors path=\"freepasses\" cssclass=\"error\" /> <br><br> \t\tpostal code: <form:input path=\"postalcode\" /> <!-- the message shown equals the messages from both of the validation annotations defined for the postalcode attribute in the customer class --> \t\t<form:errors path=\"postalcode\" cssclass=\"error\" /> \t\t<br><br> \t\t<input type=\"submit\" value=\"submit\" /> \t</form:form> </body> </html> $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/MVC/Form Validation.html",
    "title": "Form Validation",
    "body": " index search search back form validation java has a standard bean validation api that defines a metadata model and an api for entity validation. here is a list of bean validation features you can check: required validate length validate numbers validate with regular expressions custom validation some annotations to perform the validation are the following: set up add hibernate's library (hibernate validator)for bean validation which is fully compliant with java's bean validation api. required validation number range validation validation with regular expressions handle string in integer field custom validation $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/MVC/Required Validation.html",
    "title": "Required Validation",
    "body": " index search search back required validation in this section we will show how to perform a required validation. add validation rule to bean we create a customer class, whose lastname attribute must be non-null, that is, lastname is a required attribute: package com.springdemo.mvc; import javax.validation.constraints.notnull; import javax.validation.constraints.size; public class customer { \tprivate string firstname; \t // validation annotation \t@notnull(message=\"is required\") \t@size(min=1, message=\"is required\") \tprivate string lastname; \tpublic string getfirstname() { \t\treturn firstname; \t} \tpublic void setfirstname(string firstname) { \t\tthis.firstname = firstname; \t} \tpublic string getlastname() { \t\treturn lastname; \t} \tpublic void setlastname(string lastname) { \t\tthis.lastname = lastname; \t} } note that if we wanted to make an integer required, we must use the wrapper java classes (i.e. integer), that will be able to handle empty strings as inputs and nulls. the primitive types will throw an exception. perform validation in the controller we also package com.springdemo.mvc; import javax.validation.valid; import org.springframework.beans.propertyeditors.stringtrimmereditor; import org.springframework.stereotype.controller; import org.springframework.ui.model; import org.springframework.validation.bindingresult; import org.springframework.web.bind.webdatabinder; import org.springframework.web.bind.annotation.initbinder; import org.springframework.web.bind.annotation.modelattribute; import org.springframework.web.bind.annotation.requestmapping; @controller @requestmapping(\"/customer\") public class customercontroller { \t// add an initbinder ... to convert trim input strings \t// remove leading and trailing whitespace \t// resolve issue for our validation \t \t@initbinder \t//@initbinder annotation works as a pre-processor \t// it will pre-process each web request to our controller \tpublic void initbinder(webdatabinder databinder) { \t\t \t\t// trim strings (true: empty strings to null) \t\tstringtrimmereditor stringtrimmereditor = new stringtrimmereditor(true); \t \t\t// for every string class apply the trim editor \t\tdatabinder.registercustomeditor(string.class, stringtrimmereditor); \t} \t \t \t@requestmapping(\"/showform\") \tpublic string showform(model themodel) { \t\t \t\tthemodel.addattribute(\"customer\", new customer()); \t\t \t\treturn \"customer-form\"; \t} \t \t@requestmapping(\"/processform\") \t// @valid: tells spring to perform validation on the customer object \t// bindingresult: results of the validation will be placed in bindingresult \tpublic string processform( \t\t\t@valid @modelattribute(\"customer\") customer thecustomer, \t\t\tbindingresult thebindingresult) { \t\t \t\tsystem.out.println(\"last name: |\" + thecustomer.getlastname() + \"|\"); \t\t \t\t// check if validation was sucessfull \t\tif (thebindingresult.haserrors()) { \t\t\t// if not sucessfull send back \t\t\treturn \"customer-form\"; \t\t} \t\telse { \t\t\t// if sucessfull \t\t\treturn \"customer-confirmation\"; \t\t} \t} } when performing spring mvc validation, the location of the bindingresult parameter is very important. in the method signature, the bindingresult parameter must appear immediately after the model attribute. display error on html <%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %> <html> <head> \t<title>customer registration form</title> \t \t<style> \t\t.error {color:red} \t</style> </head> <body> <i>fill out the form. asterisk (*) means required.</i> <br><br> \t<form:form action=\"processform\" modelattribute=\"customer\"> \t\tfirst name: <form:input path=\"firstname\" /> \t\t<br><br> \t\tlast name (*): <form:input path=\"lastname\" /> <!-- we use the error form tag to display an error when the input is not valid --> <!-- the message shown equals the messages from both of the validation annotations defined for the lastname attribute in the customer class --> \t\t<form:errors path=\"lastname\" cssclass=\"error\" /> \t\t<br><br> \t\t<input type=\"submit\" value=\"submit\" /> \t</form:form> </body> </html> $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/MVC/Request Params and Request Mappings.html",
    "title": "Request Params and Request Mappings",
    "body": " index search search back request params and request mappings request params spring provides for a specific annotation that allows you to retrieve request parameters directly without using the httpservletrequest object. given the form: package com.springdemo.mvc; import javax.servlet.http.httpservletrequest; import org.springframework.stereotype.controller; import org.springframework.ui.model; import org.springframework.web.bind.annotation.requestmapping; import org.springframework.web.bind.annotation.requestparam; @controller public class helloworldcontroller { \t@requestmapping(\"/processformversionthree\")\t \tpublic string processformversionthree( // we use the annotation to obtain the parameter \t\t\t@requestparam(\"studentname\") string thename, \t\t\tmodel model) { \t\t\t\t \t\t// convert the data to all caps \t\tthename = thename.touppercase(); \t\t \t\t// create the message \t\tstring result = \"hey my friend from v3! \" + thename; \t\t \t\t// add message to the model \t\tmodel.addattribute(\"message\", result); \t\t\t\t \t\treturn \"helloworld\"; \t}\t } controller request mappings they serve as a parent mapping for the controller all request mappings on methods in the controller are relative for example: package com.springdemo.mvc; import javax.servlet.http.httpservletrequest; import org.springframework.stereotype.controller; import org.springframework.ui.model; import org.springframework.web.bind.annotation.requestmapping; import org.springframework.web.bind.annotation.requestparam; @controller // this is the request mapping for the controller @requestmapping(\"/hello\") public class helloworldcontroller { \t// both of these request mappings are relative to the parent mapping \t// that is the mapping translates to domain/hello/showform \t// need a controller method to show the initial html form \t@requestmapping(\"/showform\") \tpublic string showform() { \t\treturn \"helloworld-form\"; \t} \t\t \t// need a controller method to process the html form \t@requestmapping(\"/processform\") \tpublic string processform() { \t\treturn \"helloworld\"; \t} } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/MVC/Handle String in Integer Field.html",
    "title": "Handle String Input in Integer Field",
    "body": " index search search back handle string input in integer field if we want to avoid the trace returned by errors like inputting the wrong data type (string instead of int), we can define a custom message that will override those messages. create a custom message create a properties file in resources/messages.properties // errortype.springmodelattributename.fieldname typemismatch.customer.freepasses=invalid number specify properties file in configuration we add the following in our configuration file spring-mvc-demo-servlet.xml <?xml version=\"1.0\" encoding=\"utf-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" \txmlns:xsi=\"http://www.w3.org/2001/xmlschema-instance\" \txmlns:context=\"http://www.springframework.org/schema/context\" \txmlns:mvc=\"http://www.springframework.org/schema/mvc\" \txsi:schemalocation=\" \t\thttp://www.springframework.org/schema/beans \thttp://www.springframework.org/schema/beans/spring-beans.xsd \thttp://www.springframework.org/schema/context \thttp://www.springframework.org/schema/context/spring-context.xsd \thttp://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"> \t<context:component-scan base-package=\"com.luv2code.springdemo\" /> \t<mvc:annotation-driven/> \t<bean \t\tclass=\"org.springframework.web.servlet.view.internalresourceviewresolver\"> \t\t<property name=\"prefix\" value=\"/web-inf/view/\" /> \t\t<property name=\"suffix\" value=\".jsp\" /> \t</bean> \t <!-- load custom message resources --> <bean id=\"messagesource\" class=\"org.springframework.context.support.resourcebundlemessagesource\"> \t\t\t\t<!-- path where the properties file is stored --> <property name=\"basenames\" value=\"resources/messages\" /> </bean> </beans> $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/MVC/Custom Validation.html",
    "title": "Custom Validation",
    "body": " index search search back custom validation create a custom java annotation create annotation clas package com.springdemo.mvc.validation; import java.lang.annotation.elementtype; import java.lang.annotation.retention; import java.lang.annotation.retentionpolicy; import java.lang.annotation.target; import javax.validation.constraint; import javax.validation.payload; // specify the class that holds the validation logic @constraint(validatedby = coursecodeconstraintvalidator.class) // where you can use this annotation: on a method or on a field @target( { elementtype.method, elementtype.field } ) @retention(retentionpolicy.runtime) // note the @interface (it is needed to create the annotation) public @interface coursecode { \t// define default course code \tpublic string value() default \"luv\"; \t \t// define default error message \tpublic string message() default \"must start with luv\"; \t \t// define default groups \tpublic class<?>[] groups() default {}; \t \t// define default payloads \tpublic class<? extends payload>[] payload() default {}; } create validator class this class holds the validation logic package com.springdemo.mvc.validation; import javax.validation.constraintvalidator; import javax.validation.constraintvalidatorcontext; // implements the previous constraintvalidator interface, with generics: <annotation interface, data type> public class coursecodeconstraintvalidator \timplements constraintvalidator<coursecode, string> { \tprivate string courseprefix; \t \t@override \tpublic void initialize(coursecode thecoursecode) { \t\t// obtain prefix from the \"value\" attribute of our annotation \t\tcourseprefix = thecoursecode.value(); \t} \t@override \t// called when we use the @valid annotation \tpublic boolean isvalid(string thecode, constraintvalidatorcontext theconstraintvalidatorcontext) { \t\tboolean result; \t\t \t\t// validation logic \t\tif (thecode != null) { \t\t\tresult = thecode.startswith(courseprefix); \t\t} \t\telse { \t\t\tresult = true; \t\t} \t\t \t\treturn result; \t} } add custom validation public class customer { \tprivate string firstname; \t \t@notnull(message=\"is required\") \t@size(min=1, message=\"is required\") \tprivate string lastname; \t@notnull(message=\"is required\") \t@min(value=0, message=\"must be greater than or equal to zero\") \t@max(value=10, message=\"must be less than or equal to 10\") \tprivate integer freepasses; \t@pattern(regexp=\"^[a-za-z0-9]{5}\", message=\"only 5 chars/digits\") \tprivate string postalcode; \t // use our custom validation tag \t@coursecode(value=\"tops\", message=\"must start with tops\") \tprivate string coursecode; perform validation on controller package com.springdemo.mvc; import javax.validation.valid; import org.springframework.beans.propertyeditors.stringtrimmereditor; import org.springframework.stereotype.controller; import org.springframework.ui.model; import org.springframework.validation.bindingresult; import org.springframework.web.bind.webdatabinder; import org.springframework.web.bind.annotation.initbinder; import org.springframework.web.bind.annotation.modelattribute; import org.springframework.web.bind.annotation.requestmapping; @controller @requestmapping(\"/customer\") public class customercontroller { \t// add an initbinder ... to convert trim input strings \t// remove leading and trailing whitespace \t// resolve issue for our validation \t \t@initbinder \t//@initbinder annotation works as a pre-processor \t// it will pre-process each web request to our controller \tpublic void initbinder(webdatabinder databinder) { \t\t \t\t// trim strings (true: empty strings to null) \t\tstringtrimmereditor stringtrimmereditor = new stringtrimmereditor(true); \t \t\t// for every string class apply the trim editor \t\tdatabinder.registercustomeditor(string.class, stringtrimmereditor); \t} \t \t \t@requestmapping(\"/showform\") \tpublic string showform(model themodel) { \t\t \t\tthemodel.addattribute(\"customer\", new customer()); \t\t \t\treturn \"customer-form\"; \t} \t \t@requestmapping(\"/processform\") \t// @valid: tells spring to perform validation on the customer object \t// bindingresult: results of the validation will be placed in bindingresult \tpublic string processform( \t\t\t@valid @modelattribute(\"customer\") customer thecustomer, \t\t\tbindingresult thebindingresult) { \t\t \t\tsystem.out.println(\"last name: |\" + thecustomer.getlastname() + \"|\"); \t\t \t\t// check if validation was sucessfull \t\tif (thebindingresult.haserrors()) { \t\t\t// if not sucessfull send back \t\t\treturn \"customer-form\"; \t\t} \t\telse { \t\t\t// if sucessfull \t\t\treturn \"customer-confirmation\"; \t\t} \t} } when performing spring mvc validation, the location of the bindingresult parameter is very important. in the method signature, the bindingresult parameter must appear immediately after the model attribute. display error on html <%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %> <html> <head> \t<title>customer registration form</title> \t \t<style> \t\t.error {color:red} \t</style> </head> <body> <i>fill out the form. asterisk (*) means required.</i> <br><br> \t<form:form action=\"processform\" modelattribute=\"customer\"> \t\tfirst name: <form:input path=\"firstname\" /> \t\t<br><br> \t\tlast name (*): <form:input path=\"lastname\" /> \t\t<form:errors path=\"lastname\" cssclass=\"error\" /> \t\t<br><br> \t\tfree passes: <form:input path=\"freepasses\" /> \t\t<form:errors path=\"freepasses\" cssclass=\"error\" /> <br><br> \t\tpostal code: <form:input path=\"postalcode\" /> \t\t<form:errors path=\"postalcode\" cssclass=\"error\" /> \t\t<br><br> <!-- the message shown equals the messages from both of the validation annotations defined for the coursecode attribute in the customer class --> \t\t\tcourse code: <form:input path=\"coursecode\" /> \t\t\t<form:errors path=\"coursecode\" cssclass=\"error\" /> \t\t<br><br> \t\t<input type=\"submit\" value=\"submit\" /> \t</form:form> </body> </html> $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Maven/Overview.html",
    "title": "Maven",
    "body": " index search search back maven maven is a project management tool. the most popular use of maven is for build management and dependencies. behind the scenes what maven does is: reads the configuration file of our application: pom.xml checks on the local repository if the library is already stored (like a cache) if not, it goes to the remote repository and searches for it then it saves it to the local repository finally it uses the downloaded library to build and run the application maven also downloads the libraries' dependencies. and when you build and run your application, maven will handle the class/build path for you, based on the configuration file. standard directory structure $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Maven/Additional Repositories.html",
    "title": "Additional Repositories",
    "body": " index search search back additional repositories as we have said, if maven does not find some dependency in your local repository it goes to the central repository to search for it. but what if the dependency is not in the central repository. then we have to define the repository in our pom.xml: $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Maven/POM File Structure.html",
    "title": "POM File Structure",
    "body": " index search search back pom file structure the pom file has the following structure: project metadata: information about the project dependencies: list of dependencies for the project plug-ins: additional custom tasks to run (junit tests, reports, etc) project coordinates project coordinates uniquely identify a project: where: group id: name of company, group or organization artifact id: name for the project version: a specific release version dependency coordinates to add a given dependency project, we need: group id artifact id optional: version (best practice to include the version) find dependencies search maven maven repository $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Maven/Maven Archetypes.html",
    "title": "Maven Archetypes",
    "body": " index search search back maven archetypes archetypes are used to create new maven projects, you can think of them as starter projects. some archetypes are: for standalone projects: maven-archetype-quickstart for web projects: maven-archetype-webapp $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Maven/Private Repositories.html",
    "title": "Private Repositories",
    "body": " index search search back private repositories if you want to create repositories with restricted access you can: set up your own private maven repository in your server, that is secure with credentials: id/password some maven repository manager products are: archiva artifactory nexus if you do not want to create your own server, there are also cloud based solutions like: package cloud my maven repo $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/index.html",
    "title": "Spring",
    "body": " index search search back spring introduction core spring framework spring mvc hibernate spring rest spring boot thymeleaf maven spring security aspect oriented programming intro spring docs getting ready spring framework set up core spring framework spring with xml configuration inversion of control dependency injection bean scopes and life cycle spring with java annotations java annotations spring with only java spring configuration with java code spring mvc overview configuration controller view read html form data model add css and js request params and request mappings form tags form validation hibernate overview configuration annotations usage sessions database operations advanced annotations concepts onetoone onetomany eager vs lazy loading manytomany spring rest json data binding spring rest controller pojos as json exception handling spring boot overview controller spring boot project structure spring boot starters spring boot devtools spring boot actuator application properties jpa spring data jpa spring data rest thymeleaf overview tables maven overview pom file structure maven archetypes additional repositories private repositories spring security overview java configuration basic security custom login form log out cross site request forgery display user and roles authorization jdbc database authentication aspect oriented programming (aop) overview before advice pointcut expressions pointcut declarations control aspect order joinpoints afterreturning advice afterthrowing advice after advice around advice $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Set Up.html",
    "title": "Set Up",
    "body": " index search search back set up requirements: jdk java application server (i.e. tomcat) java integrated development environment (ide) spring 5 jar files (download manually or use maven) $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Security/Custom Login Form.html",
    "title": "Custom Login Form",
    "body": " index search search back custom login form now we are going to configure the security of the access to web path in application, login, logout, etc: package com.springsecurity.demo.config; import org.springframework.context.annotation.configuration; import org.springframework.security.config.annotation.authentication.builders.authenticationmanagerbuilder; import org.springframework.security.config.annotation.web.builders.httpsecurity; import org.springframework.security.config.annotation.web.configuration.enablewebsecurity; import org.springframework.security.config.annotation.web.configuration.websecurityconfigureradapter; import org.springframework.security.core.userdetails.user; import org.springframework.security.core.userdetails.user.userbuilder; @configuration @enablewebsecurity public class demosecurityconfig extends websecurityconfigureradapter { \t@override \tprotected void configure(authenticationmanagerbuilder auth) throws exception { \t\t// add our users for in memory authentication \t\tuserbuilder users = user.withdefaultpasswordencoder(); \t\t \t\tauth.inmemoryauthentication() \t\t\t.withuser(users.username(\"john\").password(\"test123\").roles(\"employee\")) \t\t\t.withuser(users.username(\"mary\").password(\"test123\").roles(\"manager\")) \t\t\t.withuser(users.username(\"susan\").password(\"test123\").roles(\"admin\")); \t} \t@override \tprotected void configure(httpsecurity http) throws exception { // here is the control of the access to web path http.authorizerequests() // require authentication for every request .anyrequest().authenticated() // and for form login customize the login page shown .and() .formlogin() \t\t\t\t\t\t// custom jsp page .loginpage(\"/showmyloginpage\") \t\t\t\t\t\t// you do not need to create a method in your controller for this endpoint, it is handled by spring .loginprocessingurl(\"/authenticatetheuser\") .permitall(); \t\t \t} } create the form we create the login page /showmyloginpage as follows: <!-- reference the spring and jsp tags --> <%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %> <%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %> <html> <head> \t<title>custom login page</title> \t<style> \t\t.failed { \t\t\tcolor: red; \t\t} \t</style> </head> <body> <h3>my custom login page</h3> \t\t<!-- the form points to the endpoint specified preivously: \"authenticatetheuser\" --> \t\t<!-- contextpath is the domain of our app, i.e. localhost:8080 --> \t<form:form action=\"${pagecontext.request.contextpath}/authenticatetheuser\" \t\t\t method=\"post\"> \t\t<!-- check for login error --> \t\t<c:if test=\"${param.error != null}\"> \t\t\t<i class=\"failed\">sorry! you entered invalid username/password.</i> \t\t</c:if> \t\t<p> \t\t\tuser name: <input type=\"text\" name=\"username\" /> \t\t</p> \t\t<p> \t\t\tpassword: <input type=\"password\" name=\"password\" /> \t\t</p> \t\t<input type=\"submit\" value=\"login\" /> \t</form:form> </body> </html> note that spring appends a parameter error when the user fails to login. that is what we use as a condition to show our error message, that is, we check if param.error exists. also, spring security defines default names for login form fields: user name field: username password field: password login controller we also need a controller method for requests to /showmyloginpage: package com.springsecurity.demo.controller; import org.springframework.stereotype.controller; import org.springframework.web.bind.annotation.getmapping; @controller public class logincontroller { \t@getmapping(\"/showmyloginpage\") \tpublic string showmyloginpage() { \t\t \t\t// this is the custom-login.jsp we created in the previous section \t\treturn \"custom-login\"; \t\t \t} } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Security/JDBC Database Authentication.html",
    "title": "JDBC Database Authentication",
    "body": " index search search back jdbc database authentication spring security can read user account info from database by default, you have to follow spring security's predefined table schemas. you can customize the table schemas, but you will be responsible for writing the code to access the data. set up database the tables we have to create are the following: password encryption in spring security 5, passwords are stored using a specific format: {id}encodedpassword the id references the operation used to encrypt the password: noop: plain text. so the password is stored as follows in the database: {noop}test123 bcrypt: bcrypt password hashing. so the password is stored as follows in the database: {bcrypt}$2a$12$r9h/cipz0gi.urnnx3kh2opst9/pgbkqquzi.ss7kiugo2t0jwmuw etc. add dependiencies we define the dependencies in our pom.xmlfile that are needed to add support to connect to databases: \t\t<!-- add mysql and c3p0 support --> \t\t<dependency> \t\t\t<groupid>mysql</groupid> \t\t\t<artifactid>mysql-connector-java</artifactid> \t\t\t<version>8.0.16</version> \t\t</dependency> \t\t \t\t<dependency> \t\t\t<groupid>com.mchange</groupid> \t\t\t<artifactid>c3p0</artifactid> \t\t\t<version>0.9.5.4</version> \t\t</dependency> jdbc properties files inside /src/main/resources we create the properties file persistence-mysql.properties for our database connections: # # jdbc connection properties # jdbc.driver=com.mysql.jdbc.driver jdbc.url=jdbc:mysql://localhost:3306/spring_security_demo_plaintext?usessl=false jdbc.user=springstudent jdbc.password=springstudent # # connection pool properties # connection.pool.initialpoolsize=5 connection.pool.minpoolsize=5 connection.pool.maxpoolsize=20 connection.pool.maxidletime=3000 spring security configuration we have to modify our main configuration class, to include our database properties file and create the datasource package com.luv2code.springsecurity.demo.config; import java.beans.propertyvetoexception; import java.util.logging.logger; import javax.sql.datasource; import org.springframework.beans.factory.annotation.autowired; import org.springframework.context.annotation.bean; import org.springframework.context.annotation.componentscan; import org.springframework.context.annotation.configuration; import org.springframework.context.annotation.propertysource; import org.springframework.core.env.environment; import org.springframework.web.servlet.viewresolver; import org.springframework.web.servlet.config.annotation.enablewebmvc; import org.springframework.web.servlet.view.internalresourceviewresolver; import com.mchange.v2.c3p0.combopooleddatasource; @configuration @enablewebmvc @componentscan(basepackages=\"com.luv2code.springsecurity.demo\") @propertysource(\"classpath:persistence-mysql.properties\") public class demoappconfig { \t// set up variable to hold the properties \t@autowired \tprivate environment env; \t \t// set up a logger for diagnostics \tprivate logger logger = logger.getlogger(getclass().getname()); \t \t \t// define a bean for viewresolver \t@bean \tpublic viewresolver viewresolver() { \t\t \t\tinternalresourceviewresolver viewresolver = new internalresourceviewresolver(); \t\t \t\tviewresolver.setprefix(\"/web-inf/view/\"); \t\tviewresolver.setsuffix(\".jsp\"); \t\t \t\treturn viewresolver; \t} \t \t// define a bean for our security datasource \t \t@bean \tpublic datasource securitydatasource() { \t\t \t\t// create connection pool \t\tcombopooleddatasource securitydatasource \t\t\t\t\t\t\t\t\t= new combopooleddatasource(); \t\t\t\t \t\t// set the jdbc driver class \t\ttry { // obtain driver from properties file \t\t\tsecuritydatasource.setdriverclass(env.getproperty(\"jdbc.driver\")); \t\t} catch (propertyvetoexception exc) { \t\t\tthrow new runtimeexception(exc); \t\t} \t\t \t\t // obtain database info from properties file \t\tlogger.info(\">>> jdbc.url=\" + env.getproperty(\"jdbc.url\")); \t\tlogger.info(\">>> jdbc.user=\" + env.getproperty(\"jdbc.user\")); \t\t \t\t \t\t// set database connection props \t\tsecuritydatasource.setjdbcurl(env.getproperty(\"jdbc.url\")); \t\tsecuritydatasource.setuser(env.getproperty(\"jdbc.user\")); \t\tsecuritydatasource.setpassword(env.getproperty(\"jdbc.password\")); \t\t \t\t// set connection pool props \t\tsecuritydatasource.setinitialpoolsize( \t\t\t\tgetintproperty(\"connection.pool.initialpoolsize\")); \t\tsecuritydatasource.setminpoolsize( \t\t\t\tgetintproperty(\"connection.pool.minpoolsize\")); \t\tsecuritydatasource.setmaxpoolsize( \t\t\t\tgetintproperty(\"connection.pool.maxpoolsize\")); \t\tsecuritydatasource.setmaxidletime( \t\t\t\tgetintproperty(\"connection.pool.maxidletime\")); \t\t \t\treturn securitydatasource; \t} \t \t// need a helper method \t// read environment property and convert to int \t \tprivate int getintproperty(string propname) { \t\t \t\tstring propval = env.getproperty(propname); \t\t \t\t// now convert to int \t\tint intpropval = integer.parseint(propval); \t\t \t\treturn intpropval; \t} } now in our security configuration we do two things: inject the datasource we defined previouly that holds authentication information tell spring to use jdbc for authentication package com.springsecurity.demo.config; import javax.sql.datasource; import org.springframework.beans.factory.annotation.autowired; import org.springframework.context.annotation.configuration; import org.springframework.security.config.annotation.authentication.builders.authenticationmanagerbuilder; import org.springframework.security.config.annotation.web.builders.httpsecurity; import org.springframework.security.config.annotation.web.configuration.enablewebsecurity; import org.springframework.security.config.annotation.web.configuration.websecurityconfigureradapter; import org.springframework.security.core.userdetails.user; import org.springframework.security.core.userdetails.user.userbuilder; @configuration @enablewebsecurity public class demosecurityconfig extends websecurityconfigureradapter { \t// add a reference to our security data source \t@autowired \tprivate datasource securitydatasource; \t \t \t@override \tprotected void configure(authenticationmanagerbuilder auth) throws exception { \t\t// use jdbc authentication \t\tauth.jdbcauthentication().datasource(securitydatasource); \t\t \t} \t@override \tprotected void configure(httpsecurity http) throws exception { \t\thttp.authorizerequests() \t\t\t.antmatchers(\"/\").hasrole(\"employee\") \t\t\t.antmatchers(\"/leaders/**\").hasrole(\"manager\") \t\t\t.antmatchers(\"/systems/**\").hasrole(\"admin\") \t\t\t.and() \t\t\t.formlogin() \t\t\t\t.loginpage(\"/showmyloginpage\") \t\t\t\t.loginprocessingurl(\"/authenticatetheuser\") \t\t\t\t.permitall() \t\t\t.and() \t\t\t.logout().permitall() \t\t\t.and() \t\t\t.exceptionhandling().accessdeniedpage(\"/access-denied\"); \t\t \t} } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Security/Authorization.html",
    "title": "Authorization",
    "body": " index search search back authorization in this section we are going to show how to restrict access based on roles. our example follows the following scheme: where only managers and above can access the /leaders endpoint and only admins can access the /systems endpoint. create controllers we create a basic controller for every endpoint: package com.springsecurity.demo.controller; import org.springframework.stereotype.controller; import org.springframework.web.bind.annotation.getmapping; @controller public class democontroller { \t// add request mapping for index page \t@getmapping(\"/\") \tpublic string showhome() { \t\t \t\treturn \"home\"; \t} \t \t// add request mapping for /leaders \t@getmapping(\"/leaders\") \tpublic string showleaders() { \t\t \t\treturn \"leaders\"; \t} \t \t// add request mapping for /systems \t@getmapping(\"/systems\") \tpublic string showsystems() { \t\t \t\treturn \"systems\"; \t} \t } we also create a controller for the /acess-denied endpoint: package com.springsecurity.demo.controller; import org.springframework.stereotype.controller; import org.springframework.web.bind.annotation.getmapping; @controller public class logincontroller { \t@getmapping(\"/showmyloginpage\") \tpublic string showmyloginpage() { \t\t \t\t// return \"plain-login\"; \t\treturn \"fancy-login\"; \t} \t \t// add request mapping for /access-denied \t@getmapping(\"/access-denied\") \tpublic string showaccessdenied() { \t\t \t\treturn \"access-denied\"; \t} } define user roles and restrict accessand restrict access in our configuration file we had saved in-memory a list of users with some defined roles, we are going to update it to have more roles. we are also going to define the authorization scheme we showed earlier. package com.springsecurity.demo.config; import org.springframework.context.annotation.configuration; import org.springframework.security.config.annotation.authentication.builders.authenticationmanagerbuilder; import org.springframework.security.config.annotation.web.builders.httpsecurity; import org.springframework.security.config.annotation.web.configuration.enablewebsecurity; import org.springframework.security.config.annotation.web.configuration.websecurityconfigureradapter; import org.springframework.security.core.userdetails.user; import org.springframework.security.core.userdetails.user.userbuilder; @configuration @enablewebsecurity public class demosecurityconfig extends websecurityconfigureradapter { @override protected void configure(authenticationmanagerbuilder auth) throws exception { // add our users for in memory authentication userbuilder users = user.withdefaultpasswordencoder(); // add more roles auth.inmemoryauthentication() .withuser(users.username(\"john\").password(\"test123\").roles(\"employee\")) .withuser(users.username(\"mary\").password(\"test123\").roles(\"employee\", \"manager\")) .withuser(users.username(\"susan\").password(\"test123\").roles(\"employee\", \"admin\")); } @override protected void configure(httpsecurity http) throws exception { // handle requests http.authorizerequests() // set role for index page .antmatchers(\"/\").hasrole(\"employee\") // set role for leaders page .antmatchers(\"/leaders/**\").hasrole(\"manager\") // set role for systems page .antmatchers(\"/systems/**\").hasrole(\"admin\") .and() .formlogin() .loginpage(\"/showmyloginpage\") .loginprocessingurl(\"/authenticatetheuser\") .permitall() .and() .logout().permitall() // also define the page where the user is redirected if it does not have access to the resource it requests .and() .exceptionhandling().accessdeniedpage(\"/access-denied\"); } } display content based on roles in our home page, we add two conditionals so only managers can see the link to the leaders page, and only admins can see the link to the systems page: <%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %> <%@ taglib prefix=\"security\" uri=\"http://www.springframework.org/security/tags\" %> <html> <head> \t<title>luv2code company home page</title> </head> <body> \t<h2>luv2code company home page</h2> \t<hr> \t<p> \twelcome to the luv2code company home page! \t</p> \t<hr> \t<!-- display user name and role --> \t<p> \t\tuser: <security:authentication property=\"principal.username\" /> \t\t<br><br> \t\trole(s): <security:authentication property=\"principal.authorities\" /> \t</p> \t<!-- check if user has the manager role, if so show the link --> \t<security:authorize access=\"hasrole('manager')\"> \t\t<!-- add a link to point to /leaders ... this is for the managers --> \t\t<p> \t\t\t<a href=\"${pagecontext.request.contextpath}/leaders\">leadership meeting</a> \t\t\t(only for manager peeps) \t\t</p> \t</security:authorize>\t \t<!-- check if user has the admin role, if so show the link --> \t<security:authorize access=\"hasrole('admin')\"> \t\t<!-- add a link to point to /systems ... this is for the admins --> \t\t<p> \t\t\t<a href=\"${pagecontext.request.contextpath}/systems\">it systems meeting</a> \t\t\t(only for admin peeps) \t\t</p> \t</security:authorize> \t<hr> \t<!-- add a logout button --> \t<form:form action=\"${pagecontext.request.contextpath}/logout\" \t\t\t method=\"post\"> \t\t<input type=\"submit\" value=\"logout\" /> \t</form:form> </body> </html> $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Security/Java Configuration.html",
    "title": "Java Configuration",
    "body": " index search search back java configuration we are going to show the demoappconfig.java that holds the base configuration of our application: package com.springsecurity.demo.config; import org.springframework.context.annotation.bean; import org.springframework.context.annotation.componentscan; import org.springframework.context.annotation.configuration; import org.springframework.web.servlet.viewresolver; import org.springframework.web.servlet.config.annotation.enablewebmvc; import org.springframework.web.servlet.view.internalresourceviewresolver; // tell spring this is a configuration file @configuration // enables annotations @enablewebmvc // search for components in \"com.springsecurity.demo\" package @componentscan(basepackages=\"com.springsecurity.demo\") public class demoappconfig { \t// define a bean for viewresolver \t@bean \tpublic viewresolver viewresolver() { \t\t \t\tinternalresourceviewresolver viewresolver = new internalresourceviewresolver(); \t\t \t\tviewresolver.setprefix(\"/web-inf/view/\"); \t\tviewresolver.setsuffix(\".jsp\"); \t\t \t\treturn viewresolver; \t} } as you can see we have defined a viewresolver that prepends /web-inf/view/ to every view, and appends .jsp to every view. web app initializer spring mvc provides support for web app initialization, and makes sure your code is automatically detected. your code is used to initialize the servlet container. as an example: package com.springsecurity.demo.config; import org.springframework.web.servlet.support.abstractannotationconfigdispatcherservletinitializer; public class myspringmvcdispatcherservletinitializer extends abstractannotationconfigdispatcherservletinitializer { \t@override \tprotected class<?>[] getrootconfigclasses() { \t\t// todo auto-generated method stub \t\treturn null; \t} \t@override \t// tell spring where the configuration for the servlet is \tprotected class<?>[] getservletconfigclasses() { \t\treturn new class[] { demoappconfig.class }; \t} \t@override \t// map the servlet to the path \"/\" \tprotected string[] getservletmappings() { \t\treturn new string[] { \"/\" }; \t} } here is the correspondence with the xml servlet configuration file: $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Security/Basic Security.html",
    "title": "Basic Security",
    "body": " index search search back basic security create security spring initializer spring security provides support for security initialization. your security code is used to initialize the servlet container. there is a special class to register the spring security filters. you need this class for the spring security filters to \"activate\". next we show an example: package com.springsecurity.demo.config; import org.springframework.security.web.context.abstractsecuritywebapplicationinitializer; public class securitywebapplicationinitializer \t\t\t\t\t\textends abstractsecuritywebapplicationinitializer { } create spring security configuration (@configuration) now we create our spring security configuration file: package com.springsecurity.demo.config; import org.springframework.context.annotation.configuration; import org.springframework.security.config.annotation.authentication.builders.authenticationmanagerbuilder; import org.springframework.security.config.annotation.web.builders.httpsecurity; import org.springframework.security.config.annotation.web.configuration.enablewebsecurity; import org.springframework.security.config.annotation.web.configuration.websecurityconfigureradapter; import org.springframework.security.core.userdetails.user; import org.springframework.security.core.userdetails.user.userbuilder; // tell spring this is a configuration file @configuration @enablewebsecurity public class demosecurityconfig extends websecurityconfigureradapter { \t@override \tprotected void configure(authenticationmanagerbuilder auth) throws exception { \t\t// add our users for in memory authentication (this is for test purposes only, you would usually retrieve this information encrypted from the database) \t\tuserbuilder users = user.withdefaultpasswordencoder(); \t\t // use the authenticationmanagerbuilder given by spring to handle authentication \t\tauth \t\t\t.inmemoryauthentication() \t\t\t.withuser(users.username(\"john\").password(\"test123\").roles(\"employee\")) \t\t\t.withuser(users.username(\"mary\").password(\"test123\").roles(\"manager\")) \t\t\t.withuser(users.username(\"susan\").password(\"test123\").roles(\"admin\")); \t} } add users, passwords and roles $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Security/index.html",
    "title": "Overview",
    "body": " index search search back overview spring security is implemented using servlet filters in the background there are two methods of securing a web app: declarative programmatic servlet filters servlet filters are used to pre-process/post-process web requests. they can route web requests based on security logic. spring provides a bulk of security functionality with servlet filters. this is described in the following picture: we can see spring intercepts the request to /mytopsecretstuff and uses the app's security configuration, alongside information about the user, passwords and roles to pre and post-process the request. spring security in action next we show a flowchart of the pre-processing made by spring security filters: if the resource is protected we go to step (2), else we go to step (4) if the user is authenticated we go to step (3), else we go to step (6) if the user is authorized to access the resource we go to step (4), else we go to step (5) the resource is shown to the user the access to the resource is denied we send the user to the login page, if the user logins correctly we go to step (3) declarative security you define your application's security constraints in configuration. for that, you can either: use all java configuration (@configuration) use a spring configuration file (xml) programmatic security you can also do it programmatically: spring security provides an api for custom application coding. it also provides greater customization for specific apps. authentication/authorization information about users/passwords/roles, etc can be stored: in-memory jdbc ldap custom etc maven dependencies to use this framework, you have to add the following dependency to your project: \t<dependencies> ... \t\t<!-- spring security --> \t\t<!-- spring-security-web and spring-security-config --> \t\t \t\t<dependency> \t\t <groupid>org.springframework.security</groupid> \t\t <artifactid>spring-security-web</artifactid> \t\t <version>${springsecurity.version}</version> \t\t</dependency> ... \t<dependencies> $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Security/Cross Site Request Forgery.html",
    "title": "Cross Site Request Forgery",
    "body": " index search search back cross site request forgery spring security protects against cross-site request forgery. csrf is a security attack where a website tricks you into executing an action on a web application that you are currently logged in. protection from this type of attack is embedded in the spring security filters. this protection is enabled by default. spring security uses the synchronizer token pattern, where each request includes a session cookie and a randomly generated token. so for request processing, spring security verifies the token before processing. how to use it? for form submissions use \"post\" instead of \"get\" the spring security tag <form:form> automatically adds the csrf token. if you do not use the tag, you must manually add the csrf token. if you do not add the token you get an error message: 403 forbidden, and further information about how the token cannot be null. how to see the csrf token? when your jsp with the <form:form> tag is processed into an html page, you will be able to see the token inside the form tag: $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Security/Display User and Roles.html",
    "title": "Display User and Roles",
    "body": " index search search back display user and roles in this section we are going to show how to display in our jsp files the user id and its role: add jsp tag library as dependency first we add to our pom.xml file the jsp tag library: \t\t<!-- add spring security taglibs support --> \t\t<dependency> \t\t <groupid>org.springframework.security</groupid> \t\t <artifactid>spring-security-taglibs</artifactid> \t\t <version>${springsecurity.version}</version> \t\t</dependency>\t jsp page then add the tag library to the jsp page, and we use its tags to access the user id and its role: <%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %> <!-- add tag library --> <%@ taglib prefix=\"security\" uri=\"http://www.springframework.org/security/tags\" %> <html> <head> \t<title>luv2code company home page</title> </head> <body> \t<h2>luv2code company home page</h2> \t<hr> \t<p> \twelcome to the luv2code company home page! \t</p> \t<hr> \t<!-- display user name and role --> \t<p> \t\tuser: <security:authentication property=\"principal.username\" /> \t\t<br><br> \t\trole(s): <security:authentication property=\"principal.authorities\" /> \t</p> \t<hr> \t<!-- add a logout button --> \t<form:form action=\"${pagecontext.request.contextpath}/logout\" \t\t\t method=\"post\"> \t\t<input type=\"submit\" value=\"logout\" /> \t</form:form> </body> </html> $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Security/Log Out.html",
    "title": "Log Out",
    "body": " index search search back log out we are going to show in this section how to add the logout functionality to our spring application. configuration to our existing configuration we add: package com.springsecurity.demo.config; import org.springframework.context.annotation.configuration; import org.springframework.security.config.annotation.authentication.builders.authenticationmanagerbuilder; import org.springframework.security.config.annotation.web.builders.httpsecurity; import org.springframework.security.config.annotation.web.configuration.enablewebsecurity; import org.springframework.security.config.annotation.web.configuration.websecurityconfigureradapter; import org.springframework.security.core.userdetails.user; import org.springframework.security.core.userdetails.user.userbuilder; @configuration @enablewebsecurity public class demosecurityconfig extends websecurityconfigureradapter { \t@override \tprotected void configure(authenticationmanagerbuilder auth) throws exception { \t\t// add our users for in memory authentication \t\tuserbuilder users = user.withdefaultpasswordencoder(); \t\t \t\tauth.inmemoryauthentication() \t\t\t.withuser(users.username(\"john\").password(\"test123\").roles(\"employee\")) \t\t\t.withuser(users.username(\"mary\").password(\"test123\").roles(\"manager\")) \t\t\t.withuser(users.username(\"susan\").password(\"test123\").roles(\"admin\")); \t} \t@override \tprotected void configure(httpsecurity http) throws exception { // here is the control of the access to web path http.authorizerequests() // require authentication for every request .anyrequest().authenticated() .and() .formlogin() .loginpage(\"/showmyloginpage\") .loginprocessingurl(\"/authenticatetheuser\") .permitall(); // add logout functionality .and() .logout().permitall() \t\t \t} } the default url for logging out is /logout. log out button now we create the logout button in our home page: <%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %> <html> <head> \t<title>luv2code company home page</title> </head> <body> \t<h2>luv2code company home page</h2> \t<hr> \t<p> \twelcome to the luv2code company home page! \t</p> \t<!-- add a logout button: it point to \"/logout\" endpoint --> \t<form:form action=\"${pagecontext.request.contextpath}/logout\" \t\t\t method=\"post\"> \t\t<input type=\"submit\" value=\"logout\" /> \t</form:form> </body> </html> note that the logout logic is handled directly by spring, what it does is: invalidate the user's http session and remove cookies, etc. sends the user back to the login page appends a logout parameter: ?logout $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Thymeleaf/Overview.html",
    "title": "Overview",
    "body": " index search search back overview thymeleaf is a java templating engine. a thymeleaf template can be an html page with some thymeleaf expressions and include dynamic content from thymeleaf expressions. in a web app, thymeleaf is processed on the server. to use thymeleaf you have to include it in your dependencies: ... \t\t<dependency> \t\t\t<groupid>org.springframework.boot</groupid> \t\t\t<artifactid>spring-boot-starter-thymeleaf</artifactid> \t\t</dependency> ... placement in spring boot, your thymeleaf template files go in src/main/resources/templates. and for web apps, thymeleaf templates have an .html extension. example given the following controller: @controller public class democontroller { \t// create a mapping for \"/hello\" \t@getmapping(\"/hello\") \tpublic string sayhello(model themodel) { \t\t \t\tthemodel.addattribute(\"thedate\", new java.util.date()); \t\t \t\treturn \"helloworld\"; \t} } we create the corresponding template helloworld.html: <!doctype html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> \t<title>thymeleaf demo</title> </head> <!-- we obtain the date from the model --> <body> \t<p th:text=\"'time on the server is ' + ${thedate}\" /> </body> </html> to add styles, we create a css files in src/main/resources/static/css, and then we reference the styles: <!doctype html> <html xmlns:th=\"http://www.thymeleaf.org\"> <head> \t<title>thymeleaf demo</title> \t<!-- reference css file --> \t<link rel=\"stylesheet\" \t\t th:href=\"@{/css/demo.css}\" /> </head> <body> \t<p th:text=\"'time on the server is ' + ${thedate}\" class=\"funny\" /> </body> </html> $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Thymeleaf/Tables.html",
    "title": "Tables in Thymeleaf",
    "body": " index search search back tables in thymeleaf in this section we are going to show how to create a table with thymeleaf: controller we create a controller for employee, to list and add employees. package com.springboot.thymeleafdemo.controller; import java.util.arraylist; import java.util.list; import javax.annotation.postconstruct; import org.springframework.stereotype.controller; import org.springframework.ui.model; import org.springframework.web.bind.annotation.getmapping; import org.springframework.web.bind.annotation.requestmapping; import com.springboot.thymeleafdemo.model.employee; @controller @requestmapping(\"/employees\") public class employeecontroller { \t// load employee data \t \tprivate list<employee> theemployees; \t \t@postconstruct \tprivate void loaddata() { \t\t \t\t// create employees \t\temployee emp1 = new employee(1, \"leslie\", \"andrews\", \"leslie@luv2code.com\"); \t\temployee emp2 = new employee(2, \"emma\", \"baumgarten\", \"emma@luv2code.com\"); \t\temployee emp3 = new employee(3, \"avani\", \"gupta\", \"avani@luv2code.com\"); \t\t// create the list \t\ttheemployees = new arraylist<>(); \t\t \t\t// add to the list \t\ttheemployees.add(emp1); \t\ttheemployees.add(emp2); \t\ttheemployees.add(emp3); \t \t} \t \t// add mapping for \"/list\" \t@getmapping(\"/list\") \tpublic string listemployees(model themodel) { \t\t \t\t// add to the spring model \t\tthemodel.addattribute(\"employees\", theemployees); \t\t \t\treturn \"list-employees\"; \t} } entity we create the entity employee: package com.springboot.thymeleafdemo.model; public class employee { \tprivate int id; \tprivate string firstname; \tprivate string lastname; \tprivate string email; \tpublic employee() { \t\t \t} \tpublic employee(int id, string firstname, string lastname, string email) { \t\tthis.id = id; \t\tthis.firstname = firstname; \t\tthis.lastname = lastname; \t\tthis.email = email; \t} \tpublic int getid() { \t\treturn id; \t} \tpublic void setid(int id) { \t\tthis.id = id; \t} \tpublic string getfirstname() { \t\treturn firstname; \t} \tpublic void setfirstname(string firstname) { \t\tthis.firstname = firstname; \t} \tpublic string getlastname() { \t\treturn lastname; \t} \tpublic void setlastname(string lastname) { \t\tthis.lastname = lastname; \t} \tpublic string getemail() { \t\treturn email; \t} \tpublic void setemail(string email) { \t\tthis.email = email; \t} \t@override \tpublic string tostring() { \t\treturn \"employee [id=\" + id + \", firstname=\" + firstname + \", lastname=\" + lastname + \", email=\" + email + \"]\"; \t} \t\t } template finally we create the template for list-employees.html: <!doctype html> <html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"> <head> <!-- required meta tags --> <meta charset=\"utf-8\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"> <!-- bootstrap css --> <link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/css/bootstrap.min.css\" integrity=\"sha384-gjzzqfgwb1qttn6wy59fff1bugjplsa9dkkmp0dgimdm4iymj70gzwkybi706tws\" crossorigin=\"anonymous\"> <title>employee directory</title> </head> <body> <div class=\"container\"> <h3>employee directory</h3> <hr> <table class=\"table table-bordered table-striped\"> <thead class=\"thead-dark\"> <tr> <th>first name</th> <th>last name</th> <th>email</th> </tr> </thead> <tbody> <!-- for loop for all employees, stored in the model --> <tr th:each=\"tempemployee : ${employees}\"> <td th:text=\"${tempemployee.firstname}\" />\t <td th:text=\"${tempemployee.lastname}\" />\t <td th:text=\"${tempemployee.email}\" />\t </tr> </tbody>\t\t </table> </div> </body> </html> $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Bean Scopes/Life Cycle.html",
    "title": "Bean Life Cycle",
    "body": " index search search back bean life cycle the bean life cycle is as follows: as you can see you can add method/hooks: add custom code during bean initialization calling business logic methods setting up handles to resources (db, sockets, etc) add custom code during bean destruction calling business logic methods clean up handles to resources (db, sockets, etc) define methods first of all we define the methods in our bean: package com.springdemo; public class trackcoach implements coach { \tprivate fortuneservice fortuneservice; \tpublic trackcoach() { \t\t \t} \t \tpublic trackcoach(fortuneservice fortuneservice) { \t\tthis.fortuneservice = fortuneservice; \t} \t@override \tpublic string getdailyworkout() { \t\treturn \"run a hard 5k\"; \t} \t@override \tpublic string getdailyfortune() { \t\treturn \"just do it: \" + fortuneservice.getfortune(); \t} \t// add an init method \tpublic void domystartupstuff() { \t\tsystem.out.println(\"trackcoach: inside method domystartupstuff\"); \t} \t \t// add a destroy method \tpublic void domycleanupstuffyoyo() { \t\tsystem.out.println(\"trackcoach: inside method domycleanupstuffyoyo\");\t\t \t} } configure hooks in the configuration file once the initialization and clean-up methods have been defined, we configure them in our configuration file: <?xml version=\"1.0\" encoding=\"utf-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/xmlschema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemalocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"> \t<!-- define your beans here --> \t \t<!-- define the dependency --> \t<bean id=\"myfortuneservice\" \t class=\"com.springdemo.happyfortuneservice\"> \t</bean> \t \t<!-- note the new tag \"scope\" --> \t<bean id=\"mycoach\" \tclass=\"com.springdemo.trackcoach\" \t\tinit-method=\"domystartupstuff\" \t\tdestroy-method=\"domycleanupstuffyoyo\">\t \t\t \t\t<!-- set up constructor injection --> \t\t<constructor-arg ref=\"myfortuneservice\" /> \t</bean> </beans> main method now in our app, we create the bean to check that our methods are being called: package com.springdemo; import org.springframework.context.support.classpathxmlapplicationcontext; public class beanlifecycledemoapp { \t \tpublic static void main(string[] args) { \t\t// load the spring configuration file \t\tclasspathxmlapplicationcontext context = \t\t\t\tnew classpathxmlapplicationcontext(\"beanlifecycle-applicationcontext.xml\"); \t\t\t\t \t\t// retrieve bean from spring container \t\tcoach thecoach = context.getbean(\"mycoach\", coach.class); \t\tsystem.out.println(thecoach.getdailyworkout()); \t\t \t\t// close the context \t\tcontext.close(); \t} } notes when using xml configuration, i want to provide additional details regarding the method signatures of the init-method and destroy-method . access modifier: the method can have any access modifier (public, protected, private) return type: the method can have any return type. however, \"void' is most commonly used. if you give a return type just note that you will not be able to capture the return value. as a result, \"void\" is commonly used. method name: the method can have any method name. arguments: the method can not accept any arguments. the method should be no-arg. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Bean Scopes/Bean Scopes and Life cycle.html",
    "title": "Spring Bean Scopes and Life Cycle",
    "body": " index search search back spring bean scopes and life cycle scope life cycle $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Bean Scopes/Scope.html",
    "title": "Bean Scopes",
    "body": " index search search back bean scopes intro the scope of a bean refers to the life cycle of the bean: how long does it live how many instances are created how is the bean shared the default scope of the bean is a singleton: the spring container creates only one instance of the bean it is cached in memory all requests to the bean will return a shared reference to the same bean other scopes are: a singleton scope is good for stateless data a prototype scope is good for stateful data (the container returns a new bean for each request). note that for this type of bean, spring does not call the destroy method. specify scope in xml config file <?xml version=\"1.0\" encoding=\"utf-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/xmlschema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemalocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"> <!-- define your beans here --> <!-- define the dependency --> <bean id=\"myfortuneservice\" class=\"com.springdemo.happyfortuneservice\"> </bean> <!-- note the new tag \"scope\" --> <bean id=\"mycoach\" class=\"com.springdemo.trackcoach\" scope=\"prototype\">\t <!-- set up constructor injection --> <constructor-arg ref=\"myfortuneservice\" /> </bean> </beans> main method now, from our application we do: package com.springdemo; import org.springframework.context.support.classpathxmlapplicationcontext; public class beanscopedemoapp { \tpublic static void main(string[] args) { \t\t// load the spring configuration file \t\tclasspathxmlapplicationcontext context = \t\t\t\tnew classpathxmlapplicationcontext(\"beanscope-applicationcontext.xml\"); \t\t\t\t \t\t// retrieve bean from spring container \t\tcoach thecoach = context.getbean(\"mycoach\", coach.class); \t\tcoach alphacoach = context.getbean(\"mycoach\", coach.class); \t\t \t\t// check if they are the same \t\tboolean result = (thecoach == alphacoach); \t\t \t\t// print out the results \t\tsystem.out.println(\"\\npointing to the same object: \" + result); \t\t \t\tsystem.out.println(\"\\nmemory location for thecoach: \" + thecoach); \t\tsystem.out.println(\"\\nmemory location for alphacoach: \" + alphacoach + \"\\n\"); \t \t\t// close the context \t\tcontext.close(); \t} } observe, the result variable should be set to false, because we are using the prototype scope. also the values of the memory location for the two objects should be distinct for that same reason. however if we were using scope=\"singleton\", then result should be true, and both objects should have the same memory location. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Spring Rest/Spring Rest Controller.html",
    "title": "Spring Rest Controller",
    "body": " index search search back spring rest controller spring web mvc provides support for spring rest. for that we use a new annotation called restcontroller which is an extension of controller and handles rest requests and responses. spring rest will also automatically convert java pojos to json as long as the jackson project is on the classpath or pom.xml. hello world to exemplify how to set up a rest controller in spring we will create an application that upong request sends back a hello world! message: configuration first of all, make sure you have the jackson project, mvc and rest and also servlet libraries as a maven dependency or as a library in your classpath. \t<dependencies> \t\t<!-- add spring mvc and rest support --> \t\t<dependency> \t\t\t<groupid>org.springframework</groupid> \t\t\t<artifactid>spring-webmvc</artifactid> \t\t\t<version>5.0.5.release</version> \t\t</dependency> \t\t \t\t<!-- add jackson for json converters --> \t\t<dependency> \t\t\t<groupid>com.fasterxml.jackson.core</groupid> \t\t\t<artifactid>jackson-databind</artifactid> \t\t\t<version>2.9.9.2</version> \t\t</dependency> \t\t<!-- add servlet support for \t\t\t spring's abstractannotationconfigdispatcherservletinitializer --> \t\t<dependency> \t\t\t<groupid>javax.servlet</groupid> \t\t\t<artifactid>javax.servlet-api</artifactid> \t\t\t<version>3.1.0</version> \t\t</dependency> \t\t<!-- add support for jsp ... get rid of eclipse error -->\t\t\t\t \t\t<dependency> \t\t\t<groupid>javax.servlet.jsp</groupid> \t\t\t<artifactid>javax.servlet.jsp-api</artifactid> \t\t\t<version>2.3.1</version> \t\t</dependency> \t\t\t\t \t</dependencies> general we create a configuration class as follows: package com.springdemo.config; import org.springframework.context.annotation.componentscan; import org.springframework.context.annotation.configuration; import org.springframework.web.servlet.config.annotation.enablewebmvc; import org.springframework.web.servlet.config.annotation.webmvcconfigurer; // mark it as a configuration class @configuration @enablewebmvc // enable component scanning in our source code @componentscan(\"com.springdemo\") public class demoappconfig implements webmvcconfigurer { } servlet initializer we have to specify the configuration of our servlet, for this we extend abstractannotationconfigdispatcherservletinitializer: package com.springdemo.config; import org.springframework.web.servlet.support.abstractannotationconfigdispatcherservletinitializer; public class myspringmvcdispatcherservletinitializer extends abstractannotationconfigdispatcherservletinitializer { \t@override \tprotected class<?>[] getrootconfigclasses() { \t\t// todo auto-generated method stub \t\treturn null; \t} \t@override \tprotected class<?>[] getservletconfigclasses() { // specify our config class \t\treturn new class[] { demoappconfig.class }; \t} \t@override \tprotected string[] getservletmappings() { \t\treturn new string[] { \"/\" }; \t} } controller for this we need to create our server with the controller that handles this request: package com.springdemo.rest; import org.springframework.web.bind.annotation.getmapping; import org.springframework.web.bind.annotation.requestmapping; import org.springframework.web.bind.annotation.restcontroller; @restcontroller @requestmapping(\"/test\") public class demorestcontroller { \t// add code for the \"/hello\" endpoint \t \t@getmapping(\"/hello\") \tpublic string sayhello() { \t\treturn \"hello world!\"; \t} \t } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Spring Rest/POJOs as JSON.html",
    "title": "POJOs as JSON",
    "body": " index search search back pojos as json to test converting pojos to json we are going to create a service that allows us to retrieve a list of students: create pojo we are going to create the student entity: package com.springdemo.entity; public class student { \tprivate string firstname; \tprivate string lastname; \t \tpublic student() { \t\t \t} \tpublic student(string firstname, string lastname) { \t\tthis.firstname = firstname; \t\tthis.lastname = lastname; \t} \tpublic string getfirstname() { \t\treturn firstname; \t} \tpublic void setfirstname(string firstname) { \t\tthis.firstname = firstname; \t} \tpublic string getlastname() { \t\treturn lastname; \t} \tpublic void setlastname(string lastname) { \t\tthis.lastname = lastname; \t} \t } create service we now code the logic that handles the controller. package com.springdemo.rest; import java.util.arraylist; import java.util.list; import javax.annotation.postconstruct; import org.springframework.web.bind.annotation.getmapping; import org.springframework.web.bind.annotation.pathvariable; import org.springframework.web.bind.annotation.requestmapping; import org.springframework.web.bind.annotation.restcontroller; import com.luv2code.springdemo.entity.student; @restcontroller @requestmapping(\"/api\") public class studentrestcontroller { \tprivate list<student> thestudents; \t \t \t// define @postconstruct to load the student data ... only once! \t@postconstruct \tpublic void loaddata() { \t \t\tthestudents = new arraylist<>(); \t\t \t\tthestudents.add(new student(\"poornima\", \"patel\")); \t\tthestudents.add(new student(\"mario\", \"rossi\")); \t\tthestudents.add(new student(\"mary\", \"smith\"));\t\t \t} \t \t \t \t// define endpoint for \"/students\" - return list of students \t@getmapping(\"/students\") \tpublic list<student> getstudents() { \t\t\t \t\treturn thestudents; \t} \t \t// define endpoint for \"/students/{studentid}\" - return student at index \t@getmapping(\"/students/{studentid}\") \tpublic student getstudent(@pathvariable int studentid) { \t\t \t\t// just index into the list ... keep it simple for now \t\treturn thestudents.get(studentid); \t\t \t} } note that the endpoint \"/students/{studentid}\" has a path variable studentid $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Spring Rest/JSON Data Binding.html",
    "title": "Java JSON Data Binding",
    "body": " index search search back java json data binding data binding is the process of converting json data to a java pojo (the conversion goes both ways) data binding is the same as serialization/deserialization and marshalling/unmarshalling. spring uses the jackson project behind the scenes which handles data binding between json and java pojos. for conversion we use object mapper by default jackson will call appropiate getter and setter methods to populate a pojo from a json or to create a json object from a pojo. to convert from json to java, jackson calls the setter methods to convert from java to json, jackson calls the getter methods set up add jackson project as a dependency in the maven file: \t<dependencies> \t\t<!-- todo: add your dependency here --> \t\t<dependency> \t\t\t<groupid>com.fasterxml.jackson.core</groupid> \t\t\t<artifactid>jackson-databind</artifactid> \t\t\t<version>2.10.0.pr1</version> \t\t</dependency>\t \t\t\t \t</dependencies> create pojo class we now create the class we are going to convert to json (serialize): package com.jackson.json.demo; public class student { \tprivate int id; \tprivate string firstname; \tprivate string lastname; \tprivate boolean active; \t \tpublic student() { \t\t \t} \t \tpublic int getid() { \t\treturn id; \t} \t \tpublic void setid(int id) { \t\tthis.id = id; \t} \t \tpublic string getfirstname() { \t\treturn firstname; \t} \t \tpublic void setfirstname(string firstname) { \t\tthis.firstname = firstname; \t} \t \tpublic string getlastname() { \t\treturn lastname; \t} \t \tpublic void setlastname(string lastname) { \t\tthis.lastname = lastname; \t} \t \tpublic boolean isactive() { \t\treturn active; \t} \t \tpublic void setactive(boolean active) { \t\tthis.active = active; \t} \t } main app now, to test it we are going to create a student object by reading from a json object: package com.jackson.json.demo; import java.io.file; import com.fasterxml.jackson.databind.objectmapper; public class driver { \tpublic static void main(string[] args) { \t\t \t\ttry { \t\t\t// create object mapper \t\t\tobjectmapper mapper = new objectmapper(); \t\t\t \t\t\t// read json file and map/convert to java pojo: \t\t\t// data/sample-lite.json \t\t\t \t\t\tstudent thestudent = mapper.readvalue( \t\t\t\t\t\tnew file(\"data/sample-lite.json\"), student.class); \t\t} \t\tcatch (exception exc) { \t\t\texc.printstacktrace(); \t\t} \t} } nested objects but, how can we read nested properties inside a json file, like the following: { \t\"id\": 14, \t\"firstname\": \"mario\", \t\"lastname\": \"rossi\", \t\"active\": true, \t\"address\": { \t\t\"street\": \"100 main st\", \t\t\"city\": \"philadelphia\", \t\t\"state\": \"pennsylvania\", \t\t\"zip\": \"19103\", \t\t\"country\": \"usa\" \t}, \t\"languages\" : [\"java\", \"c#\", \"python\", \"javascript\"] } as you can see the address property has properties inside it. what we are going to do is create a new attribute address inside the student object, which will be a pojo object in itself. package com.jackson.json.demo; public class student { \tprivate int id; \tprivate string firstname; \tprivate string lastname; \tprivate boolean active; \t \tprivate address address; \t \tprivate string[] languages; \t \tpublic student() { \t\t \t} \t \tpublic int getid() { \t\treturn id; \t} \t \tpublic void setid(int id) { \t\tthis.id = id; \t} \t \tpublic string getfirstname() { \t\treturn firstname; \t} \t \tpublic void setfirstname(string firstname) { \t\tthis.firstname = firstname; \t} \t \tpublic string getlastname() { \t\treturn lastname; \t} \t \tpublic void setlastname(string lastname) { \t\tthis.lastname = lastname; \t} \t \tpublic boolean isactive() { \t\treturn active; \t} \t \tpublic void setactive(boolean active) { \t\tthis.active = active; \t} \tpublic address getaddress() { \t\treturn address; \t} \tpublic void setaddress(address address) { \t\tthis.address = address; \t} \tpublic string[] getlanguages() { \t\treturn languages; \t} \tpublic void setlanguages(string[] languages) { \t\tthis.languages = languages; \t} \t } we also need to create the address class: package com.jackson.json.demo; public class address { \tprivate string street; \tprivate string city; \tprivate string state; \tprivate string zip; \tprivate string country; \t \tpublic address() { \t\t \t} \tpublic string getstreet() { \t\treturn street; \t} \tpublic void setstreet(string street) { \t\tthis.street = street; \t} \tpublic string getcity() { \t\treturn city; \t} \tpublic void setcity(string city) { \t\tthis.city = city; \t} \tpublic string getstate() { \t\treturn state; \t} \tpublic void setstate(string state) { \t\tthis.state = state; \t} \tpublic string getzip() { \t\treturn zip; \t} \tpublic void setzip(string zip) { \t\tthis.zip = zip; \t} \tpublic string getcountry() { \t\treturn country; \t} \tpublic void setcountry(string country) { \t\tthis.country = country; \t} } ignore unknwon properties to ignore properties from the json file that cannot be mapped to an attribute in the pojo we use the annotation: package com.jackson.json.demo; @jsonignoreproperties(ignoreunkown=true) public class student { \tprivate int id; \tprivate string firstname; $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Spring Rest/Exception Handling.html",
    "title": "Exception Handling",
    "body": " index search search back exception handling in this section we are going to show how to create an error page to display when there is an error on a request. create error response class package com.springdemo.rest; public class studenterrorresponse { \tprivate int status; \tprivate string message; \tprivate long timestamp; \tpublic studenterrorresponse() { \t\t \t} \t \tpublic studenterrorresponse(int status, string message, long timestamp) { \t\tthis.status = status; \t\tthis.message = message; \t\tthis.timestamp = timestamp; \t} \tpublic int getstatus() { \t\treturn status; \t} \tpublic void setstatus(int status) { \t\tthis.status = status; \t} \tpublic string getmessage() { \t\treturn message; \t} \tpublic void setmessage(string message) { \t\tthis.message = message; \t} \tpublic long gettimestamp() { \t\treturn timestamp; \t} \tpublic void settimestamp(long timestamp) { \t\tthis.timestamp = timestamp; \t} \t \t } create exception class package com.springdemo.rest; public class studentnotfoundexception extends runtimeexception { \tpublic studentnotfoundexception(string message, throwable cause) { \t\tsuper(message, cause); \t} \tpublic studentnotfoundexception(string message) { \t\tsuper(message); \t} \tpublic studentnotfoundexception(throwable cause) { \t\tsuper(cause); \t} \t } rest service with exception what we need to know is: define an exception handler method with @exceptionhandler annotation the exception handler will return a response entity response entity is a wrapper for the http response object resposneentity provides a fine-grained control to specify: http status code http headers response body package com.springdemo.rest; import java.util.arraylist; import java.util.list; import javax.annotation.postconstruct; import org.springframework.http.httpstatus; import org.springframework.http.responseentity; import org.springframework.web.bind.annotation.exceptionhandler; import org.springframework.web.bind.annotation.getmapping; import org.springframework.web.bind.annotation.pathvariable; import org.springframework.web.bind.annotation.requestmapping; import org.springframework.web.bind.annotation.restcontroller; import com.springdemo.entity.student; @restcontroller @requestmapping(\"/api\") public class studentrestcontroller { \tprivate list<student> thestudents; \t// define @postconstruct to load the student data ... only once! \t@postconstruct \tpublic void loaddata() { \t \t\tthestudents = new arraylist<>(); \t\t \t\tthestudents.add(new student(\"poornima\", \"patel\")); \t\tthestudents.add(new student(\"mario\", \"rossi\")); \t\tthestudents.add(new student(\"mary\", \"smith\"));\t\t \t} \t \t \t \t// define endpoint for \"/students\" - return list of students \t@getmapping(\"/students\") \tpublic list<student> getstudents() { \t\t\t \t\treturn thestudents; \t} \t \t// define endpoint for \"/students/{studentid}\" - return student at index \t@getmapping(\"/students/{studentid}\") \tpublic student getstudent(@pathvariable int studentid) { \t\t \t\t// just index into the list ... keep it simple for now \t\t// check the studentid against list size \t\tif ( (studentid >= thestudents.size()) || (studentid < 0) ) {\t\t\t \t\t\tthrow new studentnotfoundexception(\"student id not found - \" + studentid); \t\t} \t\t \t\treturn thestudents.get(studentid); \t\t \t} // tag it as an exception handling method \t@exceptionhandler // type of response body exception type to handle \tpublic responseentity<studenterrorresponse> handleexception(studentnotfoundexception exc) { \t\t \t\tstudenterrorresponse error = new studenterrorresponse(); \t\t // json error object \t\terror.setstatus(httpstatus.not_found.value()); \t\terror.setmessage(exc.getmessage()); \t\terror.settimestamp(system.currenttimemillis()); \t // return response with the error object and the status code \t\treturn new responseentity<>(error, httpstatus.not_found); \t } // another exception handler \t@exceptionhandler // catch any exception thrown \tpublic responseentity<studenterrorresponse> handleexception(exception exc) { \t\t \t\tstudenterrorresponse error = new studenterrorresponse(); \t\t \t\terror.setstatus(httpstatus.bad_request.value()); \t\terror.setmessage(exc.getmessage()); \t\terror.settimestamp(system.currenttimemillis()); \t\t \t\treturn new responseentity<>(error, httpstatus.bad_request); \t}\t } global exception handler instead of having the exception handling methods in every controller, we defined them globally. for that we use controlleradvice that acts as a filter between the requests and the controller. it: pre-processes requests to controllers post-processes responses to handle exceptions so, we create a class with the @controlleradvice annotation: package com.springdemo.rest; import org.springframework.http.httpstatus; import org.springframework.http.responseentity; import org.springframework.web.bind.annotation.controlleradvice; import org.springframework.web.bind.annotation.exceptionhandler; @controlleradvice public class studentrestexceptionhandler { \t// add exception handling code here \t// add an exception handler using @exceptionhandler \t@exceptionhandler \tpublic responseentity<studenterrorresponse> handleexception(studentnotfoundexception exc) { \t\t \t\t// create a studenterrorresponse \t\tstudenterrorresponse error = new studenterrorresponse(); \t\t \t\terror.setstatus(httpstatus.not_found.value()); \t\terror.setmessage(exc.getmessage()); \t\terror.settimestamp(system.currenttimemillis()); \t\t \t\t// return responseentity \t\treturn new responseentity<>(error, httpstatus.not_found); \t} \t \t// add another exception handler ... to catch any exception (catch all) \t@exceptionhandler \tpublic responseentity<studenterrorresponse> handleexception(exception exc) { \t\t \t\t// create a studenterrorresponse \t\tstudenterrorresponse error = new studenterrorresponse(); \t\terror.setstatus(httpstatus.bad_request.value()); \t\terror.setmessage(exc.getmessage()); \t\terror.settimestamp(system.currenttimemillis()); \t\t \t\t// return responseentity\t\t \t\treturn new responseentity<>(error, httpstatus.bad_request); \t} \t } and now we modify the controller to make use of this paradigm: package com.springdemo.rest; import java.util.arraylist; import java.util.list; import javax.annotation.postconstruct; import org.springframework.http.httpstatus; import org.springframework.http.responseentity; import org.springframework.web.bind.annotation.exceptionhandler; import org.springframework.web.bind.annotation.getmapping; import org.springframework.web.bind.annotation.pathvariable; import org.springframework.web.bind.annotation.requestmapping; import org.springframework.web.bind.annotation.restcontroller; import com.springdemo.entity.student; @restcontroller @requestmapping(\"/api\") public class studentrestcontroller { \tprivate list<student> thestudents; \t \t// define @postconstruct to load the student data ... only once! \t@postconstruct \tpublic void loaddata() { \t \t\tthestudents = new arraylist<>(); \t\t \t\tthestudents.add(new student(\"poornima\", \"patel\")); \t\tthestudents.add(new student(\"mario\", \"rossi\")); \t\tthestudents.add(new student(\"mary\", \"smith\"));\t\t \t} \t// define endpoint for \"/students\" - return list of students \t@getmapping(\"/students\") \tpublic list<student> getstudents() { \t\t\t \t\treturn thestudents; \t} \t \t// define endpoint for \"/students/{studentid}\" - return student at index \t@getmapping(\"/students/{studentid}\") \tpublic student getstudent(@pathvariable int studentid) { \t\t \t\t// just index into the list ... keep it simple for now \t\t// check the studentid against list size \t\tif ( (studentid >= thestudents.size()) || (studentid < 0) ) { \t\t\tthrow new studentnotfoundexception(\"student id not found - \" + studentid); \t\t} \t\t\t \t\treturn thestudents.get(studentid); \t}\t } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/SpringBoot/Spring Boot Project Structure.html",
    "title": "Spring Boot Project Structure",
    "body": " index search search back spring boot project structure application properties by default, spring boot will load properties from: application.properties in the src project directory. we inject it in our code the same way we did it with spring static content by default, spring boot wil load static resources from \"/static\" directory testing unit tests are stored on the src directory under the /test folder $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/SpringBoot/Spring Boot Starters.html",
    "title": "Spring Boot Starters",
    "body": " index search search back spring boot starters spring boot staters offer a curated list of dependencies that are grouped together and tested by the spring development team. so now, if your application depends on the web and security module and also uses thymeleaf and jpa, you add the following dependencies: ... \t<dependencies> <!-- web --> \t\t<dependency> \t\t\t<groupid>org.springframework.boot</groupid> \t\t\t<artifactid>spring-boot-starter-web</artifactid> \t\t</dependency> <!-- security --> \t\t<dependency> \t\t\t<groupid>org.springframework.boot</groupid> \t\t\t<artifactid>spring-boot-starter-security</artifactid> \t\t</dependency> <!-- jpa --> \t\t<dependency> \t\t\t<groupid>org.springframework.boot</groupid> \t\t\t<artifactid>spring-boot-starter-data-jpa</artifactid> \t\t</dependency> <!-- thymeleaf --> \t\t<dependency> \t\t\t<groupid>org.springframework.boot</groupid> \t\t\t<artifactid>spring-boot-starter-thymeleaf</artifactid> \t\t</dependency> \t\t<!-- add support for automatic reloading --> \t\t<dependency> \t\t\t<groupid>org.springframework.boot</groupid> \t\t\t<artifactid>spring-boot-devtools</artifactid> \t\t</dependency> \t\t\t\t \t</dependencies> ... spring boot starter parent this is a special starter that provides defaults: default compiler level utf-8 source encoding you include it in your pom.xml file as follows: ... \t<parent> \t\t<groupid>org.springframework.boot</groupid> \t\t<artifactid>spring-boot-starter-parent</artifactid> \t\t<version>2.1.2.release</version> \t\t<relativepath/> <!-- lookup parent from repository --> \t</parent> \t<dependencies> \t... \t</dependencies> ... if you want to override a default, you use properties: ... \t<parent> \t\t<groupid>org.springframework.boot</groupid> \t\t<artifactid>spring-boot-starter-parent</artifactid> \t\t<version>2.1.2.release</version> \t\t<relativepath/> <!-- lookup parent from repository --> \t</parent> \t \t<!-- override default java version --> \t<properties> \t\t<java.version>1.8</java.version> \t</properties> \t<dependencies> \t... \t</dependencies> ... $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/SpringBoot/Spring Data JPA.html",
    "title": "Spring Data JPA",
    "body": " index search search back spring data jpa with jpa api we created a employee dao, however what if we need to create one for each entity we manage. then we would duplicate a lot of code, because the calls to the api are basically the same. that is what we use spring data jpa, we plug in the entity type and the primary key to the dao, and spring creates it an manages it for us. create repository so now the employee dao is as follows: package com.springboot.cruddemo.dao; import org.springframework.data.jpa.repository.jparepository; import com.springboot.cruddemo.entity.employee; public interface employeerepository extends jparepository<employee, integer> { } use repository and the employee service is: package com.springboot.cruddemo.service; import java.util.list; import java.util.optional; import org.springframework.beans.factory.annotation.autowired; import org.springframework.stereotype.service; import com.springboot.cruddemo.dao.employeerepository; import com.springboot.cruddemo.entity.employee; @service public class employeeserviceimpl implements employeeservice { // here we make use of the above implemented repository \tprivate employeerepository employeerepository; \t \t@autowired \tpublic employeeserviceimpl(employeerepository theemployeerepository) { \t\temployeerepository = theemployeerepository; \t} \t \t@override \tpublic list<employee> findall() { \t\treturn employeerepository.findall(); \t} \t@override \tpublic employee findbyid(int theid) { \t\toptional<employee> result = employeerepository.findbyid(theid); \t\t \t\temployee theemployee = null; \t\t \t\tif (result.ispresent()) { \t\t\ttheemployee = result.get(); \t\t} \t\telse { \t\t\t// we didn't find the employee \t\t\tthrow new runtimeexception(\"did not find employee id - \" + theid); \t\t} \t\t \t\treturn theemployee; \t} \t@override \tpublic void save(employee theemployee) { \t\temployeerepository.save(theemployee); \t} \t@override \tpublic void deletebyid(int theid) { \t\temployeerepository.deletebyid(theid); \t} } this employeeservice implements the interface: package com.springboot.cruddemo.service; import java.util.list; import com.springboot.cruddemo.entity.employee; public interface employeeservice { \tpublic list<employee> findall(); \t \tpublic employee findbyid(int theid); \t \tpublic void save(employee theemployee); \t \tpublic void deletebyid(int theid); \t } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/SpringBoot/Application Properties.html",
    "title": "Application Properties",
    "body": " index search search back application properties by default spring boot reads information from a standard properties file in src/main/resources/application.properties. you can define any custom properties in this file and your app can access properties using the annotation @value(we have done this before). configuring the spring boot server some properties offered by spring are: core # log levels severity mapping logging.level.org.springframework=debug logging.level.org.hibernate=trace logging.level.org.luv2code=info # log file name logging.file=date.log web # http server port server.port=7070 # context path of the application server.servlet.context-path=/my-app # default http session timeout server.servlet.session.timeout=15m actuator properties # endpoints to include by name or wildcard management.endpoints.web.exposure.include=* # endpoints to exclude by name or wildcard management.endpoints.web.exposure.exclude=beans,mapping security # default username spring.security.user.name=admin # password for default user spring.security.user.password=mypass data properties # jdbc url of the database spring.datasource.url=jdbc:mysql://localhost:3306/myapp # login username of the database spring.datasource.username=alba # login password of the database spring.datasource.password=testpass $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/SpringBoot/Controller.html",
    "title": "Rest Controller",
    "body": " index search search back rest controller in this section we are going to show how to create a rest controller in a spring boot application: create controller the controller is the same as in spring rest: package com.springboot.demo.mycoolapp.rest; import java.time.localdatetime; import org.springframework.beans.factory.annotation.value; import org.springframework.web.bind.annotation.getmapping; import org.springframework.web.bind.annotation.restcontroller; @restcontroller public class funrestcontroller { \t\t \t// expose \"/\" that return \"hello world\" \t \t@getmapping(\"/\") \tpublic string sayhello() { \t\treturn \"hello world! time on server is \" + localdatetime.now(); \t} \t main app the springbootapplication is made up of three annotations: auto configuration (@enableautoconfiguration) component scanning (@componentscan) additional configuration (@configuration) package com.springboot.demo.mycoolapp; import org.springframework.boot.springapplication; import org.springframework.boot.autoconfigure.springbootapplication; // annotation to tell spring this is an spring application @springbootapplication public class mycoolappapplication { \tpublic static void main(string[] args) { \t\t// boostrap spring boot application \t\tspringapplication.run(mycoolappapplication.class, args); \t} } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/SpringBoot/Spring Boot DevTools.html",
    "title": "Spring Boot DevTools",
    "body": " index search search back spring boot devtools spring boot dev tools automatically restart your application when code is updated. the only thing you need to do is add the module to the dependencies: ... \t<dependencies> \t\t<!-- add support for automatic reloading --> \t\t<dependency> \t\t\t<groupid>org.springframework.boot</groupid> \t\t\t<artifactid>spring-boot-devtools</artifactid> \t\t</dependency> \t\t\t\t \t</dependencies> ... $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/SpringBoot/index.html",
    "title": "Overview",
    "body": " index search search back overview spring boot is a framework that: make it easier to get started with spring development minimize the amount of manual configuration perform auto-configuration based on props files and jar classpath help to resolve dependency conflicts (maven or gradle) provide an embedded http server so you can get started quickly to create a new project you just have to go to spring initiliazr, where you simply select your dependencies and lets you create a maven/gradle project and import it into an ide. so now our app is a jar file, and it includes the source code and also the embedded http server, so can be ran from the command line, from your ide, etc. however if you want to export your code as a war file, you can also do that by exporting only your source code, without the embedded server. with the jar file you can run your application by executing: $ java -jar app.jar $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/SpringBoot/JPA.html",
    "title": "JPA",
    "body": " index search search back jpa until now, to manage data we have been using the entitymanager along with the hibernate api. however now we are going to use the standard jpa api. the jpa api methods are similar to native hibernate api. it also supports a query language jpql (jpa query language) comparing hibernate to jpa: example: for managing employees with jpa, we first create the data access object: package com.springboot.cruddemo.dao; import java.util.list; import javax.persistence.entitymanager; import javax.persistence.query; import org.springframework.beans.factory.annotation.autowired; import org.springframework.stereotype.repository; import com.luv2code.springboot.cruddemo.entity.employee; @repository public class employeedaojpaimpl implements employeedao { \tprivate entitymanager entitymanager; \t \t@autowired \tpublic employeedaojpaimpl(entitymanager theentitymanager) { \t\tentitymanager = theentitymanager; \t} \t \t@override \tpublic list<employee> findall() { \t\t// create a query \t\tquery thequery = \t\t\t\tentitymanager.createquery(\"from employee\"); \t\t \t\t// execute query and get result list \t\tlist<employee> employees = thequery.getresultlist(); \t\t \t\t// return the results\t\t \t\treturn employees; \t} \t@override \tpublic employee findbyid(int theid) { \t\t// get employee \t\temployee theemployee = \t\t\t\tentitymanager.find(employee.class, theid); \t\t \t\t// return employee \t\treturn theemployee; \t} \t@override \tpublic void save(employee theemployee) { \t\t// save or update the employee \t\temployee dbemployee = entitymanager.merge(theemployee); \t\t \t\t// update with id from db ... so we can get generated id for save/insert \t\ttheemployee.setid(dbemployee.getid()); \t\t \t} \t@override \tpublic void deletebyid(int theid) { \t\t// delete object with primary key \t\tquery thequery = entitymanager.createquery( \t\t\t\t\t\t\t\"delete from employee where id=:employeeid\"); \t\t \t\tthequery.setparameter(\"employeeid\", theid); \t\t \t\tthequery.executeupdate(); \t} } and then we call it from the employee service: package com.springboot.cruddemo.service; import java.util.list; import org.springframework.beans.factory.annotation.autowired; import org.springframework.beans.factory.annotation.qualifier; import org.springframework.stereotype.service; import org.springframework.transaction.annotation.transactional; import com.springboot.cruddemo.dao.employeedao; import com.springboot.cruddemo.entity.employee; @service public class employeeserviceimpl implements employeeservice { \tprivate employeedao employeedao; \t \t@autowired \tpublic employeeserviceimpl(@qualifier(\"employeedaojpaimpl\") employeedao theemployeedao) { \t\temployeedao = theemployeedao; \t} \t \t@override \t@transactional \tpublic list<employee> findall() { \t\treturn employeedao.findall(); \t} \t@override \t@transactional \tpublic employee findbyid(int theid) { \t\treturn employeedao.findbyid(theid); \t} \t@override \t@transactional \tpublic void save(employee theemployee) { \t\temployeedao.save(theemployee); \t} \t@override \t@transactional \tpublic void deletebyid(int theid) { \t\temployeedao.deletebyid(theid); \t} } this class implements the following interface: package com.springboot.cruddemo.service; import java.util.list; import com.springboot.cruddemo.entity.employee; public interface employeeservice { \tpublic list<employee> findall(); \t \tpublic employee findbyid(int theid); \t \tpublic void save(employee theemployee); \t \tpublic void deletebyid(int theid); \t } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/SpringBoot/Spring Boot Actuator.html",
    "title": "Spring Boot Actuator",
    "body": " index search search back spring boot actuator spring boot actuator automatically exposes endpoints to monitor and manage your application. you only need to add the dependency to you pom.xml file: ... \t<dependencies> ... \t\t<!-- add support for spring boot actuator --> \t\t<dependency> \t\t\t<groupid>org.springframework.boot</groupid> \t\t\t<artifactid>spring-boot-starter-actuator</artifactid> \t\t</dependency> \t\t\t\t \t</dependencies> ... the endpoints are prefixed by /actuator, some of them are: /health: health information about your application /info: information about your project. by default it return an empty json object. you can add info through application.properties as follows: info.app.name=my super cool app info.app.description=a crazy fun app, yoohoo! info.app.version=1.0.0 /auditevents: audit events for your application /beans: list of all beans registered in the spring application context /mappings: list of all @requestmapping path by default only /health and /info are exposed, to expose all actuator endpoints you need to specify on application.properties (you can also specify only the ones you want separated by commas): management.endpoints.web.exposure.include=* add security first you need to add spring security as a dependency in your pom.xml: ... \t<dependencies> \t\t... <!-- security --> \t\t<dependency> \t\t\t<groupid>org.springframework.boot</groupid> \t\t\t<artifactid>spring-boot-starter-security</artifactid> \t\t</dependency> \t\t... \t</dependencies> ... now, when we access some endpoints like /actuator/beans spring will prompt a login to grant access to the endpoint. the default user name is \"user\" the password will be printed on the console where you start the application to override these defaults edit the application.properties file as follows: spring.security.user.name=alba spring.security.user.password=mypassword we can also exclude endpoints by adding the following declarations to the application.properties file: management.endpoints.web.exposure.exclude=health,info $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/SpringBoot/Spring Data REST.html",
    "title": "Spring Data Rest",
    "body": " index search search back spring data rest what if we want to also reduce the code for creating api, that is, what if spring could create a rest api for us using our jparepository, such that it would expose all of the basic rest api crud features automatically. what does it do? it scans your project fro jparepository it exposes rest apis for each entity type for your jparepository so now, we can remove our employee services and our rest controllers, because it is handled automatically by spring. the only thing needed is adding spring data rest as a dependency: \t<dependencies> ... \t\t<!-- add dependency for spring data rest --> \t\t<dependency> \t\t\t<groupid>org.springframework.boot</groupid> \t\t\t<artifactid>spring-boot-starter-data-rest</artifactid> \t\t</dependency> ... \t</dependencies> to sum up, now in your application you only will have: your entity: employee the corresponding jpa repository: employeerepository dependency main application the first one applies to each entity your application has. spring data rest is hateoas compliant (the responses include metadata about itself). configuration you can specify the name of the endpoint that is exposed (by the default is the plural of the entity) with: @repositoryrestresource(path=\"members\") public interface employeerepository extends jparepository<employee, integer> { } the default number of elements returned are 20, then we can use pagination to retrieve the next ones with query parameters (?page=0). some properties available to tweak in application.properties are: spring.data.rest.base-path: base path used to expose repository resources spring.data.rest.default-page-size: default size pages spring.data.rest.max-page-size: maximum size of pages sorting you can sort by the property names of your entity. on the employee example we have firstname, lastname and email, therefore we can do: http://localhost:8080/employees?sort=firstname or http://localhost:8080/employees?sort=firstname,desc $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Dependency Injection/Injecting Literal Values.html",
    "title": "Injecting Literal Values",
    "body": " index search search back injecting literal values to inject concrete attributes into our beans: define the attributes first we define the attributes emailaddress and team in the object. also we create the set and get methods for both of them: package com.luv2code.springdemo; public class cricketcoach implements coach { \tprivate fortuneservice fortuneservice; \t \t// add new fields for emailaddress and team \tprivate string emailaddress; \tprivate string team; \t \t\t \tpublic cricketcoach() { \t\tsystem.out.println(\"cricketcoach: inside no-arg constructor\"); \t} \t /* setters and getters */ \tpublic string getemailaddress() { \t\treturn emailaddress; \t} \tpublic void setemailaddress(string emailaddress) { \t\tsystem.out.println(\"cricketcoach: inside setter method - setemailaddress\"); \t\tthis.emailaddress = emailaddress; \t} \tpublic string getteam() { \t\treturn team; \t} \tpublic void setteam(string team) { \t\tsystem.out.println(\"cricketcoach: inside setter method - setteam\"); \t\tthis.team = team; \t} /* setter injection */ \tpublic void setfortuneservice(fortuneservice fortuneservice) { \t\tsystem.out.println(\"cricketcoach: inside setter method - setfortuneservice\"); \t\tthis.fortuneservice = fortuneservice; \t} \t@override \tpublic string getdailyworkout() { \t\treturn \"practice fast bowling for 15 minutes\"; \t} \t@override \tpublic string getdailyfortune() { \t\treturn fortuneservice.getfortune(); \t} } configuration file now we define the properties in the configuration file: <?xml version=\"1.0\" encoding=\"utf-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/xmlschema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemalocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"> \t<!-- define your beans here --> \t<!-- define the dependency --> \t<bean id=\"myfortuneservice\" class=\"com.springdemo.happyfortuneservice\"> \t</bean> \t \t<bean id=\"mycoach\" \t\tclass=\"com.springdemo.trackcoach\">\t \t\t<!-- set up constructor injection --> \t\t<constructor-arg ref=\"myfortuneservice\" /> \t</bean> \t \t<bean id=\"mycricketcoach\" class=\"com.springdemo.cricketcoach\"> \t <!-- set up setter injection --> \t <!-- ref: references the id of the bean we define previously --> \t <!-- name: name of the setter method set<name>, where the first \t letter of the name is capitalized --> \t <property name=\"fortuneservice\" ref=\"myfortuneservice\" /> \t\t<!-- inject literal values, where name is the name of the attribute in the bean \t\tand value is the value to set the value to --> \t <property name=\"emailaddress\" value=\"email@email.com\" /> \t <property name=\"team\" value=\"best team\" /> \t</bean> </beans> main method now in the main method of our app we can call the getters and setters for these new attributes: package com.springdemo; import org.springframework.context.support.classpathxmlapplicationcontext; public class setterdemoapp { \tpublic static void main(string[] args) { \t\t// load the spring configuration file \t\tclasspathxmlapplicationcontext context = \t\t\t\tnew classpathxmlapplicationcontext(\"applicationcontext.xml\"); \t\t \t\t// retrieve bean from spring container \t\tcricketcoach thecoach = context.getbean(\"mycricketcoach\", cricketcoach.class); \t\t \t\t// retrieve attribute values \t\tsystem.out.println(thecoach.getteam()); \t\tsystem.out.println(thecoach.getemailaddress()); \t\t\t\t\t\t \t\t// close the context \t\tcontext.close(); \t} } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Dependency Injection/Inject Values From a Properties File.html",
    "title": "Inject Values from the Properties Files",
    "body": " index search search back inject values from the properties files create the properties file let's define our properties inside a properties file sport.properties: foo.email=myeasycoach@email.com foo.team=royal challengers bangalore load the properties file now we load the properties file using the context tag inside our config file: <?xml version=\"1.0\" encoding=\"utf-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/xmlschema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemalocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"> <!-- load the properties file: sport.properties --> <context:property-placeholder location=\"classpath:sport.properties\"/> <!-- define your beans here --> <!-- define the dependency --> <bean id=\"myfortuneservice\" class=\"com.springdemo.happyfortuneservice\"> </bean> <bean id=\"mycoach\" \tclass=\"com.springdemo.trackcoach\">\t \t<!-- set up constructor injection --> \t<constructor-arg ref=\"myfortuneservice\" /> </bean> <bean id=\"mycricketcoach\" class=\"com.springdemo.cricketcoach\"> <!-- set up setter injection --> <!-- ref: references the id of the bean we define previously --> <!-- name: name of the setter method set<name>, where the first letter of the name is capitalized --> <property name=\"fortuneservice\" ref=\"myfortuneservice\" /> <!-- inject literal values, where name is the name of the attribute in the bean and value is the value to set the value to --> <!-- note that we are now referencing the values from the properties file --> <property name=\"emailaddress\" value=\"${foo.email})\" /> <property name=\"team\" value=\"${foo.team}\" /> </bean> </beans> main method in the main method, we create our object as usual, and if we invoke the getter methods, we retrieve the values passed in the property file: package com.springdemo; import org.springframework.context.support.classpathxmlapplicationcontext; public class setterdemoapp { \tpublic static void main(string[] args) { \t\t// load the spring configuration file \t\tclasspathxmlapplicationcontext context = \t\t\t\tnew classpathxmlapplicationcontext(\"applicationcontext.xml\"); \t\t \t\t// retrieve bean from spring container \t\tcricketcoach thecoach = context.getbean(\"mycricketcoach\", cricketcoach.class); \t\t \t\t// retrieve attribute values from property file \t\tsystem.out.println(thecoach.getteam()); \t\tsystem.out.println(thecoach.getemailaddress()); \t\t\t\t\t\t \t\t// close the context \t\tcontext.close(); \t} } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Dependency Injection/Constructor Injection.html",
    "title": "Constructor Injection",
    "body": " index search search back constructor injection now we will show an example where the baseballcoach has fortuneservice as a dependency. so, first we create the dependency interface as follows: create dependency object package com.springdemo; public interface fortuneservice { \tpublic string getfortune(); \t } next we create the dependency class than implements the interface: package com.springdemo; public class happyfortuneservice implements fortuneservice { \t@override \tpublic string getfortune() { \t\treturn \"today is your lucky day!\"; \t} } establish dependency let's also update the coach interface to add a method getdailyfortune (note that all classes that implement this interface have to implement this new method): package com.springdemo; public interface coach { \tpublic string getdailyworkout(); \t \tpublic string getdailyfortune(); } now create a constructor for the dependency in the class that has the dependency package com.springdemo; public class baseballcoach implements coach { \t// define a private field for the dependency \tprivate fortuneservice fortuneservice; \t \t// define a constructor for dependency injection \tpublic baseballcoach(fortuneservice thefortuneservice) { \t\tfortuneservice = thefortuneservice; \t} \t \t@override \tpublic string getdailyworkout() { \t\treturn \"spend 30 minutes on batting practice\"; \t} \t@override \tpublic string getdailyfortune() {\t\t \t\t// use my fortuneservice to get a fortune\t\t \t\treturn fortuneservice.getfortune(); \t} } configuration file finally define the dependency in the configuration file: <?xml version=\"1.0\" encoding=\"utf-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/xmlschema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemalocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"> <!-- define your beans here --> <!-- define the dependency --> <bean id=\"myfortuneservice\" class=\"com.springdemo.happyfortuneservice\"> </bean> <!-- bean with the dependency --> <bean id=\"mycoach\" class=\"com.springdemo.trackcoach\">\t <!-- set up constructor injection, note ref=id of bean --> <constructor-arg ref=\"myfortuneservice\" /> </bean> </beans> behind the scenes, spring framework does: package com.springdemo; public class myapp { \tpublic static void main(string[] args) { \t\t// create object \t\t// from the bean with id = myfortuneservice in the config file \t\thappyfortuneservice myfortuneservice = new happyfortuneservice(); \t\t \t\t// add dependency via constructor \t\t// from the bean with id = mycoach in the config file \t\ttrackcoach mycoach = new trackcoach(fortuneservice); \t} } main method we do not need to make any modifications to the app, when we create the coach bean using spring, the framework deals with the dependency injection: package com.luv2code.springdemo; import org.springframework.context.support.classpathxmlapplicationcontext; public class hellospringapp { \tpublic static void main(string[] args) { \t\t// load the spring configuration file \t\tclasspathxmlapplicationcontext context = \t\t\t\tnew classpathxmlapplicationcontext(\"applicationcontext.xml\"); \t\t\t\t \t\t// retrieve bean from spring container (with the dependency) \t\tcoach thecoach = context.getbean(\"mycoach\", coach.class); \t\t \t\t// call methods on the bean \t\tsystem.out.println(thecoach.getdailyworkout()); \t\t \t\t// let's call our new method for fortunes \t\tsystem.out.println(thecoach.getdailyfortune()); \t\t \t\t// close the context \t\tcontext.close(); \t} } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Dependency Injection/Dependency Injection.html",
    "title": "Dependency Injection",
    "body": " index search search back dependency injection the dependencies of the objects are managed by the spring container object factory: so instead of having to build the object and all of its dependencies, the spring factory will do this work for you. injection types there are several injection types in spring. the more common are: constructor injection setter injection injecting literal values inject values from a properties file $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Dependency Injection/Setter Injection.html",
    "title": "Setter Injection",
    "body": " index search search back setter injection inject dependencies by calling setter methods on your class create dependency object refer to create dependency object define dependency we include a setter method that takes the dependency as an argument like: package com.springdemo; public class cricketcoach implements coach { \tprivate fortuneservice fortuneservice;\t \t \t// create a no-arg constructor \tpublic cricketcoach() { \t\tsystem.out.println(\"cricketcoach: inside no-arg constructor\"); \t} \t \t// our setter method \tpublic void setfortuneservice(fortuneservice fortuneservice) { \t\tsystem.out.println(\"cricketcoach: inside setter method - setfortuneservice\"); \t\tthis.fortuneservice = fortuneservice; \t} \t@override \tpublic string getdailyworkout() { \t\treturn \"practice fast bowling for 15 minutes\"; \t} \t@override \tpublic string getdailyfortune() { \t\treturn fortuneservice.getfortune(); \t} } configuration file <?xml version=\"1.0\" encoding=\"utf-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/xmlschema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemalocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"> <!-- define your beans here --> <!-- define the dependency --> <bean id=\"myfortuneservice\" class=\"com.springdemo.happyfortuneservice\"> </bean> <bean id=\"mycoach\" \tclass=\"com.springdemo.trackcoach\">\t \t<!-- set up constructor injection --> \t<constructor-arg ref=\"myfortuneservice\" /> </bean> <bean id=\"mycricketcoach\" class=\"com.springdemo.cricketcoach\"> <!-- set up setter injection --> <!-- ref: references the id of the bean we define previously --> <!-- name: name of the setter method set<name>, where the first letter of the name is capitalized --> <property name=\"fortuneservice\" ref=\"myfortuneservice\" /> </bean> </beans> behind the scenes, spring framework does: package com.springdemo; public class myapp { \tpublic static void main(string[] args) { \t\t// create object \t\t// from the bean with id = myfortuneservice in the config file \t\thappyfortuneservice myfortuneservice = new happyfortuneservice(); \t\t \t\t// from the bean with id = mycricketcoach in the config file \t\tcricketcoach mycricketcoach = new cricketcoach(fortuneservice); \t\t// add dependency via setter \t\tmycricketcoach.setfortuneservice(myfortuneservice); \t} } main method now, on the main method of our spring app, we create the object by reading the config file, and spring automatically injects the dependency via the setter method: package com.springdemo; import org.springframework.context.support.classpathxmlapplicationcontext; public class setterdemoapp { \tpublic static void main(string[] args) { \t\t// load the spring configuration file \t\tclasspathxmlapplicationcontext context = \t\t\t\tnew classpathxmlapplicationcontext(\"applicationcontext.xml\"); \t\t \t\t// retrieve bean from spring container \t\tcricketcoach thecoach = context.getbean(\"mycricketcoach\", cricketcoach.class); \t\t \t\t// call methods on the bean \t\tsystem.out.println(thecoach.getdailyworkout()); \t\t \t\tsystem.out.println(thecoach.getdailyfortune()); \t\t\t\t\t\t \t\t// close the context \t\tcontext.close(); \t} } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/AOP/Overview.html",
    "title": "Overview",
    "body": " index search search back overview aspect-oriented programming is a programming technique based on the concept of an aspect (that is something that encapsulated cross-cutting logic/functionality, which means logic that affect the project transversally like logging or security). what aop does behind the scenes is call methods from the classes/aspects (like a logging class) whenever a method is called (this depends on the configuration): advantages reusable modules resolve code tangling resolve code scatter applied selectively based on configuration disadvantages too many aspects and app flow is hard to follow minor performance cost for aspect execution terminology aspect: module of code for a cross-cutting concern (logging, security...) advice: what action is takes and when it should be applied joint point: when to apply code during program execution pointcut: a predicate expression for where advice should be applied advice types before advice: run before the method after finally advice: run after the method (like finally clause in try catch) after returning advice: run after the method (success execution) after throwing advice: run after the method (if exception if thrown) around advice: run before and after the method weaving it refers to the connection being made between aspects and target objects to create an advised object. there are different types: compile-time load-time run-time note that the slowest is the run-time weaving best practices keep the code inside the advices small keep the code fast do not perform any expensive/slow operations $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/AOP/After Advice.html",
    "title": "After Advice",
    "body": " index search search back after advice this advice runs always when the method is completed (like a finally clause inside a try catch). for example if we want to always run the advice afterfinallyfindaccountsadvice when the method findaccounts inside accountdao finishes: package com.aopdemo.aspect; import java.util.list; import org.aspectj.lang.joinpoint; import org.aspectj.lang.annotation.after; import org.aspectj.lang.annotation.afterreturning; import org.aspectj.lang.annotation.afterthrowing; import org.aspectj.lang.annotation.aspect; import org.aspectj.lang.annotation.before; import org.aspectj.lang.reflect.methodsignature; import org.springframework.core.annotation.order; import org.springframework.stereotype.component; import com.aopdemo.account; @aspect @component @order(2) public class mydemologgingaspect { \t@after(\"execution(* com.aopdemo.dao.accountdao.findaccounts(..))\") \tpublic void afterfinallyfindaccountsadvice(joinpoint thejoinpoint) { \t\t \t\t// print out which method we are advising on \t\tstring method = thejoinpoint.getsignature().toshortstring(); \t\tsystem.out.println(\"\\n=====>>> executing @after (finally) on method: \" \t\t\t\t\t\t\t+ method); \t \t} } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/AOP/AfterThrowing Advice.html",
    "title": "AfterThrowing Advice",
    "body": " index search search back afterthrowing advice this advice is run whenever the target object throws and execption. for example: package com.aopdemo.aspect; import java.util.list; import org.aspectj.lang.joinpoint; import org.aspectj.lang.annotation.afterreturning; import org.aspectj.lang.annotation.afterthrowing; import org.aspectj.lang.annotation.aspect; import org.aspectj.lang.annotation.before; import org.aspectj.lang.reflect.methodsignature; import org.springframework.core.annotation.order; import org.springframework.stereotype.component; import com.luv2code.aopdemo.account; @aspect @component @order(2) public class mydemologgingaspect { \t \t@afterthrowing( \t\t\tpointcut=\"execution(* com.aopdemo.dao.accountdao.findaccounts(..))\", \t\t\t// define the name of the parameter that holds the exception object \t\t\tthrowing=\"theexc\") \tpublic void afterthrowingfindaccountsadvice( \t\t\t\t\tjoinpoint thejoinpoint, throwable theexc) { \t\t \t\t// print out which method we are advising on \t\tstring method = thejoinpoint.getsignature().toshortstring(); \t\tsystem.out.println(\"\\n=====>>> executing @afterthrowing on method: \" + method); \t\t \t\t// log the exception \t\tsystem.out.println(\"\\n=====>>> the exception is: \" + theexc); \t \t} } in this code sample we have the advice afterthrowingfindaccountsadvice that is run whenever the method findaccounts inside accountdao throws an exception. we also make use of the throwing attribute that lets us map the exception object to a parameter inside our advice. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/AOP/JoinPoints.html",
    "title": "JoinPoints",
    "body": " index search search back joinpoints when we are in an aspect, how can we access method parameters? display method signature to display the method signature we do the following: package com.aopdemo.aspect; import org.aspectj.lang.joinpoint; import org.aspectj.lang.annotation.aspect; import org.aspectj.lang.annotation.before; import org.aspectj.lang.reflect.methodsignature; import org.springframework.core.annotation.order; import org.springframework.stereotype.component; import com.aopdemo.account; @aspect @component @order(2) public class mydemologgingaspect { \t \t@before(\"com.aopdemo.aspect.luvaopexpressions.fordaopackagenogettersetter()\") \tpublic void beforeaddaccountadvice(joinpoint thejoinpoint) { \t\t \t\tsystem.out.println(\"\\n=====>>> executing @before advice on method\");\t \t\t \t\t// display the method signature \t\tmethodsignature methodsig = (methodsignature) thejoinpoint.getsignature(); \t\t \t\tsystem.out.println(\"method: \" + methodsig); \t} } display method arguments also, to display the method arguments: package com.aopdemo.aspect; import org.aspectj.lang.joinpoint; import org.aspectj.lang.annotation.aspect; import org.aspectj.lang.annotation.before; import org.aspectj.lang.reflect.methodsignature; import org.springframework.core.annotation.order; import org.springframework.stereotype.component; import com.aopdemo.account; @aspect @component @order(2) public class mydemologgingaspect { \t \t@before(\"com.aopdemo.aspect.luvaopexpressions.fordaopackagenogettersetter()\") \tpublic void beforeaddaccountadvice(joinpoint thejoinpoint) { \t\t \t\tsystem.out.println(\"\\n=====>>> executing @before advice on method\");\t \t\t// display method arguments \t\t// get args \t\tobject[] args = thejoinpoint.getargs(); \t\t \t\t// loop through args \t\tfor (object temparg : args) { \t\t\tsystem.out.println(temparg); \t\t\t \t\t\tif (temparg instanceof account) { \t\t\t\t \t\t\t\t// downcast and print account specific stuff \t\t\t\taccount theaccount = (account) temparg; \t\t\t\t \t\t\t\tsystem.out.println(\"account name: \" + theaccount.getname()); \t\t\t\tsystem.out.println(\"account level: \" + theaccount.getlevel());\t\t\t\t\t\t\t\t \t\t\t} \t\t}\t\t \t} } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/AOP/Before Advice.html",
    "title": "Before Advice",
    "body": " index search search back before advice we use the tag @before to execute some code before we call the target object function: add dependencies we have to download the aspectj jar file, because spring aop depends on some on their framework's classes create target object we create a dao object: package com.aopdemo.dao; import org.springframework.stereotype.component; @component public class accountdao { \tpublic void addaccount() { \t\tsystem.out.println( \t\t\tgetclass() \t\t\t+ \": doing my db work: adding an account\" \t\t); \t} } spring configuration we now have to enable aop proxying in our app configuration: package com.aopdemo; import org.springframework.context.annotation.componentscan; import org.springframework.context.annotation.configuration; import org.springframework.context.annotation.enableaspectjautoproxy; @configuration // enable proxying to add before advice @enableaspectjautoproxy @componentscan(\"com.aopdemo\") public class democonfig { } create aspect with @before now it is time to create an aspect with @before advice: package com.aopdemo.aspect; import org.aspectj.lang.annotation.aspect; import org.aspectj.lang.annotation.before; import org.springframework.stereotype.component; @aspect @component public class mydemologgingaspect { \t// this is where we add all of our related advices for logging \t// here we specify we want to run this code before calling the \t// object method public void addaccount \t@before(\"execution(public void addaccount())\") \tpublic void beforeaddaccountadvice() { \t\tsystem.out.println(\"\\n=====>>> executing @before advice on addaccount()\"); \t} } main app we now create a demo app: package com.aopdemo; import org.springframework.context.annotation.annotationconfigapplicationcontext; import com.aopdemo.dao.accountdao; public class maindemoapp { \tpublic static void main(string[] args) { \t\t// read spring config java class \t\tannotationconfigapplicationcontext context = \t\t\t\tnew annotationconfigapplicationcontext(democonfig.class); \t\t \t\t// get the bean from spring container \t\taccountdao theaccountdao = context.getbean(\"accountdao\", accountdao.class); \t\t \t\t// call the business method \t\ttheaccountdao.addaccount(); \t\t// do it again! \t\tsystem.out.println(\"\\nlet's call it again!\\n\"); \t\t \t\t// call the business method again \t\ttheaccountdao.addaccount(); \t\t\t\t \t\t// close the context \t\tcontext.close(); \t} } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/AOP/Around Advice.html",
    "title": "Around Advice",
    "body": " index search search back around advice this type of advice is always called before and after the target object. when using the @around advice we have access to a reference of a proceeding join point. which is a handle to the target method, and will let us execute the taget method. so for example if we want to measure the performance of the getfortunemethod: package com.aopdemo.aspect; import java.util.list; import org.aspectj.lang.joinpoint; import org.aspectj.lang.proceedingjoinpoint; import org.aspectj.lang.annotation.after; import org.aspectj.lang.annotation.afterreturning; import org.aspectj.lang.annotation.afterthrowing; import org.aspectj.lang.annotation.around; import org.aspectj.lang.annotation.aspect; import org.aspectj.lang.annotation.before; import org.aspectj.lang.reflect.methodsignature; import org.springframework.core.annotation.order; import org.springframework.stereotype.component; import com.aopdemo.account; @aspect @component @order(2) public class mydemologgingaspect { \t \t@around(\"execution(* com.aopdemo.service.*.getfortune(..))\")\t \tpublic object aroundgetfortune( \t\t\tproceedingjoinpoint theproceedingjoinpoint) throws throwable { \t\t \t\t// print out method we are advising on \t\tstring method = theproceedingjoinpoint.getsignature().toshortstring(); \t\tsystem.out.println(\"\\n=====>>> executing @around on method: \" + method); \t\t \t\t// get begin timestamp \t\tlong begin = system.currenttimemillis(); \t\t \t\t// now, let's execute the method \t\tobject result = theproceedingjoinpoint.proceed(); \t\t \t\t// get end timestamp \t\tlong end = system.currenttimemillis(); \t\t \t\t// compute duration and display it \t\tlong duration = end - begin; \t\tsystem.out.println(\"\\n=====> duration: \" + duration / 1000.0 + \" seconds\"); \t\t \t\treturn result; \t} } the advice aroundgetfortune is called before the getfortune is called, then it proceeds to call from inside the advice and we measure how long does the method take to run. exception handling inside an advice, to handle exceptions you can: handle the exception inside the advice \t@around(\"execution(* com.aopdemo.service.*.getfortune(..))\")\t \tpublic object aroundgetfortune( \t\t\tproceedingjoinpoint theproceedingjoinpoint) throws throwable { \t\t \t\t// print out method we are advising on \t\tstring method = theproceedingjoinpoint.getsignature().toshortstring(); \t\tsystem.out.println(\"\\n=====>>> executing @around on method: \" + method); \t\t \t\t// get begin timestamp \t\tlong begin = system.currenttimemillis(); \t\t \t\ttry { \t\t\tresult = theproceedingjoinpoint.proceed(); \t\t} catch (exception e) { \t\t\t// log the exception \t\t\tmylogger.warning(e.getmessage()); \t\t\t \t\t\t// give users a custom messagee \t\t\tresult = \"major accident! but no worries, \" \t\t\t\t\t+ \"your private aop helicopter is on the way!\"; \t\t} \t\t \t\t// get end timestamp \t\tlong end = system.currenttimemillis(); \t\t \t\t// compute duration and display it \t\tlong duration = end - begin; \t\tsystem.out.println(\"\\n=====> duration: \" + duration / 1000.0 + \" seconds\"); \t\t \t\treturn result; \t} simply rethrow the exception \t@around(\"execution(* com.aopdemo.service.*.getfortune(..))\")\t \tpublic object aroundgetfortune( \t\t\tproceedingjoinpoint theproceedingjoinpoint) throws throwable { \t\t \t\t// print out method we are advising on \t\tstring method = theproceedingjoinpoint.getsignature().toshortstring(); \t\tsystem.out.println(\"\\n=====>>> executing @around on method: \" + method); \t\t \t\t// get begin timestamp \t\tlong begin = system.currenttimemillis(); \t\t \t\ttry { \t\t\tresult = theproceedingjoinpoint.proceed(); \t\t} catch (exception e) { \t\t\t// log the exception \t\t\tmylogger.warning(e.getmessage()); \t\t\t// rethrow exception \t\t\tthrow e; \t\t} \t\t \t\t// get end timestamp \t\tlong end = system.currenttimemillis(); \t\t \t\t// compute duration and display it \t\tlong duration = end - begin; \t\tsystem.out.println(\"\\n=====> duration: \" + duration / 1000.0 + \" seconds\"); \t\t \t\treturn result; \t} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/AOP/Pointcut Expressions.html",
    "title": "Pointcut Expressions",
    "body": " index search search back pointcut expressions a pointcut expression is a predicate expression that tells spring when to apply a given advice. spring aop uses aspectj's pointcut expression language. execution pointcut the expression pattern is the following: execution(modifiers-pattern? return-type-pattern declaring-type-pattern? method-name-pattern(param-pattern) throws-pattern?) modifiers-pattern?: spring aop only supports public or * return-type-pattern: void, boolean, string, list<costumer>, etc declaring-type-pattern?: the class name method-name-pattern(param-pattern): method name to match, and parameters type to match throws-pattern?: exception types to match if the parameter is optional it is followed by an ?. you can also add wildcards inside the patterns. match methods some examples are: match concrete method inside a class: @before(\"execution(public void com.aopdemo.dao.accountdao.addaccount())\") match a method inside any class: @before(\"execution(public void addaccount())\") match any method that starts with add: @before(\"execution(public void add*())\") match all methods inside a given package: @before(\"execution(* com.aopdemo.dao.*.*(..))\") the first * denotes the return type, it can be anything the second * denotes the class name, it can be anything inside the package the third * denotes the method name, it can be anything lastly, .. denotes the param-type, there can be 0 or more parameters match parameters there are the following parameter pattern wildcards: (): matches a method with no arguments (*): matches a method with one argument of any type (..): matches a method with 0 or more arguments of any type for example: match addaccount methods with no arguments: @before(\"execution(* addaccount())\") match addacount methods with one account parameter: @before(\"execution(* addaccount(com.aopdemo.account))\") match addacount methods with any number of parameters: @before(\"execution(* addaccount(*))\") $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/AOP/AfterReturning Advice.html",
    "title": "AfterReturning Advice",
    "body": " index search search back afterreturning advice this advice is run after the method is done executing, and it executed successfully. the flow of this advice is the following: so for example, if you want to have an advice run everytime we call the findaccounts method inside a concrete class, and we also want to print out the result we obtained we do the following: package com.aopdemo.aspect; import java.util.list; import org.aspectj.lang.joinpoint; import org.aspectj.lang.annotation.afterreturning; import org.aspectj.lang.annotation.aspect; import org.aspectj.lang.annotation.before; import org.aspectj.lang.reflect.methodsignature; import org.springframework.core.annotation.order; import org.springframework.stereotype.component; import com.aopdemo.account; @aspect @component @order(2) public class mydemologgingaspect { \t\t \t// add a new advice for @afterreturning on the findaccounts method \t@afterreturning( \t\t\tpointcut=\"execution(* com.aopdemo.dao.accountdao.findaccounts(..))\", // this is the parameter name of the list of accounts returned by findaccounts \t\t\treturning=\"result\") \tpublic void afterreturningfindaccountsadvice( \t\t\t\t\tjoinpoint thejoinpoint, list<account> result) { \t\t \t\t// print out which method we are advising on \t\tstring method = thejoinpoint.getsignature().toshortstring(); \t\tsystem.out.println(\"\\n=====>>> executing @afterreturning on method: \" + method); \t\t\t\t \t\t// print out the results of the method call \t\tsystem.out.println(\"\\n=====>>> result is: \" + result); \t} } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/AOP/Pointcut Declarations.html",
    "title": "Pointcut Declarations",
    "body": " index search search back pointcut declarations how can we reuse a pointcut expression? we need to: create a pointcut declaration apply the pointcut declaration to the advices we want create pointcut declaration we define the pointcut declaration with the pointcut annotation and we bind it to an arbitrary method. package com.aopdemo.aspect; import org.aspectj.lang.annotation.aspect; import org.aspectj.lang.annotation.before; import org.aspectj.lang.annotation.pointcut; import org.springframework.stereotype.component; @aspect @component public class mydemologgingaspect { \t@pointcut(\"execution(* com.aopdemo.dao.*.*(..))\") \tprivate void fordaopackage() {} } reuse pointcut declaration to reuse this declaration we simply call the method that is bound to the pointcut declaration: package com.aopdemo.aspect; import org.aspectj.lang.annotation.aspect; import org.aspectj.lang.annotation.before; import org.aspectj.lang.annotation.pointcut; import org.springframework.stereotype.component; @aspect @component public class mydemologgingaspect { \t@pointcut(\"execution(* com.aopdemo.dao.*.*(..))\") \tprivate void fordaopackage() {} \t // reuse declaration \t@before(\"fordaopackage()\") \tpublic void beforeaddaccountadvice() {\t\t \t\tsystem.out.println(\"\\n=====>>> executing @before advice on method\");\t\t \t} \t // reuse declaration \t@before(\"fordaopackage()\") \tpublic void performapianalytics() { \t\tsystem.out.println(\"\\n=====>>> performing api analytics\");\t\t \t} \t } combine pointcut declarations how can we apply multiple pointcut expressions to a single advice? well we can combine pointcut expressions using logic operators: and (&&) or (||) not (!) for example: @before(\"expressionone() && expressiontwo()\") @before(\"expressionone() || expressiontwo()\") @before(\"expressionone() && !expressiontwo()\") imagine we want to execute an advice for every method in the package except for getters and setters, then we do: package com.aopdemo.aspect; import org.aspectj.lang.annotation.aspect; import org.aspectj.lang.annotation.before; import org.aspectj.lang.annotation.pointcut; import org.springframework.stereotype.component; @aspect @component public class mydemologgingaspect { \t@pointcut(\"execution(* com.aopdemo.dao.*.*(..))\") \tprivate void fordaopackage() {} \t \t// create pointcut for getter methods \t@pointcut(\"execution(* com.aopdemo.dao.*.get*(..))\") \tprivate void getter() {} \t \t// create pointcut for setter methods \t@pointcut(\"execution(* com.aopdemo.dao.*.set*(..))\") \tprivate void setter() {} \t \t// create pointcut: include package ... exclude getter/setter \t@pointcut(\"fordaopackage() && !(getter() || setter())\") \tprivate void fordaopackagenogettersetter() {} \t \t@before(\"fordaopackagenogettersetter()\") \tpublic void beforeaddaccountadvice() {\t\t \t\tsystem.out.println(\"\\n=====>>> executing @before advice on method\");\t\t \t} \t \t@before(\"fordaopackagenogettersetter()\") \tpublic void performapianalytics() { \t\tsystem.out.println(\"\\n=====>>> performing api analytics\");\t\t \t} } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/AOP/Control Aspect Order.html",
    "title": "Control Aspect Order",
    "body": " index search search back control aspect order how do we control the order of advices being applied when they all match the pointcut expressions? to control order we should: refactor: place advices in separate aspects control order on aspects using the @order annotation refactor and order we are going to create three aspects separate from each other as follows: so with the ordering the aspect flow looks something like this: log to cloud aspect package com.luv2code.aopdemo.aspect; import org.aspectj.lang.annotation.aspect; import org.aspectj.lang.annotation.before; import org.springframework.core.annotation.order; import org.springframework.stereotype.component; @aspect @component // set order @order(1) public class mycloudlogasyncaspect { \t@before(\"com.aopdemo.aspect.luvaopexpressions.fordaopackagenogettersetter()\") \tpublic void logtocloudasync() { \t\tsystem.out.println(\"\\n=====>>> logging to cloud in async fashion\");\t\t \t} } logging aspect package com.aopdemo.aspect; import org.aspectj.lang.annotation.aspect; import org.aspectj.lang.annotation.before; import org.springframework.core.annotation.order; import org.springframework.stereotype.component; @aspect @component // set the order @order(2) public class mydemologgingaspect { \t \t@before(\"com.aopdemo.aspect.luvaopexpressions.fordaopackagenogettersetter()\") \tpublic void beforeaddaccountadvice() {\t\t \t\tsystem.out.println(\"\\n=====>>> executing @before advice on method\");\t\t \t} \t } analytics aspect package com.aopdemo.aspect; import org.aspectj.lang.annotation.aspect; import org.aspectj.lang.annotation.before; import org.springframework.core.annotation.order; import org.springframework.stereotype.component; @aspect @component // set the order @order(3) public class myapianalyticsaspect { \t@before(\"com.aopdemo.aspect.luvaopexpressions.fordaopackagenogettersetter()\") \tpublic void performapianalytics() { \t\tsystem.out.println(\"\\n=====>>> performing api analytics\");\t\t \t} } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Java Annotations/Field Injection.html",
    "title": "Field Injection",
    "body": " index search search back field injection field injection allows you to inject dependencies by setting field values on your class directly (even private ones). this is accomplished by using java reflection. for this, we need to configure the autowired annotation as follows: apply it directly to the field which saves us from using setter methods for dependency injection. define dependency as component package com.springdemo; import org.springframework.stereotype.component; // we tell spring this is a bean @component public class happyfortuneservice implements fortuneservice { \t@override \tpublic string getfortune() { \t\treturn \"today is your lucky day!\"; \t} } specify dependency package com.springdemo; import org.springframework.stereotype.component; import org.springframework.beans.factory.annotation.autowired; @component public class tenniscoach implements coach { // we tell spring to search for beans (classes with @component annotation) // that implement the fortuneservice interface @autowired \tprivate fortuneservice fortuneservice; \t \tpublic tenniscoach() {} \t@override \tpublic string getdailyworkout() { \t\treturn \"practice your backhand volley\"; \t} \t@override \tpublic string getdailyfortune() { \t\treturn fortuneservice.getfortune(); \t} } the main method and the configuration files remain unchanged. and when we execute this piece of code, spring will automatically inject the dependency because of the autowired annotation. package com.springdemo; import org.springframework.context.support.classpathxmlapplicationcontext; public class annotationdemoapp { \tpublic static void main(string[] args) { \t\t// read spring config file \t\tclasspathxmlapplicationcontext context = \t\t\t\tnew classpathxmlapplicationcontext(\"applicationcontext.xml\"); \t\t \t\t// get the bean from spring container \t\tcoach thecoach = context.getbean(\"tenniscoach\", coach.class); \t\t \t\t// call a method on the bean \t\tsystem.out.println(thecoach.getdailyworkout()); \t\t// call method to get daily fortune \t\tsystem.out.println(thecoach.getdailyfortune()); \t\t\t\t \t\t// close the context \t\tcontext.close(); \t} } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Java Annotations/Method Injection.html",
    "title": "Method Injection",
    "body": " index search search back method injection one thing to note is that you can add dependency injection on any method you want, does not have to be a setter method: define dependency as component package com.springdemo; import org.springframework.stereotype.component; // we tell spring this is a bean @component public class happyfortuneservice implements fortuneservice { \t@override \tpublic string getfortune() { \t\treturn \"today is your lucky day!\"; \t} } specify dependency we now create a setter method in our class for the injection: package com.springdemo; import org.springframework.stereotype.component; import org.springframework.beans.factory.annotation.autowired; @component public class tenniscoach implements coach { \tprivate fortuneservice fortuneservice; \t \tpublic tenniscoach() {} // we tell spring to search for beans (classes with @component annotation) // that implement the fortuneservice interface \t@autowired public anymethod(fortuneservice fortuneservice){ this.fortuneservice = fortuneservice; } \t@override \tpublic string getdailyworkout() { \t\treturn \"practice your backhand volley\"; \t} \t@override \tpublic string getdailyfortune() { \t\treturn fortuneservice.getfortune(); \t} } the main method and the configuration files remain unchanged. and when we execute this piece of code, spring will automatically inject the dependency because of the autowired annotation. package com.springdemo; import org.springframework.context.support.classpathxmlapplicationcontext; public class annotationdemoapp { \tpublic static void main(string[] args) { \t\t// read spring config file \t\tclasspathxmlapplicationcontext context = \t\t\t\tnew classpathxmlapplicationcontext(\"applicationcontext.xml\"); \t\t \t\t// get the bean from spring container \t\tcoach thecoach = context.getbean(\"tenniscoach\", coach.class); \t\t \t\t// call a method on the bean \t\tsystem.out.println(thecoach.getdailyworkout()); \t\t// call method to get daily fortune \t\tsystem.out.println(thecoach.getdailyfortune()); \t\t\t\t \t\t// close the context \t\tcontext.close(); \t} } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Java Annotations/index.html",
    "title": "Java Annotations",
    "body": " index search search back java annotations java annotations are special labels added to classes. they provide metadata about the class, and can be processed at compile time or run-time for special processing. we use annotations to minimize the xml configuration. spring scans the classes to find beans and configure them internally (as we have done with the xml configuration). in order to use this approach we need to: enable component scanning in our spring configuration file and add the @component annotation to our class inversion of control dependency injection scopes life cycles $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Java Annotations/Constructor Injection.html",
    "title": "Constructor Injection",
    "body": " index search search back constructor injection define dependency as component package com.springdemo; import org.springframework.stereotype.component; // we tell spring this is a bean @component public class happyfortuneservice implements fortuneservice { \t@override \tpublic string getfortune() { \t\treturn \"today is your lucky day!\"; \t} } specify dependency package com.springdemo; import org.springframework.stereotype.component; import org.springframework.beans.factory.annotation.autowired; @component public class tenniscoach implements coach { \tprivate fortuneservice fortuneservice; \t // we tell spring to search for beans (classes with @component annotation) // that implement the fortuneservice interface \t@autowired \tpublic tenniscoach(fortuneservice thefortuneservice) { \t\tfortuneservice = thefortuneservice; \t} \t@override \tpublic string getdailyworkout() { \t\treturn \"practice your backhand volley\"; \t} \t@override \tpublic string getdailyfortune() { \t\treturn fortuneservice.getfortune(); \t} } the main method and the configuration files remain unchanged. package com.springdemo; import org.springframework.context.support.classpathxmlapplicationcontext; public class annotationdemoapp { \tpublic static void main(string[] args) { \t\t// read spring config file \t\tclasspathxmlapplicationcontext context = \t\t\t\tnew classpathxmlapplicationcontext(\"applicationcontext.xml\"); \t\t \t\t// get the bean from spring container \t\tcoach thecoach = context.getbean(\"tenniscoach\", coach.class); \t\t \t\t// call a method on the bean \t\tsystem.out.println(thecoach.getdailyworkout()); \t\t// call method to get daily fortune \t\tsystem.out.println(thecoach.getdailyfortune()); \t\t\t\t \t\t// close the context \t\tcontext.close(); \t} } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Java Annotations/Qualifier Annotation.html",
    "title": "Qualifier",
    "body": " index search search back qualifier in order to specify which specific implementation of an interface we want to use, when this interface is implemented by several beans, then we use the qualifier annotation. the qualifier annotation can be used in any dependency injection implementation: constructor injection (has different syntax) setter injection method injection field injection define dependency as component package com.springdemo; import org.springframework.stereotype.component; // we tell spring this is a bean @component public class happyfortuneservice implements fortuneservice { \t@override \tpublic string getfortune() { \t\treturn \"today is your lucky day!\"; \t} } specify dependency package com.springdemo; import org.springframework.stereotype.component; import org.springframework.beans.factory.annotation.autowired; @component public class tenniscoach implements coach { \t \t// we tell spring to search for beans (classes with @component annotation) \t// that implement the fortuneservice interface whose name is \"happyfortuneservice\" \t// (note this is the default name of the component if you set one explicitly you \t// will have to specify that one in the qualifier annotation) \t@autowired \t@qualifier(\"happyfortuneservice\") \tprivate fortuneservice fortuneservice; \t \tpublic tenniscoach() {} \t \t@override \tpublic string getdailyworkout() { \t\treturn \"practice your backhand volley\"; \t} \t \t@override \tpublic string getdailyfortune() { \t\treturn fortuneservice.getfortune(); \t} } the main method and the configuration files remain unchanged. and when we execute this piece of code, spring will automatically inject the dependency because of the autowired annotation. package com.springdemo; import org.springframework.context.support.classpathxmlapplicationcontext; public class annotationdemoapp { \tpublic static void main(string[] args) { \t\t// read spring config file \t\tclasspathxmlapplicationcontext context = \t\t\t\tnew classpathxmlapplicationcontext(\"applicationcontext.xml\"); \t\t \t\t// get the bean from spring container \t\tcoach thecoach = context.getbean(\"tenniscoach\", coach.class); \t\t \t\t// call a method on the bean \t\tsystem.out.println(thecoach.getdailyworkout()); \t\t// call method to get daily fortune \t\tsystem.out.println(thecoach.getdailyfortune()); \t\t\t\t \t\t// close the context \t\tcontext.close(); \t} } qualifier in constructor package com.springdemo; import org.springframework.beans.factory.annotation.autowired; import org.springframework.beans.factory.annotation.qualifier; import org.springframework.stereotype.component; @component public class tenniscoach implements coach { private fortuneservice fortuneservice; // define a default constructor public tenniscoach() { system.out.println(\">> tenniscoach: inside default constructor\"); } @autowired public tenniscoach(@qualifier(\"happyfortuneservice\") fortuneservice thefortuneservice) { system.out.println(\">> tenniscoach: inside constructor using @autowired and @qualifier\"); fortuneservice = thefortuneservice; } } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Java Annotations/Scopes.html",
    "title": "Scopes",
    "body": " index search search back scopes to explicitly specify scopes with java annotations you do as follows: package com.springdemo; import org.springframework.stereotype.component; import org.springframework.context.annotation.scope; @component @scope(\"singleton\") public class tenniscoach implements coach { ... or package com.springdemo; import org.springframework.stereotype.component; import org.springframework.context.annotation.scope; @component @scope(\"prototype\") public class tenniscoach implements coach { ... refer to more information about scopes are in bean scopes: $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Java Annotations/Inversion of Control.html",
    "title": "Inversion of Control",
    "body": " index search search back inversion of control let's see how to make us of inversion of control with annotations: enable component scanning we remove all of the beans we defined, and enable component scanning: <?xml version=\"1.0\" encoding=\"utf-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/xmlschema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemalocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"> \t<!-- add entry to enable component scanning --> \t<context:component-scan base-package=\"com.springdemo\" /> </beans> now spring will scan recursively all of the files in this package. add @component annotation to classes we add the @component annotation to our classes (note we do not add it to the interfaces like coach). package com.springdemo; import org.springframework.stereotype.component; @component // we can also set the explicit name like // @component(\"mytenniscoach\") public class tenniscoach implements coach { \t \t@override \tpublic string getdailyworkout() { \t\treturn \"practice your backhand volley\"; \t} } note that we can name the component explicitly or by default. main method in our application we do not really need to change anything. we create our bean the same way we did before. the only thing to note is that if we set the name of the component explicitly, then when we instantiate the bean, we should refer to it by said name. package com.springdemo; import org.springframework.context.support.classpathxmlapplicationcontext; public class annotationdemoapp { \tpublic static void main(string[] args) { \t\t// read spring config file \t\tclasspathxmlapplicationcontext context = \t\t\t\tnew classpathxmlapplicationcontext(\"applicationcontext.xml\"); \t\t \t\t// get the bean from spring container \t\t// if we set the name explicitly \t\tcoach thecoach = context.getbean(\"mytenniscoach\", coach.class); // else \t\tcoach thecoach = context.getbean(\"tenniscoach\", coach.class); \t\t \t\t// call a method on the bean \t\tsystem.out.println(thecoach.getdailyworkout()); \t\t\t\t \t\t// close the context \t\tcontext.close(); \t\t \t} } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Java Annotations/Life Cycles.html",
    "title": "Life Cycle",
    "body": " index search search back life cycle to define methods to add when the beans is constructed or destroyed we use the postconstruct and predestroy annotation. package com.springdemo; public class trackcoach implements coach { \t \tprivate fortuneservice fortuneservice; \t \tpublic trackcoach() { \t\t \t} \t \tpublic trackcoach(fortuneservice fortuneservice) { \t\tthis.fortuneservice = fortuneservice; \t} \t \t@override \tpublic string getdailyworkout() { \t\treturn \"run a hard 5k\"; \t} \t \t@override \tpublic string getdailyfortune() { \t\treturn \"just do it: \" + fortuneservice.getfortune(); \t} \t \t// run when the bean is done creating \t@postconstruct \tpublic void domystartupstuff() { \t\tsystem.out.println(\"trackcoach: inside method domystartupstuff\"); \t} \t \t// run before the bean is destroyed \t@predestroy \tpublic void domycleanupstuffyoyo() { \t\tsystem.out.println(\"trackcoach: inside method domycleanupstuffyoyo\");\t\t \t} } refer to more information about scopes are in bean life cycle: notes access modifier: the method can have any access modifier (public, protected, private) return type: the method can have any return type. however, \"void' is most commonly used. if you give a return type just note that you will not be able to capture the return value. as a result, \"void\" is commonly used. method name: the method can have any method name. arguments: the method can not accept any arguments. the method should be no-arg. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Java Annotations/Dependency Injection.html",
    "title": "Dependency Injection",
    "body": " index search search back dependency injection we will introduce dependency injection with annotation using autowiring: spring looks for a class that matches the attribute type (call or interface) (i.e. fortuneservice) spring will inject it automatically if there are multiple implementations: tell spring which specific bean to use with the qualifier annotation constructor injection setter injection method injection field injection inject using properties file qualifier annotation which dependency to use choose a style and stay consistent in your project. you get the same functionality regardless of the type of dependency injection you use. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Java Annotations/Setter Injection.html",
    "title": "Setter Injection",
    "body": " index search search back setter injection define dependency as component package com.springdemo; import org.springframework.stereotype.component; // we tell spring this is a bean @component public class happyfortuneservice implements fortuneservice { \t@override \tpublic string getfortune() { \t\treturn \"today is your lucky day!\"; \t} } specify dependency we now create a setter method in our class for the injection: package com.springdemo; import org.springframework.stereotype.component; import org.springframework.beans.factory.annotation.autowired; @component public class tenniscoach implements coach { \tprivate fortuneservice fortuneservice; \t \tpublic tenniscoach() {} // we tell spring to search for beans (classes with @component annotation) // that implement the fortuneservice interface \t@autowired public setfortuneservice(fortuneservice fortuneservice){ this.fortuneservice = fortuneservice; } \t@override \tpublic string getdailyworkout() { \t\treturn \"practice your backhand volley\"; \t} \t@override \tpublic string getdailyfortune() { \t\treturn fortuneservice.getfortune(); \t} } the main method and the configuration files remain unchanged. and when we execute this piece of code, spring will automatically inject the dependency because of the autowired annotation. package com.springdemo; import org.springframework.context.support.classpathxmlapplicationcontext; public class annotationdemoapp { \tpublic static void main(string[] args) { \t\t// read spring config file \t\tclasspathxmlapplicationcontext context = \t\t\t\tnew classpathxmlapplicationcontext(\"applicationcontext.xml\"); \t\t \t\t// get the bean from spring container \t\tcoach thecoach = context.getbean(\"tenniscoach\", coach.class); \t\t \t\t// call a method on the bean \t\tsystem.out.println(thecoach.getdailyworkout()); \t\t// call method to get daily fortune \t\tsystem.out.println(thecoach.getdailyfortune()); \t\t\t\t \t\t// close the context \t\tcontext.close(); \t} } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Java Annotations/Inject using Properties File.html",
    "title": "Inject properties file using Java annotations",
    "body": " index search search back inject properties file using java annotations this solution will show you how inject values from a properties file using annotations. the values will no longer be hard coded in the java code. create a properties file we create new text file: src/sport.properties foo.email=myeasycoach@luv2code.com foo.team=silly java coders load the properties we load the properties in the configuration xml file. for that we add the line: <context:property-placeholder location=\"classpath:sport.properties\"/> inject values lastly we inject the properties values into our bean like so: @value(\"${foo.email}\") private string email; @value(\"${foo.team}\") private string team; $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Hibernate/Concepts.html",
    "title": "Database Concepts",
    "body": " index search search back database concepts cascade: perform an operations on related entities on save: if we save an object, if it is related to another object, we need to also save that other object on delete: if we delete an object that is related to another object, we might need to delete that other object (depends on the use case) fetch types: when we fetch data, should we retrieve everything? eager: will retrieve everything lazy: will retrieve on request cascade types persist: if entity is persisted/saved, the related entity will also be persisted remove: if entity is removed/deleted, the related entity will also be deleted refresh: if entity is refreshed, the related entity will also be refreshed detach: if entity is detached (not associated with session), the related entity will also be detached merge: if entity is merged, the related entity will also be merged all: all of the above cascade types by default, no operations are cascaded. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Hibernate/Sessions.html",
    "title": "Sessions",
    "body": " index search search back sessions there are two key components when it comes to session handling: sessionfactory: reads the hibernate configuration file, creates sessions objects, and is created only once in the application and reused over and over again session: is a wrapper around a jdbc connection, which is the main object used to save/retrieve objects. this object is created multiple times. so to create a sessionfactory and then create session from it: public class demo { public static void main(string[] args) { // create session factory sessionfactory factory = new configuration() // configuration file in src/ (if it is not specified, hibernate will look for a file named hibernate.cfg.xml) .configure(\"hibernate.cfg.xml\") // class that was annotated to be mapped .addannotatedclass(student.class) // you can add multiple classes .addannotatedclass(...) // create the factory .buildsessionfactory(); // create session session session = factory.getcurrentsession(); try {\t\t\t // use session object to perform crud operations\t } finally { // delete session factory factory.close(); } } } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Hibernate/ManyToMany.html",
    "title": "Many To Many Relationship",
    "body": " index search search back many to many relationship here we demonstrate how to implement a many to many relationship between two entities. for this we need a join table: well, first of all you have to define the two database tables corresponding to these two entities. and then we define a intermediate table to act as the join table called course_student. entities we now code the two entities: package com.hibernate.demo.entity; // annotate the class as an entity and map to db table @entity @table(name=\"course\") public class course { // define the fields // annotate the fields with db column names @id @generatedvalue(strategy=generationtype.identity) @column(name=\"id\") private int id; @column(name=\"title\") private string title; // set up one to many relationship @manytoone(cascade= // on delete course, do not delete instructor {cascadetype.persist, cascadetype.merge, cascadetype.detach, cascadetype.refresh}) @joincolumn(name=\"instructor_id\") private instructor instructor; // set up unidirectional one to many relationship @onetomany(fetch=fetchtype.lazy, cascade=cascadetype.all) \t@joincolumn(name=\"course_id\") \tprivate list<review> reviews; // set up many to many relationship with lazy loading // so only courses are retrieved, and the students associated // are obtained only if needed \t@manytomany(fetch=fetchtype.lazy, \t\t\tcascade= {cascadetype.persist, cascadetype.merge, \t\t\t cascadetype.detach, cascadetype.refresh}) // specifying the join table, and the corresponding // foreign keys @jointable( // table name name=\"course_student\", // this entity's pk joincolumns=@joincolumn(name=\"course_id\"), // related entity's pk inversejoincolumns=@joincolumn(name=\"student_id\") ) private list<student> students; public course() { }\t\t ... // setters and getters } and now the student: package com.hibernate.demo.entity; @entity @table(name=\"student\") public class student { @id @generatedvalue(strategy=generationtype.identity) @column(name=\"id\") private int id; @column(name=\"first_name\") private string firstname; @column(name=\"last_name\") private string lastname; @column(name=\"email\") private string email; // set up many to many relationship with lazy loading // so only students are retrieved, and the courses associated // are obtained only if needed @manytomany(fetch=fetchtype.lazy, \t\tcascade= {cascadetype.persist, cascadetype.merge, \t\t cascadetype.detach, cascadetype.refresh}) // specifying the join table, and the corresponding // foreign keys @jointable( // table name \t\tname=\"course_student\", // this entity's pk \t\tjoincolumns=@joincolumn(name=\"student_id\"), // related entity's pk \t\tinversejoincolumns=@joincolumn(name=\"course_id\") \t\t)\t private list<course> courses; // constructor, getters, setters .... main app to test our code, we are going to get a course and add it to a student: package com.hibernate.demo; public class createdemo { public static void main(string[] args) { // create session factory // ... // create session session session = factory.getcurrentsession(); try {\t\t // start a transaction session.begintransaction(); // get the student mary from database int studentid = 2; student tempstudent = session.get(student.class, studentid); // create more courses course tempcourse1 = new course(\"rubik's cube - how to speed cube\"); course tempcourse2 = new course(\"atari 2600 - game development\"); \t\t\t // add student to courses tempcourse1.addstudent(tempstudent); tempcourse2.addstudent(tempstudent); \t\t\t // save the courses session.save(tempcourse1); session.save(tempcourse2); // commit transaction session.gettransaction().commit(); } finally { session.close(); \tfactory.close(); } } } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Hibernate/Database Operations.html",
    "title": "Database Operations",
    "body": " index search search back database operations save java object to save a java object: public ... { try {\t\t\t \t// create a student object \tstudent tempstudent = new student(\"paul\", \"doe\", \"paul@luv2code.com\"); \t \t// start a transaction \tsession.begintransaction(); \t \t// save the student object \tsession.save(tempstudent); \t \t// commit transaction \tsession.gettransaction().commit(); } finally { \tfactory.close(); } } read java object public ... { try {\t\t\t // from the student created and saved previously // find out the student's id: primary key // now get a new session and start transaction session = factory.getcurrentsession(); session.begintransaction(); // retrieve student based on the id: primary key system.out.println(\"\\ngetting student with id: \" + tempstudent.getid()); // get from the db by the primary key of the student student mystudent = session.get(student.class, tempstudent.getid()); // commit the transaction session.gettransaction().commit(); } finally { \tfactory.close(); } } query java object hibernate has a query language for retrieving objects: hql which is similar to sql. public class querystudentdemo { public static void main(string[] args) { // create session factory ... // create session session session = factory.getcurrentsession(); try {\t\t\t // start a transaction session.begintransaction(); // note we use the java object name for the table name // and the name of the attribute in the class for the name // of the column (firstname istd of first_name) // query students: lastname='doe' or firstname='daffy' thestudents = session.createquery(\"from student s where\" + \" s.lastname='doe' or s.firstname='daffy'\").getresultlist(); // query students where email like '%gmail.com' thestudents = session.createquery(\"from student s where\" \t\t+ \" s.email like '%gmail.com'\").getresultlist(); // commit transaction session.gettransaction().commit(); } finally { \tfactory.close(); } } update java objects public class updatestudentdemo { public static void main(string[] args) { // create session factory ... // create session session session = factory.getcurrentsession(); try {\t\t\t\t\t\t\t\t // update one student int studentid = 1; // now get a new session and start transaction session = factory.getcurrentsession(); session.begintransaction(); student mystudent = session.get(student.class, studentid); // update name of student mystudent.setfirstname(\"scooby\"); // commit the transaction session.gettransaction().commit(); // update several students session = factory.getcurrentsession(); session.begintransaction(); // update email for all students system.out.println(\"update email for all students\"); session.createquery(\"update student set email='foo@gmail.com'\") \t.executeupdate(); \t\t\t // commit the transaction session.gettransaction().commit(); } finally { \tfactory.close(); } } } delete java objects public class deletestudentdemo { public static void main(string[] args) { // create session factory ... // create session session session = factory.getcurrentsession(); try {\t\t\t\t\t\t\t\t int studentid = 1; \t\t\t // now get a new session and start transaction session = factory.getcurrentsession(); session.begintransaction(); // retrieve student based on the id: primary key student mystudent = session.get(student.class, studentid); // delete the student session.delete(mystudent); // delete student id=2 session.createquery(\"delete from student where id=2\").executeupdate(); // commit the transaction session.gettransaction().commit(); } finally { \tfactory.close(); } } } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Hibernate/Annotations.html",
    "title": "Configure Hibernate with Annotations",
    "body": " index search search back configure hibernate with annotations add hibernate configuration file we create the following hibernate.cfg.xml file: <!doctype hibernate-configuration public \"-//hibernate/hibernate configuration dtd 3.0//en\" \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"> <hibernate-configuration> <!-- a session factory allows us to get sessions objects to connect to the database --> <session-factory> <!-- jdbc database connection settings --> <property name=\"connection.driver_class\">com.mysql.cj.jdbc.driver</property> <property name=\"connection.url\">jdbc:mysql://localhost:3306/hb_student_tracker?usessl=false&amp;servertimezone=utc</property> <property name=\"connection.username\">hbstudent</property> <property name=\"connection.password\">hbstudent</property> <!-- jdbc connection pool settings ... using built-in test pool --> <property name=\"connection.pool_size\">1</property> <!-- select our sql dialect --> <property name=\"dialect\">org.hibernate.dialect.mysqldialect</property> <!-- echo the sql to stdout --> <property name=\"show_sql\">true</property> <!-- set the current session context --> <property name=\"current_session_context_class\">thread</property> </session-factory> </hibernate-configuration> annotate java class hibernate deals with the concept of entity, which is basically a java class with its attributes, setters and getters, that is mapped to a database table with the help of annotations. note that there are two ways of configuring the mapping: xml config file (legacy) java annotations (modern, preferred) with java annotations we have to follow these steps: map the class to a database table // let spring know this is an entity we want to map to a database table @entity // provides the actual name of the table (observe in this case it is optional // because the name of the class = the name of the database table) @table(name=\"student\") public class student { ... } map the fields to database columns public class student { // primary key @id // how to generate primary key @generatedvalue(strategy=generationtype.identity) // column name (also not needed if the name in the database and the name here are the same) @column(name=\"id\") private int id; @column(name=\"first_name\") private string firstname; @column(name=\"last_name\") private string lastname; @column(name=\"email\") private string email; ... } some other id generation strategies are: auto: pick the appropiate strategy for the given database identity: assign primary keys using database identidy column sequence: assign primary keys using a database sequence table: assign primary keys using an uderlying database table to ensure uniqueness you can also create your custom generator $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Hibernate/Eager vs Lazy Loading.html",
    "title": "Eager vs Lazy Loading",
    "body": " index search search back eager vs lazy loading eager: fetches all data all at once (with dependencies of the entity) lazy: fetches required data only lazy loading is usually preferred, that is only load data when absolutely needed. the flow of lazy loading is: load the main entity first load dependent entities on demand note than when using lazy loading you need an open hibernate session, else if you close the session and try to retrieve the data hibernate will throw an exception. default fetch types mapping defaul fetch type @onetoone fetchtype.eager @onetomany fetchtype.lazy @manytoone fetchtype.eager @manytomany fetchtype.lazy specify fetch type on entity we can specify the fetching type on the entity as follows: @entity @table(name=\"instructor\") public class instructor { \t@id \t@generatedvalue(strategy=generationtype.identity) \t@column(name=\"id\") \tprivate int id; \t \t@onetoone(cascade=cascadetype.all) \t@joincolumn(name=\"instructor_detail_id\") \tprivate instructordetail instructordetail; \t // specify fetch type (only load the courses on demand, their retrieval // is delayed) \t@onetomany(fetch=fetchtype.lazy, \t\t\t mappedby=\"instructor\", \t\t\t cascade= {cascadetype.persist, cascadetype.merge, \t\t\t\t\t\t cascadetype.detach, cascadetype.refresh}) \tprivate list<course> courses; ... avoid closed session exception to avoid the error we use the join fetch (we do override lazy loading with eager loading) of hql: public class fetchjoindemo { public static void main(string[] args) { // create session factory sessionfactory factory = ... // create session session session = factory.getcurrentsession(); try {\t\t\t // start a transaction session.begintransaction(); // hibernate query with hql to avoid exception of lazy loading when closing session // get the instructor from db int theid = 1; query<instructor> query = \t\tsession.createquery(\"select i from instructor i \" \t\t\t\t\t\t+ \"join fetch i.courses \" \t\t\t\t\t\t+ \"where i.id=:theinstructorid\", \t\t\t\tinstructor.class); // set parameter on query query.setparameter(\"theinstructorid\", theid); // execute query and get instructor instructor tempinstructor = query.getsingleresult(); system.out.println(\"luv2code: instructor: \" + tempinstructor);\t // commit transaction session.gettransaction().commit(); // close the session session.close(); system.out.println(\"\\nluv2code: the session is now closed!\\n\"); // get courses for the instructor system.out.println(\"luv2code: courses: \" + tempinstructor.getcourses()); system.out.println(\"luv2code: done!\"); } finally { // add clean up code session.close(); factory.close(); } } } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Hibernate/index.html",
    "title": "Hibernate",
    "body": " index search search back hibernate is a framework for persisting/saving java objects in a database handles all of the low-level sql minimizes the amount jdbc code to develop provides the object-to-relational mapping (orm): the developer defines a mapping between a java class and a database table hibernate uses jdbc for all database communications: $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Hibernate/OneToMany.html",
    "title": "One To Many Relationship",
    "body": " index search search back one to many relationship unidirectional bidirectional unidirectional here we demonstrate how to implement a unidirectional one to many relationship between two entities: well, first of all you have to define the two database tables corresponding to these two entities. entities we now code the two entities: package com.hibernate.demo.entity; // annotate the class as an entity and map to db table @entity @table(name=\"course\") public class course { // define the fields // annotate the fields with db column names @id @generatedvalue(strategy=generationtype.identity) @column(name=\"id\") private int id; @column(name=\"title\") private string title; // set up one to many relationship @manytoone(cascade= // on delete course, do not delete instructor {cascadetype.persist, cascadetype.merge, cascadetype.detach, cascadetype.refresh}) @joincolumn(name=\"instructor_id\") private instructor instructor; // set up unidirectional one to many relationship @onetomany(fetch=fetchtype.lazy, cascade=cascadetype.all) \t@joincolumn(name=\"course_id\") \tprivate list<review> reviews; public course() { }\t\t ... // setters and getters } and now the review: package com.hibernate.demo.entity; @entity @table(name=\"review\") public class review { \t@id \t@generatedvalue(strategy=generationtype.identity) \t@column(name=\"id\") \tprivate int id; \t \t@column(name=\"comment\") \tprivate string comment; \t \tpublic review() { \t\t \t} note that there is no reference in the review to the course. main app to test our code, we are going to get a course and the list of review objects associated. the test main app is the following: package com.hibernate.demo; public class createdemo { public static void main(string[] args) { // create session factory // ... // create session session session = factory.getcurrentsession(); try {\t\t // start a transaction session.begintransaction(); // get the course int theid = 10; course tempcourse = session.get(course.class, theid); // get reviews tempcourse.getreviews(); // commit transaction session.gettransaction().commit(); } finally { session.close(); \tfactory.close(); } } } bidirectional now we will define the following relationship: let's now see how to code a bidirectional relationship: entities package com.hibernate.demo.entity; /* annotate the class as an entity and map to db table */ @entity @table(name=\"instructor\") public class instructor { // define the fields and annotate the fields // with db column names @id @generatedvalue(strategy=generationtype.identity) @column(name=\"id\") private int id; @column(name=\"first_name\") private string firstname; @column(name=\"last_name\") private string lastname; @column(name=\"email\") private string email; // set up mapping to instructordetail entity // note the cascade type @onetoone(cascade=cascadetype.all) // define the foreign key @joincolumn(name=\"instructor_detail_id\") private instructordetail instructordetail; // bidirectional relationship with courses // the mapping information is in the instructor // property in the course class @onetomany(mappedby=\"instructor\", // on delete instructor, do not delete courses cascade= {cascadetype.persist, cascadetype.merge, cascadetype.detach, cascadetype.refresh}) private list<course> courses; public instructor() { \t } ... // setters and getters } and now the course class: package com.hibernate.demo.entity; // annotate the class as an entity and map to db table @entity @table(name=\"course\") public class course { // define the fields // annotate the fields with db column names @id @generatedvalue(strategy=generationtype.identity) @column(name=\"id\") private int id; @column(name=\"title\") private string title; // set up one to many relationship @manytoone(cascade= // on delete course, do not delete instructor {cascadetype.persist, cascadetype.merge, cascadetype.detach, cascadetype.refresh}) @joincolumn(name=\"instructor_id\") private instructor instructor; public course() { }\t\t ... // setters and getters } main app in our test main app we are going to search for an instructordetail object, and we are going to retrieve the related instructor object: package com.hibernate.demo; public class getinstructordetaildemo { public static void main(string[] args) { session = factory.getcurrentsession(); try { // start a transaction session.begintransaction(); // get the instructor from db int theid = 1; instructor tempinstructor = session.get(instructor.class, theid);\t\t // create some courses course tempcourse1 = new course(\"air guitar - the ultimate guide\"); course tempcourse2 = new course(\"the pinball masterclass\"); // add courses to instructor tempinstructor.add(tempcourse1); tempinstructor.add(tempcourse2); // save the courses session.save(tempcourse1); session.save(tempcourse2); // commit transaction session.gettransaction().commit(); } catch(exception exc){ exc.printstacktrace(); } finally { // finish session session.close(); // remove factory\t factory.close(); } } } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Hibernate/OneToOne.html",
    "title": "One To One Relationship",
    "body": " index search search back one to one relationship unidirectional bidirectional unidirectional here we demonstrate how to implement a unidirectional one to one relationship between two entities: well, first of all you have to define the two database tables corresponding to these two entities. entities we now code the two entities: package com.hibernate.demo.entity; /* annotate the class as an entity and map to db table */ @entity @table(name=\"instructor\") public class instructor { // define the fields and annotate the fields // with db column names @id @generatedvalue(strategy=generationtype.identity) @column(name=\"id\") private int id; @column(name=\"first_name\") private string firstname; @column(name=\"last_name\") private string lastname; @column(name=\"email\") private string email; // set up mapping to instructordetail entity // note the cascade type @onetoone(cascade=cascadetype.all) // define the foreign key @joincolumn(name=\"instructor_detail_id\") private instructordetail instructordetail; public instructor() { \t } ... // setters and getters } note the specification of the cascade type. and now the instructordetail: package com.hibernate.demo.entity; // annotate the class as an entity and map to db table @entity @table(name=\"instructor_detail\") public class instructordetail { \t// define the fields \t// annotate the fields with db column names \t \t@id \t@generatedvalue(strategy=generationtype.identity) \t@column(name=\"id\") \tprivate int id; \t \t@column(name=\"youtube_channel\") \tprivate string youtubechannel; \t \t@column(name=\"hobby\") \tprivate string hobby; \t \tpublic instructordetail() { }\t\t ... // setters and getters } main app to test our code, we are going to create an instructor object and an instructordetail object and save them. the test main app is the following: package com.hibernate.demo; public class createdemo { public static void main(string[] args) { // create session factory // ... // create session session session = factory.getcurrentsession(); try {\t\t\t // create the objects instructor tempinstructor = \t\tnew instructor(\"madhu\", \"patel\", \"madhu@mail.com\"); instructordetail tempinstructordetail = \t\tnew instructordetail( \t\t\t\t\"http://www.youtube.com\", \t\t\t\t\"guitar\");\t\t // associate the objects tempinstructor.setinstructordetail(tempinstructordetail); // start a transaction session.begintransaction(); // save the instructor // // note: this will also save the details object // because of cascadetype.all // session.save(tempinstructor);\t\t\t\t\t // commit transaction session.gettransaction().commit(); } finally { \tfactory.close(); } } } bidirectional now we will define the following bidirectional one to one relationship: let's now see how to code a bidirectional relationship: entities package com.hibernate.demo.entity; /* annotate the class as an entity and map to db table */ @entity @table(name=\"instructor\") public class instructor { // define the fields and annotate the fields // with db column names @id @generatedvalue(strategy=generationtype.identity) @column(name=\"id\") private int id; @column(name=\"first_name\") private string firstname; @column(name=\"last_name\") private string lastname; @column(name=\"email\") private string email; // set up mapping to instructordetail entity // note the cascade type @onetoone(cascade=cascadetype.all) // define the foreign key @joincolumn(name=\"instructor_detail_id\") private instructordetail instructordetail; public instructor() { \t } ... // setters and getters and now the instructordetail: package com.hibernate.demo.entity; // annotate the class as an entity and map to db table @entity @table(name=\"instructor_detail\") public class instructordetail { // define the fields // annotate the fields with db column names @id @generatedvalue(strategy=generationtype.identity) @column(name=\"id\") private int id; @column(name=\"youtube_channel\") private string youtubechannel; @column(name=\"hobby\") private string hobby; \t // add @onetoone annotation // mappedby refers to the instructordetail property // in the instructor class // this uses the information from the instructor class in @joincolumn // to define the mapping @onetoone(mappedby=\"instructordetail\", // different cascade types cascade={ cascadetype.detach, cascadetype.merge, cascadetype.persist, cascadetype.refresh}) private instructor instructor; public instructordetail() { }\t\t ... // setters and getters } main app in our test main app we are going to search for an instructordetail object, and we are going to retrieve the related instructor object: package com.hibernate.demo; public class getinstructordetaildemo { \tpublic static void main(string[] args) { session = factory.getcurrentsession(); try { // start a transaction session.begintransaction(); // get the instructor detail object int theid = 2999; instructordetail tempinstructordetail = \t\tsession.get(instructordetail.class, theid); \t\t\t // print the associated instructor system.out.println(\"the associated instructor: \" + \t\t\t\t\ttempinstructordetail.getinstructor()); // commit transaction session.gettransaction().commit(); } catch(exception exc){ exc.printstacktrace(); } finally { // finish session \t\t\tsession.close(); \t\t // remove factory\t \t\t\tfactory.close(); } } } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Java Configuration/Load Properties from File.html",
    "title": "Load Properties from File",
    "body": " index search search back load properties from file in order to inject values read from a properties file we do the following: create the file first, we create the file sport.properties foo.email=myeasycoach@luv2code.com foo.team=awesome java coders load the file now, we load the file from our configuration class: package com.springdemo; import org.springframework.context.annotation.bean; import org.springframework.context.annotation.configuration; import org.springframework.context.annotation.propertysource; import org.springframework.context.support.propertysourcesplaceholderconfigurer; @configuration @propertysource(\"classpath:sport.properties\") public class sportconfig { \t \t// define bean for our sad fortune service \t@bean \tpublic fortuneservice sadfortuneservice() { \t\treturn new sadfortuneservice(); \t} \t \t// define bean for our swim coach and inject dependency \t@bean \tpublic coach swimcoach() { \t\tswimcoach myswimcoach = new swimcoach(sadfortuneservice()); \t\t \t\treturn myswimcoach; \t} \t } inject values we inject the values at field level in our bean: package com.springdemo; import org.springframework.beans.factory.annotation.value; public class swimcoach implements coach { \tprivate fortuneservice fortuneservice; \t@value(\"${foo.email}\") \tprivate string email; \t \t@value(\"${foo.team}\") \tprivate string team; ... $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Java Configuration/index.html",
    "title": "Spring Configuration with Java",
    "body": " index search search back spring configuration with java we are now going to use java to configure our application instead of using xml, to do that we follow the next steps: create a java class and annotate as @configuration add component scanning support with @componentscan (optional), which is xml we did as: <?xml version=\"1.0\" encoding=\"utf-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" ....> \t<!-- add entry to enable component scanning --> \t<context:component-scan base-package=\"com.springdemo\" /> </beans> in the main app read the spring java configuration class configuration with java inversion of control load properties from file dependency injection $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Java Configuration/Inversion of Control.html",
    "title": "Inversion of Control",
    "body": " index search search back inversion of control to define a bean, we now use our configuration class: create the bean package com.springdemo; // note there are no special annotations public class swimcoach implements coach { \tprivate fortuneservice fortuneservice; \tpublic swimcoach(fortuneservice thefortuneservice) { \t\tfortuneservice = thefortuneservice; \t} \t \t@override \tpublic string getdailyworkout() { \t\treturn \"swim 1000 meters as a warm up.\"; \t} \t@override \tpublic string getdailyfortune() { \t\treturn fortuneservice.getfortune(); \t} } we also create the sadfortuneservice bean: package com.springdemo; import org.springframework.stereotype.component; @component public class sadfortuneservice implements fortuneservice { \t@override \tpublic string getfortune() { \t\treturn \"today is a sad day :(\"; \t} } define the bean in the configuration class package com.springdemo; import org.springframework.context.annotation.bean; import org.springframework.context.annotation.configuration; @configuration public class sportconfig { \t \t// define bean for our sad fortune service \t@bean \tpublic fortuneservice sadfortuneservice() { \t\treturn new sadfortuneservice(); \t} \t \t// define bean for our swim coach and inject dependency // without springs dependency injection \t@bean \tpublic coach swimcoach() { \t\tswimcoach myswimcoach = new swimcoach(sadfortuneservice()); \t\t \t\treturn myswimcoach; \t} \t } the @bean annotation tells spring that we are creating a bean component manually. we didn't specify a scope so the default scope is singleton. public coach swimcoach(){ specifies that the bean will bean id of \"swimcoach\". the @bean annotation will intercept any requests for \"swimcoach\" bean. since we didn't specify a scope, the bean scope is singleton. so now in our main method: main method package com.luv2code.springdemo; import org.springframework.context.annotation.annotationconfigapplicationcontext; public class javaconfigdemoapp { \tpublic static void main(string[] args) { \t\t// read spring config java class \t\tannotationconfigapplicationcontext context = \t\t\t\tnew annotationconfigapplicationcontext(sportconfig.class); \t\t \t\t// get the bean from spring container by its id \t\tcoach thecoach = context.getbean(\"swimcoach\", coach.class); \t\t \t\t// call a method on the bean \t\tsystem.out.println(thecoach.getdailyworkout()); \t\t\t\t \t\t// call method to get the daily fortune \t\tsystem.out.println(thecoach.getdailyfortune()); \t\t\t\t\t \t\t// close the context \t\tcontext.close(); \t\t \t} } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Java Configuration/Configuration With Java.html",
    "title": "Configuration With Java",
    "body": " index search search back configuration with java create configuration class package com.springdemo; import org.springframework.context.annotation.componentscan; import org.springframework.context.annotation.configuration; // 1. define configuration class @configuration // 2. add component scanning support @componentscan(\"com.springdemo\") public class sportconfig { \t } load the configuration class package com.springdemo; import org.springframework.context.annotation.annotationconfigapplicationcontext; public class javaconfigdemoapp { \tpublic static void main(string[] args) { \t\t// read spring config java class \t\tannotationconfigapplicationcontext context = \t\t\t\tnew annotationconfigapplicationcontext(sportconfig.class); \t\t \t\t// get the bean from spring container \t\tcoach thecoach = context.getbean(\"tenniscoach\", coach.class); \t\t \t\t// call a method on the bean \t\tsystem.out.println(thecoach.getdailyworkout()); \t\t\t\t \t\t// call method to get the daily fortune \t\tsystem.out.println(thecoach.getdailyfortune()); \t\t\t\t\t \t\t// close the context \t\tcontext.close(); \t\t \t} } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Spring/Spring Framework.html",
    "title": "Spring Framework",
    "body": " index search search back spring framework components: core container beans (define entities) core (management of beans) spel: spring expression language (annotations) context (store entities) aop (aspect oriented programming): allows you to create application wide services like messaging, logging, security, etc. and add this functionality to your objects in a declarative fashion. data access layer: establishes the connection with the database jdbc helper classes orm: provides hook to hibernate transactions oxm jms (java message service) for async messages web layer: all web related classes, holds all of the spring mvc framework servlet websocket web portlet test layer: supports tdd: unit integration mock spring projects spring modules built on top of the core spring framework: spring boot spring cloud spring batch etc spring projects $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/Reducer.html",
    "title": "Reducers and Actions",
    "body": " index search search back reducers and actions let's now see an example of a reducer, more concretely the reducer of the user slice we defined previously: // use create slice to define the slice import { createslice } from \"@reduxjs/toolkit\"; // define initial state const initialstatevalue = { name: \"\", age: 0, email: \"\" }; export const userslice = createslice({ // name of slice name: \"user\", // initial state of reducer initialstate: { value: initialstatevalue }, // possible reducers reducers: { login: (state, action) => { state.value = action.payload; }, logout: (state) => { state.value = initialstatevalue; }, }, }); // de-structure actions export const { login, logout } = userslice.actions; // export reducer export default userslice.reducer; we now $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/useReducer.html",
    "title": "useReducer",
    "body": " index search search back usereducer an alternative to usestate. accepts a reducer of type (state, action) => newstate, and returns the current state paired with a dispatch method. usereducer is usually preferable to usestate when you have complex state logic that involves multiple sub-values or when the next state depends on the previous one. usereducer also lets you optimize performance for components that trigger deep updates because you can pass dispatch down instead of callbacks. for example: import react, { usestate, usereducer } from 'react'; // components import modal from './modal'; // data import { data } from '../../../data'; // reducer dispatch function import { reducer } from './reducer'; // initial state for the reducer const defaultstate = { people: [], ismodalopen: false, modalcontent: '', }; const index = () => { // define state variables const [name, setname] = usestate(''); // define reducer: (dispatch fuction, initial state) const [state, dispatch] = usereducer(reducer, defaultstate); const handlesubmit = (e) => { // avoid the re-rendering caused by the submit event e.preventdefault(); if (name) { const newitem = { id: new date().gettime().tostring(), name }; // call reducer to update state dispatch({ type: 'add_item', payload: newitem }); setname(''); } else { // call reducer to update state dispatch({ type: 'no_value' }); } }; const closemodal = () => { // call reducer to update state dispatch({ type: 'close_modal' }); }; return ( <> {/*render modal component conditionally */} {state.ismodalopen && ( <modal closemodal={closemodal} modalcontent={state.modalcontent} /> )} {/* form to add a new person to the reducer state variable */} <form onsubmit={handlesubmit} classname='form'> <div> <input type='text' value={name} onchange={(e) => setname(e.target.value)} /> </div> <button type='submit'>add </button> </form> {/* show the people stored in the reducer state variable */} {state.people.map((person) => { return ( <div key={person.id} classname='item'> <h4>{person.name}</h4> <button onclick={() => // call reducer to update state dispatch({ type: 'remove_item', payload: person.id }) } > remove </button> </div> ); })} </> ); }; export default index; now, let's see the reducer function: /* reducer function */ export const reducer = (state, action) => { // define logic for each type of action if (action.type === 'add_item') { // add new person (action.payload) to existing people array (state.people) const newpeople = [...state.people, action.payload]; return { // always copy the value from the previous state ...state, // update the people array people: newpeople, ismodalopen: true, modalcontent: 'item added', }; } if (action.type === 'no_value') { // always copy the value from the previous state return { ...state, ismodalopen: true, modalcontent: 'please enter value' }; } if (action.type === 'close_modal') { return { ...state, ismodalopen: false }; } if (action.type === 'remove_item') { // filter people array, by removing the person const newpeople = state.people.filter( (person) => person.id !== action.payload ); // copy the previous state (...state) and update the people the array (newpeople) return { ...state, people: newpeople }; } throw new error('no matching action type'); }; $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/Event Basics.html",
    "title": "Event Basics",
    "body": " index search search back event basics list of all possible events to define an event we have to specify: attribute: like onclick, onmousehover, etc. eventhandler: the function to apply. this can be specified as a reference or as an in-line function. next, we present an example: import react from 'react' const book = ({ title, author }) => { const clickhandler = () => {alert('hello!!')} return ( <article classname='book'> <!-- here we have the eventhandler as an in-line function --> <h1 onclick={() => alert('hello!!')}>{title}</h1> <h4>{author}</h4> <!-- here we have the eventhandler as a reference --> <button type=\"button\" onclick={clickhandler}>this is a button</button> </article> ); }; export default book to pass an argument to the eventhandler we have to use a lambda function, else when we load the application will invoke the function clickhandler(author) import react from 'react' const book = ({ title, author }) => { const clickhandler = (author) => {alert(author)} return ( <article classname='book'> <h1 onclick={() => alert('hello!!')}>{title}</h1> <h4>{author}</h4> <!-- wrap function with an in-line function --> <button type=\"button\" onclick={() => clickhandler(author)}>this is a button</button> </article> ); }; export default book we can also access the event object from within the function, like: import react from 'react' const book = ({ title, author }) => { // you can always access the event object from an eventhandler const clickhandler = (author, e) => {console.log(e)} return ( <article classname='book'> <h1 onclick={() => alert('hello!!')}>{title}</h1> <h4>{author}</h4> <button type=\"button\" onclick={() => clickhandler(author)}>this is a button</button> </article> ); }; export default book $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/Controlled Inputs.html",
    "title": "Controlled Inputs",
    "body": " index search search back controlled inputs let's see how to handle inputs in a form using react: import react, { usestate } from 'react'; const controlledinputs = () => { const [firstname, setfirstname] = usestate(''); const [people, setpeople] = usestate([]); const handlesubmit = (e) => { // avoid the default behaviour in submit which re-renders the page e.preventdefault(); // our own logic for the submit action if (firstname) { // create new person object const person = { id: new date().gettime().tostring(), firstname }; // update our state (remember you need to spred the people state variable we have before, else the you would // override the people state variable and it would be assigned to only the person object) setpeople((people) => { return [...people, person]; }); // set to empty, so the value of the input is the empty string setfirstname(''); } else { // no values to create new person console.log('empty values'); } }; return ( <> <article> {/*event handler for the submit event*/} <form onsubmit={handlesubmit}> <div > <label htmlfor='firstname'>name : </label> <input type='text' id='firstname' name='firstname' {/*set the value of the input, it updates every time we change the input*/} value={firstname} {/*event handler for the change event: use a lambda function to pass the event e and get the value in the input*/} onchange={(e) => setfirstname(e.target.value)} /> </div> <button type='submit'>add person</button> </form> {/*show each person in the people array */} {people.map((person, index) => { const { id, firstname } = person; return ( <div classname='item' key={id}> <h4>{firstname}</h4> </div> ); })} </article> </> ); }; export default controlledinputs; multiple inputs how can we define an event handler for the onchange event that is generic, instead of defining one for each input? to showcase this scenario, we will use the same code as before, but with two new inputs. all of the inputs have the same onchange event handler. import react, { usestate } from 'react'; const controlledinputs = () => { // create a new state variable person, that holds the properties of the person we are currently creating const [person, setperson] = usestate({ firstname: '', email: '', age: '' }); // array of people we have already created const [people, setpeople] = usestate([]); // generic event handler const handlechange = (e) => { // obtain the name of the input/state variable const name = e.target.name; // obtain the new value for the input const value = e.target.value; // update the value of the property for the current person setperson({ ...person, [name]: value }); }; const handlesubmit = (e) => { e.preventdefault(); if (person.firstname && person.email && person.age) { const newperson = { ...person, id: new date().gettime().tostring() }; setpeople([...people, newperson]); setperson({ firstname: '', email: '', age: '' }); } }; return ( <> <article classname='form'> <form> <div classname='form-control'> <label htmlfor='firstname'>name : </label> <input type='text' id='firstname' name='firstname' // access the firstname of the person object value={person.firstname} // generic event handler onchange={handlechange} /> </div> <div classname='form-control'> <label htmlfor='email'>email : </label> <input type='email' id='email' name='email' // access the email of the person object value={person.email} // generic event handler onchange={handlechange} /> </div> <div classname='form-control'> <label htmlfor='age'>age : </label> <input type='number' id='age' name='age' // access the age of the person object value={person.age} // generic event handler onchange={handlechange} /> </div> <button type='submit' classname='btn' onclick={handlesubmit}> add person </button> </form> </article> <article> {people.map((person) => { const { id, firstname, email, age } = person; return ( <div key={id} classname='item'> <h4>{firstname}</h4> <p>{email}</p> <p>{age}</p> </div> ); })} </article> </> ); }; export default controlledinputs; $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/Get State.html",
    "title": "Get State",
    "body": " index search search back get state in order to access the state saved in our state, we do the following: import react from \"react\"; import { useselector } from \"react-redux\"; function profile() { // use the useselector hook const user = useselector((state) => state.user.value); return ( <div style={{ color: themecolor }}> <h1> profile page</h1> <!--obtain the user state--> <p> name: {user.name} </p> <p> age: {user.age}</p> <p> email: {user.email}</p> </div> ); } export default profile; $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/npm.html",
    "title": "npm",
    "body": " index search search back npm it is the node package manager: create package.json (manifest) file, with the list of dependencies $ npm init install package locally and add it to package.json, under the keyword \"dependencies\" $ npm install <package name> install package globally (requires sudo) $ npm install -g <package name> install package only for development $ npm install <package name> --save-dev the packages installed with be saved under the file node_modules to install all the dependencies listed in package.json, just run: $ npm install where the package.json is. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/Prop Drilling.html",
    "title": "Prop Drilling",
    "body": " index search search back prop drilling prop drilling refers to the scenario where we have to pass props to anidated components recursively. next up, we show and example import react, { usestate } from 'react'; // data import { data } from '../../../data'; // outer component const propdrilling = () => { // state passed as a prop const [people, setpeople] = usestate(data); // event handler passed as a prop const removeperson = (id) => { setpeople((people) => { return people.filter((person) => person.id !== id); }); }; return ( <section> <h3>prop drilling</h3> {/* pass props to the list elements */} <list people={people} removeperson={removeperson} /> </section> ); }; // middle component const list = ({ people, removeperson }) => { return ( <> {people.map((person) => { {/* pass props to the singleperson elements */} return ( <singleperson key={person.id} {...person} removeperson={removeperson} /> ); })} </> ); }; // inner component const singleperson = ({ id, name, removeperson }) => { return ( <div classname='item'> <h4>{name}</h4> <button onclick={() => removeperson(id)}>remove</button> </div> ); }; export default propdrilling; in these cases we can use the context api $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/Custom Hooks.html",
    "title": "Custom Hooks",
    "body": " index search search back custom hooks customs hooks allow us to avoid duplicating code that uses hooks and essentially in different places of your code. for example, the fetching function is very common, so we create a usefetch hook. when you define a custom hook, that is, if you define a function outside a component that uses hooks, you will have to name it use<functionname>, else you will get an error. import react, { usestate, useeffect } from 'react' // import custom hook import { usefetch } from './2-usefetch' const url = 'https://course-api.com/javascript-store-products' const example = () => { // values returned by usefetch const { loading, products } = usefetch(url) return ( <div> <h2>{loading ? 'loading...' : 'data'}</h2> </div> ) } export default example import { usestate, useeffect, usecallback } from 'react'; export const usefetch = (url) => { // state within the hook const [loading, setloading] = usestate(true); const [products, setproducts] = usestate([]); // functionality of the hook const getproducts = usecallback(async () => { const response = await fetch(url); const products = await response.json(); setproducts(products); setloading(false); }, [url]); // run whenever the url or the getproducts function changes useeffect(() => { getproducts(); }, [url, getproducts]); // values returned by the custom hook return { loading, products }; }; note we are using the hook usecallback (refer to performance optimization), we do this because we are specifying getproducts as a dependency for useeffect. however getproducts is created every time the state changes. so when we call useeffect, we change the state, and therefore create the function getproducts, which triggers useeffect, thus the state changes, and we create getproducts, and so on and so forth. to avoid this, we use usecallback, which will create the function whenever any of the dependencies in the list change. so this means, now getproducts is only created when the url changes. this allows us to avoid the infinite loop we ran into before. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/Performance Optimization.html",
    "title": "Performance Optimization",
    "body": " index search search back performance optimization even though react is fast by default (you do not need to use it), we can use different optimization techniques (mind, they do add their own cost): react.memo react.memo stores a component, and only re-renders if the props of the component change (it memoizes the component). in the next example, that means that we only re-render biglist if products change, thus, we do not re-render any singleproduct component unless products change. import react, { usestate, usecallback, usememo } from 'react' // custom hook import { usefetch } from 'usefetch' const url = 'https://course-api.com/javascript-store-products' const index = () => { const { products } = usefetch(url) const [count, setcount] = usestate(0) return ( <> <h1>count : {count}</h1> <button classname='btn' onclick={() => setcount(count + 1)}> click me </button> <biglist products={products} /> </> ) } // each time a prop or the state changes, the component re-renders, so all // the elements of the list are processed again. // however if we use react.memo we only re-render the component if products change const biglist = react.memo(({ products }) => { return ( <section classname='products'> {products.map((product) => { return ( <singleproduct key={product.id} {...product} ></singleproduct> ) })} </section> ) }) const singleproduct = ({ fields }) => { let { name, price } = fields price = price / 100 const image = fields.image[0].url return ( <article classname='product'> <img src={image} alt={name} /> <h4>{name}</h4> <p>${price}</p> </article> ) } export default index usecallback what happens if we pass a function to biglist, well if the state changes (whichever variable of the state) then the function is created again, and so the function is different. which means the props of biglist list changes, and causes react.memo to re-render the entire component. that is why we use usecallback. usecallback allows us to define when to create a function, by specifying the dependencies like we did with useeffect: if the dependency is []: then only create in the first render if there are variables in the []: create whenever those variables change if there is nothing: create always. refer to customs hooks for an use case of usecallback inside the custom hook usefetch. import react, { usestate, usecallback, usememo } from 'react' // custom hook import { usefetch } from 'usefetch' const url = 'https://course-api.com/javascript-store-products' const index = () => { const { products } = usefetch(url); const [count, setcount] = usestate(0); const [cart, setcart] = usestate(0); // we only create this function when we update the cart value // that is we memoize the function const addtocart = usecallback(() => { setcart(cart + 1) }, [cart]) return ( <> <h1>count : {count}</h1> <button classname='btn' onclick={() => setcount(count + 1)}> click me </button> <biglist products={products} addtocart={addtocart}/> </> ) } // each time a prop or the state changes, the component re-renders. because now // addtocart is define with usecallback, the re-render is not triggered const biglist = react.memo(({ products, addtocart }) => { return ( <section classname='products'> {products.map((product) => { return ( <singleproduct key={product.id} {...product} addtocart={addtocart} ></singleproduct> ) })} </section> ) }) const singleproduct = ({ fields, addtocart }) => { let { name, price } = fields price = price / 100 const image = fields.image[0].url return ( <article classname='product'> <img src={image} alt={name} /> <h4>{name}</h4> <p>${price}</p> <button onclick={addtocart}>add to cart</button> </article> ) } export default index; usememo note that this hook deals with values (which is the traditional functionality of the idea of memoizing), whilst react.memo look for changes in the props. in the next example we create a function that returns a value, and we memoize the function, so it only computes the value whenever the products change (the argument of the function), else it returns the value stored before: import react, { usestate, usecallback, usememo } from 'react' // custom hook import { usefetch } from 'usefetch' const url = 'https://course-api.com/javascript-store-products' // define the function we are going to memoize const calculatemostexpensive = (data) => { return ( data.reduce((total, item) => { const price = item.fields.price if (price >= total) { total = price } return total }, 0) / 100 ) } const index = () => { const { products } = usefetch(url); const [count, setcount] = usestate(0); const [cart, setcart] = usestate(0); const addtocart = usecallback(() => { setcart(cart + 1) }, [cart]) // memoize the function with usememo const mostexpensive = usememo(() => calculatemostexpensive(products), [ products, ]) return ( <> <h1>count : {count}</h1> <button classname='btn' onclick={() => setcount(count + 1)}> click me </button> <!-- show most expensive product --> <h1>most expensive : ${mostexpensive}</h1> <biglist products={products} addtocart={addtocart}/> </> ) } const biglist = react.memo(({ products, addtocart }) => { return ( <section classname='products'> {products.map((product) => { return ( <singleproduct key={product.id} {...product} addtocart={addtocart} ></singleproduct> ) })} </section> ) }) const singleproduct = ({ fields, addtocart }) => { let { name, price } = fields price = price / 100 const image = fields.image[0].url return ( <article classname='product'> <img src={image} alt={name} /> <h4>{name}</h4> <p>${price}</p> <button onclick={addtocart}>add to cart</button> </article> ) } export default index; $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/Basics.html",
    "title": "Basics",
    "body": " index search search back basics redux is a complex state management tool, with a single store (javascrip object) as a cds (central data storage). components store: object that holds the state reducers: events handler that manages the state and returns the new updated state. the reducers get the arguments and return the state modified. actions: describe the event handler by the reducer and has two properties: type: is the identifier of the action payload: holds the data dispatch: is used to send actions to update the data so redux is composed by: handle an action the process of handling an action is the following: we create an action object and dispatch it: the store forwards the action to the reducer: the reducer updates the state and returns it the store notifies the ui components of the change of the state install redux $ npm install redux react-redux first steps inside src create a store folder inside the store folder create an index.js that holds all of the react states in this file $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/Children in Props.html",
    "title": "Children in Props",
    "body": " index search search back children in props you can nest content inside your component. if we have the following: import react from 'react'; import reactdom from 'react-dom'; // css import './index.css'; import book from './book' const singlebook = { title: 'book title', author: 'book author' } reactdom.render( <book {...singlebook}> <p> i am nested!</p> </book>, document.getelementbyid('root') ); you can access the nested object from your component: import react from 'react' // de-structure the children prop const book = ({ title, author, children }) => { return ( <article classname='book'> <h1>{title}</h1> <h4>{author}</h4> {children} </article> ); }; export default book $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/PropTypes.html",
    "title": "PropTypes",
    "body": " index search search back proptypes proptypes allows us to validate our props. import react from 'react' import product from './product' import { usefetch } from './usefetch' const url = 'https://course-api.com/react-prop-types-example' const index = () => { const { products } = usefetch(url) return ( <div> <h2>products</h2> <section classname='products'> {products.map((product) => { // pass the props return <product key={product.id} {...product} /> })} </section> </div> ) } export default index in this product component we show how to use proptypes to parametrize the props, and how to use conditional render to avoid getting an error when some of the props are missing. import react from 'react'; import proptypes from 'prop-types'; import defaultimage from './assets/default-image.jpeg'; const product = ({ image, name, price }) => { const url = image && image.url; return ( <article classname='product'> {/*use conditional rendering in case the data does not exist */} <img src={url || defaultimage} alt={name || 'default name'} /> <h4>{name}</h4> <p>${price || 3.99}</p> </article> ); }; // define the proptypes for the object product.proptypes = { image: proptypes.object.isrequired, name: proptypes.string.isrequired, price: proptypes.number.isrequired, }; export default product; default props in this other product component, we show how to use defaultprops instead of conditional rendering. import react from 'react'; import proptypes from 'prop-types'; import defaultimage from './assets/default-image.jpeg'; const product = ({ image, name, price }) => { return ( <article classname='product'> {/*use conditional rendering in case the data does not exist */} <img src={image.url} alt={name} /> <h4>{name}</h4> <p>${price}</p> </article> ); }; // define the proptypes for the object product.proptypes = { image: proptypes.object.isrequired, name: proptypes.string.isrequired, price: proptypes.number.isrequired, }; product.defaultprops = { name: 'default name', price: 3.99, image: defaultimage, }; export default product; $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/useState.html",
    "title": "useState",
    "body": " index search search back usestate error in the next piece of code we show how, if we change the value of a variable in react, it does not change in our web app because it is not re-rendered: import react from 'react'; const errorexample = () => { let title = 'random title'; const handleclick = () => { title = 'hello people'; console.log(title); }; return ( <react.fragment> <h2>{title}</h2> <button type='button' onclick={handleclick}> change title </button> </react.fragment> ); }; export default errorexample; that is why we will need to use the hook usestate, so we change handle state changes. import react, { usestate } from 'react'; const usestatebasics = () => { const [text, settext] = usestate('random title'); const handleclick = () => { if (text === 'random title') { settext('hello world'); } else { settext('random title'); } }; return ( <react.fragment> <h1>{text}</h1> <button type='button' onclick={handleclick}> change title </button> </react.fragment> ); }; export default usestatebasics; when we invoke usestate we have to pass as an argument the initial value of the state variable. usestate is a function that returns an array: the first element: the state variable the second element: the handler that controls the value of the state value when using usestate with objects, whenever you update one property of the object, you have to pass the object to the handler (with the spread operator), and then override the property you want to update: import react, { usestate } from 'react'; const usestateobject = () => { // object const [person, setperson] = usestate({ name: 'peter', age: 24, message: 'random message', }); const changemessage = () => { // pass the person object with the spread operator // and override the message property setperson({ ...person, message: 'hello world' }); }; return ( <> <h3>{person.name}</h3> <h3>{person.age}</h3> <h4>{person.message}</h4> <button classname='btn' onclick={changemessage}> change message </button> </> ); }; export default usestateobject; asynchronous functions if we want to update a value asynchronally, and fetch the value of the state variable when the change happens, and not when the function is defined, then: import react, { usestate } from 'react'; const usestatecounter = () => { const [value, setvalue] = usestate(0); const reset = () => { setvalue(0); }; const complexincrease = () => { settimeout(() => { // value is the value of the state variable when the timeout is defined // if you call it multiple times consecutively you get the same value, because they all get value = 0 // setvalue(value + 1); // prevstate is the value of the state variable when the timeout finished // if you call it multiple times consecutively you get different values, because value has already been updated // by another settimeout. // if you call it multiple times setvalue((prevstate) => { return prevstate + 1; }); }, 2000); }; return ( <> <section style={{ margin: '4rem 0' }}> <h2>more complex counter</h2> <h1>{value}</h1> <button classname='btn' onclick={complexincrease}> increase later </button> </section> </> ); }; export default usestatecounter; $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/Dispatch.html",
    "title": "Dispatch",
    "body": " index search search back dispatch in order to dispatch actions in our reducers we do as follows: import react from \"react\"; // get dispatch hook import { usedispatch } from \"react-redux\"; // get actions import { login, logout } from \"../features/user\"; function login() { // initialize dispatch hook const dispatch = usedispatch(); return ( <div> <button onclick={() => { // dispatch login action dispatch(login({ name: \"pedro\", age: 20, email: \"pedro@gmail.com\" })); }} > login </button> <button onclick={() => { // dispatch logout action dispatch(logout()); }} > logout </button> </div> ); } export default login; $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/index.html",
    "title": "React",
    "body": " index search search back react basic react npm create-react-app babel file structure start in indexjs jsx rules css in jsx props children in props list of components event basics advanced react properties hooks usestate useeffect conditional rendering controlled inputs useref usereducer prop drilling context api custom hooks proptypes react router performance optimization redux basics index reducers and actions get state dispatch $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/List of components.html",
    "title": "List of Components",
    "body": " index search search back list of components react has one restriction for list of objects, and that is: they have to have a key. so, for example: import react from 'react'; import reactdom from 'react-dom'; // css import './index.css'; import book from './book' // data to create book object const books = [ { id: '1', title: 'book title', author: 'book author' }, { id: '2', title: 'book title', author: 'book author' }, ] const booklist = books.map((book) => { // de-structure book object return <book key={book.id} {...book} />; }) reactdom.render( <div> booklist </div>, document.getelementbyid('root') ); $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/React Router.html",
    "title": "React Router",
    "body": " index search search back react router in react routing behaves differently than in traditional html applications: it does not fetch the html page from the server, it is done in the client side. there is no re-rendering even though we change the url. here we have an example: import react from 'react'; // react router import { browserrouter as router, route, switch } from 'react-router-dom'; // pages import home from './home'; import about from './about'; import people from './people'; import error from './error'; import person from './person'; // navbar import navbar from './navbar'; const reactroutersetup = () => { return ( <router> <navbar /> <!-- with the switch component only the first one that matches is displayed --> <switch> <!-- match the path exactly, else this will be rendered always along the other components --> <route exact path='/'> <!-- component to display --> <home /> </route> <!-- match the path --> <route path='/about'> <about /> </route> <!-- match the path --> <route path='/people'> <people /> </route> <!-- match the path and pass id as a parameter --> <!-- specify children property because it will be a list of components --> <route path='/person/:id' children={<person />}></route> <!-- match any path (this is only displayed when the other paths do not match if we use the switch component)--> <route path='*'> <error /> </route> </switch> </router> ); }; export default reactroutersetup; links how do we navigate through our application, well by using links. so, for example, in the navbar: import react from 'react'; import { link } from 'react-router-dom'; const navbar = () => { return ( <nav> <ul> <li> <!-- specify the path --> <link to='/'>home</link> </li> <li> <!-- specify the path --> <link to='/about'>about</link> </li> <li> <!-- specify the path --> <link to='/people'>people</link> </li> </ul> </nav> ); }; export default navbar; to pass a parameter to the link we can do the following: import react, { usestate } from 'react'; import { data } from '../../../data'; import { link } from 'react-router-dom'; const people = () => { // list of people const [people, setpeople] = usestate(data); return ( <div> <h1>people page</h1> {people.map((person) => { return ( <div key={person.id} classname='item'> <h4>{person.name}</h4> <!-- specify the path and pass the id of the current person as a parameter --> <link to={`/person/${person.id}`}>learn more</link> </div> ); })} </div> ); }; export default people; now in the person component, we can fetch the parameter: import react, { usestate, useeffect } from 'react'; import { data } from '../../../data'; import { link, useparams } from 'react-router-dom'; const person = () => { // state const [name, setname] = usestate('default name'); // useparams hook to fetch the parameter // the name of the parameter (id), is specified in the \"route\" component // in our case the path to person was: /person/:id const { id } = useparams(); useeffect(() => { const newperson = data.find((person) => person.id === parseint(id)); setname(newperson.name); }, []); return ( <div> <h1>{name}</h1> <!-- go to the previous page of the list of people --> <link to='/people' classname='btn'> back to people </link> </div> ); }; export default person; $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/JSX Rules.html",
    "title": "JSX Rules",
    "body": " index search search back jsx rules always return something always return a single element or div, section, article or react.fragment (does not create a div) enclosing the element use camelcase for html attribute use classname instead of class close every element $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/File Structure.html",
    "title": "File Structure",
    "body": " index search search back file structure node_modules: folder that contains all of the dependencies package.json: is the manifest file for the project scripts start: runs the development server build: creates a production version for the project inside a folder called build, where the optimized files resulting of the build are stored. the rest of the files created by create-react-app are mostly useless: app.js app.css app.test.js logo.svg serviceworker.js setuptests.js also all of the contents of index.js can be removed. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/CSS in JSX.html",
    "title": "CSS in JSX",
    "body": " index search search back css in jsx we can define the style inside jsx, for that we use the prop style. the first curly braces takes us back to javascript, and the second are to specify the creation of an object. also note that we do not write font-size but we use the react convention of writing fontsize const author = () => ( <h4 style={{fontsize: '1px'}}> test </h4> ); this level has higher preference (overrides) than the css imported from a css file. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/create-react-app.html",
    "title": "create-react-app",
    "body": " index search search back create-react-app you do not need create-react-app to create a react app, but it makes it way easier: npx create-react-app <app-name> cd <app-name> npm start $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/useRef.html",
    "title": "useRef",
    "body": " index search search back useref useref returns a mutable ref object whose .current property is initialized to the passed argument. some properties: preserves the value of the object does not trigger re-render assigned to dom nodes/elements import react, { useeffect, useref } from 'react'; const userefbasics = () => { // create the container const refcontainer = useref(null); const handlesubmit = (e) => { e.preventdefault(); // print the value inside the input console.log(refcontainer.current.value); }; useeffect(() => { // focus on the input element whenever we render the application refcontainer.current.focus(); }); return ( <> <form classname='form' onsubmit={handlesubmit}> <div> {/*the refcontainer points to the input element*/} <input type='text' ref={refcontainer} /> </div> <button type='submit'>submit</button> </form> </> ); }; export default userefbasics; $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/Index.html",
    "title": "Index file",
    "body": " index search search back index file in the following piece of code we create our store object, where we are going to save the state of our application. as you may note, in this store there are three slices defined. that is because we differentiate three different states (slices). so our store is defined as: { user: {...} theme: {...} } import { configurestore } from \"@reduxjs/toolkit\"; // different slices import userslice from \"./features/userslice.js\"; import themeslice from \"./features/themeslice.js\"; // create store const store = configurestore({ reducer: { // in each case obtain the reducer user: userslice.reducer, theme: themeslice.reducer, }, }); export default store; now, we have to wrap our application with our store: import react from \"react\"; import reactdom from \"react-dom\"; import app from \"./app\"; // import our store as a provider import { provider } from \"react-redux\"; import store from \"./store\"; reactdom.render( <react.strictmode> <provider store={store}> <app /> </provider> </react.strictmode>, document.getelementbyid(\"root\") ); $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/useEffect.html",
    "title": "useEffect",
    "body": " index search search back useeffect this hook is used for any work needed to be made outside of the component: fetch data, changing the document title, signing up for a subscription, setting up an event listener. runs after every re-render cleanup function second parameter import react, { usestate, useeffect } from 'react'; const useeffectbasics = () => { // callback called whenever the component is rendered useeffect(() => { document.title = `new messages(${value})`; }); return ( <> <h1>{value}</h1> <button classname='btn'}> click me </button> </> ); }; export default useeffectbasics; dependencies the useeffect definition allows you to pass an array of dependencies: if it is specified as []: useeffect will only be triggered in the first render if it is an array of state variables: it will be triggered every time the state variable is updated. import react, { usestate, useeffect } from 'react'; const useeffectbasics = () => { const [value, setvalue] = usestate(0); // only trigger on first render // useeffect(() => { // document.title = `new messages(${value})`; // }, []); // call whenever value is updated useeffect(() => { document.title = `new messages(${value})`; }, [value]); return ( <> <h1>{value}</h1> <button classname='btn'}> click me </button> </> ); }; export default useeffectbasics; clean up function useeffect lets us define a function that is invoked once we exit the function: import react, { usestate, useeffect } from 'react'; const useeffectcleanup = () => { const [size, setsize] = usestate(window.innerwidth); const checksize = () => { setsize(window.innerwidth); }; useeffect(() => { console.log('useeffect'); window.addeventlistener('resize', checksize); // clean up function return () => { console.log('cleanup'); window.removeeventlistener('resize', checksize); }; }, []); console.log('render'); return ( <> <h1>window</h1> <h2>{size} px</h2> </> ); }; export default useeffectcleanup; fetch data up next we will show how to get data using useeffect. note, if we do not specify the restriction of only triggering on the first render: useeffect calls getusers getusers updates the state, and so the component re-renders because there is a re-render, useeffect is called again thus, we end in an infinite loop import react, { usestate, useeffect } from 'react'; const url = 'https://api.github.com/users'; const useeffectfetchdata = () => { const [users, setusers] = usestate([]); const getusers = async () => { const response = await fetch(url); const users = await response.json(); setusers(users); }; useeffect(() => { getusers(); // specify [] so we only run useeffect on the first render. }, []); return ( <> <h3>github users</h3> <ul classname='users'> {users.map((user) => { const { id, login, avatar_url, html_url } = user; return ( <li key={id}> <img src={avatar_url} alt={login} /> <div> <h4>{login}</h4> <a href={html_url}>profile</a> </div> </li> ); })} </ul> </> ); }; export default useeffectfetchdata; $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/Conditional Rendering.html",
    "title": "Conditional Rendering",
    "body": " index search search back conditional rendering in the following example we show how we can have react display different elements conditionally: import react, { usestate, useeffect } from 'react'; const url = 'https://api.github.com/users/quincylarson'; const multiplereturns = () => { const [isloading, setisloading] = usestate(true); const [iserror, setiserror] = usestate(false); const [user, setuser] = usestate('default user'); // fetch data useeffect(() => { fetch(url) .then((resp) => { if (resp.status >= 200 && resp.status <= 299) { return resp.json(); } else { // update the control state variables setisloading(false); setiserror(true); throw new error(resp.statustext); } }) .then((user) => { const { login } = user; setuser(login); // update the control state variables setisloading(false); }) .catch((error) => console.log(error)); }, []); // different display depending on the state of the get if (isloading) { return ( <div> <h1>loading...</h1> </div> ); } if (iserror) { return ( <div> <h1>error....</h1> </div> ); } return ( <div> <h1>{user}</h1> </div> ); }; export default multiplereturns; short circuit evlauation now, let's see an example of short circuit evaluation in action: import react, { usestate } from 'react'; const shortcircuit = () => { const [text, settext] = usestate(''); const [iserror, setiserror] = usestate(false); // if text is falsy, then return 'hello world' // else return text // const firstvalue = text || 'hello world'; // if text is true, then return 'hello world' // else return text // const secondvalue = text && 'hello world'; return ( <> {/*if text is false, return h1 with 'john doe value'*/} <h1>{text || 'john doe'}</h1> {/*if text is true, return h1 with 'john doe value'*/} {text && <h1>'john doe'</h1>} </> ); }; export default shortcircuit; ternary operators we can also use ternary operators to render conditionally in react. import react, { usestate } from 'react'; const shortcircuit = () => { const [iserror, setiserror] = usestate(false); return ( <> <button classname='btn' onclick={() => setiserror(!iserror)}> toggle error </button> {/*check the value of iserror, if is error is true, return the first value after the ? else return the second value*/} {iserror ? ( <p>there is an error...</p> ) : ( <div> <h2>there is no error</h2> </div> )} </> ); }; export default shortcircuit; $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/Context API.html",
    "title": "Context API",
    "body": " index search search back context api context api and usecontext allows us to resolve the issue of the prop drilling. the context has two components: the provider: works as a distributer the consumer we use them as follows: import react, { usestate, usecontext } from 'react'; import { data } from '../../../data'; // create context object const personcontext = react.createcontext(); const contextapi = () => { // state saved in the context const [people, setpeople] = usestate(data); // event handler saved in the context const removeperson = (id) => { setpeople((people) => { return people.filter((person) => person.id !== id); }); }; return ( {/*wrap the components in the context provider, so all the nested components have access to the variables defined in the context object*/} <personcontext.provider value={{ removeperson, people }}> <h3>context api / usecontext</h3> <list /> </personcontext.provider> ); }; const list = () => { // obtain data from the context with the usecontext hook const maindata = usecontext(personcontext); return ( <> {maindata.people.map((person) => { return <singleperson key={person.id} {...person} />; })} </> ); }; const singleperson = ({ id, name }) => { // obtain data from the context with the usecontext hook const { removeperson } = usecontext(personcontext); return ( <div classname='item'> <h4>{name}</h4> <button onclick={() => removeperson(id)}>remove</button> </div> ); }; export default contextapi; $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/Start in indexjs.html",
    "title": "Start in index.js",
    "body": " index search search back start in index.js keep in mind, index.js is the entry point: first of all refer to file structure, and then basically remove everything from index.js, and replace it for: import react from 'react'; import reactdom from 'react-dom'; // css import './index.css'; we use the reactdom module to make use of the react dom api, which let's us render components, etc. next we call reactdom.render() to output our html: import react from 'react'; import reactdom from 'react-dom'; // css import './index.css'; function component() { return ( <h4> hi! </h4> ); } reactdom.render( <component/>, document.getelementbyid(\"root\") ) note the function must start with a capital letter the tag that encloses the component must be closed, so either: <component/> or <component></ component> we use document.getelementbyid(\"root\"), this tells react where to place the component inside the html $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/Babel.html",
    "title": "Babel",
    "body": " index search search back babel babel is a javascript compiler that converts es7, es6 to e5 so it can run smoothly in older browsers. this way we can use new features of es7 and es6 while maintaining compatibility. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/Props.html",
    "title": "Props",
    "body": " index search search back props in react to define parameters in our components, we do as follows: import react from 'react' // this are the props const book = (props) => { return ( <article classname='book'> <img src={props.img} alt='' /> <h1>{props.title}</h1> <h4>{props.author}</h4> </article> ); }; export default book another way (more readable), is to spread the object: import react from 'react' // this are the props const book = ({ title, author }) => { return ( <article classname='book'> <h1>{title}</h1> <h4>{author}</h4> </article> ); }; export default book now, to pass these props we do: import react from 'react'; import reactdom from 'react-dom'; // css import './index.css'; import book from './book' reactdom.render( <book title='book title' author='book author'/>, document.getelementbyid('root') ); spread operator let's define an object singlebook that contains all of the book's properties and pass it to the book component: import react from 'react'; import reactdom from 'react-dom'; // css import './index.css'; import book from './book' const singlebook = { title: 'book title', author: 'book author' } reactdom.render( // use the spread operator <book {...singlebook}/>, document.getelementbyid('root') ); $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/React/Properties Hooks.html",
    "title": "Properties of Hooks",
    "body": " index search search back properties of hooks all the hooks have the following properties: they start with the word use the component where they are created must be named in uppercase they cannot be invoked inside a function/component body. you cannot call hooks conditionally $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/index.html",
    "title": "Web Development",
    "body": " index search search back web development front react back node.js django spring technologies docker graphql db mongodb $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/MongoDB/commands.html",
    "title": "MongoDB Commands",
    "body": " index search search back mongodb commands to log into mongodb with the created user and database: $ mongo -u <your username> -p <your password> \\\\ --authenticationdatabase <your database name> or $ mongo -u <your username> \\\\ --authenticationdatabase <your database name> to connect to the database use the following uri: mongodb://yourusername:yourpasswordhere@127.0.0.1:27017/your-database-name $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/MongoDB/index.html",
    "title": "MongoDB",
    "body": " index search search back mongodb mongodb commands $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Django/django_notes.html",
    "title": "Django Notes",
    "body": " index search search back django notes in this section we lay out some concepts about the django framework. apps models the models can be thought of as objects, in the sense of oop, that have certain attributes. this objects are then mapped by django to the database of choice. to define new models, or modify existing model (e.g. the user model) you need to modify the models.py file in the root folder of every app that is created. alternatively, you can centralize all of your models on the core app. an example of a simple model is the following tag model: class tag(models.model): \"\"\"tag to be used for a book\"\"\" # define the attributes of the table name = models.charfield(max_length=255) # define the relation between the tag and the user user = models.foreignkey( settings.auth_user_model, on_delete=models.cascade, ) # define the string representation of the tag def __str__(self): return self.name once the model is define, it needs to be registered on the admin.py file: admin.site.register(models.tag) specifically when modifying existing models, you will need to extend the classes defined by django (e.g. abstractbaseuser, useradmin). for example: class user(abstractbaseuser, permissionsmixin): \"\"\"custom user model that suppors using email instead of username\"\"\" email = models.emailfield(max_length=255, unique=true) name = models.charfield(max_length=255) is_active = models.booleanfield(default=true) is_staff = models.booleanfield(default=false) objects = usermanager() which has to be registered as follows: admin.site.register(models.user, useradmin) where useradmin is a class define in the admin.py file, that defines the custom user model: class useradmin(baseuseradmin): ordering = ['id'] list_display = ['email', 'name'] # user edit page fields fieldsets = ( (none, {'fields': ('email', 'password')}), (_('personal info'), {'fields': ('name',)}), ( _('permissions'), {'fields': ('is_active', 'is_staff', 'is_superuser')} ), (_('important dates'), {'fields': ('last_login',)}) ) # user create page fields add_fieldsets = ( (none, { 'classes': ('wide',), 'fields': ('email', 'password', 'password2') }), admin this is the feature that allows you to manage your models, let it be create them, modify them or delete them. the functionality of the admin model is defined within the admin.py file on the root folder of every app that is created. in order to create a superuser execute the following command: $ python manage.py createsuperuser on docker: $ docker-compose run app sh -c \"python manage.py createsuperuser\" then, you will be prompted to enter an email and a password. once you have filled said fields, you can start the server with $ docker-compose up and enter to the admin page located on 127.0.0.1:8000/admin, where you can log in with your credentials. urls django allows us to define relative urls on a very modular way. first off, we have the core file when it comes to url definition: app/app/urls.py. here we may have something like this: from django.contrib import admin from django.urls import path, include urlpatterns = [ path('admin/', admin.site.urls), path('api/user/', include('user.urls')), ] this example shows that the urlpatterns variable is a list that holds all of the urls defined in our project. the modularization comes from the way the urls defined on the user’s app are specified. first we specify the endpoint for these urls (namely api/user/), and then we pull all the relative urls from the user’s app, defined on the file app/user/urls.py. which are then concatenated with api/user/. the urls defined on the user app are as follows: app_name = 'user' urlpatterns = [ path('create/', views.createuserview.as_view(), name='create'), ] this the can be used like this: # create user api endpoint dinamically create_user_url = reverse('user:create') serializers this files are defined to specify how to serialize (map to the database) the json objects received, in our case, from http requests. for that we create, for each model, a class that extends serializers.modelserializer. in this class we define an inner class called meta that tells the framework which fields does the object have and so allows the mapping to take place. you can also add extra arguments to this inner class, for example to restrict or exercise a stronger control on the fields. next on, we have a simple example of our user model serializer: from django.contrib.auth import get_user_model from rest_framework import serializers class userserializer(serializers.modelserializer): \"\"\"serializer for the users object\"\"\" class meta: \"\"\"info about how to serialize the user model\"\"\" model = get_user_model() fields = ('email', 'password', 'name') # extra requirements for the user model extra_kwargs = {'password': {'write_only': true, 'min_length': 5}} def create(self, validated_data): \"\"\"create a new user with encrypted password and return it\"\"\" # validation_data: json data passed in the http post return get_user_model().objects.create_user(**validated_data) we can also serialize an object that is not related to a model per se, for example: class authtokenserializer(serializers.serializer): \"\"\"serializer for the user authentication object\"\"\" email = serializers.charfield() password = serializers.charfield( style={'input_type': 'password'}, trim_whitespace=false ) views this is, on simple terms, a python function that takes a web request and returns a web response. in our case, we will mostly use views for our api, so we use pre-make view that allows us to easily make an api that creates, updates, etc an object on the database using the serializer that we specify, for example, the api for creating a user is as follows: class createuserview(generics.createapiview): \"\"\"create a new user in the system\"\"\" serializer_class = userserializer in case of wanting to update an object we extend generics.retrieveupdateapiview instead of generics.createapiview. because this view is private, we need to indicate an authentication mechanism and the level of permissions the user has, in our case the authentication is made via token and the permissions are that the user needs to be logged in. class manageuserview(generics.retrieveupdateapiview): \"\"\"manage the authenticated user\"\"\" serializer_class = userserializer # authentication mechanism by which the authentication happens authentication_classes = (authentication.tokenauthentication,) permission_classes = (permissions.isauthenticated,) def get_object(self): \"\"\"retrieve and return authentication user\"\"\" return self.request.user actions start the server observe that this is executed on the docker-compose configuration file $ python manage.py runserver 0.0.0.0:8000 sync django settings (app/app/settings.py) $ python manage.py migrate on docker: $ docker-compose run app sh -c \"python manage.py migrate\" sync changes made on models $ docker-compose run app sh -c \"python manage.py migrate\" on docker: $ docker-compose run app sh -c \"python manage.py makemigrations\" you can also specify the name off the app that contains the model $ python manage.py makemigrations app_name $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Django/index.html",
    "title": "Django",
    "body": " index search search back django django notes $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/GraphQL/relationships.html",
    "title": "Relationships",
    "body": " index search search back relationships one to many we are now going to illustrate the situation where an animal belongs to only one category whilst a category contains several animals: type animal { id: id! category: category! name: string! parameter: string! } type category { id: id! name: string! animals: [animal!]! parameter: string! } where we have stored in our database the id of the category as a foreign key of the animal entity. in order to query for animals from a category we create a new resolver: const resolvers = { query: { animals: () => animals, animal: (parent, args, ctx) => { let animal = animals.find((animal) => { return animal.paramenter === args.id }) return animal } } category: { animals: (parent, args, ctx) => { return animals.filter((animal) >= { return animal.category == parent.id }) } } } so if we query for: { category(parameter: \"mammal\"){ category animals { name } } } we get all the names of the animals that are mammals. the parent object symbolizes the object resulting from category(parameter: \"mammal\"), this object will be a category object and will have an id, that we will use in our resolver to filter the animals. observe that the animals have a attribute called category, which is *not* the same as the type definition we have made for our animal object, this attribute is defined on the database. note that we have created a category resolver that acts as the query resolver but for queries within the category object. we, now, do the same for the animals, meaning we want to get the category object that we specified in the animal object, for that we create a new resolver: animal: { category: (parent, args, ctx) => { return categories.find((category) => { return category.id === parent.category }) } } so what we do is go through all of the categories until we find the one that has the same id. { animal(parameter: \"cat\"){ name category { name } } and with this query we retrieve the name and the category name of a cat. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/GraphQL/updating.html",
    "title": "Mutations",
    "body": " index search search back mutations in order to update, delete or add new data using graphql we use mutations. typedef we create the type definition for the mutation object (which is reserved in graphql to modify/add data, much like the query object). in it, we define all the modifying functions we want, along with the data that must be provided to execute the modification, and also the type of object that is returned. type mutation { addanimal( name: string! description: [string!]! parameter: string! category: string! ): animal removeanimal(id: id!): boolean! } with this we have defined the addanimal method, which creates and animal by specifying the name, description, url parameter and the category. this function will return an animal object. we have also defined the removeanimal method, that only takes an id as a parameter and returns a boolean. resolvers we now define the logic behind both of these methods, so we create a mutation.js file as follows: const { v4 } = require(\"uuid\") const mutation = { addanimal: (parent, { name, description, parameter, category }, { animals }) => { let newanimal = { id: v4(), name, description, parameter, category, } // only because this is an object: here we would create in the database animals.push(newanimal) return newanimal }, removeanimal: (parent, { id }, { animals }) => { // here we would delete in the database let index = animals.findindex((animal) => { return animal.id === id }); animals.splice(index, 1); return true } } module.exports = mutation note that we de-structure the parameters from the args object for readability sake. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/GraphQL/file_structure.html",
    "title": "File Structure",
    "body": " index search search back file structure what is best practice is to separate the type definitions and the resolvers: typedefs: stored in schema.js for example. resolvers: stored in a folder called resolvers, and then for each resolver we create a file, for example for the query resolver: const category = { animals: (parent, args, { animals }) => { return animals.filter(animal => { return animal.category === parent.id }) } } module.exports = category then we create an index.js inside the resolvers folder where we can import and export all of our resolvers together: const query = require('./query') const category = require('./category') const animal = require('./animal') module.exports = { query, category, animal } and we put everything together in our index.js inside the root folder: const { apolloserver } = require('apollo-server'); const { maincards, animals, categories } = require('./db') const typedefs = require('./schema') const { query, category, animal } = require('./resolvers/index') const server = new apolloserver({ typedefs, resolvers: { query, animal, category }, context: { maincards, animals, categories } }); // the `listen` method launches a web server. server.listen().then(({ url }) => { console.log(`🚀 server ready at ${url}`); }); we now use the context object in order to make our \"database\" available to all of the resolvers through ctx. (note that we de-structure the object to the get animal object). $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/GraphQL/terminology.html",
    "title": "Terminology",
    "body": " index search search back terminology schema it defines the data associated with an entity: type person { id: id! name: string! email: string! age: int! phone: string gender: boolean! } that is to say, it defines the type definitions of the data that conforms a given entity. resolver the data that we get back is dependent on the resolvers. they are functions that return data that follow a certain schema, it does not need to follow the schema, but then when querying it, it may throw and error. people(parent, args, ctx, info){ return[ { id: \"1\", name: \"laith\", email: \"email@email.com\", age: 23, phone: \"623198135\", gender: true } ] } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/GraphQL/fetch.html",
    "title": "Fetch Data",
    "body": " index search search back fetch data you can start requesting data with usequery. usequery is a react hook that shares graphql data with your ui. so for example to fetch the image and the title of the cards: import { usequery, gql } from '@apollo/client' const fetch_data = gql` { maincards { image title } } ` function mainhero(){ const maindata = usequery(fetch_data) return(<div></div>) } where maincards is one of our resolvers, and we specify that we want to select the image and the title. so now, we can de-structure the different attributes offered by the apolloprovider, namely loading, error and data. and therefore control the flow of our application by using them. import { usequery, gql } from '@apollo/client' const fetch_data = gql` { maincards { image title } } ` function mainhero(){ const { loading, error, data } = usequery(fetch_data) return(<div></div>) } variables in order to make a query by passing parameters we do: const animal_query = gql` query($slug: string!){ animal(slug: $slug){ title image stock description price } } ` where $string is the variable we want to pass in, and we specify its type and the fact that it is required with string!. now to make the query we do: function animalpage() { const { slug } = useparameters() const { loading, data, error } = usequery( variables: { slug: 'cat' } ) } with variables we pass in all of the parameters needed in the query. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/GraphQL/index.html",
    "title": "GraphQL",
    "body": " index search search back graphql backend intro terminoligy graphql server queries, typedefs and resolvers relationships file structure mutations frontend graphql client fetch data mutations $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/GraphQL/intro.html",
    "title": "Intro",
    "body": " index search search back intro graphql is a query language used to communicate to our api and query for data. difference with apis whenever we use rest apis and we hit specific endpoints, more often than not, we are going to retrieve some data that we have no use for. this is what is called overfetching. for example when you access https://my-rest-api/animals you get an object with a list of animal objects, and you may not need all of the information of every animal. graphql solves this problem by: only having one endpoint. from this endpoint we use the graph query language to select whatever data that we want. for example, to retrieve the same information stated above: query{ animals{ title ratings img price } } which gets only the specified attributes for each animal. graphql also solves underfetching, which is the situation where you cannot get enough data with a call to only one endpoint, forcing you to call a second endpoint. for example, if you want information about the animals and the categories you have to access https://my-rest-api/animals, and https://my-rest-api/categories, however with graphql: query{ animals{ title ratings img price } categories{ id title img } } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/GraphQL/mutations_client.html",
    "title": "Mutations",
    "body": " index search search back mutations in order to execute a mutation from the client side we create a mutation request: const add_animal_mutation = gql` mutation( $name: string!, $description: [string!] $parameter: string!, $category: string! ) { addanimal( name: $name, description: $description, parameter: $parameter, category: $category ) } ` and now we use the usemutation hook to obtain the function that will be called in order to update our animal: import { usemutation, gql } from '@apollo/client' function animal(){ const [addanimal] = usemutation(add_animal_mutation) return( <div> <button onclick={() => addanimal({ variables: { name: 'cat', description: ['this is a description'], parameter: 'cat', category: 'mammal' } } )}/> </div> ) } with this we get the function addanimal with the usemutation hook and we use it in our button, so when it is clicked we add a cat to our animal collection. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/GraphQL/client.html",
    "title": "Client",
    "body": " index search search back client as well as with the server there are several clients for graphql within different languages and frameworks, visit the official page to check them out. we are going to use apollo client so for that we need to install apollo and graphql on the client side of our application: $ npm install @apollo/client graphql in our case we are going to connect our client to react (reference). so, first we import the necessary modules. import react from 'react'; import { render } from 'react-dom'; import { apolloclient, inmemorycache, apolloprovider, usequery, gql } from \"@apollo/client\"; const client = new apolloclient({ uri: 'http://localhost:4000', cache: new inmemorycache() }); function app() { return ( <div> <h2>my first apollo app 🚀</h2> </div> ); } render( <apolloprovider client={client}> <app /> </apolloprovider>, document.getelementbyid('root'), ); we tell apollo that our graphql server is listening for request on our localhost on the port 4000. where apollo allows us to cache our queries, with the inmemorycache module. that way we do not need to make the same request twice, because the data is cached in memory. and then, we wrap our app with the apolloprovider, so all of our components have access to our client. note that we pass our client as a prop. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/GraphQL/server.html",
    "title": "GraphQL Server",
    "body": " index search search back graphql server graphql supports several languages, and has several servers that do mainly the same. consult the official page for the one that suits your needs. we are going to use apollo-server to demonstrate how to use graphql in a node.js application: so, first, we install the apollo-server along with graphql dependency with npm: $ npm install apollo-server graphql now we use graphql to define our type definitions: const { apolloserver, gql } = require('apollo-server'); const typedefs = gql` type book { title: string author: string } type query { books: [book] } and we also create our resolvers: const resolvers = { query: { books: () => books, } } where books is an already defined array of books. finally we create the actual server: const server = new apolloserver({typedefs, resolvers}); server.listen().then(({ url }) => { console.log(`🚀 server ready at ${url}`); }); $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/GraphQL/qtr.html",
    "title": "Queries TypeDefs and Resolvers",
    "body": " index search search back queries typedefs and resolvers typedefs: define how the data should look. resolvers: resolve what the actual data is going to be. here we could introduce some logic, like calling the database or applying validation. query: defines how we can query our data type query{ books: [book] } so the book resolver would return an array of books. data specification arrays: to define an array on typedefs or queries you use []. type book { author: [string] } non nullable field: to specify that an attribute cannot be null you use !. type book { author: string! author: [string]! // the array must not be null author: [string!]! // the elements of the array and the array must not be null } queries parameters: on the query object you add an argument between brackets (the ! specifies the argument must be provided). type animal { id: id! name: string! description: [string!]! } type query { animals: [animal!]! animal(id: string!): animal } on the resolver we use the arg parameter to retrieve the parameter passed: const resolvers = { query: { animals: () => animals, animal: (parent, args, ctx) => { let animal = animals.find((animal) => { retunr animal.id === args.id }) return animal } } } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Docker/engine.html",
    "title": "Docker Engine",
    "body": " index search search back docker engine when you install docker on your linux system you are installing: docker daemon: this is the background process that manages docker objects (i.e. images, containers, volumes and networks). rest api: it is the interface programs can access to provide instructions to the daemon. docker cli: command line interface to manage our docker objects. this uses the rest api to interact with the docker daemon. note that the docker cli can be run from a remote machine, that is to say the rest api and the docker daemon are running on a different machine. so, in order to interact with the api we use the -h flag, indicating the ip where the api and the daemon reside with the 2375 port. $ docker -h=10.123.2.1:2375 <docker-command> $ docker -h=10.123.2.1:2375 run nginx containerization as we have seen all of our containers run on top of the same operative system, so it is a given that the processes will be handled by the same kernel. this means that the processes of our containers are run along with the rest of processes in the host machine, in other words the pids of all the processes must be different. what docker does to isolate these processes is the container is using namespaces and maps the process id to another process id within the container, and that is visible only on this container. cgroups because all docker containers share the hosts resources it could be possible that a container takes up all of the machine's resources. so, to restrict the amount of resources used by a container docker uses cgroups. you can specify the amount of cpu or ram that the container is allowed to have: $ docker run --cpus=.5 ubuntu $ docker run --memory=100m ubuntu $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Docker/environmentvar.html",
    "title": "Environment Variables",
    "body": " index search search back environment variables in order to pass an environment variables to our container we run: $ docker run -e env_var=value <image_name> this way we set up and environment variable within the container. if you inspect a running container, you will be able to see the environment variables defined, inside the \"env\" object: $ docker inspect <image_name> { . . \"config\": { \"hostname\": \"51049352a8ee\", \"domainname\": \"\", \"user\": \"\", \"attachstdin\": false, \"attachstdout\": false, \"attachstderr\": false, \"exposedports\": { \"3456/tcp\": {}, \"80/tcp\": {} }, \"tty\": false, \"openstdin\": false, \"stdinonce\": false, \"env\": [ \"path=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\", \"nginx_version=1.19.10\", \"njs_version=0.5.3\", \"pkg_release=1\" ], \"cmd\": [ \"nginx\", \"-g\", \"daemon off;\" ] . . . } $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Docker/registry.html",
    "title": "Docker Registry",
    "body": " index search search back docker registry public registry in the following example you are pulling the nginx image, which in reality is stored as nginx/nginx where the first nginx corresponds to the user name, and the second to the image name. image: nginx this is a public image so it is stored in a public registry, usually in docker.io which is the default registry. so a more verbose configuration file would be: image: docker.io/nginx/nginx private registry when you have applications that should no be made available to the public private registries are used. to pull or use an image from a private registry: register into the private registry: $ docker login private-registry.io run the image indicating the registry: $ docker run private-registry.io/apps/internal-app deploy private registry a private registry is in itself a docker image, so first you have to have your registry image running: $ docker run -p 5000:5000 --name registry registry:2 so now you have your registry running on port 5000. the next step is to assign a tag to your image as follows: $ docker image tag my-image localhost:5000/my-image where my-image is the name of the image and localhost:5000/my-image is the tag assigned. finally you push your image to your registry $ docker push localhost:5000/my-image now you can pull your image: $ docker pull localhost:5000/my-image $ docker pull 192.168.56.100:5000/my-image $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Docker/kubernetes.html",
    "title": "Kubernetes",
    "body": " index search search back kubernetes some of its functionalities are: running several instances of a service. scaling up or down the number of instances. rolling updates. rolling back from updates. supports many different network and storage renderers. provides autoscaling. helps you test new features of your application by only upgrading a percentage of the instances, which allows for doing ab testing. architecture a kubernetes cluster consists of several nodes, the worker nodes are where containers will be launched, so even if one node fails the application is still available. kubernetes clusters are managed by the master, which is a node that watches over worker nodes and is responsible of the orchestration of containers in the worker nodes. components when you install kubernetes in your system you are actually installing: api server: acts as the front-end for kubernetes, so all of the programs talk to this server to interact with the kubernetes server. etcd: it is the distributed reliable key value store to store all data to manage the cluster. scheduler: responsible for distributing work. controller: responsible for noticing/responding to nodes/containers going down. container runtime: underline software used to run containers (e.g. docker). kubelet: is the agent that runs in each node in the cluster, and is responsible of making sure the containers are running on the nodes as expected. one of the command line utilities used by kubernetes is kubectl, that is the kubernetes cli and is used to deploy and manage applications on a kubernetes cluster. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Docker/compose_networks.html",
    "title": "Docker Compose Networks",
    "body": " index search search back docker compose networks let's start with an example application, which is made up of five services: voting-app: a front-end application for the user to vote. redis: and in-memory database to store the vote. worker: application in the back-end that processes the vote and stores it in the database. db: database in which the vote is stored. result-app: front-end application that shows the voting results. in this architecture we have two networks: front-end: voting-app and result-app back-end: all the services. therefore it is desirable to define two networks in our docker-compose and attach the networks to the services: version: 2 services: redis: image: redis networks: - back-end db: image: postgres networks: - front-end vote: image: voting-app networks: - front-end - back-end result: image: result networks: - front-end - back-end worker: image: worker networks: - front-end - back-end networks: - front-end: - back-end: as you can see we define two networks: front-end and back-end (note that we have omitted the configuration of the networks) and then for each service we specify the network to which the service has access (also, observe that the configuration of the services has been trimmed down for readability purposes). $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Docker/swarm.html",
    "title": "Docker Swarm",
    "body": " index search search back docker swarm you can combine multiple docker machines together into a single cluster and docker swarm will take care of managing your services. you need to have different hosts with docker installed on them. you must designate one to be the manager, so the rest are the workers. run the docker swarm init command on the manager and that will initialize the manager. on the workers run docker swarm join <token> where <token> is specified in the output of docker swarm init. now you can deploy your services in your cluster, and will be run on the nodes (i.e. workers). docker service docker services are one or more instances of application or services that run along the nodes in the swarm cluster. $ docker services create --replicas=3 <image-name> this creates three instances of my image and runs them in the nodes of the cluster. this command must be run on the manager node, not on the worker nodes. it is similar to the docker run command in terms of the options to pass (networks, ports, interactive mode, etc.) $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Docker/storage.html",
    "title": "Storage",
    "body": " index search search back storage the data pertaining docker is stored within the folder /var/lib/docker/. this includes containers, images, volumes created, etc. layers because of docker's layered architecture when creating very similar images that share a lot of instructions, it uses the cached layers and is, therefore more efficient by not building each image from scratch. for example, when you update your application's source code, only the instructions after the copy instruction, this one included, from your dockerfile is run. image and container layers the layers created from each instruction on the dockerfile constitute the image layers and are all read-only files. when you run your image a new layer is created, denoted by container layer which is a writable file which is a writable file. however, when the container is destroyed, this layer is removed. this is the reason why we use volumes for permanent storage. this is needed because all the containers use the same image, so the changes made in the image by the different containers should not affect the image. copy-on-write also, the changes made on files stored in the image are not made on the original file. the file is copied to the container layer and the changes are made onto this copy. volumes as we have said, we need volumes to store permanent data. so, first we create the volume: $ docker volume <volume_name> which is stored in /var/lib/docker/volumes volume mounting once we have created the volume, we specify that we want to mount this volume within our container: $ docker run -v <volume_name>:/var/lib/mysql mysql if you run this same command, without creating the volume first, docker will automatically create the volume for you. bind mounting if you want to mount another directory that is not inside /var/lib/docker/volumes, then you have to specify the whole directory's (may be an absolute or relative path). $ docker run -v /data/mysql:/var/lib/mysql mysql mount this is the new way to mount: $ docker run --mount type=bind,source=/data/mysql,target=/var/lib/mysql which is preferred as it is more verbose. storage administration the responsible for all of these operations that happen under the hood are the storage drivers, which are chosen depending on the hosts' os: aufs zfs btrfs device mapper overlay overlay2 $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Docker/cmd_vs_entrypoint.html",
    "title": "CMD vs ENTRYPOINT",
    "body": " index search search back cmd vs entrypoint cmd a command allows us to append to the command executed when the container start of the base image. for example, ubuntu's cmd is bash, so if we append sleep 5 our container will sleep for 5 seconds when started and then exit. from ubuntu cmd sleep 5 the command can also be specified as cmd [\"sleep\", \"5\"]. entrypoint this other instruction also adds to the base image starting command, but this lets us add arguments from the command line, for example, if we define the following dockerfile: from ubuntu entrypoint [\"sleep\"] we build the image $ docker build dockerfile -t ubuntu-sleeper and then we running with 10 as and argument: $ docker run ubuntu-sleeper 10 our container will sleep for 10 seconds and then exit. to define a default value for sleep, when no argument is passed from the command line, we use both entrypoint and cmd from ubuntu entrypoint [\"sleep\"] cmd [\"5\"] to override the entrypoint command specified in the dockerfile we use the flag --entrypoint: $ docker run --entrypoint sleep2.0 ubuntu-sleeper 10 difference when using cmd when running: $ docker run ubuntu-sleeper sleep 10 the argument sleep 10 replaces entirely the starting command. however with entrypoint if we run: $ docker run ubuntu-sleeper 10 the argument 10 is passed and appended to the entrypoint command. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Docker/windows_mac.html",
    "title": "Docker on Windows and Mac",
    "body": " index search search back docker on windows and mac on these systems we have two options: docker toolbox (usually for older pc's): installs docker along with virtualbox to create a linux system on which docker is run. hypervirtualization: installs docker and uses hyper-v (comes with windows server or professional edition) or hyperkit on mac. this allows docker to create a linux machine under the hood and run docker in it. windows containers the options just discussed will only work for linux applications and containers. in 2016 microsoft announced support for windows containers, there are two types: windows server container: the containers share the kernel, as regular linux containers do. hyper-v isolation: each container is run within a highly optimized virtual machine, so complete kernel isolation between the containers and the underline host is guaranteed. base images where in linux we had the debian, ubuntu or alpine base images in windows we have two options: windows server core nano server: this is a headless deploy of the windows server, that is, the lightweight option. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Docker/images_commands.html",
    "title": "Image",
    "body": " index search search back image list lists downloaded images: $ docker images or alternatively: $ docker image ls remove remove an image $ docker rmi nginx you must stop and remove all the containers that are instances of the image before removing said image. download to only download an image and not also run a container: $ docker pull nginx create your own image first create a dockerfile specifying all of the steps required to set up your application: from ubuntu run apt-get update run apt-get install python run pip install flask run pip install flask-mysql copy . /opt/source-code entrypoint flask_app=/opt/source-code/app.py flask run then build your image, to store locally: $ docker build dockerfile -t mycustomapp here we specify our dockerfile as input for building the image and the tag of the image with the flag -t. to make it available on the dockerhub: $ docker push mycustomapp dockerfile this is configuration file that follows a certain syntax and tells docker how to build the image. the syntax is the following: instruction argument in the previous example we have: from: defines the base image, which can be an os or another image (every image have to be based off another image). run: run a particular command on the base image. copy: copies files from the host system onto the docker image. entrypoint: specifies the command that will be run when the container is started. layered architecture docker follows a layered architecture so each instruction represents a different layer, which contains only the changes from the layer before, and may serve as a snapshot from which to start the build from a particular layer. also, docker caches the layers, so if there is an error, the build would start from the last layer that did not produce a failure. also, if you were to add additional steps, docker would not start the build from scratch. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Docker/index.html",
    "title": "Docker",
    "body": " index search search back docker intro set up container image environment variables cmd vs entrypoint networking storage docker compose docker compose networks docker registry docker engine docker on windows and mac container orchestration docker swarm kubernetes $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Docker/nerworking.html",
    "title": "Networking",
    "body": " index search search back networking when you install docker it creates three networks automatically: bridge: default network the container get attached to. $ docker run ubuntu none: $ docker run ubuntu --network=none host $ docker run ubuntu --network=host bridge this is a private internal network created by docker on the host. all containers can access each other using their internal ip (usually subnets of 172.17.0.3). to access from outside you have to map a port of the container to a port of the host. host another way to configure the network is to associate the container to the host's network, removing all kind of network isolation between the docker host and the docker container. this way when you run a server on port 5000 it would automatically accessible from the host on the port 5000 without needing to map it to a host's port. this prevents you from using the same ports for different applications. none the containers are not attached to any network and are, therefore, isolated from any other containers so they do not have any access to the external network or other containers. user defined networks because with the default internal network, the containers can access each other, it is sometimes desirable to create new internal networks: $ docker network create --drive bridge --subnet 172.18.0.0/16 <network_name> to list the created networks: $ docker network ls inspect network in order to see the network configuration use inspect and head to the networks section: $ docker inspect ( container_name | container_id ) . . . \"macaddress\": \"aa:bb:cc:dd:ee:ff\", \"networks\": { \"bridge\": { \"ipamconfig\": null, \"links\": null, \"aliases\": null, \"networkid\": \"24af0d...\", \"endpointid\": \"3449a29...\", \"gateway\": \"172.17.0.1\", \"ipaddress\": \"172.17.0.3\", \"ipprefixlen\": 16, \"ipv6gateway\": \"\", \"globalipv6address\": \"\", \"globalipv6prefixlen\": 0, \"macaddress\": \"02:42:ac:11:00:03\", \"driveropts\": null } } . . . embedded dns when containers in the same subnet may want to access each other, for that you could hard code the internal ip assigned to the containers. however this is not advisable, as this ip may change when the container is started in another occasion in the future. because of that all containers in a docker host can resolve each other using their names. this is possible has a built-in dns server for this purpose that runs at 172.0.0.11. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Docker/compose.html",
    "title": "Docker Compose",
    "body": " index search search back docker compose it is used to set up a complex application running multiple services. docker commands map to docker compose as follows: to start the application we run: $ docker-compose up build if we would like to tell docker compose to build a docker build instead of pulling an image we use the build keyword inside a service instead of the image keyword. and we specify the location of the directory which contains the application code and a dockerfile. vote: build: ./vote ports: - 5000:80 links: - redis versions different docker compose versions have different formats and functionality. version 2 from version 2 on, you must specify the docker compose version by adding to the top of the file: version: 2 also, all of the different containers should be listed under a sevices section. and now, links are no longer needed as docker creates a virtual network and attaches all of the services to this network with the name of the service. finally, a depends_on keyword is introduced to force a order of startup. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Docker/intro.html",
    "title": "Intro",
    "body": " index search search back intro what are containers they are completely isolated environments, they have their own processes, network interfaces, etc. however they share the same os kernel. docker uses lxc containers, which are very low lever, so docker provides a high level tool that allows us to manage our containers easily. sharing the kernel as we have said, docker uses the system's kernel, so it is capable of running any distributions whose underlying kernel is linux (e.g. docker running on ubuntu can run a container based on debian, fedora, etc.) containers vs virtual machines containers: application 1 application 2 libs/dependencies 1 libs/dependencies 2 container 1 container 2 docker   os   hardware   virtual machines: application 1 application 2 libs/dependencies 1 libs/dependencies 2 os 1 os 2 virtual machine 1 virtual machine 2 hypervisor   hardware   the main differences are the use of hypervisors in virtual machines and how on these, each instance has its own os. which results in needing more hardware resources. also virtual machines have total isolation, as they use their own os, which does not happen with containers, because these do share the same kernel. however the key is combining both technologies, so each virtual machine runs several applications hosted in different containers. container vs image an image can be thought as a package or a template that is used to create one or more containers. that is to say, containers are running instances of images that are isolated and have their own environment. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Docker/setup.html",
    "title": "Set Up",
    "body": " index search search back set up in this first step, we will present how to install the necessary tools to use docker and docker compose in arch linux. install docker in the current section we will lay out the steps to carry out in order to get docker up and running on an arch linux machine. docker engine before installing anything we will update the system as follows $ sudo pacman -syu when it is done updating we will proceed rebooting the system, and then we enable the loop module: $ sudo tee /etc/modules-load.d/loop.conf <<< \"loop\" $ sudo modprobe loop install using static binaries for reference go to the official documentation on docker's website. firstly we will download the static binary archive on https://download.docker.com/linux/static/stable/. once the file is downloaded extract it executing the following command, and substituting our docker-20.10.8 for your package's version. $ tar xzvf docker-20.10.8.tgz copy the binaries to your executable path (/usr/bin or /bin). this is optional. $ sudo cp docker/* /usr/bin/ start docker's daemon: $ sudo dockerd finally run to check that the installation was correct (it will download an example image that outputs a message informing the user that the installation was successful, among other things). $ sudo docker run hello-world official repo this other approach will allows to have a docker service so we do not have to always run sudo dockerd & to start docker's daemon. we install docker using pacman: $ sudo pacman -s docker afterwards, we enable the docker service executing: $ sudo systemctl start docker.service $ sudo systemctl enable docker.service finally run to check that the installation was correct (it will download an example image that outputs a message informing the user that the installation was successful, among other things). $ sudo docker run hello-world configure docker running as normal user in order to use docker as a normal user we need to add said user to the docker group. add the docker group $ sudo groupadd docker add your user to the docker group $ sudo usermod -ag docker $user log out, log in and verify that it runs properly $ docker run hello-world install docker compose download the current stable release of docker compose. mind you, this command downloads the 1.29.2 version, check the official page for new releases. $ sudo curl -l \"https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose make the binary executable $ sudo chmod +x /usr/local/bin/docker-compose test the installation $ docker-compose --version docker-compose version 1.29.2, build 5becea4c $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Docker/orchestration.html",
    "title": "Container Orchestration",
    "body": " index search search back container orchestration when in production, it is often needed that several instances of containers are run (because of a heavy load on the application for example). so in these cases you need to monitor the instances as well as the host itself in case any of them crash. for that we use container orchestration that offers a set of tools and scripts that allow us to manage the hosts and containers. the typical approach is to create several instances of containers in different hosts, so if one fails the application can still offer the service. for example: $ docker service create --replicas=100 nodejs some solutions let us automatically scale the number of containers depending on the demand. others can help in automatically adding new hosts to support the user load. they also provide complex networking between the containers as well as load balancing user requests across different hosts or sharing storage between the hosts, configuration management or security. there are several solutions: docker swarm from docker kubernetes from google mesos from apache. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/ComputerScience/WebDev/Docker/containers.html",
    "title": "Container",
    "body": " index search search back container run basics run a container from an image, the attached way, (i.e. it is not run on the background). $ docker run nginx if the image is not present on the host it will be downloaded from docker hub. when it is downloaded it runs and exits right away, because there is not application running in the container. to run the container in the detach mode, so it run on the background: $ docker run -d nginx to bring the container to the foreground: $ docker attach ( container_id | container_name ) run a container with a specific tag: $ docker run redis:4.0 this way we run the redis image where redis's version is 4.0. run a container listening to the standard input (because by default docker does not listen for input): $ docker run -i <image_name> this way we are running our container in interactive mode. in order to attach a terminal: $ docker run -it <image_name> port mapping each container is assigned a port (e.g. 5000) and an internal ip by default (e.g. 127.17.0.2) but this ip is only accessible from the host. so to access it from outside, we would use our host's ip (e.g. 192.168.1.5), however we still need to map our container's port to a free port in our host. so to map, for example, the port 5000 of our docker container to the port 80 of our host: $ docker run -p 80:5000 <image_name> and now, we can access the service running in our docker container by heading to 192.168.1.5:80. this way all traffic in this specific url will be routed to the port 5000 in our docker container. volume mapping our container has its own file system, so the changes made to data stored in it are only made in the container. if you want certain data to persist (because when removing the docker container the files stored within are also removed) you use the flag -v to map a certain file/folder in the container to a certain file/folder in our host: $ docker run -v /opt/datadir:/var/lib/mysql mysql in this particular example we store the data we saved in our mysql database in a directory in our container (/var/lib/mysql), and we map this directory to a directory in our host (/opt/datadir) this way docker mounts implicitly the folder in our host to the folder in the container. linking if we have a web application that connects to a redis instance, we need to tell the web app's container which redis instance to wait for (because there may be multiple). so, first we start the redis container: $ docker run -d --name=redis redis and now we start our web app's container and we link it with the redis container: $ docker run -d --name=vote -p 5000:80 --link redis:redis voting-app the redis before the colon is the name of our redis container, and the redis after the name is the name used in the web app container. this option is soon to be deprecated because new concepts are technologies are being introduced. information of a container in order to get more detailed information about a certain container: $ docker inspect ( container_name | container_id ) logs to see the logs of a container (usually printed to the stdout): $ docker log ( container_name | container_id ) list lists all running containers and some information about it. $ docker ps to see all containers, even if they are not currently running: $ docker ps -a stop stop running a container who matches the id or the name provided: docker stop ( container_id | container_name ) remove removes a container permanently docker rm ( container_id | container_name ) execute commands to execute a command after creating a new container: $ docker run ubuntu sleep 5 this commands starts the container and run the command sleep 5 and then exits. to execute a command in a currently running container: $ docker exec ( container_id | container_name ) cat /etc/hosts $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Other/Rices/arch_install.html",
    "title": "Arch Linux Installation",
    "body": " index search search back arch linux installation set up set the keyboard layout: $ loadkeys es augment the size of the iso image: $ mount -o remount,size=1g /run/archiso/cowspace download git: $ pacman -syy && pacman -s git configure git to store the credentials: $ git config --global credential.helper store clone the repository: git clone https://github.com/albamr09/archinstaller.git now, you are good to go to start the installation process. install place yourself inside the root of the repository: cd archinstaller check out the configuration file, in case some values do not make sense to you: cat install_scripts/config.sh if you are satisfied with the configuration, simply execute: cd install_scripts && ./install.sh this will cause the installation to begin. it is mostly automatic, but sometimes you will have to enter a password here and there. so do not just let it execute by itself, because there are timeouts that will cause the installation to hault with an error. once this finished, reboot your computer. when the computer is up and running again, you will be met with a very minimal login interface. log in with you user, and execute the following: cd /install_scripts && ./post_install this script prompts you to connect to a wifi access point. it also sets up some needed services (like lightdm!) and removes all the installation files used from you system so it is nice an clean. well, now your arch linux is ready to go! $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Other/VimWiki/index.html",
    "title": "Vim Wiki",
    "body": " index search search back vim wiki key bindings convert current file to html: ,wh see html file in browser: ,whh more info on vimwiki latex inline \\(a = 1\\) equation \\begin{align} a \\end{align} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Other/index.html",
    "title": "Other",
    "body": " index search search back other rices arch linux installation misc vimwiki macos vm $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Other/MacOS/index.html",
    "title": "Mac OS VM",
    "body": " index search search back mac os vm source initial setup ubuntu/debian: $ sudo apt-get install qemu uml-utilities virt-manager git \\ wget libguestfs-tools p7zip-full make dmg2img -y fedora: $ sudo dnf install @virutalization start libvirt service: $ sudo systemctl start libvirt $ sudo systemctl enable libvirt add user to the kvm and libvirt groups (might be needed). $ sudo usermod -ag kvm $(whoami) $ sudo usermod -ag libvirt $(whoami) $ sudo usermod -ag input $(whoami) note: re-login after executing this command. now edit /etc/libvirt/qemu.conf and set user and group to your user. clone this repository on your qemu system. files from this repository are used in the following steps. $ cd ~ $ git clone --depth 1 --recursive https://github.com/kholia/osx-kvm.git $ cd osx-kvm note: with this you are installing your vm on $home. fetch macos installer. $ ./fetch-macos-v2.py on this step select monterey. convert the downloaded basesystem.dmg file into the basesystem.img file. $ dmg2img -i basesystem.dmg basesystem.img create a virtual hdd image where macos will be installed. if you change the name of the disk image from mac_hdd_ng.img to something else, the boot scripts will need to be updated to point to the new image name. $ qemu-img create -f qcow2 mac_hdd_ng.img 128g be aware that the machine can easily reach that amount of memory. installation cli method (primary). just run the opencore-boot.sh script to start the installation process. $ ./opencore-boot.sh before installing go to disk utility inside the machine and erase the partition we are going to use for the virtual machine (the one that is roughly 128gb). for that click on erase and select mac os extended (journaled). once the erasing procedure is done, you can start the installation normally. edit macos-libvirt-catalina.xml file and change the various file paths (search for changeme strings in that file). the following command should do the trick usually. $ sed \"s/changeme/$user/g\" macos-libvirt-catalina.xml > macos.xml $ virt-xml-validate macos.xml create a vm on virt-manager by running the following command. $ virsh --connect qemu:///system define macos.xml launch virt-manager and start the macos virtual machine. post-installation open virt-manager, select macos and edit cpus and memory so the virtual machine does not lag incredibly. permissions bug (might only happen in fedora) if you get an error when starting the machine related to permissions, they are solved with: $ sudo setenforce permissive if they are related with selinux. if that is the case, refer to. undo the previous command with: $ sudo setenforce enforcing on your $home directory try to fix with: $ sudo chcon -r -u system_u -r object_r -t svirt_image_t osx-kvm/ screen resolution execute the virtual machine and press esc inmmediately. select device management option and change ovmf to 1920x1080p resolution. enter the virtual machine, once it has been booted open a terminal and write: $ diskutil list select the disk where the efi partition is location $ sudo diskutil mount disk1s1 $ vi /volumes/efi/efi/oc/config.plist and edit the entry under resolution to be 1920x1080@32. reboot the machine. once rebooted go to system preferences > displays and check show all resolutions and select 1920x1080. connect to physical iphone open virtual manager, and enter the configuration of the machine. click on add hardware and select usb host, now edit the xml entry just created and substitue the content with: <hostdev mode=\"subsystem\" type=\"usb\" managed=\"yes\"> <source> <vendor id=\"0x05ac\"/> <product id=\"0x12a8\"/> </source> <address type=\"usb\" bus=\"0\" port=\"1\"/> </hostdev> where vendor id and product id is obtained through lsusb on the host machine: $ lsusb ... bus 001 device 004: id 05ac:12a8 apple, inc. iphone 5/5c/5s/6/se ... keyboard is locked if the keyboard seems to be captured when the machine starts, remove the entry on the machine hardware configuration that has this content or similar (this is my keyboard's smart card, may not apply to your case.) <hostdev mode=\"subsystem\" type=\"usb\" managed=\"yes\"> <source> <vendor id=\"0x04f2\"/> <product id=\"0x1469\"/> </source> <address type=\"usb\" bus=\"0\" port=\"2\"/> </hostdev> optimization source only the following are actually important: add more video memory open virtual manager, select macos machine and open the configuration. locate vga and change the xml entry so that vgamem has the value 65536. skip the gui login screen (at your own risk!) $ defaults write com.apple.loginwindow autologinuser -bool true disable spotlight indexing on macos to heavily speed up virtual instances. $ sudo mdutil -i off -a enable performance mode # check if enabled (should contain `serverperfmode=1`) $ nvram boot-args # turn on $ sudo nvram boot-args=\"serverperfmode=1 $(nvram boot-args 2>/dev/null | cut -f 2-)\" disable heavy login screen wallpaper $ sudo defaults write /library/preferences/com.apple.loginwindow desktoppicture \"\" reduce motion & transparency (could be faulty) defaults write com.apple.accessibility differentiatewithoutcolor -int 1 defaults write com.apple.accessibility reducemotionenabled -int 1 defaults write com.apple.universalaccess reducemotion -int 1 defaults write com.apple.universalaccess reducetransparency -int 1 defaults write com.apple.accessibility reducemotionenabled -int 1 to undo any of this changes refer to the reference material. gpu passthrough to be continued $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/07_03.html",
    "title": "The Conic Sections and Nonlinear Systems",
    "body": " index search search back the conic sections and nonlinear systems characteristics the conic sections in this chapter have equations that can be written in the form: \\[%align ax^2 + dx + cy^2 + ey + f = 0 \\] where either \\(a\\) or \\(c\\) must be nonzero. the special characteristics of each conic section are summarizeed in the following table. the chart summarizes our work with conic sections: eccentricity a conic is the set of all points \\(p(x, y)\\) in a plane such that the ratio of the distance from \\(p\\) to a fixed point and the distance from \\(p\\) to a fixed line is constant. the constant ratio is called the ecccentricity of the conic, written \\(e\\). parabola if the conic is a parabola, then by definition, the distances \\(d(p, f)\\) and \\(d(p, d)\\) are equal, thus every parabola has eccentricity \\(1\\). ellipse for an ellipse, eccentricity is a measure of its \"roundness\". the constant ratio in the definition is \\(e = \\frac{c}{a}\\), where \\(c\\) is the distance from the center of the figure to a focus and \\(a\\) is the distance from the center to a vertex. by the definition of an ellipse, \\(a^2 > b^2\\) and \\(c = \\sqrt{a^2 - b^2}\\). thus, for the ellipse: \\begin{align} 0 < c < a \\end{align} divide by \\(a\\): \\begin{align} 0 < \\frac{c}{a} < 1 \\end{align} where \\(e = \\frac{c}{a}\\): \\begin{align} 0 < e < 1 \\end{align} circle in the circle the foci coincide with the center such that \\(a = b\\) and \\(c = \\sqrt{a^2 - b^2} = 0\\) and therefore \\(e = \\frac{c}{a} = 0\\). hyperbola the hyperbola also has eccentricity \\(e = \\frac{c}{a}\\). by definition \\(c = \\sqrt{a^2 + b^2} > a\\), so: \\begin{align} 0 < a < c \\end{align} divide by \\(a\\): \\begin{align} 0 < 1 < \\frac{a}{c} \\end{align} \\begin{align} 0 < 1 < e \\end{align} therefore \\(e > 1\\). such that narrow hyperbolas have \\(e\\) near \\(1\\) and wide hyperbolas have a large value of \\(e\\). nonlinear systems a nonlinear system of equations can have any number of solutions. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/07_02.html",
    "title": "Ellipses and Hyperbolas",
    "body": " index search search back ellipses and hyperbolas ellipse an ellipse is the set of all points in a plane, the sum of whose distances from two fixed points is constant. each fixed point is called a focus (plural, foci) of the ellipse. an ellipse has two axes of symmetry: the major axis (the longer one) and the minor axis (the shorter one). the foci are always located on the major axis. the midpoint of the major axis is the center of the ellipse, and the endpoints of the major axis are the vertices of the ellipse. a chord through a focus and perpendicular to the major axis is called a latus rectum. the graph of an ellipse is not the graph of a function. given an ellipse with center at the origin, foci \\(f(c, 0)\\) and \\(f′(-c, 0)\\), and vertices \\(v(a, 0)\\) and \\(v′(-a, 0)\\). from the previous image we know that the distance from \\(v\\) to \\(f\\) is \\(a - c\\) and the distance from \\(v\\) to \\(f′\\) is \\(a + c\\). the sum of these distances is \\(2a\\). since \\(v\\) is on the ellipse, all othe points must satisfy this distance, such that for any point \\(p(x, y)\\) on the ellipse: \\begin{align} d(p, f) + d(p, f') = 2a \\end{align} \\begin{align} \\sqrt{(x - c)^2 + y^2} + \\sqrt{(x + c)^2 + y^2} = 2a \\end{align} \\begin{align} \\sqrt{(x - c)^2 + y^2} = 2a - \\sqrt{(x + c)^2 + y^2} \\end{align} we now square each side: \\begin{align} (x - c)^2 + y^2 = 4a^2 - 4a\\sqrt{(x + c)^2 + y^2} + (x + c)^2 + y^2 \\end{align} \\begin{align} x^2 + c^2 - 2xc + y^2 = 4a^2 - 4a\\sqrt{(x + c)^2 + y^2} + x^2 + c^2 + 2xc + y^2 \\end{align} \\begin{align} - 4xc = 4a^2 - 4a\\sqrt{(x + c)^2 + y^2} \\end{align} \\begin{align} - xc = a^2 - a\\sqrt{(x + c)^2 + y^2} \\end{align} \\begin{align} xc + a^2 = a\\sqrt{(x + c)^2 + y^2} \\end{align} we square both sides again: \\begin{align} (xc + a^2)^2 = a^2\\left((x + c)^2 + y^2\\right) \\end{align} \\begin{align} x^2c^2 + a^4 + 2xca^2 = a^2\\left(x^2 + c^2 + 2xc + y^2\\right) \\end{align} \\begin{align} x^2c^2 + a^4 + 2xca^2 = a^2x^2 + a^2c^2 + 2xca^2 + a^2y^2 \\end{align} \\begin{align} x^2c^2 + a^4 = a^2x^2 + a^2c^2 + a^2y^2 \\end{align} \\begin{align} x^2c^2 - a^2x^2 - a^2y^2 = - a^4 + a^2c^2 \\end{align} \\begin{align} x^2(c^2 - a^2)- a^2y^2 = a^2 (-a^2 + c^2) \\end{align} we multiply both sides by \\(-1\\): \\begin{align} x^2(a^2 - c^2) + a^2y^2 = a^2 (a^2 - c^2) \\end{align} we divide both sides by \\(a^2(a^2 - c^2)\\): \\begin{align} \\frac{x^2}{a^2} + \\frac{y^2}{(a^2 - c^2)} = 1 \\end{align} which gives us the standard form equation for the ellipse with center on the origin, vertices \\((\\pm a, 0)\\) and foci \\((\\pm c, 0)\\). since \\(b(0, b)\\) is on the ellipse, then: \\begin{align} d(b, f) + d(b + f') = 2a \\end{align} \\begin{align} \\sqrt{(-c)^2 + b^2} + \\sqrt{c^2 + b^2} = 2a \\end{align} \\begin{align} 2\\sqrt{c^2 + b^2} = 2a \\end{align} we square both sides \\begin{align} 4(c^2 + b^2) = 4a^2 \\end{align} \\begin{align} c^2 + b^2 = a^2 \\end{align} \\begin{align} b^2 = a^2 - c^2 \\end{align} therefore, by sustuting on the ellipse formula we obtain: \\begin{align} \\frac{x^2}{a^2} + \\frac{y^2}{b^2} = 1 \\end{align} standard forms of equations for ellipses the ellipse with center at the origin and equation: \\begin{align} \\frac{x^2}{a^2} + \\frac{y^2}{b^2} = 1, (a > b > 0) \\end{align} has vertices \\((\\pm a, 0)\\), endpoints of the minor axis \\((0, \\pm b)\\) and foci \\((\\pm c, 0)\\) where \\(c^2 = a^2 - b^\\) the ellipse with center at the origin and equation \\begin{align} \\frac{x^2}{b^2} + \\frac{y^2}{a^2} = 1, (a > b > 0) \\end{align} has vertices \\((0, \\pm a)\\), endpoints of the minor axis \\((\\pm b, 0)\\) and foci \\((0, \\pm c)\\) where \\(c^2 = a^2 - b^\\) translations of ellipses an ellipse with center at \\((h, k)\\) where \\(b^2 = a^2 - c^2\\) with \\(a > b > 0\\) and \\(c > 0\\) satisfies one of the following equations: major axis: horizontal, foci \\((h \\pm c, k)\\) and vertices \\((h \\pm a, k)\\): \\begin{align} \\frac{(x - h)^2}{a^2} + \\frac{(y - k)^2}{b^2} = 1 \\end{align} major axis: vertical, foci \\((h, k \\pm c)\\) and vertices \\((h, k \\pm a)\\): \\begin{align} \\frac{(x - h)^2}{b^2} + \\frac{(y - k)^2}{a^2} = 1 \\end{align} hyperbola a hyperbola is the set of all points in a plane such that the absolute value of the difference of the distances from two fixed points is constant. the two fixed points are called the foci of the hyperbola. suppose a hyperbola has center at the origin and foci at \\(f'(- c, 0)\\) and \\(f(c, 0)\\). the midpoint of the segment \\(f′f\\) is the center of the hyperbola, and the points \\(v'(- a, 0)\\) and \\(v(a, 0)\\) are the vertices of the hyperbola. the line segment v'v is the transverse axis of the hyperbola. a chord through a focus and perpendicular to an extension of the transverse axis is a latus rectum. standard forms of equations for hyperbolas the hyperbola with center at the origin and equation \\begin{align} \\frac{x^2}{a^2} - \\frac{y^2}{b^2} = 1 \\end{align} has vertices \\((\\pm a, 0)\\), asymptotes \\(y = \\pm \\frac{b}{a}x\\) and foci \\((\\pm c, 0)\\) where \\(c^2 = a^2 + b^2\\). the hyperbola with center at the origin and equation \\begin{align} \\frac{y^2}{a^2} - \\frac{x^2}{b^2} = 1 \\end{align} has vertices \\((0, \\pm a)\\), asymptotes \\(y = \\pm \\frac{a}{b}x\\) and foci \\((0, \\pm c)\\) where \\(c^2 = a^2 + b^2\\). to explain the concept of asymptotes, we can start with the first equation for a hyperbola, where the foci are on the x-axis, and solve for \\(y\\): \\begin{align} \\frac{x^2}{a^2} - \\frac{y^2}{b^2} = 1 \\end{align} \\begin{align} \\frac{y^2}{b^2} = \\frac{x^2}{a^2} - 1 \\end{align} \\begin{align} \\frac{y^2}{b^2} = \\frac{x^2 - a^2}{a^2} \\end{align} \\begin{align} \\frac{y}{b} = \\pm \\frac{1}{a} \\sqrt{x^2 - a^2} \\end{align} \\begin{align} y = \\pm \\frac{b}{a} \\sqrt{x^2 - a^2} \\end{align} \\begin{align} y = \\pm \\frac{b}{a} \\frac{x}{x} \\sqrt{x^2 - a^2} \\end{align} \\begin{align} y = \\pm \\frac{b}{a} x \\sqrt{\\frac{x^2 - a^2}{x^2}} \\end{align} \\begin{align} y = \\pm \\frac{b}{a} x \\sqrt{\\frac{x^2}{x^2} - \\frac{a^2}{x^2}} \\end{align} \\begin{align} y = \\pm \\frac{b}{a} x \\sqrt{1 - \\frac{a^2}{x^2}} \\end{align} so when \\(x \\rightarrow \\ifty\\) we know that \\(\\frac{a^2}{x^2} \\rightarrow 0\\) and thus: \\begin{align} y = \\pm \\frac{b}{a} x \\sqrt{1} \\end{align} \\begin{align} y = \\pm \\frac{b}{a} x \\end{align} which defines the asymptotes of the hyperbola. the lines are the extended diagonals of the rectangle whose vertices are \\((a, b)\\), \\((- a, b)\\), \\((a, - b)\\), and \\((- a, - b)\\). this rectangle is called the fundamental rectangle of the hyperbola. if the foci are on the y-axis the hyperbola is defined as follows: \\begin{align} y = \\pm \\frac{a}{b} x \\end{align} translations of hyperbolas a hyperbola with center \\((h, k)\\), where \\(c^2 = a^2 + b^2\\) is defined in one of two ways: traverse axis is horizontal, vertices are \\((h \\pm a, k)\\), foci are \\((h \\pm c, k)\\) and asymptotes are \\(y = \\pm \\frac{b}{a}(x - h) + k\\) \\begin{align} \\frac{(x - h)^2}{a^2} - \\frac{(y - k)^2}{b^2} = 1 \\end{align} traverse axis is verticsl, vertices are \\((k, h \\pm a)\\), foci are \\((k, h \\pm c)\\) and asymptotes are \\(y = \\pm \\frac{a}{b}(x - h) + k\\) \\begin{align} \\frac{(y - k)^2}{a^2} - \\frac{(x - h)^2}{b^2} = 1 \\end{align} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/06_05.html",
    "title": "Determinants and Cramer's Rule",
    "body": " index search search back determinants and cramer's rule determinants of \\(2 \\times 2\\) matrices the determinant of a \\(2 \\times 2\\) matrix \\(a\\) is a real number defined as \\(det(a) = a_{11} a_{22}− a_{21} a_{12}\\). determinants of \\(3 \\times 3\\) matrices the determinant of a \\(3 \\times 3\\) matrix \\(a\\) is a real number defined as \\(det(a) = (a_{11}a_{22}a_{33} + a_{12} a_{23} a_{31} + a_{13} a_{21}a_{32}) − (a_{31}a_{22}a_{13} + a_{32} a_{23} a_{11} + a_{33} a_{21}a_{12})\\). cofactor let \\(m_{ij}\\) be the minor for element \\(a_{ij}\\) in an \\(n \\times n\\) matrix. the cofactor of \\(a_{ij}\\), written \\(a_{ij}\\), is defined as follows. \\begin{align} a_{ij} = (-1)^{i + j} \\cdot m_{ij} \\end{align} cramer's rule for \\(2 \\times 2\\) systems the solution of the system: \\begin{align} a_1x + b_1y = c_1 \\end{align} \\begin{align} a_2x + b_2y = c_2 \\end{align} is given by: \\begin{align} x = \\frac{d_x}{d}, y = \\frac{d_y}{d} \\end{align} where: \\begin{align} d_x = det( \\begin{bmatrix} c_1 & b_1 \\\\ c_2 & b_2 \\\\ \\end{bmatrix}) \\end{align} \\begin{align} d_y = det( \\begin{bmatrix} a_1 & c_1 \\\\ a_2 & c_2 \\\\ \\end{bmatrix}) \\end{align} \\begin{align} d = det( \\begin{bmatrix} a_1 & b_1 \\\\ a_2 & b_2 \\\\ \\end{bmatrix}) \\neq 0 \\end{align} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/06_02.html",
    "title": "Solutions of Linear Systems in Three Variables",
    "body": " index search search back solutions of linear systems in three variables we can extend the ideas of systems of equations in two variables to linear equations of the form: \\begin{align} ax + by + cz = d \\end{align} considering the possible intersections of the planes representing three equations in three unknowns shows that the solution set of such a system may be either a single ordered triple \\((x, y, z)\\), an infinite set of ordered triples (dependent equations), or the empty set (an inconsistent system). the following steps can be used to solve a linear system with three variables. eliminate a variable from any two of the equations. eliminate the same variable from a different pair of equations. eliminate a second variable using the resulting two equations in two variables to get an equation with just one variable. find the values of the remaining variables by substitution. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/06_03.html",
    "title": "Solution of Linear Systems by Row Transformations",
    "body": " index search search back solution of linear systems by row transformations solving linear systems of equations can be streamlined by using matrices. consider a system of three equations and three unknowns. \\begin{align} a_1 x + b_1y + c_1z = d_1 \\end{align} \\begin{align} a_2 x + b_2y + c_2z = d_2 \\end{align} \\begin{align} a_3 x + b_3y + c_3z = d_3 \\end{align} can be written as the following augmented matrix: \\begin{align} \\begin{bmatrix} a_1 & b_1 & c_1 & d_1 \\\\ a_2 & b_2 & c_2 & d_2 \\\\ a_3 & b_3 & c_3 & d_3 \\\\ \\end{bmatrix} \\end{align} matrix row transformations for any augmented matrix of a system of linear equations, the following row transformations will result in the matrix of an equivalent system. any two rows may be interchanged. the elements of any row may be multiplied by a nonzero real number. any row may be changed by adding to its elements a multiple of the corresponding elements of another row. row echelon method the echelon (triangular) form of an augmented matrix has 1s down the diagonal from upper left to lower right and 0s below each 1. once a system of linear equations is in echelon form, back-substitution can be used to find the solution set. the row echelon method uses matrices to solve a system of linear equations. start by obtaining a 1 as the first entry in the first column and then transform all entries below it to a 0. continue through the columns obtaining a 1 as the second entry in the second column (zeros below), the third entry in the third column (zeros below), and so on. repeat this process to row echelon form. the following matrix is an augmented matrix in row echelon form: \\begin{align} \\begin{bmatrix} 1 & 2 & 3 & 4\\\\ 0 & 5 & 6 & 7\\\\ 0 & 0 & 0 & 9\\\\ \\end{bmatrix} \\end{align} reduced row echelon method the reduced row echelon form has 1s along the main diagonal and 0s both below and above. for example \\begin{align} \\begin{bmatrix} 1 & 1 & 1 & 6\\\\ 2 & -1 & 1 & 5\\\\ 3 & 1 & -1 & 9\\\\ \\end{bmatrix} \\end{align} by using row transformations, this augmented matrix can be transformed to \\begin{align} \\begin{bmatrix} 1 & 0 & 0 & 3\\\\ 0 & 1 & 0 & 2\\\\ 0 & 0 & 1 & 1\\\\ \\end{bmatrix} \\end{align} which represents \\(x = 3, y = 2, z = 1\\). there is no need for back-substitution with reduced row echelon form. special cases whenever a row of the augmented matrix is of the form \\begin{align} \\begin{bmatrix} 0 & 0 & \\cdots & a\\\\ \\end{bmatrix} \\end{align} where \\(a \\neq 0\\) the system is inconsistent and there will be no solution. a row of the matrix of a linear system in the form: \\begin{align} \\begin{bmatrix} 0 & 0 & \\cdots & 0\\\\ \\end{bmatrix} \\end{align} indicates that the equations of the system are dependent. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/08_03.html",
    "title": "Right Triangles and Evaluating Trigonometric Functions",
    "body": " index search search back right triangles and evaluating trigonometric functions right-triangle definitions of the trigonometric functions figure 41 shows an acute angle \\(a\\) in standard position. the side of length \\(y\\) in figure 41 is called the side opposite angle \\(a\\), and the side of length \\(x\\) is called the side adjacent to angle \\(a\\). such that: \\begin{align} \\sin a = \\frac{y}{r} = \\frac{\\text{side opposite}}{\\text{hypotenuse}} \\end{align} \\begin{align} \\cos a = \\frac{x}{r} = \\frac{\\text{side adjacent}}{\\text{hypotenuse}} \\end{align} \\begin{align} \\tan a = \\frac{y}{x} = \\frac{\\text{side opposite}}{\\text{side adjacent}} \\end{align} \\begin{align} \\csc a = \\frac{r}{y} = \\frac{\\text{hypotenuse}}{\\text{side opposite}} \\end{align} \\begin{align} \\sec a = \\frac{r}{x} = \\frac{\\text{hypotenuse}}{\\text{side adjacent}} \\end{align} \\begin{align} \\cot a = \\frac{x}{y} = \\frac{\\text{side adjacent}}{\\text{side opposite}} \\end{align} trigonometric function values of special angles certain special angles, such as \\(30º, 45º\\) and \\(60º\\) occur so often that they deserve special study. see figure 43(a), for convenience the length of the sides is \\(2\\). bisecting one angle of this equilateral triangle leads to two right triangles, each of which has angles of \\(30°, 60°\\), and \\(90°\\), as shown in figure 43(b). let \\(x\\) represent the length of the longer leg: \\begin{align} 2^2 = 1^2 + x^2 \\end{align} \\begin{align} 4 = 1 + x^2 \\end{align} \\begin{align} 3 = x^2 \\end{align} \\begin{align} \\sqrt{3} = x \\end{align} therefore the hypotenuse is \\(2\\), the side opposite is \\(1\\) and the side adjacent is \\(\\sqrt{3}\\). from the definition of the trigonometric functions: \\begin{align} \\sin 30º = \\frac{\\text{side opposite}}{\\text{hypotenuse}} = \\frac{1}{2} \\end{align} \\begin{align} \\cos 30º = \\frac{\\text{side adjacent}}{\\text{hypotenuse}} = \\frac{\\sqrt{3}}{2} \\end{align} \\begin{align} \\tan 30º = \\frac{\\text{side opposite}}{\\text{side adjacent}} = \\frac{\\sqrt{3}}{3} \\end{align} \\begin{align} \\csc 30º = \\frac{\\text{hypotenuse}}{\\text{side opposite}} = \\frac{2}{1} = 2 \\end{align} \\begin{align} \\sec 30º = \\frac{\\text{hypotenuse}}{\\text{side adjacent}} = \\frac{2\\sqrt{3}}{3} \\end{align} \\begin{align} \\cot 30º = \\frac{\\text{side adjacent}}{\\text{side opposite}} = \\frac{\\sqrt{3}}{1} = \\sqrt{3} \\end{align} for \\(60º\\) refer to figure 44, such that hypotenuse is \\(2\\), side opposite is \\(\\sqrt{3}\\) and side adjacent is \\(1\\). therefore from the definition of the trigonometric functions: \\begin{align} \\sin 60º = \\frac{\\text{side opposite}}{\\text{hypotenuse}} = \\frac{\\sqrt{3}}{2} \\end{align} \\begin{align} \\cos 60º = \\frac{\\text{side adjacent}}{\\text{hypotenuse}} = \\frac{1}{2} \\end{align} \\begin{align} \\tan 60º = \\frac{\\text{side opposite}}{\\text{side adjacent}} = \\frac{\\sqrt{3}}{1} = \\sqrt{3} \\end{align} \\begin{align} \\csc 60º = \\frac{\\text{hypotenuse}}{\\text{side opposite}} = \\frac{2\\sqrt{3}}{3} \\end{align} \\begin{align} \\sec 60º = \\frac{\\text{hypotenuse}}{\\text{side adjacent}} = \\frac{2}{1} = 2 \\end{align} \\begin{align} \\cot 60º = \\frac{\\text{side adjacent}}{\\text{side opposite}} = \\frac{\\sqrt{3}}{3} \\end{align} for \\(45º\\) we start with a \\(45º-45º\\) right triangle as shown in figure 45. this triangle has two equal sides whose length is \\(1\\) unit. therefore, by the pythagoread theorem: \\begin{align} 1^2 + 1^2 = r^2 \\end{align} \\begin{align} r = \\sqrt{2} \\end{align} that is the hypotenuse is \\(\\sqrt{2}\\), the side opposite is \\(1\\) and the side adjacent is \\(1\\), so from the definition of the trigonometric functions: \\begin{align} \\sin 45º = \\frac{\\text{side opposite}}{\\text{hypotenuse}} = \\frac{1}{\\sqrt{2}} = \\frac{\\sqrt{2}}{2} \\end{align} \\begin{align} \\cos 45º = \\frac{\\text{side adjacent}}{\\text{hypotenuse}} = \\frac{1}{\\sqrt{2}} = \\frac{\\sqrt{2}}{2} \\end{align} \\begin{align} \\tan 45º = \\frac{\\text{side opposite}}{\\text{side adjacent}} = \\frac{1}{1} = 1 \\end{align} \\begin{align} \\csc 45º = \\frac{\\text{hypotenuse}}{\\text{side opposite}} = \\frac{\\sqrt{2}}{1} = \\sqrt{2} \\end{align} \\begin{align} \\sec 45º = \\frac{\\text{hypotenuse}}{\\text{side adjacent}} = \\frac{\\sqrt{2}}{1} = \\sqrt{2} \\end{align} \\begin{align} \\cot 45º = \\frac{\\text{side adjacent}}{\\text{side opposite}} = \\frac{1}{1} = 1 \\end{align} cofunction identities in a right triangle \\(abc\\) with right angle \\(c\\), the acute angles \\(a\\) and \\(b\\) are complementary. see figure 46. the length of the side opposite angle \\(a\\) is \\(a\\), and the length of the side opposite angle \\(b\\) is \\(b\\). the length of the hypotenuse is \\(c\\). in this triangle, \\(\\sin a = \\frac{a}{c}\\) and \\(\\cos b\\) is also equal to \\(\\frac{a}{c}\\). similar reasoning yields the following. \\begin{align} \\tan a = \\frac{a}{b} = \\cot b \\end{align} \\begin{align} \\sec a = \\frac{c}{b} = \\csc b \\end{align} if these identities follow we say \\(\\sin\\) and \\(\\cos\\) are cofunctions, as well as \\(\\tan\\) and \\(\\cot\\) and \\(\\sec\\) and \\(\\csc\\). since angles \\(a\\) and \\(b\\) are complementary \\(a + b = 90º\\), that is \\(b = 90º - a\\), therefore: \\begin{align} \\sin a = \\cos b = \\cos (90º - a) \\end{align} this is a cofunction identity, the rest are as follows: given an acute angle \\(a\\) in degrees: \\begin{align} \\cos a = \\sin b = \\sin (90º - a) \\end{align} \\begin{align} \\tan a = \\cot b = \\cot (90º - a) \\end{align} \\begin{align} \\csc a = \\sec b = \\sec (90º - a) \\end{align} \\begin{align} \\sec a = \\csc b = \\csc (90º - a) \\end{align} \\begin{align} \\cot a = \\tan b = \\tan (90º - a) \\end{align} given an acute angle \\(a\\) is radians: \\begin{align} \\sin a = \\cos b = \\cos \\left(\\frac{\\pi}{2} - a\\right) \\end{align} \\begin{align} \\cos a = \\sin b = \\sin \\left(\\frac{\\pi}{2} - a\\right) \\end{align} \\begin{align} \\tan a = \\cot b = \\cot \\left(\\frac{\\pi}{2} - a\\right) \\end{align} \\begin{align} \\csc a = \\sec b = \\sec \\left(\\frac{\\pi}{2} - a\\right) \\end{align} \\begin{align} \\sec a = \\csc b = \\csc \\left(\\frac{\\pi}{2} - a\\right) \\end{align} \\begin{align} \\cot a = \\tan b = \\tan \\left(\\frac{\\pi}{2} - a\\right) \\end{align} reference angles a reference angle for an angle \\(\\theta\\), written \\(\\theta'\\), is the positive acute angle made by the terminal side of angle \\(\\theta\\) and the x-axis. if an angle \\(\\theta\\) is negative or has measure greater than \\(360°\\), its reference angle is found by first finding its coterminal angle that is between \\(0°\\) and \\(360°\\). finding trigonometric function values for a nonquadrantal angle \\(\\theta\\) if \\(\\theta > 360°\\), or if \\(\\theta < 0°\\), then find a coterminal angle. find the reference angle \\(\\theta'\\). find the trigonometric function values for reference angle \\(\\theta'\\). determine the correct signs for the values, given by the quadrant of \\(\\theta\\). $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/06_06.html",
    "title": "Solution of Linear Systems by Matrix Inverses",
    "body": " index search search back solution of linear systems by matrix inverses multiplicative inverses of square matrices in a similar way, if \\(a\\) is an \\(n \\times n\\) matrix, then its multiplicative inverse, written \\(a^{-1}\\), must satisfy both: \\begin{align} aa^{-1} = a^{-1}a = i_n \\end{align} this result means that only a square matrix can have a multiplicative inverse. the inverse matrix of an \\(n \\times n\\) matrix \\(a\\) (if it exists) can be found analytically by first forming the augmented matrix \\([a|i_n]\\) such that \\(ax = i_n\\), thus \\(x = a^{-1}\\). this means you are solving \\(n\\) systems of linear equations of the form \\(ax_i = i_{n_i}\\). this system is solved by performing matrix row operations, until the left side of the augmented matrix becomes the identity matrix. the resulting augmented matrix can be written as \\([i_n|a^{-1}]\\), where the right side of the matrix is \\(a^{-1}\\). if \\(a^{-1}\\) exists, then it is unique. if \\(a^{-1}\\) does not exist, then \\(a\\) is a singular matrix. using determinants to find inverses if \\begin{align} a = \\begin{bmatrix} a & b \\\\ c & d \\end{bmatrix} \\end{align} and \\(det(a) \\neq 0\\) then \\begin{align} a^{-1} = \\frac{1}{det(a)}\\begin{bmatrix} d & -b \\\\ -c & a \\end{bmatrix} \\end{align} if \\(det(a) = 0\\), then \\(a^{−1}\\) does not exist and \\(a\\) is a singular matrix. solving linear systems using inverse matrices to solve the matrix equation \\(ax = b\\), first see if \\(a^{-1}\\) exists. assuming that it does, use the facts that \\(a^{-1}a = i\\) and \\(ix = x\\). \\begin{align} ax = b \\end{align} \\begin{align} a^{-1}(ax) = a^{-1}b \\end{align} \\begin{align} (a^{-1}a)x = a^{-1}b \\end{align} \\begin{align} ix = a^{-1}b \\end{align} \\begin{align} x = a^{-1}b \\end{align} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/08_02.html",
    "title": "Trigonometric Functions and Fundamental Identities",
    "body": " index search search back trigonometric functions and fundamental identities trigonometric functions let \\((x, y)\\) be a point other than the origin on the terminal side of an angle \\(\\theta\\) instandard position. the distance from the point to the origin is \\(r = \\sqrt{x^2 + y^2}\\). the six trigonometric functions of \\(\\theta\\) are as follows: \\begin{align} \\sin \\theta = \\frac{y}{r} \\end{align} \\begin{align} \\cos \\theta = \\frac{x}{r} \\end{align} \\begin{align} \\tan \\theta = \\frac{y}{x}, x \\neq 0 \\end{align} \\begin{align} \\csc \\theta = \\frac{r}{y} \\end{align} \\begin{align} \\sec \\theta = \\frac{r}{x} \\end{align} \\begin{align} \\cot \\theta = \\frac{x}{y}, y \\neq 0 \\end{align} \\(\\sin \\theta = \\frac{y}{r}\\) is the same no matter which point is used to find it. refer to figure 28, which shows an angle \\(\\theta\\) and two distinct points on its terminal side. point \\(p\\) has coordinates \\((x, y)\\), and point \\(p'\\) with coordinates \\((x', y')\\). let \\(r\\) be the length of the hypotenuse of triangle \\(opq\\), and let \\(r'\\) be the length of the hypotenuse of triangle \\(op'q'\\). since corresponding sides of similar triangles are in proportion: \\begin{align} \\frac{y}{r} = \\frac{y'}{r'} = \\sin \\theta \\end{align} we can also find the trigonometric function values of an angle if we know the equation of the line coinciding with the terminal ray: \\begin{align} ax + by = 0 \\end{align} by choosing any point on the ray, we can find the trigonometric function values of the angle. in general, it is true that \\(m = \\tan \\theta\\). function values of quadrantal angles conditions for undefined function values if the terminal side of the quadrantal angle lies along the y-axis (\\(x\\) equals zero), then the tangent and secant functions are undefined. if the terminal side of the quadrantal angle lies along the x-axis (\\(y\\) equals zero), then the cotangent and cosecant functions are undefined. reciprocal identities the definitions of the trigonometric functions were written to illustrate that certain function pairs are reciprocals of each other. since: \\begin{align} \\sin \\theta = \\frac{y}{r} \\end{align} and \\begin{align} \\csc \\theta = \\frac{r}{y} \\end{align} then: \\begin{align} \\sin \\theta = \\frac{1}{\\csc \\theta} \\end{align} therefore, the reciprocal identities are listed below: \\begin{align} \\sin \\theta = \\frac{1}{\\csc \\theta} \\end{align} \\begin{align} \\cos \\theta = \\frac{1}{\\sec \\theta} \\end{align} \\begin{align} \\tan \\theta = \\frac{1}{\\cot \\theta} \\end{align} \\begin{align} \\csc \\theta = \\frac{1}{\\sin \\theta} \\end{align} \\begin{align} \\sec \\theta = \\frac{1}{\\cos \\theta} \\end{align} \\begin{align} \\cot \\theta = \\frac{1}{\\tan \\theta} \\end{align} signs and ranges of function values a point \\((x, y)\\) in quadrant ii has \\(x < 0\\) and \\(y > 0\\). this makes the values of sine and cosecant positive for quadrant ii angles, while the other four functions take on negative values. similar results can be obtained for the other quadrants, as summarized here. in figure 37 we can see that as the measure of the angle increases, \\(y\\) increases, but never exceeds \\(r\\), so \\(y \\leq r\\). in a similar way, angles in quadrant iv suggest that \\(-r \\leq y\\). therefore: \\begin{align} -r \\leq y \\leq r \\end{align} \\begin{align} -1 \\leq \\frac{y}{r} \\leq 1 \\end{align} \\begin{align} -1 \\leq \\sin \\theta \\leq 1 \\end{align} similar reasoning leads to the following: \\begin{align} -1 \\leq \\cos \\theta \\leq 1 \\end{align} the tangent of an angle is defined as \\(\\frac{y}{x}\\). it is possible that \\(x < y\\), \\(x = y\\), or \\(x > y\\). for this reason, \\(\\frac{y}{x}\\) can take any value, so \\(\\tan \\theta\\) can be any real number, as can \\(\\cot \\theta\\). the functions \\(\\sec \\theta\\) and \\(\\csc \\theta\\) are reciprocals of the functions \\(\\cos \\theta\\) and \\(\\sin \\theta\\), respectively, making the following true: \\begin{align} \\sec \\theta \\leq -1 \\text{ or } \\sec \\theta \\geq 1 \\end{align} and \\begin{align} \\csc \\theta \\leq -1 \\text{ or } \\csc \\theta \\geq 1 \\end{align} pythagorean identities given \\(x^2 + y^2 = r^2\\), then: \\begin{align} \\frac{x^2}{r^2} + \\frac{y^2}{r^2} = \\frac{r^2}{r^2} \\end{align} \\begin{align} \\left(\\frac{x}{r}\\right)^2 + \\left(\\frac{y}{r}\\right)^2 = 1 \\end{align} \\begin{align} \\left(\\cos \\theta\\right)^2 + \\left(\\sin \\theta\\right)^2 = 1 \\end{align} similarly: \\begin{align} \\frac{x^2}{x^2} + \\frac{y^2}{x^2} = \\frac{r^2}{x^2} \\end{align} \\begin{align} 1 + \\left(\\frac{y}{x}\\right)^2 = \\left(\\frac{r}{x}\\right)^2 \\end{align} \\begin{align} 1 + \\left(\\tan \\theta\\right)^2 = \\left(\\sec \\theta\\right)^2 \\end{align} similarly: \\begin{align} \\frac{x^2}{y^2} + \\frac{y^2}{y^2} = \\frac{r^2}{y^2} \\end{align} \\begin{align} \\left(\\frac{x}{y}\\right)^2 + 1 = \\left(\\frac{r}{y}\\right)^2 \\end{align} \\begin{align} \\left(\\cot \\theta\\right)^2 + 1 = \\left(\\csc \\theta \\right)^2 \\end{align} quotient identities consider the quotient of \\(\\sin \\theta\\) and \\(\\cos \\theta\\): \\begin{align} \\frac{\\sin \\theta}{\\cos \\theta} = \\frac{\\frac{y}{r}}{\\frac{x}{r}} = \\frac{y}{x} = \\tan \\theta \\end{align} where \\(\\cos \\theta \\neq 0\\). similarly: \\begin{align} \\frac{\\cos \\theta}{\\sin \\theta} = \\frac{\\frac{x}{r}}{\\frac{y}{r}} = \\frac{x}{y} = \\cot \\theta \\end{align} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/07_04.html",
    "title": "Parametric Equations",
    "body": " index search search back parametric equations a plane curve is a set of points \\((x, y)\\) such taht \\(x= f(t)\\), \\(y = g(t)\\) and \\(f\\) and \\(g\\) are both continuous on an interval \\(i\\). the equations \\(x = f(t)\\) and \\(y = g(t)\\) are parametric equations with parameter \\(t\\). graphing a parabola defined parametrically graph the plane curve \\(x = t^2, y = 2t + 3\\) for \\(t \\in [-3, 3]\\). make a table of corresponding values of \\(t\\), \\(x\\), and \\(y\\) over the domain of \\(t\\). \\(t\\) \\(x\\) \\(y\\) \\(-3\\) \\(9\\) \\(-3\\) \\(-2\\) \\(4\\) \\(-1\\) \\(-1\\) \\(1\\) \\(1\\) \\(0\\) \\(0\\) \\(3\\) \\(1\\) \\(1\\) \\(5\\) \\(2\\) \\(4\\) \\(7\\) \\(3\\) \\(9\\) \\(9\\) then plot the points. to find an equivalent rectangular equation, we eliminate the parameter \\(t\\). \\begin{align} y = 2t + 3 \\end{align} \\begin{align} y - 3 = 2t \\end{align} \\begin{align} \\frac{y - 3}{2} = t \\end{align} now we substitute the result in the first equation \\(x = t^2\\): \\begin{align} x = t^2 = \\left(\\frac{y - 3}{2}\\right)^2 = \\frac{(y - 3)^2}{4} = \\frac{1}{4}(y-3)^2 \\end{align} this is indeed an equation of a horizontal parabola that opens to the right. because \\(t\\) is in \\([3, -3]\\), \\(x\\) is in \\([3, 0]\\), and \\(y\\) is in \\([-3, 9]\\). the rectangular equation must be given with its restricted domain as: \\begin{align} x = \\frac{1}{4}(y-3)^2, \\text{ for } x \\in [0, 9] \\end{align} $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/index.html",
    "title": "A Graphical Approach to Algebra and Trigonometry",
    "body": " index search search back a graphical approach to algebra and trigonometry linear functions, equations and inequalities analysis of graphs of functions polynomial functions rational, power and root functions inverse, exponential and logarithmic functions systems and matrices systems of equations solutions of linear systems in three variables solution of linear systems by row transformations matrix properties and operations determinants and cramer's rule solution of linear systems by matrix inverses systems of inequalities and linear programming partial fractions analytic geometry and nonlinear systems circles and parabolas ellipses and hyperbolas the conic sections and nonlinear systems parametric equations trigonometric functions and applications. angles and their measures trigonometric functions and fundamental identities right triangles and evaluating trigonometric functions applications of right triangles $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/08_04.html",
    "title": "Applications of Right Triangles",
    "body": " index search search back applications of right triangles the results of physical measurements are only approximately accurate and depend on the precision of the measuring instrument as well as the aptness of the observer. the digits obtained by actual measurement are called significant digits. solving triangles to solve a triangle means to find the measures of all the angles and sides of the triangle. angles of elevation or depression the angle of elevation from point \\(x\\) to point \\(y\\) (above \\(x\\)) is the acute angle formed by ray \\(xy\\) and a horizontal ray with endpoint at \\(x\\) (see figure 61). the angle of depression from point \\(x\\) to point \\(y\\) (below \\(x\\)) is the acute angle formed by ray \\(xy\\) and a horizontal ray with endpoint \\(x\\) (see figure 62). bearing when a single angle is given, such as \\(164°\\), it is understood that the bearing is measured in a clockwise direction from due north (see figure 64). the second method for expressing bearing starts with a north–south line and uses an acute angle to show the direction, either east or west, from this line (see figure 66). $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/06_04.html",
    "title": "Matrix Properties and Operations",
    "body": " index search search back matrix properties and operations in general, a matrix with \\(m\\) rows and \\(n\\) columns has dimension \\(m \\times n\\). the number of rows is always given first certain matrices have special names. an \\(n \\times n\\) matrix is a square matrix of order n. also, a matrix with just one row is a row matrix, and a matrix with just one column is a column matrix. two matrices are equal if they have the same dimension and if corresponding elements, position by position, are equal a matrix containing only zeros as elements is called a zero matrix. matrix addition the sum of two \\(m \\times n\\) matrices \\(a\\) and \\(b\\) is the \\(m \\times n\\) matrix \\(a + b\\) in which each element is the sum of the corresponding elements of \\(a\\) and \\(b\\). only matrices with the same dimension can be added. multiplication of a matrix by a scalar the product of a scalar \\(k\\) and a matrix \\(a\\) is the matrix \\(ka\\), each of whose elements is \\(k\\) times the corresponding element of \\(a\\). matrix multiplication the product \\(ab\\) of an \\(m \\times n\\) matrix \\(a\\) and an \\(n \\times k\\) matrix \\(b\\) is an \\(m \\times k\\) matrix and is found as follows. to find the \\(i\\)th row, \\(j\\)th column element of \\(ab\\), multiply each element in the \\(i\\)th row of \\(a\\) by the corresponding element in the \\(j\\)th column of \\(b\\). the sum of these products gives the element of row \\(i\\), column \\(j\\) of \\(ab\\). \\begin{align} c_{ij} = \\sum_{k=1}^{n} a_{ik}b_{kj} \\end{align} the product ab can be found only if the number of columns of a is the same as the number of rows of b. the final product will have as many rows as a and as many columns as b. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/06_07.html",
    "title": "Systems of Inequalities and Linear Programming",
    "body": " index search search back systems of inequalities and linear programming a line divides a plane into three sets of points: the points of the line itself the points belonging to the two regions determined by the line. each of these two regions is called a half plane. the line is the boundary of each half plane. solving linear inequalities a linear inequality in two variables is an inequality of the form \\begin{align} ax + by \\leq c, \\end{align} where \\(a\\), \\(b\\), and \\(c\\) are real numbers with \\(a\\) and \\(b\\) not both equal to \\(0\\). (the symbol \\(\\leq\\) be replaced with \\(\\geq\\), \\(>\\) or \\(<\\)). graphing a linear inequality graph \\(x + 4y 7 > 4\\). the boundary here is the line \\(x + 4y = 4\\). since the points on this line do not satisfy \\(x + 4y = 4\\), make the line dashed. to decide which half plane represents the solution, solve for \\(y\\). such that \\(y > -\\frac{1}{4}x + 1\\) since \\(y\\) is greater than \\(-\\frac{1}{4}x + 1\\), the graph of the solution set is the half plane above the boundary two methods for graphing an inequality for a function \\(f\\), the graph of \\(y < f(x)\\) consists of all the points that are below the graph of y = ƒ(x). the graph of \\(y > f(x)\\) consists of all the points that are above the graph of \\(y = f(x)\\). if the inequality is not or cannot be solved for \\(y\\), choose a test point not on the boundary. if the test point satisfies the inequality, the graph includes all points on the same side of the boundary as the test point. otherwise, the graph includes all points on the other side of the boundary. soliving systems of inequalitites the solution set of a system of inequalities is the intersection of the solution sets of its members graph the solution set of the system. \\begin{align} x > 6 - 2y \\end{align} \\begin{align} x^2 < 2y \\end{align} the next figures show the graphs for both inequalities as well as the solution set, that is the intersection of the regions that represent the solution set for each inequality. linear programming we use linear programming to find an optimum value. a linear programming problem typically needs the definition of the following concepts: the restrictions of the problem, usually a system of inequalitites, that conform the constraints. an objetive function, which is the function we aim to optimize. the region of feasible solutions that is the set of values for \\(x\\) and \\(y\\) that satisfy all constraints. fundamental theorem of linear programming if the optimal value for a linear programming problem exists, it occurs at a vertex of the region of feasible solutions. solving a linear programming problem write the objective function and all necessary constraints. graph the region of feasible solutions. identify all vertices (corner points). evaluate the objective function at each vertex. the solution is given by the vertex producing the optimal value of the objective function. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/08_01.html",
    "title": "Angles and Their Measures",
    "body": " index search search back angles and their measures basic terminology two distinct points \\(a\\) and \\(b\\) determine a line called line \\(ab\\). the portion of the line between \\(a\\) and \\(b\\), including points \\(a\\) and \\(b\\), is segment \\(ab\\). the portion of line \\(ab\\) that starts at \\(a\\) and continues through \\(b\\) and on past \\(b\\) is called ray \\(ab\\). point \\(a\\) is the endpoint of the ray. in trigonometry, an angle consists of two rays in a plane with a common endpoint, or two line segments with a common endpoint. these two rays (or segments) are called the sides of the angle and the common endpoint is called the vertex of the angle. associated with an angle is its measure, generated by a rotation about the vertex. this measure is determined by rotating a ray starting at one side of the angle, called the initial side, to the position of the other side, called the terminal side. a counterclockwise rotation generates an angle with positive measure, while a clockwise rotation generates an angle with negative measure. degree measure the most common unit used to measure the size of angles is the degree. we assign \\(360\\) degrees to a complete rotation of a ray. an angle measuring between \\(0\\)° and \\(90\\)° is an acute angle. an angle measuring exactly \\(90\\)° is a right angle. an angle measuring more than \\(90\\)° but less than \\(180\\)° is an obtuse angle, and an angle of exactly \\(180\\)° is a straight angle. if the sum of the measures of two positive angles is \\(90°\\), the angles are called complementary and the angles are complements. two positive angles with measures whose sum is \\(180°\\) are supplementary and the angles are supplements. one minute, written \\(1'\\), is \\(\\frac{1}{60}\\) of a degree and one second, \\(1''\\), is \\(\\frac{1}{60}\\) of a minute.however angles are commonly measured in decimal degrees. standard position and coterminal angles an angle is in standard position if its vertex is at the origin and its initial side is along the positive x-axis. the angles in (a) and (b) are in standard position. an angle in standard position is said to lie in the quadrant in which its terminal side lies, such as angles with measures \\(90°\\), \\(180°\\), \\(270°\\), and so on, are called quadrantal angles. if the terminal side lies along an axis, then the angle does not lie in any quadrant. for example, an acute angle is in quadrant i (a) and an obtuse angle is in quadrant ii (b). the angles whose measures differ by a multiple of \\(360º\\) are called coterminal angles. radian measure an angle with vertex at the center of a circle that intercepts an arc on the circle equal in length to the radius of the circle has measure \\(1\\) radian. an angle \\(\\theta\\) whose vertex is at the center of a circle is called central angle. in general, if \\(\\theta\\) is a central angle in a circle of radius \\(r\\), and \\(\\theta\\) intercepts an arc of lengt \\(s\\), the radian measure of \\(\\theta\\) is \\(\\frac{s}{r}\\). degree to radian conversion we know that the circumference of a circle is given by \\(c = 2\\pi r\\), where \\(r\\) is the radius. this shows that the radius can be laid \\(2\\pi\\) times around the circle. therefore, an angle of \\(360°\\), which corresponds to a complete circle, intercepts an arc equal in length to \\(2\\pi\\) times the radius of the circle. thus, an angle of \\(360º\\) has measure \\(2\\pi\\). \\begin{align} 360º = 2\\pi \\text{ radians} \\end{align} to convert a degree measure to radians multiply the degree measure by \\(\\frac{2\\pi}{360} = \\frac{\\pi}{180}\\) to convert a radian measure to degrees multiply the radian measure by \\(\\frac{360}{2\\pi} = \\frac{180}{\\pi}\\) arc lengths and areas of sectors in the following figure angle \\(qop\\) has measure \\(1\\) radian and intercepts an arc of length \\(r\\). while angle \\(rot\\) has measure \\(\\theta\\) radians and intercepts an arc of length \\(s\\). since the lengths of the arcs are proportional to the measures of their central angles: \\begin{align} \\frac{s}{r} = \\frac{\\theta}{1} \\end{align} \\begin{align} s = r\\theta \\end{align} a sector of a circle is the portion of the interior of a circle intercepted by a central angle. the interior of a circle can be thought of as a sector intercepted by a central angle of measure \\(2\\pi\\) radians. if a central angle for a sector has measure \\(\\theta\\) radians, then the sector makes up the fraction \\(\\frac{\\theta}{2\\pi}\\) of a complete circle. the area inside a circle with radius \\(r\\) is \\(\\mathcal{a} = \\pi r^2\\), therefore, the area of the sector is given by the product of the fraction \\(\\frac{\\theta}{2\\pi}\\) and the total area: \\[ \\mathcal{a} = \\frac{\\theta}{2\\pi}(\\pi r^2) = \\frac{1}{1}r^2 \\theta, \\theta \\text{ in radians} \\] linear and angular speed suppose that point \\(p\\) moves at a constant speed along a circle of radius \\(r\\) and center \\(o\\). the measure of how fast the position of \\(p\\) is changing is called linear speed. if \\(v\\) represents linear speed, then: \\begin{align} v = \\frac{s}{t} \\end{align} where \\(s\\) is the length of the arc traced by point \\(p\\) in time \\(t\\). (this formula is just a restatement of \\(d = rt\\) with \\(s\\) as distance, \\(v\\) as rate (speed), and \\(t\\) as time.) as point \\(p\\) moves along the circle, ray \\(op\\) rotates around the origin, so the speed at which the measure ofthe angle changes is called angular speed, \\(\\omega\\) and is given by: \\begin{align} \\omega = \\frac{\\theta}{t}, \\theta \\text{ in radians} \\end{align} where \\(\\theta\\) is the measure of angle \\(pob\\). to relate linear and angular speeds we use the result \\(s = r\\theta\\), therefor: \\begin{align} v = \\frac{s}{t} = \\frac{r\\theta}{t} = r \\frac{\\theta}{t} = r \\omega \\end{align} appendix latitude gives the measure of a central angle with vertex at earth's center whose initial side goes through the equator and whose terminal side goes through the given location (basically like north-south orientation). $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/06_08.html",
    "title": "Partial Fractions",
    "body": " index search search back partial fractions decomposition of rational expressions partial fraction decomposition of \\(\\frac{f(x)}{g(x)}\\) if \\(\\frac{f(x)}{g(x)}\\) is not a proper fraction (a fraction whose numerator is lesser degree than it denominator) divide \\(f(x)\\) by \\(g(x)\\). for example \\begin{align} \\frac{x^4 - 3x^3 + x^2 + 5x}{x^2 + 3} = x^2 - 3x - 2 + \\frac{14x + 6}{x^2 + 3} \\end{align} then appy the following steps to the remainder. factor the denominator \\(g(x)\\) into factors of the form \\((ax + b)^m\\) or \\((cx^2 + dx + e)^n\\). for each distinct linear factor \\((ax + b)\\), the decomposition must include the term \\frac{a}{ax + b}. for each repeated linear factor \\((ax + b)^m\\), the decomposition must include the terms: \\begin{align} \\frac{a_1}{(ax + b)} + \\frac{a_2}{(ax + b)^2} + \\cdots + \\frac{a_m}{(ax + b)^m} \\end{align} for each distinct quadratic factor \\((cx^2 + dx + e)\\), the decomposition must include the term \\(\\frac{bx + c}{cx2 + dx + e}\\) for each repeated quadratic factor \\((cx^2 + dx + e)^n\\), the decomposition must include the terms: \\begin{align} \\frac{b_1x + c_1}{(cx^2 + dx + e)} + \\frac{b_2x + c_2}{(cx^2 + dx + e)^2} + \\cdots + \\frac{b_nx + c_n}{(cx^2 + dx + e)^n} \\end{align} use algebraic techniques to solve for the constants in the numerators of the decomposition. techniques for decomposition into partial fractions for linear factors multiply each side of the resulting rational equation by the common denominator. substitute the zero of each factor into the resulting equation. for repeated linear factors, substitute as many other numbers as is necessary to find all the constants in the numerators. the number of substitutions required will equal the number of constants \\(a, b, \\cdots\\). for example: \\begin{align} \\frac{f(x)}{(x-1)(x-2)} = \\frac{a}{(x-1)} + \\frac{b}{(x - 2)} = \\frac{a(x-2) + b(x-1)}{(x-2)(x-1)} \\end{align} multiply both sides by \\((x-1)(x-2)\\): \\begin{align} f(x) = a(x-2) + b(x-1) \\end{align} solve for \\(x = 2\\): \\begin{align} f(2) = a(0) + b(1) \\end{align} and then solve for \\(x = 1\\): \\begin{align} f(1) = a(-1) + b(0) \\end{align} for quadratic factors multiply each side of the resulting rational equation by the common denominator. collect terms on the right side of the equation. equate the coefficients of like terms to get a system of equations. solve the system to find the constants in the numerators. for example: \\begin{align} \\frac{x^2 + 3x - 1}{(x + 1)(x^2 + 2)} = \\frac{a}{(x + 1)} + \\frac{bx + c}{(x^2 + 2)} \\end{align} multiply each side by \\((x + 1)(x^2 + 2)\\): \\begin{align} x^2 + 3x - 1 = a(x^2 + 2) + (bx + c)(x + 1) \\end{align} collect the terms on each side of the equation: \\begin{align} x^2 + 3x - 1 = ax^2 + a2 + bx^2 + bx + cx + c = x^2 (a + b) + x (b + c) + 2a + c \\end{align} equate the coefficients of like terms to get a system of equations: \\begin{align} (a + b) = 1 \\end{align} \\begin{align} (b + c) = 3 \\end{align} \\begin{align} 2a + c = -1 \\end{align} solving this system for \\(a\\), \\(b\\), and \\(c\\) would give the partial fraction decomposition. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/Pre-Calculus/AGAA/07_01.html",
    "title": "Circles and Parabolas",
    "body": " index search search back circles and parabolas conic sections parabolas, circles, ellipses, and hyperbolas form a group of curves known as the conic sections, because they are the result of intersecting a cone with a plane. circle a circle is a set of points in a plane that are equidistant from a fixed point. the distance is called the radius of the circle, and the fixed point is called the center. suppose a circle has center \\((h, k)\\) and radius \\(r > 0\\). then the distance between the center \\((h, k)\\) and any point \\((x, y)\\) on the circle must equal \\(r\\). thus, an equation of the circle is as follows: \\begin{align} \\sqrt{(x - h)^2 + (y - k)^2} = r \\end{align} \\begin{align} (x - h)^2 + (y - k)^2 = r^2 \\end{align} therefore the center–radius form of the equation of a circle with center \\((h, k)\\) and radius \\(r\\) is: \\begin{align} (x - h)^2 + (y - k)^2 = r^2 \\end{align} notice that a circle is the graph of a relation that is not a function. a circle with center \\((0, 0)\\) and radius \\(r\\) has equation: \\begin{align} x^2 + y^2 = r^2 \\end{align} general form of the equation of a circle for real numbers \\(c\\), \\(d\\), and \\(e\\), the equation: \\begin{align} x^2 + y^2 + cx + dy + e = 0 \\end{align} can have a graph that is a circle, that is a point, or that is empty (contains no points.) starting with an equation in this general form, we can work in reverse by completing the square to get an equation of the form: \\begin{align} (x - h)^2 + (y - k)^2 = m \\text{ for some } m \\end{align} there are three possibilities for the graph, based on the value of \\(m\\): if \\(m > 0\\), then \\(r^2 = m\\), and the equation represents a circle with radius \\(\\sqrt{m}\\). if \\(m = 0\\), the equation represents the single point \\((h, k)\\). if \\(m < 0\\), no points satisfy the equation and the graph is empty. parabola a parabola is a set of points in a plane equidistant from a fixed point and a fixed line. the fixed point is called the focus, and the fixed line the directrix, of the parabola. we can find an equation of a parabola from the preceding definition. let the directrix be the line \\(y = -c\\) and the focus be the point \\(f\\) with coordinates \\((0, c)\\). given a point \\(p\\) on the parabola, with coordinates \\((x, y)\\), using the distance formula gives the following result: \\begin{align} d(p, f) = d(p, d) \\end{align} \\begin{align} \\sqrt{(x - 0)^2 + (y - c)^2} = \\sqrt{(x - x)^2 + [y - (-c)]^2} \\end{align} \\begin{align} x^2 + (y - c)^2 = [y +c]^2 \\end{align} \\begin{align} x^2 + (y - c)^2 = (y + c)^2 \\end{align} \\begin{align} x^2 + y^2 + c^2 - 2cy = y^2 + c^2 + 2cy \\end{align} \\begin{align} x^2 = 4cy \\end{align} the focal chord through the focus and perpendicular to the axis of symmetry of a parabola is called the latus rectum, and has length \\(|4c|\\). to see this, note in the previous image that the endpoints of the chord are \\((-x, c)\\) and \\((x, c)\\). let \\(y = c\\) in the equation of the parabola and solve for \\(x\\). \\begin{align} x^2 = 4cy \\end{align} \\begin{align} x^2 = 4c^2 \\end{align} \\begin{align} x = |2c| \\end{align} the length of half the focal chord is |2c| (from x = 0 to x = 2c or x = -2c) , so its full length is |4c|. parabola with a horizontal axis and vertex \\((0, 0)\\) the parabola with focus \\((c, 0)\\) and directrix \\(x = -c\\) has equation: \\begin{align} y^2 = 4cx \\end{align} the parabola has vertex \\((0, 0)\\), horizontal axis \\(y = 0\\), and opens to the right if \\(c > 0\\) or to the left if \\(c < 0\\). notice that the graph of a parabola with a horizontal axis is not a function. equation forms for translated parabolas a parabola with vertex \\((h, k)\\) has an equation of the form: vertical axis: \\begin{align} (x - h)^2 = 4c(y - k) \\end{align} horizontal axis: \\begin{align} (y - k)^2 = 4c(x - h) \\end{align} where the focus is a distance \\(|c|\\) from the vertex: $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Notes/Math/index.html",
    "title": "Math",
    "body": " index search search back math pre-calculus a graphical approach to algebra and trigonometry $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Study/DataScience/google-analytics.html",
    "title": "Google Data Analyst Certificate",
    "body": " index search search back google data analyst certificate source foundations: data, data, everywhere introducing data analytics all about analytical thinking the wonderful world of data set up your toolbox endless career possibilities ask questions to make data-driven decisions effective questions data driven decisions more spreadsheets basics always remember the stakeholder prepare data for exploration data types and structures bias, credibility, privacy, ethics and access databases: where data lives organizing and protecting your data optional: engaging in the data community process data from dirty to clean the importance of integrity sparkling-clean data cleaning data with sql verify and report on your cleaning results optional: adding data to your resume course challenge analyze data to answer questions organizing data to begin analysis formatting and adjusting data aggregating data for analysis performing data calculations share data through the art of visualization visualizing data creating data visualization with tableau crafting data stories developing presentations and slideshows data analysis with r programming programming and data analytics programming using rstudio working with data in r more about visualizations, aesthetics, and annotations documentations and reports google data analytics capstone: complete a case study learn about capstone basics optional: building your portfolio optional: using your portfolio putting your certificate to work $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Study/DataScience/freecodecamp.html",
    "title": "FreeCodeCamp",
    "body": " index search search back freecodecamp source there are data visualization, machine learning, data analysis in python courses $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Study/DataScience/index.html",
    "title": "Data Science Study Guide",
    "body": " index search search back data science study guide practical courses google data analyst certificate (absolutely useless) ibm data analyst certificate freecodecamp kaggle courses topics mainly covered in mathematics for machine learning: optimization linear algebra (orthogonal matrices) books to study in this order: mathematics for machine learning pattern recognition and machine learning $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Study/DataScience/ibm-analytics.html",
    "title": "IBM Data Science Certificate",
    "body": " index search search back ibm data science certificate source $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Study/index.html",
    "title": "Study",
    "body": " index search search back study study guides math cs datascience web development course plan current college algebra: start from chapter 2 nand2tetris review react do the react crash course. do the redux crash course choose the markdown previewer or the 25 + 5 clock (or both!!!! or neither!!!) future ordered by priority, one choose one at a time backend dev spring boot (list of courses): do the spring course (max 2 weeks) projects do the back end dev course from freecodecamp (max a week) continue the bookish project (add graphql) learn c++ tutorialspoints course (max a week) learn how to use cmake search for projects, some are: data structure data analysis with python course from freecodecamp data visualization course from freecodecamp review college subject on machine learning notes practice projects (add snippets to notes) to search for more project go to project ideas, there are project listings for a lot of languages, frameworks. achive copy ml notes (at least 1h a day) read math for machine learning finish sicp berkeley (at least 1h a day) $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Study/CS/Computer Architecture.html",
    "title": "Computer Architecture",
    "body": " index search search back computer architecture todo nand2tetris computer systems: a programmer's perspective resources nand2tetris each chapter involves building a small piece of the overall system, from writing elementary logic gates in hdl, through a cpu and assembler, all the way to an application the size of a tetris game. the elements of computing systems (nand2tetris) part i: hardware course on coursera part ii: software course on coursera we recommend reading through the first six chapters of the book and completing the associated projects. this will develop your understanding of the relationship between the architecture of the machine and the software that runs on it. in seeking simplicity and cohesiveness, nand2tetris trades off depth. in particular, two very important concepts in modern computer architectures are pipelining and memory hierarchy, but both are mostly absent from the text. computer systems: a programmer's perspective most courses go from chapter 1 to 6. do this course $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Study/CS/Operating Systems.html",
    "title": "Operating Systems",
    "body": " index search search back operating systems books operating systems: three easy pieces labs: xv6 labs $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Study/CS/Mathematics for Computer Science.html",
    "title": "Mathematics for Computer Science",
    "body": " index search search back mathematics for computer science books mit lecture notes video lectures mit video lectures $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Study/CS/Algorithms and Data Structures.html",
    "title": "Algorithms and Data Structures",
    "body": " index search search back algorithms and data structures books the algorithm design manual video lectures skiena's or tim's on coursera practice: leetcode problem solving book after the manual: how to solve it $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Study/CS/index.html",
    "title": "Computer Science",
    "body": " index search search back computer science source programming computer architecture algorithms and data structures mathematics for computer science operating systems computer networking databases languages and compilers distributed systems ai and machine learning ai and machine learning check the source. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Study/CS/Computer Networking.html",
    "title": "Computer Networking",
    "body": " index search search back computer networking books computer networking: a top-down approach video lectures standford: introduction to computer networking course labs: wireshark labs $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Study/CS/Programming.html",
    "title": "Programming",
    "body": " index search search back programming books structure and interpretation of computer programs video lectures brian harvey’s sicp lectures resources for the berkley course code online on scheme scheme on arch (download mit/gnu scheme) plan 1 notes notes we recommend working through at least the first three chapters of sicp and doing the exercises. for additional practice, work through a set of small programming problems like those on exercism. alternatives same course but with python instead of scheme (stk) books: composing programs lectures: 61a taught by john denero at berkley. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Study/CS/Databases.html",
    "title": "Databases",
    "body": " index search search back databases start with the recording and the go through the book (paper compilation) video lectures cs186b berkley book readings in database systems data modelling book: data and reality: a timeless perspective on perceiving and managing information in our imprecise world. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Study/CS/Distributed Systems.html",
    "title": "Distributed Systems",
    "body": " index search search back distributed systems books practice oriented: designing data-intensive applications more traditional: distributed systems, 3rd edition $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Study/CS/Languages and Compilers.html",
    "title": "Languages and Compilers",
    "body": " index search search back languages and compilers books introductory: crafting interpreters as supplementary reference for video lectures: compilers: principles, techniques & tools video lecutres alex aiken’s, on edx notes for introductory book: we suggest taking the time to work through the whole thing, attempting whichever of the \"challenges\" sustain your interest. $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/src/Study/Math/index.html",
    "title": "Math",
    "body": " index search search back math first year first semester dicrete maths discrete mathematics with applications, 2nd edition by susanna s. epp discrete mathematics structures, 4th edition by kolman, busby and ross proof writing (very advanced, do not expect to master anything in these books) mathematical proofs: a transition to advanced mathematics by gary chartrand et. al (this one is better than the next one) an introduction to abstract mathematics by robert j. bond and wiliam j. keane second semester pre-algebra (refresh really basic math) ags pre-algebra (has solutions) fearon's pre-algebra (this one is better) college algebra (after the pre-algebra one, if the pre-algebra books are too easy skip onto these ones) college algebra by kaufmann (more begginer friendly) college algebra by blitzer second year first semester pre-calculus (once you are done with college algebra. if you know some basic algebra you can skip the college algebra and start in this section) a graphical approach to algebra and trigonometry by hornsby, lial, and rockswold. 6th edition (get the instructor's edition) second semester calculus calculus by james stewart, 5th edition (very famous book, to learn basic calculus. it has a lot of problems. used to teach calculus i, ii and iii) calculus by michael spivak, 3rd edition (it has less material but it is more advanced) third year first semester differential equations a first course in differential equations by zill ordinary differential equations with applications by andrews (it is easier, good for beginners) linear algebra (try to learn as much as possible) elementary linear algebra by howard anton (beginner friendly, with exercises) linear algebra by friedgber, insel, and spence (it is harder and more difficult to read. it is proof based) second semester statistics mathematical statistics by wackerly, mendenhall, and scheaffer a first course in probability by ross complex analysis (calculus with complex numbers. both are pretty much the same, very good beginner books) fundamentals of complex analysis by saff and snider, 3rd edition complex variables and applications by brown and churchill, 7th edition fourth year first semester real analysis (one of the hardest subjects) analysis 1 and analysis 2 by terrance tao (easier to read, but the other two are standard) advanced calculus by fitzpatrick principles of mathematical analysis by rudin elements ofanalysis by ross (expends a lot of time for proofs) abstract algebra (study of groups, rings and fields. very proof based) abstract algebra by saracino (very good for beginners) contemporary abstract algebra by gallian (also good for beginners) second semester topology (optional) introduction to topology by gamelin and greene (it has full solutions for all of the problems) combinatorics (optional) applied combinatorics by tucker naive set theory (optional) naive set theory by halmos functional analysis (optional) functional analysis by kreyszig graph theory (optional) graph theory by gould $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  },
  {
    "id": "https://albamr09.github.io/index.html",
    "title": "Registry Index",
    "body": " index search search registry index notes study $(\"pre\").each(function (index, item) { $(item).html(\"<code>\" + $(item).html() + \"</code>\"); }); hljs.highlightall(); "
  }
]