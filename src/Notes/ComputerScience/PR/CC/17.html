<html><head>
    <!-- Normal styling from vimwiki -->
    <link rel="Stylesheet" type="text/css" href="../../../../../src/style/index.css">
    <!-- Custom styling from vimwiki -->
    <link rel="Stylesheet" type="text/css" href="../../../../../src/style/custom.css">
    <title>Smells and Heuristics</title>
  <link rel="icon" type="image/svg+xml" href="https://albamr09.github.io/public/icon.svg" data-description="Page icon"><script type="text/javascript" src="https://polyfill.io/v3/polyfill.min.js?features=es6" id="latex_script" data-description="Support for latex"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script" data-description="Support for latex"></script><link rel="Stylesheet" type="text/css" href="https://albamr09.github.io/src/style/search.css" data-description="Styling for search"><link rel="Stylesheet" type="text/css" href="https://albamr09.github.io/src/style/atom-one-light.min.css" data-description="Code highlight"></head>
  <body>
    <a href="https://albamr09.github.io/" style="
        color: white;
        font-weight: bold;
        text-decoration: none;
        padding: 3px 6px;
        border-radius: 3px;
        background-color: #1e90ff;
        text-transform: uppercase;
      ">Index</a>
    <form id="search_form" class="search-form">
      <input required="" type="search" id="search_term" class="searchTerm">
      <button type="submit" class="searchButton">Search</button>
    </form>
    <div id="search-background" class="search-background">
      <div id="search-result" class="search-result-hide"></div>
      <div id="search-form-modal" class="search-form-modal">
        <form id="search-form-in-modal">
          <input required="" type="search" id="search-input-in-modal" class="search-input-in-modal" placeholder="Search whatever...">
          <button type="submit" class="searchButton">Search</button>
        </form>
      </div>
    </div>
    <hr>
    <div class="content">
<p>
<a href="index.html">Back</a>
</p>

<div id="Smells and Heuristics"><h1 id="Smells and Heuristics" class="header"><a href="#Smells and Heuristics">Smells and Heuristics</a></h1></div>

<hr>

<div id="Contents" class="toc"><h2 id="Contents" class="header"><a href="#Contents">Contents</a></h2></div>
<ul>
<li>
<a href="17.html#Comments">Comments</a>

</li><li>
<a href="17.html#Environment">Environment</a>

</li><li>
<a href="17.html#Functions">Functions</a>

</li><li>
<a href="17.html#General">General</a>

</li><li>
<a href="17.html#Names">Names</a>

</li><li>
<a href="17.html#Tests">Tests</a>

</li></ul>
<hr>

<div id="Smells and Heuristics-Comments"><h2 id="Comments" class="header"><a href="#Smells and Heuristics-Comments">Comments</a></h2></div>

<p>
<span id="Smells and Heuristics-Comments-Innapropiate Information"></span><strong id="Innapropiate Information">Innapropiate Information</strong>
</p>

<p>
It is inappropriate for a comment to hold information better held in a different kind of system such as your source code control system, your issue tracking system, or any other record-keeping system. Comments should be reserved for technical notes about the code and design.
</p>

<p>
<span id="Smells and Heuristics-Comments-Obsolete Comment"></span><strong id="Obsolete Comment">Obsolete Comment</strong>
</p>

<p>
A comment that has gotten old, irrelevant, and incorrect is obsolete. If you find an obsolete comment, it is best to update it or get rid of it as quickly as possible.
</p>

<p>
<span id="Smells and Heuristics-Comments-Redundant Comment"></span><strong id="Redundant Comment">Redundant Comment</strong>
</p>

<p>
A comment is redundant if it describes something that adequately describes itself. Comments should say things that the code cannot say for itself.
</p>

<p>
<span id="Smells and Heuristics-Comments-Poorly Written Comment"></span><strong id="Poorly Written Comment">Poorly Written Comment</strong>
</p>

<p>
A comment worth writing is worth writing well. Be brief.
</p>

<p>
<span id="Smells and Heuristics-Comments-Commented-Out Code"></span><strong id="Commented-Out Code">Commented-Out Code</strong>
</p>

<p>
When you see commented-out code, delete it! Don’t worry, the source code control system still remembers it.
</p>

<div id="Smells and Heuristics-Environment"><h2 id="Environment" class="header"><a href="#Smells and Heuristics-Environment">Environment</a></h2></div>

<p>
<span id="Smells and Heuristics-Environment-Build Requires More Than One Step"></span><strong id="Build Requires More Than One Step">Build Requires More Than One Step</strong>
</p>

<p>
You should not need a sequence of arcane commands or context dependent scripts in order to build the individual elements. You should be able to check out the system with one simple command and then issue one other simple command to build it.
</p>

<p>
<span id="Smells and Heuristics-Environment-Tests Require More Than One Step"></span><strong id="Tests Require More Than One Step">Tests Require More Than One Step</strong>
</p>

<p>
You should be able to run all the unit tests with just one command.
</p>

<div id="Smells and Heuristics-Functions"><h2 id="Functions" class="header"><a href="#Smells and Heuristics-Functions">Functions</a></h2></div>

<p>
<span id="Smells and Heuristics-Functions-Too Many Arguments"></span><strong id="Too Many Arguments">Too Many Arguments</strong>
</p>

<p>
Functions should have a small number of arguments.
</p>

<p>
<span id="Smells and Heuristics-Functions-Output Arguments"></span><strong id="Output Arguments">Output Arguments</strong>
</p>

<p>
Output arguments are counterintuitive. Readers expect arguments to be inputs, not outputs.
</p>

<p>
<span id="Smells and Heuristics-Functions-Flag Arguments"></span><strong id="Flag Arguments">Flag Arguments</strong>
</p>

<p>
Boolean arguments loudly declare that the function does more than one thing. They are confusing and should be eliminated.
</p>

<p>
<span id="Smells and Heuristics-Functions-Dead Function"></span><strong id="Dead Function">Dead Function</strong>
</p>

<p>
Methods that are never called should be discarded, your source code control system still remember it.
</p>

<div id="Smells and Heuristics-General"><h2 id="General" class="header"><a href="#Smells and Heuristics-General">General</a></h2></div>

<p>
<span id="Smells and Heuristics-General-Multiple Languages in One Source File"></span><strong id="Multiple Languages in One Source File">Multiple Languages in One Source File</strong>
</p>

<p>
The ideal is for a source file to contain one, and only one, language. Realistically, we will probably have to use more than one. But we should take pains to minimize both the number and extent of extra languages in our source files.
</p>

<p>
<span id="Smells and Heuristics-General-Obvious Behaviour Is Unimplemented"></span><strong id="Obvious Behaviour Is Unimplemented">Obvious Behaviour Is Unimplemented</strong>
</p>

<p>
Following "The Principle of Least Surprise",  any function or class should implement the behaviors that another programmer could reasonably expect.
</p>

<p>
<span id="Smells and Heuristics-General-Incorrect Behaviour at the Boundaries"></span><strong id="Incorrect Behaviour at the Boundaries">Incorrect Behaviour at the Boundaries</strong>
</p>

<p>
It seems obvious to say that code should behave correctly. The problem is that we seldom realize just how complicated correct behavior is. Don’t rely on your intuition. Look for every boundary condition and write a test for it.
</p>

<p>
<span id="Smells and Heuristics-General-Overriden Safeties"></span><strong id="Overriden Safeties">Overriden Safeties</strong>
</p>

<p>
It is risky to override safeties. Turning off failing tests and telling yourself you’ll get them to pass later is bad.
</p>

<p>
<span id="Smells and Heuristics-General-Duplication"></span><strong id="Duplication">Duplication</strong>
</p>

<p>
Every time you see duplication in the code, it represents a missed opportunity for abstraction. Abide by the DRY principle (Don't Repeat Yourself).
</p>

<p>
<span id="Smells and Heuristics-General-Code at Wrong Level of Abstraction"></span><strong id="Code at Wrong Level of Abstraction">Code at Wrong Level of Abstraction</strong>
</p>

<p>
It is important to create abstractions that separate higher level general concepts from lower
level detailed concepts. We need to make sure that the separation is complete. We want all the lower level concepts to be in the derivatives and all the higher level concepts to be in the base class.
</p>

<p>
Good software design requires that we separate concepts at different levels and place them in different containers. We don’t want lower and higher level concepts mixed together.
</p>

<p>
<span id="Smells and Heuristics-General-Base Classes Depending on Their Derivatives"></span><strong id="Base Classes Depending on Their Derivatives">Base Classes Depending on Their Derivatives</strong>
</p>

<p>
The most common reason for partitioning concepts into base and derivative classes is so that the higher level base class concepts can be independent of the lower level derivative class concepts. Therefore, when we see base classes mentioning the names of their derivatives, we suspect a problem. In general, base classes should know nothing about their derivatives.
</p>

<p>
<span id="Smells and Heuristics-General-Too Much Information"></span><strong id="Too Much Information">Too Much Information</strong>
</p>

<p>
Well-defined modules have very small interfaces that allow you to do a lot with a little.
</p>

<p>
Good software developers learn to limit what they expose at the interfaces of their classes and modules. The fewer methods a class has, the better. The fewer variables a function knows about, the better. The fewer instance variables a class has, the better.
</p>

<p>
<span id="Smells and Heuristics-General-Dead Code"></span><strong id="Dead Code">Dead Code</strong>
</p>

<p>
Dead code is code that isn’t executed. Dead code is not completely updated when designs change. It still compiles, but it does not follow newer conventions or rules. Delete it.
</p>

<p>
<span id="Smells and Heuristics-General-Vertical Separation"></span><strong id="Vertical Separation">Vertical Separation</strong>
</p>

<p>
Variables and function should be defined close to where they are used. Local variables should be declared just above their first usage and should have a small vertical scope. Private functions should be defined just below their first usage.
</p>

<p>
<span id="Smells and Heuristics-General-Inconsistency"></span><strong id="Inconsistency">Inconsistency</strong>
</p>

<p>
If you do something a certain way, do all similar things in the same way.
</p>

<p>
<span id="Smells and Heuristics-General-Artificial Coupling"></span><strong id="Artificial Coupling">Artificial Coupling</strong>
</p>

<p>
Things that don’t depend upon each other should not be artificially coupled. In general an artificial coupling is a coupling between two modules that serves no direct purpose. It is a result of putting a variable, constant, or function in a temporarily convenient, though inappropriate, location. This is lazy and careless.
</p>

<p>
<span id="Smells and Heuristics-General-Feature Envy"></span><strong id="Feature Envy">Feature Envy</strong>
</p>

<p>
When a method uses accessors and mutators of some other object to manipulate the data within that object, then it envies the scope of the class of that other object. It wishes that it were inside that other class so that it could have direct access to the variables it is manipulating.
</p>

<p>
<span id="Smells and Heuristics-General-Selector Arguments"></span><strong id="Selector Arguments">Selector Arguments</strong>
</p>

<p>
Not only is the purpose of a selector argument difficult to remember, each selector argument combines many functions into one. Selector arguments are just a lazy way to avoid splitting a large function into several smaller functions.
</p>

<p>
Of course, selectors need not be boolean. They can be enums, integers, or any other type of argument that is used to select the behavior of the function. In general it is better to have many functions than to pass some code into a function to select the behavior.
</p>

<p>
<span id="Smells and Heuristics-General-Obscured Intent"></span><strong id="Obscured Intent">Obscured Intent</strong>
</p>

<p>
We want code to be as expressive as possible. Run-on expressions, Hungarian notation, and magic numbers all obscure the author’s intent. It is worth taking the time to make the intent of our code visible to our readers.
</p>

<p>
<span id="Smells and Heuristics-General-Misplaced Responsibility"></span><strong id="Misplaced Responsibility">Misplaced Responsibility</strong>
</p>

<p>
One of the most important decisions a software developer can make is where to put code. The principle of least surprise comes into play here. Code should be placed where a reader would naturally expect it to be.
</p>

<p>
<span id="Smells and Heuristics-General-Use Explanatory Variables"></span><strong id="Use Explanatory Variables">Use Explanatory Variables</strong>
</p>

<p>
One of the more powerful ways to make a program readable is to break the calculations up into intermediate values that are held in variables with meaningful names.
</p>

<p>
<span id="Smells and Heuristics-General-Function Names Should What They Do"></span><strong id="Function Names Should What They Do">Function Names Should What They Do</strong>
</p>

<p>
If you have to look at the implementation (or documentation) of the function to know what it does, then you should work to find a better name or rearrange the functionality so that it can be placed in functions with better names.
</p>

<p>
<span id="Smells and Heuristics-General-Understand the Algorithm"></span><strong id="Understand the Algorithm">Understand the Algorithm</strong>
</p>

<p>
Lots of very funny code is written because people don’t take the time to understand the algorithm. Before you consider yourself to be done with a function, make sure you understand how it works. It is not good enough that it passes all the tests. You must know that the solution is correct. Often the best way to gain this knowledge and understanding is to refactor the function into something that is so clean and expressive that it is obvious how it works.
</p>

<p>
<span id="Smells and Heuristics-General-Make Logical Dependencies Physical"></span><strong id="Make Logical Dependencies Physical">Make Logical Dependencies Physical</strong>
</p>

<p>
If one module depends upon another, that dependency should be physical, not just logical. The dependent module should not make assumptions (in other words, logical dependencies) about the module it depends upon. Rather it should explicitly ask that module for all the information it depends upon.
</p>

<p>
<span id="Smells and Heuristics-General-Prefer Polymorphism to If/Else or Switch/Case"></span><strong id="Prefer Polymorphism to If/Else or Switch/Case">Prefer Polymorphism to If/Else or Switch/Case</strong>
</p>

<p>
Most people use switch statements because it’s the obvious brute force solution, not because it’s the right solution for the situation. So this heuristic is here to remind us to consider polymorphism before using a switch. Also  the cases where functions are more volatile than types are relatively rare. So every switch statement should be suspect.
</p>

<p>
<span id="Smells and Heuristics-General-Follow Standard Conventions"></span><strong id="Follow Standard Conventions">Follow Standard Conventions</strong>
</p>

<p>
Every team should follow a coding standard based on common industry norms. This coding standard should specify things like where to declare instance variables; how to name classes, methods, and variables; where to put braces; and so on.
</p>

<p>
<span id="Smells and Heuristics-General-Replace Magic Numbers with Named Constants"></span><strong id="Replace Magic Numbers with Named Constants">Replace Magic Numbers with Named Constants</strong>
</p>

<p>
In general it is a bad idea to have raw numbers in your code. You should hide them behind well-named constants. The term “Magic Number” does not apply only to numbers. It applies to any token that has a value that is not self-describing. 
</p>

<p>
<span id="Smells and Heuristics-General-Be Precise"></span><strong id="Be Precise">Be Precise</strong>
</p>

<p>
When you make a decision in your code, make sure you make it precisely. Know why you have made it and how you will deal with any exceptions. Ambiguities and imprecision in code are either a result of disagreements or laziness. In either case they should be eliminated.
</p>

<p>
<span id="Smells and Heuristics-General-Structure over Convention"></span><strong id="Structure over Convention">Structure over Convention</strong>
</p>

<p>
Enforce design decisions with structure over convention.
</p>

<p>
<span id="Smells and Heuristics-General-Encapsulate Conditionals"></span><strong id="Encapsulate Conditionals">Encapsulate Conditionals</strong>
</p>

<p>
Extract functions that explain the intent of the conditional.
</p>
 
<p>
<span id="Smells and Heuristics-General-Avoid Negative Conditionals"></span><strong id="Avoid Negative Conditionals">Avoid Negative Conditionals</strong>
</p>

<p>
Negatives are just a bit harder to understand than positives. So, when possible, conditionals should be expressed as positives.
</p>

<p>
<span id="Smells and Heuristics-General-Functions Should Do One Thing"></span><strong id="Functions Should Do One Thing">Functions Should Do One Thing</strong>
</p>

<p>
Functions that do more than one thing should be converted into many smaller functions, each of which does one thing.
</p>

<p>
<span id="Smells and Heuristics-General-Hidden Temporal Couplings"></span><strong id="Hidden Temporal Couplings">Hidden Temporal Couplings</strong>
</p>

<p>
Temporal couplings are often necessary, but you should not hide the coupling. Structure the arguments of your functions such that the order in which they should be called is obvious.
</p>

<p>
<span id="Smells and Heuristics-General-Don't Be Arbitrary"></span><strong id="Don't Be Arbitrary">Don't Be Arbitrary</strong>
</p>

<p>
Have a reason for the way you structure your code, and make sure that reason is communicated by the structure of the code.
</p>

<p>
<span id="Smells and Heuristics-General-Encapsulate Boundary Conditions"></span><strong id="Encapsulate Boundary Conditions">Encapsulate Boundary Conditions</strong>
</p>

<p>
Boundary conditions are hard to keep track of. Put the processing for them in one place. Don’t let them leak all over the code.
</p>

<p>
<span id="Smells and Heuristics-General-Functions Should Descend Only One Level of Abstraction"></span><strong id="Functions Should Descend Only One Level of Abstraction">Functions Should Descend Only One Level of Abstraction</strong>
</p>

<p>
The statements within a function should all be written at the same level of abstraction, which should be one level below the operation described by the name of the function.
</p>

<p>
<span id="Smells and Heuristics-General-Keep Configurable Data at High Levels"></span><strong id="Keep Configurable Data at High Levels">Keep Configurable Data at High Levels</strong>
</p>

<p>
If you have a constant such as a default or configuration value that is known and expected at a high level of abstraction, do not bury it in a low-level function.
</p>

<p>
<span id="Smells and Heuristics-General-Avoid Transitive Navigation"></span><strong id="Avoid Transitive Navigation">Avoid Transitive Navigation</strong>
</p>

<p>
In general we don’t want a single module to know much about its collaborators. More specifically, if <code>A</code> collaborates with <code>B</code>, and <code>B</code> collaborates with <code>C</code>, we don’t want modules that use <code>A</code> to know about <code>C</code>. (For example, we don’t want <code>a.getB().getC().doSomething();</code>). Rather we want our immediate collaborators to offer all the services we need.
</p>

<p>
This is sometimes called the Law of Demeter. The Pragmatic Programmers call it “Writing Shy Code.”
</p>

<div id="Smells and Heuristics-Names"><h2 id="Names" class="header"><a href="#Smells and Heuristics-Names">Names</a></h2></div>

<p>
<span id="Smells and Heuristics-Names-Choose Descriptive Names"></span><strong id="Choose Descriptive Names">Choose Descriptive Names</strong>
</p>

<p>
Names in software are 90 percent of what make software readable. You need to take the time to choose them wisely and keep them relevant. Names are too important to treat carelessly. The power of carefully chosen names is that they overload the structure of the code with description. 
</p>

<p>
<span id="Smells and Heuristics-Names-Choose Names at the Appropriate Level of Abstraction"></span><strong id="Choose Names at the Appropriate Level of Abstraction">Choose Names at the Appropriate Level of Abstraction</strong>
</p>

<p>
Don’t pick names that communicate implementation; choose names the reflect the level of abstraction of the class or function you are working in.
</p>

<p>
<span id="Smells and Heuristics-Names-Use Standard Nomenclature Where Possible"></span><strong id="Use Standard Nomenclature Where Possible">Use Standard Nomenclature Where Possible</strong>
</p>

<p>
Names are easier to understand if they are based on existing convention or usage.
</p>

<p>
<span id="Smells and Heuristics-Names-Unambiguous Names"></span><strong id="Unambiguous Names">Unambiguous Names</strong>
</p>

<p>
Choose names that make the workings of a function or variable unambiguous.
</p>

<p>
<span id="Smells and Heuristics-Names-Use Long Names for Long Scopes"></span><strong id="Use Long Names for Long Scopes">Use Long Names for Long Scopes</strong>
</p>

<p>
The length of a name should be related to the length of the scope. You can use very short variable names for tiny scopes, but for big scopes you should use longer names. Variables and functions with short names lose their meaning over long distances. So the longer the scope of the name, the longer and more precise the name should be.
</p>

<p>
<span id="Smells and Heuristics-Names-Avoid Encodings"></span><strong id="Avoid Encodings">Avoid Encodings</strong>
</p>

<p>
Names should not be encoded with type or scope information. Prefixes such as <code>m_</code> or <code>f</code> are useless in today’s environments.
</p>

<p>
<span id="Smells and Heuristics-Names-Names Should Describe Side-Effects"></span><strong id="Names Should Describe Side-Effects">Names Should Describe Side-Effects</strong>
</p>

<p>
Names should describe everything that a function, variable, or class is or does. Don’t hide side effects with a name.
</p>

<div id="Smells and Heuristics-Tests"><h2 id="Tests" class="header"><a href="#Smells and Heuristics-Tests">Tests</a></h2></div>

<p>
<span id="Smells and Heuristics-Tests-Insufficient Tests"></span><strong id="Insufficient Tests">Insufficient Tests</strong>
</p>

<p>
A test suite should test everything that could possibly break. The tests are insufficient so long as there are conditions that have not been explored by the tests or calculations that have not been validated.
</p>

<p>
<span id="Smells and Heuristics-Tests-Use A Coverage Tool"></span><strong id="Use A Coverage Tool">Use A Coverage Tool</strong>
</p>

<p>
Coverage tools reports gaps in your testing strategy. They make it easy to find modules, classes, and functions that are insufficiently tested.
</p>

<p>
<span id="Smells and Heuristics-Tests-Don't Skip Trivial Tests"></span><strong id="Don't Skip Trivial Tests">Don't Skip Trivial Tests</strong>
</p>

<p>
They are easy to write and their documentary value is higher than the cost to produce them.
</p>

<p>
<span id="Smells and Heuristics-Tests-Test Boundary Conditions"></span><strong id="Test Boundary Conditions">Test Boundary Conditions</strong>
</p>

<p>
Take special care to test boundary conditions. We often get the middle of an algorithm right but misjudge the boundaries.
</p>

<p>
<span id="Smells and Heuristics-Tests-Exhaustively Test Near Bugs"></span><strong id="Exhaustively Test Near Bugs">Exhaustively Test Near Bugs</strong>
</p>

<p>
Bugs tend to congregate. When you find a bug in a function, it is wise to do an exhaustive test of that function.
</p>

<p>
<span id="Smells and Heuristics-Tests-Patterns of Failure Are Revealing"></span><strong id="Patterns of Failure Are Revealing">Patterns of Failure Are Revealing</strong>
</p>

<p>
Sometimes you can diagnose a problem by finding patterns in the way the test cases fail. This is another argument for making the test cases as complete as possible. Complete test cases, ordered in a reasonable way, expose patterns.
</p>

<p>
<span id="Smells and Heuristics-Tests-Test Covertage Patterns Can Be Revealing"></span><strong id="Test Covertage Patterns Can Be Revealing">Test Covertage Patterns Can Be Revealing</strong>
</p>

<p>
Looking at the code that is or is not executed by the passing tests gives clues to why the failing tests fail.
</p>

<p>
<span id="Smells and Heuristics-Tests-Tests Should Be Fast"></span><strong id="Tests Should Be Fast">Tests Should Be Fast</strong>
</p>

<p>
A slow test is a test that won’t get run.
</p>
</div>
  

<script type="text/javascript" src="https://albamr09.github.io/src/lib/highlight.min.js" id="js_highlight" data-description="Support sytax highlighting on code"></script><script type="text/javascript" src="https://albamr09.github.io/src/lib/zepto.min.js" id="zepto" data-description="jQuery library"></script><script type="text/javascript" src="https://albamr09.github.io/src/lib/search.js" id="search" data-description="Library to perform search"></script><script type="text/javascript" src="https://albamr09.github.io/src/lib/fuse.js" id="search" data-description="Library to perform search"></script><script type="text/javascript" id="search" data-description="Entrypoint for hightlihgting">
  $("pre").each(function (index, item) {
    $(item).html("<code>" + $(item).html() + "</code>");
  });
  hljs.highlightAll();
</script></body></html>