<html><head>
    <!-- Normal styling from vimwiki -->
    <link rel="Stylesheet" type="text/css" href="../../../../../src/style/index.css">
    <!-- Custom styling from vimwiki -->
    <link rel="Stylesheet" type="text/css" href="../../../../../src/style/custom.css">
    <title>Computer Architecture</title>
  <script type="text/javascript" src="https://polyfill.io/v3/polyfill.min.js?features=es6" id="latex_script" data-description="Support for latex"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script" data-description="Support for latex"></script><link rel="Stylesheet" type="text/css" href="https://albamr09.github.io/src/style/search.css" data-description="Styling for search"><link rel="Stylesheet" type="text/css" href="https://albamr09.github.io/src/style/atom-one-light.min.css" data-description="Code highlight"><link rel="icon" type="image/svg+xml" href="https://albamr09.github.io/public/icon.svg" data-description="Page icon"></head>
  <body>
    <a href="https://albamr09.github.io/" style="
        color: white;
        font-weight: bold;
        text-decoration: none;
        padding: 3px 6px;
        border-radius: 3px;
        background-color: #1e90ff;
        text-transform: uppercase;
      ">Index</a>
    <form id="search_form" class="search-form">
      <input required="" type="search" id="search_term" class="searchTerm">
      <button type="submit" class="searchButton">Search</button>
    </form>
    <div id="search-background" class="search-background">
      <div id="search-result" class="search-result-hide"></div>
      <div id="search-form-modal" class="search-form-modal">
        <form id="search-form-in-modal">
          <input required="" type="search" id="search-input-in-modal" class="search-input-in-modal" placeholder="Search whatever...">
          <button type="submit" class="searchButton">Search</button>
        </form>
      </div>
    </div>
    <hr>
    <div class="content">
<p>
<a href="index.html">Back</a>
</p>

<div id="Computer Architecture"><h1 id="Computer Architecture" class="header"><a href="#Computer Architecture">Computer Architecture</a></h1></div>

<hr>

<div id="Contents" class="toc"><h2 id="Contents" class="header"><a href="#Contents">Contents</a></h2></div>
<ul>
<li>
<a href="05.html#Computer%20Architecture%20Fundamentals">Computer Architecture Fundamentals</a>

<ul>
<li>
<a href="05.html#Central%20Processing%20Unit">Central Processing Unit</a>

</li><li>
<a href="05.html#Input%20and%20Output">Input and Output</a>

</li></ul>
</li><li>
<a href="05.html#%2005The%20Hack%20Hardware%20Platform%3A%20Specification">The Hack Hardware Platform  Specification</a>

<ul>
<li>
<a href="05.html#Central%20Processing%20Unit">Central Processing Unit</a>

</li><li>
<a href="05.html#Computer">Computer</a>

</li></ul>
</li></ul>
<hr>

<div id="Computer Architecture-Computer Architecture Fundamentals"><h2 id="Computer Architecture Fundamentals" class="header"><a href="#Computer Architecture-Computer Architecture Fundamentals">Computer Architecture Fundamentals</a></h2></div>

<p>
A computer is based on a fixed hardware platform capable of executing a fixed repertoire of simple instructions which serves as building blocks. Moreover the logic of these programs is temporarily stored in the computer's memory, like data.
</p>

<p>
The <span id="Computer Architecture-Computer Architecture Fundamentals-von Neumann architecture"></span><strong id="von Neumann architecture">von Neumann architecture</strong>, shown in figure 5.1, is based on a Central Processing Unit (CPU), interacting with a memory device, receiving data from some input device, and emitting data to some output device.
</p>

<p>
<img src="https://albamr09.github.io/public/assets/von_neumann.png" alt="Von Neumann Architecture" style="height:250px">
</p>

<p>
The term <span id="Computer Architecture-Computer Architecture Fundamentals-Random Access Memory"></span><strong id="Random Access Memory">Random Access Memory</strong> derives from the important requirement that each randomly selected memory register can be reached instantaneously, that is, within the same cycle.
</p>

<p>
<span id="Computer Architecture-Computer Architecture Fundamentals-Data memory"></span><strong id="Data memory">Data memory</strong>: High-level programs are designed to manipulate abstract artifacts like variables, arrays, and objects. Yet at the hardware level, these data abstractions are realized by binary values stored in memory registers.
</p>

<p>
<span id="Computer Architecture-Computer Architecture Fundamentals-Intruction memory"></span><strong id="Intruction memory">Intruction memory</strong>: Before a high-level program can be executed on a target computer, it must first be translated into the machine language of the target computer. Each high-level statement is translated into one or more low-level instructions, which are then written as binary values to a file called the binary, or executable, version of the program. Before running a program, we must first load its binary version into the computer's instruction memory.
</p>

<div id="Computer Architecture-Computer Architecture Fundamentals-Central Processing Unit"><h3 id="Central Processing Unit" class="header"><a href="#Computer Architecture-Computer Architecture Fundamentals-Central Processing Unit">Central Processing Unit</a></h3></div>

<p>
The Central Processing Unit (CPU) is in charge of executing the instructions of the program  using three main elements: An Arithmetic Logic Unit (ALU), a set of registers, and a control unit.
</p>

<p>
<span id="Computer Architecture-Computer Architecture Fundamentals-Central Processing Unit-Arithmetic Logic Unit"></span><strong id="Arithmetic Logic Unit">Arithmetic Logic Unit</strong>:  performs all the low-level arithmetic and logical operations.
</p>

<p>
<span id="Computer Architecture-Computer Architecture Fundamentals-Central Processing Unit-Registers"></span><strong id="Registers">Registers</strong>: stores interim values temporarily. It the processor's immediate memory. These registers serve various purposes: 
</p>

<ul>
<li>
<em>Data registers</em> store interim values

</li><li>
<em>Address registers</em> store values that are used to address the RAM

</li><li>
<em>Program Counter</em> tores the address of the instruction that should be fetched and executed nex

</li><li>
<em>Instruction register</em>  stores the current instruction.

</li></ul>
<p>
<span id="Computer Architecture-Computer Architecture Fundamentals-Central Processing Unit-Control"></span><strong id="Control">Control</strong>: A computer instruction is a structured package of micro-codes: sequences of one or more bits designed to tell different devices what to do. Before an instruction can be executed, it
must first be decoded into its micro-codes. Next, each micro-code is routed to its designated hardware device (ALU, registers, memory).
</p>

<p>
<span id="Computer Architecture-Computer Architecture Fundamentals-Central Processing Unit-Fetch-Execute"></span><strong id="Fetch-Execute">Fetch-Execute</strong>: In each cycle of the program's execution, the CPU fetches a binary machine instruction from the instruction memory, decodes it, and executes it. It also figures out which instruction to fetch and execute next. This is called the <span id="Computer Architecture-Computer Architecture Fundamentals-Central Processing Unit-fetch-execute cycle"></span><strong id="fetch-execute cycle">fetch-execute cycle</strong>.
</p>

<div id="Computer Architecture-Computer Architecture Fundamentals-Input and Output"><h3 id="Input and Output" class="header"><a href="#Computer Architecture-Computer Architecture Fundamentals-Input and Output">Input and Output</a></h3></div>

<p>
Computers interact with a great variety of input and output (I/O) devices. So we use a key element: memory-mapped I/O. This mapping is done by allocating, for each I/O device, a designated area in the computer's memory that acts as its memory map. Then low-level computer programs can access any I/O device by manipulating its designated memory map.
</p>

<p>
<img src="https://albamr09.github.io/public/assets/hack_memory_interface.png" alt="Hack Memory Interface" style="height:500px">
</p>

<p>
Given the multitude of computer platforms, I/O devices, and different hardware and software vendors <span id="Computer Architecture-Computer Architecture Fundamentals-Input and Output-standars"></span><strong id="standars">standars</strong> play a crucial role to realize these low-level interactions between the computer and the external devices.
</p>

<p>
Another necessary element is a <span id="Computer Architecture-Computer Architecture Fundamentals-Input and Output-device driver program"></span><strong id="device driver program">device driver program</strong>, which is added to the computer's operating system. This program controls the way this data is actually rendered on, or generated by, the physical I/O device using the memory map.
</p>

<div id="Computer Architecture- The Hack Hardware Platform: Specification"><h2 id=" The Hack Hardware Platform: Specification" class="header"><a href="#Computer Architecture- The Hack Hardware Platform: Specification"> The Hack Hardware Platform: Specification</a></h2></div>

<p>
The Hack CPU consists of the ALU built in project 2 and three registers named Data register (D), Address register (A), and Program Counter (PC).
</p>

<ol>
<li>
The <code>D</code> register is used solely for storing data values

</li><li>
The <code>A</code> register serves one of three different purposes: 

<ul>
<li>
Storing a data value

</li><li>
Selecting an address on the instruction memory

</li><li>
Selecting an address on the data memory

</li></ul>
</li></ol>
<div id="Computer Architecture- The Hack Hardware Platform: Specification-Central Processing Unit"><h3 id="Central Processing Unit" class="header"><a href="#Computer Architecture- The Hack Hardware Platform: Specification-Central Processing Unit">Central Processing Unit</a></h3></div>

<p>
The Hack CPU interface is shown in figure 5.2. The CPU expects to be connected to an instruction memory, from which it fetches instructions for execution, and to a data memory, from which it can read, and into which it can write, data values.
</p>

<p>
<img src="https://albamr09.github.io/public/assets/hack_cpu.png" alt="Hack CPU Interface" style="height:400px">
</p>

<p>
If the instruction input is an A-instruction, the CPU loads the \(16\)-bit instruction value into the A register.
</p>

<p>
If instruction is a C-instruction, then:
</p>

<ol>
<li>
The CPU causes the ALU to perform the computation specified by the instruction 

</li><li>
The CPU causes this value to be stored in the any of the A,D, or M destination registers specified by the instruction.

</li></ol>
<p>
If one of the destination registers is <code>M</code>, the CPU's <code>outM</code> output is set to the ALU output, and the CPU's <code>writeM</code> output is set to \(1\). Otherwise, <code>writeM</code> is set to \(0\).
</p>

<p>
As long as the reset input is \(0\), the CPU uses the ALU output and the jump bits of the current instruction to decide which instruction to fetch next. If reset is \(1\), the CPU sets pc to \(0\). This realizes the fetch step on the fetch-execute cycle.
</p>

<p>
The following figure shows its implementation:
</p>

<p>
<img src="https://albamr09.github.io/public/assets/hack_cpu_chip.png" alt="Hack CPU Chip" style="height:300px">
</p>

<div id="Computer Architecture- The Hack Hardware Platform: Specification-Computer"><h3 id="Computer" class="header"><a href="#Computer Architecture- The Hack Hardware Platform: Specification-Computer">Computer</a></h3></div>

<p>
When the user sets the <code>reset</code> bit to \(1\) and then to \(0\), the computer starts executing the currently loaded program. This is referred as "booting the computer." (see Figure 5.7).
</p>

<p>
<img src="https://albamr09.github.io/public/assets/hack_computer_interface.png" alt="Hack Computer Interface" style="height:350px">
</p>

<p>
For example, when you boot up a PC or a cell phone, the device is set up to run a ROM-resident program. This program, in turn, loads the operating system’s kernel (also a program) into the RAM and starts executing it.
</p>

<p>
The following figure shows the Computer implemetation:
</p>

<p>
<img src="https://albamr09.github.io/public/assets/hack_computer_chip.png" alt="Hack Computer Chip" style="height:350px">
</p>
</div>
  

<script type="text/javascript" src="https://albamr09.github.io/src/lib/highlight.min.js" id="js_highlight" data-description="Support sytax highlighting on code"></script><script type="text/javascript" src="https://albamr09.github.io/src/lib/zepto.min.js" id="zepto" data-description="Library to perform search"></script><script type="text/javascript" src="https://albamr09.github.io/src/lib/flexsearch.bundle.js" id="flexsearch" data-description="Library to perform search"></script><script type="text/javascript" src="https://albamr09.github.io/src/lib/search.js" id="search" data-description="Library to perform search"></script><script type="text/javascript" id="search" data-description="Entrypoint for hightlihgting">
  $("pre").each(function (index, item) {
    $(item).html("<code>" + $(item).html() + "</code>");
  });
  hljs.highlightAll();
</script></body></html>