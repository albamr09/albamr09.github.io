<html><head>
    <!-- Normal styling from vimwiki -->
    <link rel="Stylesheet" type="text/css" href="../../../../../src/style/index.css">
    <!-- Custom styling from vimwiki -->
    <link rel="Stylesheet" type="text/css" href="../../../../../src/style/custom.css">
    <title>Colors, Depth Testing, and Alpha Blending</title>
  <script type="text/javascript" src="https://polyfill.io/v3/polyfill.min.js?features=es6" id="latex_script" data-description="Support for latex"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script" data-description="Support for latex"></script><link rel="Stylesheet" type="text/css" href="https://albamr09.github.io/src/style/search.css" data-description="Styling for search"><link rel="Stylesheet" type="text/css" href="https://albamr09.github.io/src/style/atom-one-light.min.css" data-description="Code highlight"><link rel="icon" type="image/svg+xml" href="https://albamr09.github.io/public/icon.svg" data-description="Page icon"></head>
  <body>
    <a href="https://albamr09.github.io/" style="
        color: white;
        font-weight: bold;
        text-decoration: none;
        padding: 3px 6px;
        border-radius: 3px;
        background-color: #1e90ff;
        text-transform: uppercase;
      ">Index</a>
    <form id="search_form" class="search-form">
      <input required="" type="search" id="search_term" class="searchTerm">
      <button type="submit" class="searchButton">Search</button>
    </form>
    <div id="search-background" class="search-background">
      <div id="search-result" class="search-result-hide"></div>
      <div id="search-form-modal" class="search-form-modal">
        <form id="search-form-in-modal">
          <input required="" type="search" id="search-input-in-modal" class="search-input-in-modal" placeholder="Search whatever...">
          <button type="submit" class="searchButton">Search</button>
        </form>
      </div>
    </div>
    <hr>
    <div class="content">
<p>
<a href="index.html">Back</a>
</p>

<div id="Colors, Depth Testing, and Alpha Blending"><h1 id="Colors, Depth Testing, and Alpha Blending" class="header"><a href="#Colors, Depth Testing, and Alpha Blending">Colors, Depth Testing, and Alpha Blending</a></h1></div>

<hr>

<div id="Contents" class="toc"><h2 id="Contents" class="header"><a href="#Contents">Contents</a></h2></div>
<ul>
<li>
<a href="06.html#Using%20Colors%20in%20WeblGL">Using Colors in WeblGL</a>

</li><li>
<a href="06.html#Using%20Colors%20in%20Objects">Using Colors in Objects</a>

<ul>
<li>
<a href="06.html#Constant%20Coloring">Constant Coloring</a>

</li><li>
<a href="06.html#Per-Vertex%20Coloring">Per-Vertex Coloring</a>

</li><li>
<a href="06.html#Per-Fragment%20Coloring">Per-Fragment Coloring</a>

</li></ul>
</li><li>
<a href="06.html#Use%20of%20Color%20in%20Lights">Use of Color in Lights</a>

<ul>
<li>
<a href="06.html#Scalability%20Problem">Scalability Problem</a>

</li><li>
<a href="06.html#How%20Many%20Uniforms%20Can%20We%20Use">How Many Uniforms Can We Use</a>

</li><li>
<a href="06.html#Simplifying%20the%20Problem">Simplifying the Problem</a>

</li><li>
<a href="06.html#Using%20Uniform%20Arrays%20to%20Handle%20Multiple%20Lights">Using Uniform Arrays to Handle Multiple Lights</a>

</li><li>
<a href="06.html#Directional%20Point%20Lights">Directional Point Lights</a>

<ul>
<li>
<a href="06.html#Attenuation%20Factor">Attenuation Factor</a>

</li></ul>
</li></ul>
</li><li>
<a href="06.html#Use%20of%20Color%20in%20the%20Scene">Use of Color in the Scene</a>

<ul>
<li>
<a href="06.html#Transparency">Transparency</a>

</li><li>
<a href="06.html#Updated%20Rendering%20Pipeline">Updated Rendering Pipeline</a>

</li></ul>
</li><li>
<a href="06.html#Depth%20Testing">Depth Testing</a>

</li></ul>
<hr>

<div id="Colors, Depth Testing, and Alpha Blending-Using Colors in WeblGL"><h2 id="Using Colors in WeblGL" class="header"><a href="#Colors, Depth Testing, and Alpha Blending-Using Colors in WeblGL">Using Colors in WeblGL</a></h2></div>

<p>
WebGL supplies a fourth attribute to the RGB model. This attribute is called the alpha channel. The extended model then is known as the RGBA model, where A stands for alpha. The alpha channel contains a value between the range of \(0.0\) to \(1.0\).
</p>

<p>
A completely opaque color will have an alpha value of \(1.0\), whereas a completely transparent color will have an alpha value of \(0.0\). This is the general case, but as we will see, we need to take other factors into account when we obtain translucent colors.
</p>

<div id="Colors, Depth Testing, and Alpha Blending-Using Colors in Objects"><h2 id="Using Colors in Objects" class="header"><a href="#Colors, Depth Testing, and Alpha Blending-Using Colors in Objects">Using Colors in Objects</a></h2></div>

<div id="Colors, Depth Testing, and Alpha Blending-Using Colors in Objects-Constant Coloring"><h3 id="Constant Coloring" class="header"><a href="#Colors, Depth Testing, and Alpha Blending-Using Colors in Objects-Constant Coloring">Constant Coloring</a></h3></div>

<p>
To obtain a constant color, we store the desired color in a uniform that is passed to the fragment shader. This uniform is usually called the object's diffuse material property. We can also combine object normals and light-source information to obtain a Lambert coefficient. We can use the Lambert coefficient to proportionally change the reflecting color depending on the angle on which the light hits the object.
</p>

<div id="Colors, Depth Testing, and Alpha Blending-Using Colors in Objects-Per-Vertex Coloring"><h3 id="Per-Vertex Coloring" class="header"><a href="#Colors, Depth Testing, and Alpha Blending-Using Colors in Objects-Per-Vertex Coloring">Per-Vertex Coloring</a></h3></div>

<p>
To implement per-vertex coloring, we need to define an attribute that stores the color for the vertex in the vertex shader:
</p>

<pre>in vec4 aVertexColor;
</pre>

<p>
The next step is to assign the aVertexColor attribute to a varying so that it can be passed to the fragment shader. Remember that varyings are automatically interpolated. Therefore, each fragment will have a color that is the weighted result of its contributing vertices.
</p>

<p>
<img src="https://albamr09.github.io/public/images/ComputerScience/CG/RTGW/constant_vs_per_vertex_color.png" alt="Constant vs Per Vertex Color">
</p>

<p>
If we want our color map to be sensitive to lighting conditions, we can multiply each vertex color by the diffuse component of the light. The result is then assigned to the varying that will transfer the result to the fragment shader.
</p>

<div id="Colors, Depth Testing, and Alpha Blending-Using Colors in Objects-Per-Fragment Coloring"><h3 id="Per-Fragment Coloring" class="header"><a href="#Colors, Depth Testing, and Alpha Blending-Using Colors in Objects-Per-Fragment Coloring">Per-Fragment Coloring</a></h3></div>

<p>
We can also assign a random color to each pixel of the object we are rendering.
</p>

<div id="Colors, Depth Testing, and Alpha Blending-Use of Color in Lights"><h2 id="Use of Color in Lights" class="header"><a href="#Colors, Depth Testing, and Alpha Blending-Use of Color in Lights">Use of Color in Lights</a></h2></div>

<div id="Colors, Depth Testing, and Alpha Blending-Use of Color in Lights-Scalability Problem"><h3 id="Scalability Problem" class="header"><a href="#Colors, Depth Testing, and Alpha Blending-Use of Color in Lights-Scalability Problem">Scalability Problem</a></h3></div>

<p>
Given the desire to use more than one light in our scene, we need to define and map the number of appropriate uniforms of the lighting model of choice. If we have four properties per light (ambient, diffuse, specular, and location), we need to define four uniforms for each light. If we want to have three lights, we need to write, use, and map twelve uniforms! We need to resolve this complexity before it gets out of hand.
</p>

<div id="Colors, Depth Testing, and Alpha Blending-Use of Color in Lights-How Many Uniforms Can We Use"><h3 id="How Many Uniforms Can We Use" class="header"><a href="#Colors, Depth Testing, and Alpha Blending-Use of Color in Lights-How Many Uniforms Can We Use">How Many Uniforms Can We Use</a></h3></div>

<p>
To find out the limit for your WebGL implementation, you can query WebGL using the <code>gl.getParameter</code> function with these constants:
</p>

<pre>gl.MAX_VERTEX_UNIFORM_VECTORS
gl.MAX_FRAGMENT_UNIFORM_VECTORS
</pre>

<div id="Colors, Depth Testing, and Alpha Blending-Use of Color in Lights-Simplifying the Problem"><h3 id="Simplifying the Problem" class="header"><a href="#Colors, Depth Testing, and Alpha Blending-Use of Color in Lights-Simplifying the Problem">Simplifying the Problem</a></h3></div>

<p>
In order to simplify the problem, we can assume that the ambient component is the same for all of the lights. This will reduce the number of uniformsâ€”one fewer uniform for each light.
</p>

<div id="Colors, Depth Testing, and Alpha Blending-Use of Color in Lights-Using Uniform Arrays to Handle Multiple Lights"><h3 id="Using Uniform Arrays to Handle Multiple Lights" class="header"><a href="#Colors, Depth Testing, and Alpha Blending-Use of Color in Lights-Using Uniform Arrays to Handle Multiple Lights">Using Uniform Arrays to Handle Multiple Lights</a></h3></div>

<p>
As we've seen, handling light properties with individual uniforms makes the code verbose and difficult to maintain. Fortunately, ESSL provides several mechanisms we can use to solve the problem of handling multiple lights. One of them is <span id="Colors, Depth Testing, and Alpha Blending-Use of Color in Lights-Using Uniform Arrays to Handle Multiple Lights-uniform arrays"></span><strong id="uniform arrays">uniform arrays</strong>.
</p>

<p>
This technique allows us to handle multiple lights by introducing enumerable arrays of vectors in the shaders. This allows us to calculate light contributions by iterating through the light arrays in the shaders.
</p>

<pre c="">uniform vec3 uPositionLight[3];
</pre>

<p>
Itâ€™s important to note that ESSL does not support dynamic initialization of uniform arrays.
We could try something such as this, but will not work:
</p>

<pre c="">uniform int numLights;
uniform vec3 uPositionLight[numLights];
</pre>

<p>
However, this construct is valid:
</p>

<pre c="">const int numLights = 3;
uniform vec3 uPositionLight[numLights];
</pre>

<p>
To map these variables on javascript:
</p>

<pre javascript="">const lightPosition1 = [0, 7, 3];
const lightPosition2 = [2.5, 3, 3];
const lightPosition3 = [-2.5, 3, 3];

const location = gl.getUniformLocation(program, 'uPositionLight');

// The values are concatenated on a single flat array
gl.uniform3fv(location, [...lightPosition1, ...lightPosition2, ...lightPosition3]);
</pre>

<div id="Colors, Depth Testing, and Alpha Blending-Use of Color in Lights-Directional Point Lights"><h3 id="Directional Point Lights" class="header"><a href="#Colors, Depth Testing, and Alpha Blending-Use of Color in Lights-Directional Point Lights">Directional Point Lights</a></h3></div>

<p>
In this section, we will combine directional and positional lights creating a <span id="Colors, Depth Testing, and Alpha Blending-Use of Color in Lights-Directional Point Lights-directional point light"></span><strong id="directional point light">directional point light</strong>, commonly referred to as a <span id="Colors, Depth Testing, and Alpha Blending-Use of Color in Lights-Directional Point Lights-spot light"></span><strong id="spot light">spot light</strong>.
</p>

<p>
<img src="https://albamr09.github.io/public/images/ComputerScience/CG/RTGW/directional_point_ligth.png" alt="Directional Point Light">
</p>

<p>
The trick to creating these lights is to subtract the light-direction vector from the normal for each vertex. The resulting vector will create a different Lambert coefficient that will reflect into the cone generated by the light source. On the following excerpts we show a practical example of how a sportlight could be implemented. On the first place we have the vertex shader whose responsability it is to compute:
</p>

<ul>
<li>
The rays, <code>vRay</code>, for each light source. This is the vector between the position of the light and the position of the vertex (after is has been transformed by the model view).

</li><li>
The "modified" normal, <code>vTransformedNormals</code>. This stores the normals after the ligth direction vector has been substracted from it.

</li></ul>
<p>
We will use both of these vectors to compute the lambert term on the fragment shader.
</p>

<pre c="">#version 300 es

const int numLights = 3;

uniform mat4 uModelViewMatrix;
uniform mat4 uNormalMatrix;
uniform mat4 uProjectionMatrix;

uniform vec3 uLightPositions[numLights];
uniform vec3 uLightDirections[numLights];

in vec3 aPos;
in vec3 aNormal;

out vec3 vRay[numLights];
out vec3 vTransformedNormals[numLights];

void main(void) {
  vec4 vertex = uModelViewMatrix * vec4(aPos, 1.0);

  
  vec3 normal = vec3(uNormalMatrix * vec4(aNormal, 1.0));

  // Iterate over each light
  for(int i = 0; i &lt; numLights; i++) {
    // Define each ray as the vector berween the light and the vertex
    vec4 lightPosition = uModelViewMatrix * vec4(uLightPositions[i], 1.0);
    vRay[i] = vertex.xyz - lightPosition.xyz;
    // Transform the direction of the light
    vec3 directionLight = vec3(uNormalMatrix * vec4(uLightDirections[i], 1.0));
    // Transform the normal by substracting the direction of each light
    vTransformedNormals[i] = normal - directionLight;
  }

  gl_Position = uProjectionMatrix * vertex;
}
</pre>

<p>
Here we have the fragment shader where we compute the final color. This color is made up from two main sources:
</p>

<ul>
<li>
Ambient light

</li><li>
Diffuse light: these light is computed taking into account a number of lights given <code>numLights</code>. For each one we incrementally modify the final diffuse light, <code>Id</code>.

</li></ul>
<p>
Note that for each of these diffuse lights we apply the <a href="03.html#Lambertian Reflection Model">Lambertian Reflection Model</a>, where we compute the final color as the product of the color of the light, the color of the material and finally the cosine of the angle between the light source (<code>vRay</code>) and the normal of the surface (that is the <code>lamberTerm</code>). In this case, instead of the normal of the surface we use our transformed normal, <code>vTransformedNormals</code>.
</p>

<pre c="">#version 300 es

precision mediump float;

const int numLights = 3;

uniform vec4 uLightColors[numLights];
uniform vec4 uMaterialAmbient;
uniform vec4 uMaterialDiffuse;

uniform vec4 uLightAmbient;
uniform float uLightCutOff;

in vec3 vRay[numLights];
in vec3 vTransformedNormals[numLights];

out vec4 fragColor;

void main(void) {

  vec4 Ia = uLightAmbient * uMaterialAmbient;
  vec4 Id = vec4(0.0);
  
  // Iterate over each light
  for(int i = 0; i &lt; numLights; i++) {
    // Define the normalized transformed normal per each light, as we 
    // have modified the surface normal with the light's direction
    vec3 N = normalize(vTransformedNormals[i]);
    vec3 L = normalize(vRay[i]);
    // Cosine of angle between light and surface
    float lambertTerm = dot(N, -L);
    // If cosine is bigger than cutoff (the angle is less than an implicit
    // threhsold imposed but that cutoff) then we update the 
    // sum of the diffuse color
    if (lambertTerm &gt; uLightCutOff) {
      Id += uLightColors[i] * uMaterialDiffuse * lambertTerm;
    }
  }

  fragColor = vec4(vec3(Ia + Id), 1.0);
}
</pre>

<p>
One other thing to note is the <code>uLightCutOff</code>. This variable allows us to create a spotlight, it basically defines the minimum value of the cosine of the angle between the light source and the normal. This cosine is maximized when the light is perpendicular to the surface, and minimized when the light is perpendicular. So with the <code>uLightCutOff</code> we are kind of saying what is the maximum angle we allow between the light and the surface. 
</p>

<div id="Colors, Depth Testing, and Alpha Blending-Use of Color in Lights-Directional Point Lights-Attenuation Factor"><h4 id="Attenuation Factor" class="header"><a href="#Colors, Depth Testing, and Alpha Blending-Use of Color in Lights-Directional Point Lights-Attenuation Factor">Attenuation Factor</a></h4></div>

<p>
However we can use this threshold as the variable to define an <span id="Colors, Depth Testing, and Alpha Blending-Use of Color in Lights-Directional Point Lights-Attenuation Factor-attenuation"></span><strong id="attenuation">attenuation</strong>. For example by computing the final color as follows:
</p>

<pre>if (lambertTerm &gt; uLightCutOff) {
  Id += uLightColors[i] * uMaterialDiffuse * pow(lamberTerm, 10.0 * uLightCutOff);
}
</pre>

<p>
So now the effect of lamberTerm is not as straight forward, and it does not increasig "linearly" but by the means of a power function:
</p>

\[
f(x) = \text{lambert term}^{10 \text{cutoff}}
\]

<p>
This is illustrated of the following figure:
</p>

<p>
<img src="https://albamr09.github.io/public/images/ComputerScience/CG/RTGW/attenuation_factor_function.png" alt="Attenuation Factor">
</p>

<div id="Colors, Depth Testing, and Alpha Blending-Use of Color in the Scene"><h2 id="Use of Color in the Scene" class="header"><a href="#Colors, Depth Testing, and Alpha Blending-Use of Color in the Scene">Use of Color in the Scene</a></h2></div>

<div id="Colors, Depth Testing, and Alpha Blending-Use of Color in the Scene-Transparency"><h3 id="Transparency" class="header"><a href="#Colors, Depth Testing, and Alpha Blending-Use of Color in the Scene-Transparency">Transparency</a></h3></div>

<p>
The first approach to render transparent objects is to use <span id="Colors, Depth Testing, and Alpha Blending-Use of Color in the Scene-Transparency-polygon stippling"></span><strong id="polygon stippling">polygon stippling</strong>. This technique consists of discarding some fragments so that you can see through the object. OpenGL supports polygon stippling through the glPolygonStipple function. This function is not available in WebGL. You could try to replicate this functionality by dropping some fragments in the fragment shader using the ESSL discard command. More commonly, we can use the alpha channel information to obtain translucent objects. However, modifying the alpha values does not produce transparency automatically.
</p>

<p>
Creating transparency corresponds to altering the fragments that weâ€™ve already written to the framebuffer. On a scene where there is one translucent object in front of an opaque object (from our camera view) we need to be able to see the opaque object through the translucent object. Therefore, the fragments that overlap between the far and near objects need to be combined somehow to create the transparency effect.
</p>

<p>
To properly render transparent surfaces, we need to learn about two important WebGL concepts: <span id="Colors, Depth Testing, and Alpha Blending-Use of Color in the Scene-Transparency-depth testing"></span><strong id="depth testing">depth testing</strong> and <span id="Colors, Depth Testing, and Alpha Blending-Use of Color in the Scene-Transparency-alpha blending"></span><strong id="alpha blending">alpha blending</strong>.
</p>

<div id="Colors, Depth Testing, and Alpha Blending-Use of Color in the Scene-Updated Rendering Pipeline"><h3 id="Updated Rendering Pipeline" class="header"><a href="#Colors, Depth Testing, and Alpha Blending-Use of Color in the Scene-Updated Rendering Pipeline">Updated Rendering Pipeline</a></h3></div>

<p>
Depth testing and alpha blending are two optional stages for fragments once they've been processed by the fragment shader.
</p>

<p>
If the depth test is not activated, all the fragments are automatically available for alpha blending. If the depth test is enabled, those fragments that fail the test will automatically be discarded by the pipeline and will no longer be available for any other operation. This means that discarded fragments will not be rendered.
</p>

<p>
The following diagram shows the order in which depth testing and alpha blending are performed:
</p>

<p>
<img src="https://albamr09.github.io/public/images/ComputerScience/CG/RTGW/updated_rendering_pipeline.png" alt="Updated Rendering Pipeline">
</p>

<div id="Colors, Depth Testing, and Alpha Blending-Depth Testing"><h2 id="Depth Testing" class="header"><a href="#Colors, Depth Testing, and Alpha Blending-Depth Testing">Depth Testing</a></h2></div>
</div>
  

<script type="text/javascript" src="https://albamr09.github.io/src/lib/highlight.min.js" id="js_highlight" data-description="Support sytax highlighting on code"></script><script type="text/javascript" src="https://albamr09.github.io/src/lib/zepto.min.js" id="zepto" data-description="Library to perform search"></script><script type="text/javascript" src="https://albamr09.github.io/src/lib/flexsearch.bundle.js" id="flexsearch" data-description="Library to perform search"></script><script type="text/javascript" src="https://albamr09.github.io/src/lib/search.js" id="search" data-description="Library to perform search"></script><script type="text/javascript" id="search" data-description="Entrypoint for hightlihgting">
  $("pre").each(function (index, item) {
    $(item).html("<code>" + $(item).html() + "</code>");
  });
  hljs.highlightAll();
</script></body></html>