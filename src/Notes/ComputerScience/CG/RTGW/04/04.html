<html><head>
    <!-- Normal styling from vimwiki -->
    <link rel="Stylesheet" type="text/css" href="../../../../../../src/style/index.css">
    <!-- Custom styling from vimwiki -->
    <link rel="Stylesheet" type="text/css" href="../../../../../../src/style/custom.css">
    <title>Camera</title>
  <script type="text/javascript" src="https://polyfill.io/v3/polyfill.min.js?features=es6" id="latex_script" data-description="Support for latex"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script" data-description="Support for latex"></script><link rel="Stylesheet" type="text/css" href="https://albamr09.github.io/src/style/search.css" data-description="Styling for search"><link rel="Stylesheet" type="text/css" href="https://albamr09.github.io/src/style/atom-one-light.min.css" data-description="Code highlight"><link rel="icon" type="image/svg+xml" href="https://albamr09.github.io/public/icon.svg" data-description="Page icon"></head>
  <body>
    <a href="https://albamr09.github.io/" style="
        color: white;
        font-weight: bold;
        text-decoration: none;
        padding: 3px 6px;
        border-radius: 3px;
        background-color: #1e90ff;
        text-transform: uppercase;
      ">Index</a>
    <form id="search_form" class="search-form">
      <input required="" type="search" id="search_term" class="searchTerm">
      <button type="submit" class="searchButton">Search</button>
    </form>
    <div id="search-background" class="search-background">
      <div id="search-result" class="search-result-hide"></div>
      <div id="search-form-modal" class="search-form-modal">
        <form id="search-form-in-modal">
          <input required="" type="search" id="search-input-in-modal" class="search-input-in-modal" placeholder="Search whatever...">
          <button type="submit" class="searchButton">Search</button>
        </form>
      </div>
    </div>
    <hr>
    <div class="content">
<p>
<a href="index.html">Back</a>
</p>

<div id="Camera"><h1 id="Camera" class="header"><a href="#Camera">Camera</a></h1></div>

<hr>

<div id="Contents" class="toc"><h2 id="Contents" class="header"><a href="#Contents">Contents</a></h2></div>
<ul>
<li>
<a href="04.html#WebGL%20Does%20Not%20Have%20Cameras">WebGL Does Not Have Cameras</a>

</li><li>
<a href="04.html#.%2F04%2Ftransformations.wiki%7CTransformations%7C.%2F04%2Ftransformations.wiki">Transformations</a>

</li><li>
<a href="04.html#.%2F04%2Fmodel_view.wiki%7CThe%20Model%2C%20View%20and%20Projection%20matrices%7C.%2F04%2Fmodel_view.wiki">The Model  View and Projection matrices</a>

<ul>
<li>
<a href="04.html#Normalized%20Device%20Coordinates">Normalized Device Coordinates</a>

</li><li>
<a href="04.html#Field%20of%20View">Field of View</a>

</li></ul>
</li><li>
<a href="04.html#.%2F04%2Fnormal_transform.wiki%7CNormal%20Transform%7C.%2F04%2Fnormal_transform.wiki">Normal Transform</a>

</li><li>
<a href="04.html#WebGL%20Implementation">WebGL Implementation</a>

</li><li>
<a href="04.html#The%20Model-View%20Matrix">The Model-View Matrix</a>

<ul>
<li>
<a href="04.html#Spatial%20Encoding%20of%20the%20World">Spatial Encoding of the World</a>

<ul>
<li>
<a href="04.html#Rotation%20Matrix">Rotation Matrix</a>

</li><li>
<a href="04.html#Translation%20Vector">Translation Vector</a>

</li><li>
<a href="04.html#The%20Mysterious%20Fourth%20Row">The Mysterious Fourth Row</a>

</li></ul>
</li></ul>
</li><li>
<a href="04.html#.%2F04%2Fcamera.wiki%7CCamera%7C.%2F04%2Fcamera.wiki">Camera</a>

</li><li>
<a href="04.html#References">References</a>

</li></ul>
<hr>

<p>
Even though we have a camera within our 3D application, there is no camera object in the WebGL APIâ€”only matrices. That is because having matrices instead of a camera object gives WebGL the flexibility to represent complex projections and animations.
</p>

<div id="Camera-WebGL Does Not Have Cameras"><h2 id="WebGL Does Not Have Cameras" class="header"><a href="#Camera-WebGL Does Not Have Cameras">WebGL Does Not Have Cameras</a></h2></div>

<p>
WebGL does not have a camera object that you can manipulate. However, we can assume that what we render in the <code>canvas</code> is what our camera captures.
</p>

<p>
Every time we move our camera around, we need to update the objects according to the new camera position. So, we need to transform each vertex. Similarly, we need to make sure that the object normals and light directions are still consistent after the camera has moved. In summary, we need to analyze two different types of transformations: 
</p>

<ul>
<li>
vertex (points) and 

</li><li>
normal (vectors)

</li></ul>
<div id="Camera-[[./04/transformations.wiki|Transformations]]"><h2 id="[[./04/transformations.wiki|Transformations]]" class="header"><a href="#Camera-[[./04/transformations.wiki|Transformations]]"></a><a href="04/transformations.html">Transformations</a></h2></div>

<div id="Camera-[[./04/model_view.wiki|The Model, View and Projection matrices]]"><h2 id="[[./04/model_view.wiki|The Model, View and Projection matrices]]" class="header"><a href="#Camera-[[./04/model_view.wiki|The Model, View and Projection matrices]]"></a><a href="04/model_view.html">The Model, View and Projection matrices</a></h2></div>

<div id="Camera-[[./04/model_view.wiki|The Model, View and Projection matrices]]-Normalized Device Coordinates"><h3 id="Normalized Device Coordinates" class="header"><a href="#Camera-[[./04/model_view.wiki|The Model, View and Projection matrices]]-Normalized Device Coordinates">Normalized Device Coordinates</a></h3></div>

<p>
Once it has been determined how much of the viewing space will be rendered, the frustum is mapped into the near plane in order to produce a 2D image.
</p>

<p>
At the heart of things, WebGL doesn't really know anything about your coordinate space or about the matrices that you're using. WebGL only requires that when all of your transformations are done, things should be in normalized device coordinates. Normalized device coordinates are obtained by dividing the clipping coordinates by the \(w\) component. This is why this step is known as <span id="Camera-[[./04/model_view.wiki|The Model, View and Projection matrices]]-Normalized Device Coordinates-perspective division"></span><strong id="perspective division">perspective division</strong>. In the NDC space, the \(x\) and \(y\) coordinates represent the location of your vertices on a normalized 2D screen, while the z-coordinate encodes depth information, which is the relative location of the objects with respect to the near and far planes.
</p>

<p>
These coordinates range from \(-1\) to \(+1\) on each axis, regardless of the shape or size of the actual screen. The bottom left corner will be at \((-1, -1)\), and the top right corner will be at (1, 1). WebGL will then map these coordinates onto the viewport that was configured with <code>glViewport</code>.
</p>

<p>
<img src="https://albamr09.github.io/public/assets/normalized_device_coordinates.png" alt="Normalized Device Coordinates" style="width:500px">
</p>

<p>
<img src="https://albamr09.github.io/public/assets/view_transform_1.png" alt="View Transform" style="width:500px">
</p>

<div id="Camera-[[./04/model_view.wiki|The Model, View and Projection matrices]]-Field of View"><h3 id="Field of View" class="header"><a href="#Camera-[[./04/model_view.wiki|The Model, View and Projection matrices]]-Field of View">Field of View</a></h3></div>

<p>
The Projection matrix determines the <span id="Camera-[[./04/model_view.wiki|The Model, View and Projection matrices]]-Field of View-field of view"></span><strong id="field of view">field of view</strong> (FOV) of the camera. Which is how much of the 3D space will be captured by the camera. It is a measure given in degrees, and the term is used interchangeably with the term <span id="Camera-[[./04/model_view.wiki|The Model, View and Projection matrices]]-Field of View-angle of view"></span><strong id="angle of view">angle of view</strong>.
</p>

<p>
<img src="https://albamr09.github.io/public/assets/fov.png" alt="Field of View (FOV)" style="width:600px;">
</p>

<div id="Camera-[[./04/normal_transform.wiki|Normal Transform]]"><h2 id="[[./04/normal_transform.wiki|Normal Transform]]" class="header"><a href="#Camera-[[./04/normal_transform.wiki|Normal Transform]]"></a><a href="04/normal_transform.html">Normal Transform</a></h2></div>

<div id="Camera-WebGL Implementation"><h2 id="WebGL Implementation" class="header"><a href="#Camera-WebGL Implementation">WebGL Implementation</a></h2></div>

<p>
The following diagram shows the theory we have learned so far, along with the relationships between the steps in the theory and the implementation in WebGL.
</p>

<p>
<img src="https://albamr09.github.io/public/assets/web_gl_transformations_pipeline.png" alt="WebGL Transformations" style="width:600px">
</p>

<p>
The five transformations that we apply to object coordinates to obtain viewport coordinates are grouped into three matrices and one WebGL method:
</p>

<ul>
<li>
The <span id="Camera-WebGL Implementation-Model-View matrix"></span><strong id="Model-View matrix">Model-View matrix</strong> that groups the model and view transform in one single matrix. When we multiply our vertices by this matrix, we end up in world coordinates.

</li><li>
The <span id="Camera-WebGL Implementation-Normal matrix"></span><strong id="Normal matrix">Normal matrix</strong> is obtained by inverting and transposing the Model-View matrix. This matrix is applied to normal vectors to ensure that they continue to be perpendicular to the surface. 

</li><li>
The <span id="Camera-WebGL Implementation-Projection matrix"></span><strong id="Projection matrix">Projection matrix</strong> groups the projection transformation and the perspective division, and as a result, we end up in normalized device coordinates.

</li></ul>
<p>
Finally, we use the <code>gl.viewport</code> operation to map NDCs to viewport coordinates:
</p>

<pre javascript="">gl.viewport(minX, minY, width, height);
</pre>

<p>
The viewport coordinates originate in the lower-left corner of the HTML5 canvas.
</p>

<div id="Camera-The Model-View Matrix"><h2 id="The Model-View Matrix" class="header"><a href="#Camera-The Model-View Matrix">The Model-View Matrix</a></h2></div>

<p>
The Model-View matrix allows us to perform <span id="Camera-The Model-View Matrix-affine transformations"></span><strong id="affine transformations">affine transformations</strong> in our scene. Affine is a mathematical name that describes transformations that do not change the structure of the object undergoing such transformations. In our 3D world scene, such transformations are rotation, scaling, reflection shearing, and translation. Let's take a look at how the Model-View matrix is constructed.
</p>

<div id="Camera-The Model-View Matrix-Spatial Encoding of the World"><h3 id="Spatial Encoding of the World" class="header"><a href="#Camera-The Model-View Matrix-Spatial Encoding of the World">Spatial Encoding of the World</a></h3></div>

<p>
By default, when you render a scene, you are looking at it from the origin of the world in the negative direction of the z-axis. As shown in the following diagram, the z-axis is coming out of the screen:
</p>

<p>
<img src="https://albamr09.github.io/public/assets/spatial_world_encoding.png" alt="Spatial World Encoding" style="width:600px">
</p>

<div id="Camera-The Model-View Matrix-Spatial Encoding of the World-Rotation Matrix"><h4 id="Rotation Matrix" class="header"><a href="#Camera-The Model-View Matrix-Spatial Encoding of the World-Rotation Matrix">Rotation Matrix</a></h4></div>

<p>
The intersection of the first three rows with the first three columns defines the 3x3 Rotation matrix. This matrix contains information about rotations around the standard axis.
</p>

\begin{align}
\begin{bmatrix}
m_1 &amp; m_2 &amp; m_3 \\
m_5 &amp; m_6 &amp; m_7 \\
m_9 &amp; m_{10} &amp; m_{11} 
\end{bmatrix}
\end{align}

<div id="Camera-The Model-View Matrix-Spatial Encoding of the World-Translation Vector"><h4 id="Translation Vector" class="header"><a href="#Camera-The Model-View Matrix-Spatial Encoding of the World-Translation Vector">Translation Vector</a></h4></div>

<p>
The intersection of the first three rows with the last column defines a three-component Translation vector.
</p>

\begin{align}
\begin{bmatrix}
m_{13} &amp; m_{14} &amp; m_{15}
\end{bmatrix}
\end{align}

<div id="Camera-The Model-View Matrix-Spatial Encoding of the World-The Mysterious Fourth Row"><h4 id="The Mysterious Fourth Row" class="header"><a href="#Camera-The Model-View Matrix-Spatial Encoding of the World-The Mysterious Fourth Row">The Mysterious Fourth Row</a></h4></div>

<p>
The fourth row does not have any special meaning.
</p>

<ul>
<li>
The \(m_4\), \(m_8\), and \(m_{12}\) elements are always \(0\).

</li><li>
The \(m_{16}\) element (the Homogeneous coordinate) will always be \(1\).

</li></ul>
<div id="Camera-[[./04/camera.wiki|Camera]]"><h2 id="[[./04/camera.wiki|Camera]]" class="header"><a href="#Camera-[[./04/camera.wiki|Camera]]"></a><a href="04/camera.html">Camera</a></h2></div>

<div id="Camera-References"><h2 id="References" class="header"><a href="#Camera-References">References</a></h2></div>

<ol>
<li>
<a href="https://jsantell.com/model-view-projection/">Model View Projection</a>

</li><li>
<a href="https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/opengl-perspective-projection-matrix.html">The Perspective Projection Matrix</a>

</li></ol>
</div>
  

<script type="text/javascript" src="https://albamr09.github.io/src/lib/highlight.min.js" id="js_highlight" data-description="Support sytax highlighting on code"></script><script type="text/javascript" src="https://albamr09.github.io/src/lib/zepto.min.js" id="zepto" data-description="Library to perform search"></script><script type="text/javascript" src="https://albamr09.github.io/src/lib/flexsearch.bundle.js" id="flexsearch" data-description="Library to perform search"></script><script type="text/javascript" src="https://albamr09.github.io/src/lib/search.js" id="search" data-description="Library to perform search"></script><script type="text/javascript" id="search" data-description="Entrypoint for hightlihgting">
  $("pre").each(function (index, item) {
    $(item).html("<code>" + $(item).html() + "</code>");
  });
  hljs.highlightAll();
</script></body></html>